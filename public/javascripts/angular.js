/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonp"];
/******/ 	window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, callbacks = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId])
/******/ 				callbacks.push.apply(callbacks, installedChunks[chunkId]);
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);
/******/ 		while(callbacks.length)
/******/ 			callbacks.shift().call(null, __webpack_require__);
/******/ 		if(moreModules[0]) {
/******/ 			installedModules[0] = 0;
/******/ 			return __webpack_require__(0);
/******/ 		}
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// "0" means "already loaded"
/******/ 	// Array means "loading", array contains callbacks
/******/ 	var installedChunks = {
/******/ 		0:0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId, callback) {
/******/ 		// "0" is the signal for "already loaded"
/******/ 		if(installedChunks[chunkId] === 0)
/******/ 			return callback.call(null, __webpack_require__);
/******/
/******/ 		// an array means "currently loading".
/******/ 		if(installedChunks[chunkId] !== undefined) {
/******/ 			installedChunks[chunkId].push(callback);
/******/ 		} else {
/******/ 			// start chunk loading
/******/ 			installedChunks[chunkId] = [callback];
/******/ 			var head = document.getElementsByTagName('head')[0];
/******/ 			var script = document.createElement('script');
/******/ 			script.type = 'text/javascript';
/******/ 			script.charset = 'utf-8';
/******/ 			script.async = true;
/******/
/******/ 			script.src = __webpack_require__.p + "" + chunkId + ".chunk.js";
/******/ 			head.appendChild(script);
/******/ 		}
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(187);
	__webpack_require__(223);
	__webpack_require__(191);
	__webpack_require__(12);
	__webpack_require__(20);
	__webpack_require__(81);
	module.exports = __webpack_require__(83);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _utilNoop = __webpack_require__(65);
	
	var _utilNoop2 = _interopRequireDefault(_utilNoop);
	
	var _utilThrowError = __webpack_require__(185);
	
	var _utilThrowError2 = _interopRequireDefault(_utilThrowError);
	
	var _utilTryOrOnError = __webpack_require__(186);
	
	var _utilTryOrOnError2 = _interopRequireDefault(_utilTryOrOnError);
	
	var _Subscription2 = __webpack_require__(5);
	
	var _Subscription3 = _interopRequireDefault(_Subscription2);
	
	var Subscriber = (function (_Subscription) {
	    _inherits(Subscriber, _Subscription);
	
	    function Subscriber(destination) {
	        _classCallCheck(this, Subscriber);
	
	        _Subscription.call(this);
	        this._isUnsubscribed = false;
	        this.destination = destination;
	        if (!destination) {
	            return;
	        }
	        var subscription = destination._subscription;
	        if (subscription) {
	            this._subscription = subscription;
	        } else if (destination instanceof Subscriber) {
	            this._subscription = destination;
	        }
	    }
	
	    Subscriber.create = function create(next, error, complete) {
	        var subscriber = new Subscriber();
	        subscriber._next = typeof next === "function" && _utilTryOrOnError2['default'](next) || _utilNoop2['default'];
	        subscriber._error = typeof error === "function" && error || _utilThrowError2['default'];
	        subscriber._complete = typeof complete === "function" && complete || _utilNoop2['default'];
	        return subscriber;
	    };
	
	    Subscriber.prototype._next = function _next(value) {
	        this.destination.next(value);
	    };
	
	    Subscriber.prototype._error = function _error(err) {
	        this.destination.error(err);
	    };
	
	    Subscriber.prototype._complete = function _complete() {
	        this.destination.complete();
	    };
	
	    Subscriber.prototype.add = function add(sub) {
	        // route add to the shared Subscription if it exists
	        var _subscription = this._subscription;
	        if (_subscription) {
	            _subscription.add(sub);
	        } else {
	            _Subscription.prototype.add.call(this, sub);
	        }
	    };
	
	    Subscriber.prototype.remove = function remove(sub) {
	        // route remove to the shared Subscription if it exists
	        if (this._subscription) {
	            this._subscription.remove(sub);
	        } else {
	            _Subscription.prototype.remove.call(this, sub);
	        }
	    };
	
	    Subscriber.prototype.unsubscribe = function unsubscribe() {
	        if (this._isUnsubscribed) {
	            return;
	        } else if (this._subscription) {
	            this._isUnsubscribed = true;
	        } else {
	            _Subscription.prototype.unsubscribe.call(this);
	        }
	    };
	
	    Subscriber.prototype.next = function next(value) {
	        if (!this.isUnsubscribed) {
	            this._next(value);
	        }
	    };
	
	    Subscriber.prototype.error = function error(_error2) {
	        if (!this.isUnsubscribed) {
	            this._error(_error2);
	            this.unsubscribe();
	        }
	    };
	
	    Subscriber.prototype.complete = function complete() {
	        if (!this.isUnsubscribed) {
	            this._complete();
	            this.unsubscribe();
	        }
	    };
	
	    _createClass(Subscriber, [{
	        key: 'isUnsubscribed',
	        get: function get() {
	            var subscription = this._subscription;
	            if (subscription) {
	                // route to the shared Subscription if it exists
	                return this._isUnsubscribed || subscription.isUnsubscribed;
	            } else {
	                return this._isUnsubscribed;
	            }
	        },
	        set: function set(value) {
	            var subscription = this._subscription;
	            if (subscription) {
	                // route to the shared Subscription if it exists
	                subscription.isUnsubscribed = Boolean(value);
	            } else {
	                this._isUnsubscribed = Boolean(value);
	            }
	        }
	    }]);
	
	    return Subscriber;
	})(_Subscription3['default']);
	
	exports['default'] = Subscriber;
	module.exports = exports['default'];

/***/ }),
/* 2 */
/***/ (function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	var errorObject = { e: {} };
	exports.errorObject = errorObject;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = tryCatch;
	
	var _errorObject = __webpack_require__(2);
	
	var tryCatchTarget = undefined;
	function tryCatcher() {
	    try {
	        return tryCatchTarget.apply(this, arguments);
	    } catch (e) {
	        _errorObject.errorObject.e = e;
	        return _errorObject.errorObject;
	    }
	}
	
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}
	
	;
	module.exports = exports['default'];

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber = __webpack_require__(1);
	
	var _Subscriber2 = _interopRequireDefault(_Subscriber);
	
	var _utilRoot = __webpack_require__(16);
	
	var _utilSymbol_observable = __webpack_require__(34);
	
	var _utilSymbol_observable2 = _interopRequireDefault(_utilSymbol_observable);
	
	/**
	 * A representation of any set of values over any amount of time. This the most basic building block
	 * of RxJS.
	 *
	 * @class Observable<T>
	 */
	
	var Observable = (function () {
	    /**
	     * @constructor
	     * @param {Function} subscribe the function that is
	     * called when the Observable is initially subscribed to. This function is given a Subscriber, to which new values
	     * can be `next`ed, or an `error` method can be called to raise an error, or `complete` can be called to notify
	     * of a successful completion.
	     */
	
	    function Observable(subscribe) {
	        _classCallCheck(this, Observable);
	
	        this._isScalar = false;
	        if (subscribe) {
	            this._subscribe = subscribe;
	        }
	    }
	
	    // HACK: Since TypeScript inherits static properties too, we have to
	    // fight against TypeScript here so Subject can have a different static create signature
	    /**
	     * @static
	     * @method create
	     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
	     * @returns {Observable} a new cold observable
	     * @description creates a new cold Observable by calling the Observable constructor
	     */
	
	    /**
	     * @method lift
	     * @param {Operator} operator the operator defining the operation to take on the observable
	     * @returns {Observable} a new observable with the Operator applied
	     * @description creates a new Observable, with this Observable as the source, and the passed
	     * operator defined as the new observable's operator.
	     */
	
	    Observable.prototype.lift = function lift(operator) {
	        var observable = new Observable();
	        observable.source = this;
	        observable.operator = operator;
	        return observable;
	    };
	
	    /**
	     * @method Symbol.observable
	     * @returns {Observable} this instance of the observable
	     * @description an interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
	     */
	
	    Observable.prototype[_utilSymbol_observable2['default']] = function () {
	        return this;
	    };
	
	    /**
	     * @method subscribe
	     * @param {Observer|Function} observerOrNext (optional) either an observer defining all functions to be called,
	     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.
	     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,
	     *  the error will be thrown as unhandled
	     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.
	     * @returns {Subscription} a subscription reference to the registered handlers
	     * @description registers handlers for handling emitted values, error and completions from the observable, and
	     *  executes the observable's subscriber function, which will take action to set up the underlying data stream
	     */
	
	    Observable.prototype.subscribe = function subscribe(observerOrNext, error, complete) {
	        var subscriber = undefined;
	        if (observerOrNext && typeof observerOrNext === "object") {
	            if (observerOrNext instanceof _Subscriber2['default']) {
	                subscriber = observerOrNext;
	            } else {
	                subscriber = new _Subscriber2['default'](observerOrNext);
	            }
	        } else {
	            var next = observerOrNext;
	            subscriber = _Subscriber2['default'].create(next, error, complete);
	        }
	        subscriber.add(this._subscribe(subscriber));
	        return subscriber;
	    };
	
	    /**
	     * @method forEach
	     * @param {Function} next a handler for each value emitted by the observable
	     * @param {PromiseConstructor} PromiseCtor? a constructor function used to instantiate the Promise
	     * @returns {Promise} a promise that either resolves on observable completion or
	     *  rejects with the handled error
	     */
	
	    Observable.prototype.forEach = function forEach(next, PromiseCtor) {
	        var _this = this;
	
	        if (!PromiseCtor) {
	            if (_utilRoot.root.Rx && _utilRoot.root.Rx.config && _utilRoot.root.Rx.config.Promise) {
	                PromiseCtor = _utilRoot.root.Rx.config.Promise;
	            } else if (_utilRoot.root.Promise) {
	                PromiseCtor = _utilRoot.root.Promise;
	            }
	        }
	        if (!PromiseCtor) {
	            throw new Error('no Promise impl found');
	        }
	        return new PromiseCtor(function (resolve, reject) {
	            _this.subscribe(next, reject, resolve);
	        });
	    };
	
	    Observable.prototype._subscribe = function _subscribe(subscriber) {
	        return this.source._subscribe(this.operator.call(subscriber));
	    };
	
	    return Observable;
	})();
	
	exports['default'] = Observable;
	Observable.create = function (subscribe) {
	    return new Observable(subscribe);
	};
	module.exports = exports['default'];

/***/ }),
/* 5 */
/***/ (function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Subscription = (function () {
	    function Subscription(_unsubscribe) {
	        _classCallCheck(this, Subscription);
	
	        this.isUnsubscribed = false;
	        if (_unsubscribe) {
	            this._unsubscribe = _unsubscribe;
	        }
	    }
	
	    Subscription.prototype._unsubscribe = function _unsubscribe() {};
	
	    Subscription.prototype.unsubscribe = function unsubscribe() {
	        if (this.isUnsubscribed) {
	            return;
	        }
	        this.isUnsubscribed = true;
	        var unsubscribe = this._unsubscribe;
	        var subscriptions = this._subscriptions;
	        this._subscriptions = void 0;
	        if (unsubscribe) {
	            unsubscribe.call(this);
	        }
	        if (subscriptions != null) {
	            var index = -1;
	            var len = subscriptions.length;
	            while (++index < len) {
	                subscriptions[index].unsubscribe();
	            }
	        }
	    };
	
	    Subscription.prototype.add = function add(subscription) {
	        // return early if:
	        //  1. the subscription is null
	        //  2. we're attempting to add our this
	        //  3. we're attempting to add the static `empty` Subscription
	        if (!subscription || subscription === this || subscription === Subscription.EMPTY) {
	            return;
	        }
	        var sub = subscription;
	        switch (typeof subscription) {
	            case "function":
	                sub = new Subscription(subscription);
	            case "object":
	                if (sub.isUnsubscribed || typeof sub.unsubscribe !== "function") {
	                    break;
	                } else if (this.isUnsubscribed) {
	                    sub.unsubscribe();
	                } else {
	                    var subscriptions = this._subscriptions || (this._subscriptions = []);
	                    subscriptions.push(sub);
	                }
	                break;
	            default:
	                throw new Error('Unrecognized subscription ' + subscription + ' added to Subscription.');
	        }
	    };
	
	    Subscription.prototype.remove = function remove(subscription) {
	        // return early if:
	        //  1. the subscription is null
	        //  2. we're attempting to remove ourthis
	        //  3. we're attempting to remove the static `empty` Subscription
	        if (subscription == null || subscription === this || subscription === Subscription.EMPTY) {
	            return;
	        }
	        var subscriptions = this._subscriptions;
	        if (subscriptions) {
	            var subscriptionIndex = subscriptions.indexOf(subscription);
	            if (subscriptionIndex !== -1) {
	                subscriptions.splice(subscriptionIndex, 1);
	            }
	        }
	    };
	
	    return Subscription;
	})();
	
	exports["default"] = Subscription;
	
	Subscription.EMPTY = (function (empty) {
	    empty.isUnsubscribed = true;
	    return empty;
	})(new Subscription());
	module.exports = exports["default"];

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(17);
	var toSubscriber_1 = __webpack_require__(218);
	var observable_1 = __webpack_require__(39);
	/**
	 * A representation of any set of values over any amount of time. This the most basic building block
	 * of RxJS.
	 *
	 * @class Observable<T>
	 */
	var Observable = (function () {
	    /**
	     * @constructor
	     * @param {Function} subscribe the function that is  called when the Observable is
	     * initially subscribed to. This function is given a Subscriber, to which new values
	     * can be `next`ed, or an `error` method can be called to raise an error, or
	     * `complete` can be called to notify of a successful completion.
	     */
	    function Observable(subscribe) {
	        this._isScalar = false;
	        if (subscribe) {
	            this._subscribe = subscribe;
	        }
	    }
	    /**
	     * Creates a new Observable, with this Observable as the source, and the passed
	     * operator defined as the new observable's operator.
	     * @method lift
	     * @param {Operator} operator the operator defining the operation to take on the observable
	     * @return {Observable} a new observable with the Operator applied
	     */
	    Observable.prototype.lift = function (operator) {
	        var observable = new Observable();
	        observable.source = this;
	        observable.operator = operator;
	        return observable;
	    };
	    /**
	     * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.
	     *
	     * <span class="informal">Use it when you have all these Observables, but still nothing is happening.</span>
	     *
	     * `subscribe` is not a regular operator, but a method that calls Observables internal `subscribe` function. It
	     * might be for example a function that you passed to a {@link create} static factory, but most of the time it is
	     * a library implementation, which defines what and when will be emitted by an Observable. This means that calling
	     * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often
	     * thought.
	     *
	     * Apart from starting the execution of an Observable, this method allows you to listen for values
	     * that an Observable emits, as well as for when it completes or errors. You can achieve this in two
	     * following ways.
	     *
	     * The first way is creating an object that implements {@link Observer} interface. It should have methods
	     * defined by that interface, but note that it should be just a regular JavaScript object, which you can create
	     * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do
	     * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also
	     * that your object does not have to implement all methods. If you find yourself creating a method that doesn't
	     * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will
	     * be left uncaught.
	     *
	     * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.
	     * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent
	     * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,
	     * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,
	     * since `subscribe` recognizes these functions by where they were placed in function call. When it comes
	     * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.
	     *
	     * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.
	     * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean
	     * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback
	     * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.
	     *
	     * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.
	     * It is an Observable itself that decides when these functions will be called. For example {@link of}
	     * by default emits all its values synchronously. Always check documentation for how given Observable
	     * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.
	     *
	     * @example <caption>Subscribe with an Observer</caption>
	     * const sumObserver = {
	     *   sum: 0,
	     *   next(value) {
	     *     console.log('Adding: ' + value);
	     *     this.sum = this.sum + value;
	     *   },
	     *   error() { // We actually could just remote this method,
	     *   },        // since we do not really care about errors right now.
	     *   complete() {
	     *     console.log('Sum equals: ' + this.sum);
	     *   }
	     * };
	     *
	     * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.
	     * .subscribe(sumObserver);
	     *
	     * // Logs:
	     * // "Adding: 1"
	     * // "Adding: 2"
	     * // "Adding: 3"
	     * // "Sum equals: 6"
	     *
	     *
	     * @example <caption>Subscribe with functions</caption>
	     * let sum = 0;
	     *
	     * Rx.Observable.of(1, 2, 3)
	     * .subscribe(
	     *   function(value) {
	     *     console.log('Adding: ' + value);
	     *     sum = sum + value;
	     *   },
	     *   undefined,
	     *   function() {
	     *     console.log('Sum equals: ' + sum);
	     *   }
	     * );
	     *
	     * // Logs:
	     * // "Adding: 1"
	     * // "Adding: 2"
	     * // "Adding: 3"
	     * // "Sum equals: 6"
	     *
	     *
	     * @example <caption>Cancel a subscription</caption>
	     * const subscription = Rx.Observable.interval(1000).subscribe(
	     *   num => console.log(num),
	     *   undefined,
	     *   () => console.log('completed!') // Will not be called, even
	     * );                                // when cancelling subscription
	     *
	     *
	     * setTimeout(() => {
	     *   subscription.unsubscribe();
	     *   console.log('unsubscribed!');
	     * }, 2500);
	     *
	     * // Logs:
	     * // 0 after 1s
	     * // 1 after 2s
	     * // "unsubscribed!" after 2,5s
	     *
	     *
	     * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,
	     *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed
	     *  Observable.
	     * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,
	     *  the error will be thrown as unhandled.
	     * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.
	     * @return {ISubscription} a subscription reference to the registered handlers
	     * @method subscribe
	     */
	    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
	        var operator = this.operator;
	        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
	        if (operator) {
	            operator.call(sink, this.source);
	        }
	        else {
	            sink.add(this.source ? this._subscribe(sink) : this._trySubscribe(sink));
	        }
	        if (sink.syncErrorThrowable) {
	            sink.syncErrorThrowable = false;
	            if (sink.syncErrorThrown) {
	                throw sink.syncErrorValue;
	            }
	        }
	        return sink;
	    };
	    Observable.prototype._trySubscribe = function (sink) {
	        try {
	            return this._subscribe(sink);
	        }
	        catch (err) {
	            sink.syncErrorThrown = true;
	            sink.syncErrorValue = err;
	            sink.error(err);
	        }
	    };
	    /**
	     * @method forEach
	     * @param {Function} next a handler for each value emitted by the observable
	     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
	     * @return {Promise} a promise that either resolves on observable completion or
	     *  rejects with the handled error
	     */
	    Observable.prototype.forEach = function (next, PromiseCtor) {
	        var _this = this;
	        if (!PromiseCtor) {
	            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
	                PromiseCtor = root_1.root.Rx.config.Promise;
	            }
	            else if (root_1.root.Promise) {
	                PromiseCtor = root_1.root.Promise;
	            }
	        }
	        if (!PromiseCtor) {
	            throw new Error('no Promise impl found');
	        }
	        return new PromiseCtor(function (resolve, reject) {
	            // Must be declared in a separate statement to avoid a RefernceError when
	            // accessing subscription below in the closure due to Temporal Dead Zone.
	            var subscription;
	            subscription = _this.subscribe(function (value) {
	                if (subscription) {
	                    // if there is a subscription, then we can surmise
	                    // the next handling is asynchronous. Any errors thrown
	                    // need to be rejected explicitly and unsubscribe must be
	                    // called manually
	                    try {
	                        next(value);
	                    }
	                    catch (err) {
	                        reject(err);
	                        subscription.unsubscribe();
	                    }
	                }
	                else {
	                    // if there is NO subscription, then we're getting a nexted
	                    // value synchronously during subscription. We can just call it.
	                    // If it errors, Observable's `subscribe` will ensure the
	                    // unsubscription logic is called, then synchronously rethrow the error.
	                    // After that, Promise will trap the error and send it
	                    // down the rejection path.
	                    next(value);
	                }
	            }, reject, resolve);
	        });
	    };
	    Observable.prototype._subscribe = function (subscriber) {
	        return this.source.subscribe(subscriber);
	    };
	    /**
	     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
	     * @method Symbol.observable
	     * @return {Observable} this instance of the observable
	     */
	    Observable.prototype[observable_1.observable] = function () {
	        return this;
	    };
	    // HACK: Since TypeScript inherits static properties too, we have to
	    // fight against TypeScript here so Subject can have a different static create signature
	    /**
	     * Creates a new cold Observable by calling the Observable constructor
	     * @static true
	     * @owner Observable
	     * @method create
	     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
	     * @return {Observable} a new cold observable
	     */
	    Observable.create = function (subscribe) {
	        return new Observable(subscribe);
	    };
	    return Observable;
	}());
	exports.Observable = Observable;
	//# sourceMappingURL=Observable.js.map

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _Observable2 = __webpack_require__(4);
	
	var _Observable3 = _interopRequireDefault(_Observable2);
	
	var _Subscriber = __webpack_require__(1);
	
	var _Subscriber2 = _interopRequireDefault(_Subscriber);
	
	var _Subscription = __webpack_require__(5);
	
	var _Subscription2 = _interopRequireDefault(_Subscription);
	
	var _subjectsSubjectSubscription = __webpack_require__(177);
	
	var _subjectsSubjectSubscription2 = _interopRequireDefault(_subjectsSubjectSubscription);
	
	var subscriptionAdd = _Subscription2['default'].prototype.add;
	var subscriptionRemove = _Subscription2['default'].prototype.remove;
	var subscriptionUnsubscribe = _Subscription2['default'].prototype.unsubscribe;
	var subscriberNext = _Subscriber2['default'].prototype.next;
	var subscriberError = _Subscriber2['default'].prototype.error;
	var subscriberComplete = _Subscriber2['default'].prototype.complete;
	var _subscriberNext = _Subscriber2['default'].prototype._next;
	var _subscriberError = _Subscriber2['default'].prototype._error;
	var _subscriberComplete = _Subscriber2['default'].prototype._complete;
	
	var Subject = (function (_Observable) {
	    _inherits(Subject, _Observable);
	
	    function Subject() {
	        _classCallCheck(this, Subject);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        _Observable.call.apply(_Observable, [this].concat(args));
	        this.observers = [];
	        this.isUnsubscribed = false;
	        this.dispatching = false;
	        this.errorSignal = false;
	        this.completeSignal = false;
	    }
	
	    Subject.create = function create(source, destination) {
	        return new BidirectionalSubject(source, destination);
	    };
	
	    Subject.prototype.lift = function lift(operator) {
	        var subject = new BidirectionalSubject(this, this.destination || this);
	        subject.operator = operator;
	        return subject;
	    };
	
	    Subject.prototype._subscribe = function _subscribe(subscriber) {
	        if (subscriber.isUnsubscribed) {
	            return;
	        } else if (this.errorSignal) {
	            subscriber.error(this.errorInstance);
	            return;
	        } else if (this.completeSignal) {
	            subscriber.complete();
	            return;
	        } else if (this.isUnsubscribed) {
	            throw new Error("Cannot subscribe to a disposed Subject.");
	        }
	        this.observers.push(subscriber);
	        return new _subjectsSubjectSubscription2['default'](this, subscriber);
	    };
	
	    Subject.prototype.add = function add(subscription) {
	        subscriptionAdd.call(this, subscription);
	    };
	
	    Subject.prototype.remove = function remove(subscription) {
	        subscriptionRemove.call(this, subscription);
	    };
	
	    Subject.prototype.unsubscribe = function unsubscribe() {
	        this.observers = void 0;
	        subscriptionUnsubscribe.call(this);
	    };
	
	    Subject.prototype.next = function next(value) {
	        if (this.isUnsubscribed) {
	            return;
	        }
	        this.dispatching = true;
	        this._next(value);
	        this.dispatching = false;
	        if (this.errorSignal) {
	            this.error(this.errorInstance);
	        } else if (this.completeSignal) {
	            this.complete();
	        }
	    };
	
	    Subject.prototype.error = function error(_error) {
	        if (this.isUnsubscribed || this.completeSignal) {
	            return;
	        }
	        this.errorSignal = true;
	        this.errorInstance = _error;
	        if (this.dispatching) {
	            return;
	        }
	        this._error(_error);
	        this.unsubscribe();
	    };
	
	    Subject.prototype.complete = function complete() {
	        if (this.isUnsubscribed || this.errorSignal) {
	            return;
	        }
	        this.completeSignal = true;
	        if (this.dispatching) {
	            return;
	        }
	        this._complete();
	        this.unsubscribe();
	    };
	
	    Subject.prototype._next = function _next(value) {
	        var index = -1;
	        var observers = this.observers.slice(0);
	        var len = observers.length;
	        while (++index < len) {
	            observers[index].next(value);
	        }
	    };
	
	    Subject.prototype._error = function _error(error) {
	        var index = -1;
	        var observers = this.observers;
	        var len = observers.length;
	        // optimization -- block next, complete, and unsubscribe while dispatching
	        this.observers = void 0;
	        this.isUnsubscribed = true;
	        while (++index < len) {
	            observers[index].error(error);
	        }
	        this.isUnsubscribed = false;
	    };
	
	    Subject.prototype._complete = function _complete() {
	        var index = -1;
	        var observers = this.observers;
	        var len = observers.length;
	        // optimization -- block next, complete, and unsubscribe while dispatching
	        this.observers = void 0; // optimization
	        this.isUnsubscribed = true;
	        while (++index < len) {
	            observers[index].complete();
	        }
	        this.isUnsubscribed = false;
	    };
	
	    return Subject;
	})(_Observable3['default']);
	
	exports['default'] = Subject;
	
	var BidirectionalSubject = (function (_Subject) {
	    _inherits(BidirectionalSubject, _Subject);
	
	    function BidirectionalSubject(source, destination) {
	        _classCallCheck(this, BidirectionalSubject);
	
	        _Subject.call(this);
	        this.source = source;
	        this.destination = destination;
	    }
	
	    BidirectionalSubject.prototype._subscribe = function _subscribe(subscriber) {
	        var operator = this.operator;
	        return this.source._subscribe.call(this.source, operator ? operator.call(subscriber) : subscriber);
	    };
	
	    BidirectionalSubject.prototype.next = function next(x) {
	        subscriberNext.call(this, x);
	    };
	
	    BidirectionalSubject.prototype.error = function error(e) {
	        subscriberError.call(this, e);
	    };
	
	    BidirectionalSubject.prototype.complete = function complete() {
	        subscriberComplete.call(this);
	    };
	
	    BidirectionalSubject.prototype._next = function _next(x) {
	        _subscriberNext.call(this, x);
	    };
	
	    BidirectionalSubject.prototype._error = function _error(e) {
	        _subscriberError.call(this, e);
	    };
	
	    BidirectionalSubject.prototype._complete = function _complete() {
	        _subscriberComplete.call(this);
	    };
	
	    return BidirectionalSubject;
	})(Subject);
	
	module.exports = exports['default'];

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isFunction_1 = __webpack_require__(76);
	var Subscription_1 = __webpack_require__(27);
	var Observer_1 = __webpack_require__(67);
	var rxSubscriber_1 = __webpack_require__(40);
	/**
	 * Implements the {@link Observer} interface and extends the
	 * {@link Subscription} class. While the {@link Observer} is the public API for
	 * consuming the values of an {@link Observable}, all Observers get converted to
	 * a Subscriber, in order to provide Subscription-like capabilities such as
	 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
	 * implementing operators, but it is rarely used as a public API.
	 *
	 * @class Subscriber<T>
	 */
	var Subscriber = (function (_super) {
	    __extends(Subscriber, _super);
	    /**
	     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
	     * defined Observer or a `next` callback function.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     */
	    function Subscriber(destinationOrNext, error, complete) {
	        _super.call(this);
	        this.syncErrorValue = null;
	        this.syncErrorThrown = false;
	        this.syncErrorThrowable = false;
	        this.isStopped = false;
	        switch (arguments.length) {
	            case 0:
	                this.destination = Observer_1.empty;
	                break;
	            case 1:
	                if (!destinationOrNext) {
	                    this.destination = Observer_1.empty;
	                    break;
	                }
	                if (typeof destinationOrNext === 'object') {
	                    if (destinationOrNext instanceof Subscriber) {
	                        this.destination = destinationOrNext;
	                        this.destination.add(this);
	                    }
	                    else {
	                        this.syncErrorThrowable = true;
	                        this.destination = new SafeSubscriber(this, destinationOrNext);
	                    }
	                    break;
	                }
	            default:
	                this.syncErrorThrowable = true;
	                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
	                break;
	        }
	    }
	    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () { return this; };
	    /**
	     * A static factory for a Subscriber, given a (potentially partial) definition
	     * of an Observer.
	     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
	     * Observer represented by the given arguments.
	     */
	    Subscriber.create = function (next, error, complete) {
	        var subscriber = new Subscriber(next, error, complete);
	        subscriber.syncErrorThrowable = false;
	        return subscriber;
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `next` from
	     * the Observable, with a value. The Observable may call this method 0 or more
	     * times.
	     * @param {T} [value] The `next` value.
	     * @return {void}
	     */
	    Subscriber.prototype.next = function (value) {
	        if (!this.isStopped) {
	            this._next(value);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `error` from
	     * the Observable, with an attached {@link Error}. Notifies the Observer that
	     * the Observable has experienced an error condition.
	     * @param {any} [err] The `error` exception.
	     * @return {void}
	     */
	    Subscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._error(err);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive a valueless notification of type
	     * `complete` from the Observable. Notifies the Observer that the Observable
	     * has finished sending push-based notifications.
	     * @return {void}
	     */
	    Subscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._complete();
	        }
	    };
	    Subscriber.prototype.unsubscribe = function () {
	        if (this.closed) {
	            return;
	        }
	        this.isStopped = true;
	        _super.prototype.unsubscribe.call(this);
	    };
	    Subscriber.prototype._next = function (value) {
	        this.destination.next(value);
	    };
	    Subscriber.prototype._error = function (err) {
	        this.destination.error(err);
	        this.unsubscribe();
	    };
	    Subscriber.prototype._complete = function () {
	        this.destination.complete();
	        this.unsubscribe();
	    };
	    Subscriber.prototype._unsubscribeAndRecycle = function () {
	        var _a = this, _parent = _a._parent, _parents = _a._parents;
	        this._parent = null;
	        this._parents = null;
	        this.unsubscribe();
	        this.closed = false;
	        this.isStopped = false;
	        this._parent = _parent;
	        this._parents = _parents;
	        return this;
	    };
	    return Subscriber;
	}(Subscription_1.Subscription));
	exports.Subscriber = Subscriber;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SafeSubscriber = (function (_super) {
	    __extends(SafeSubscriber, _super);
	    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
	        _super.call(this);
	        this._parentSubscriber = _parentSubscriber;
	        var next;
	        var context = this;
	        if (isFunction_1.isFunction(observerOrNext)) {
	            next = observerOrNext;
	        }
	        else if (observerOrNext) {
	            next = observerOrNext.next;
	            error = observerOrNext.error;
	            complete = observerOrNext.complete;
	            if (observerOrNext !== Observer_1.empty) {
	                context = Object.create(observerOrNext);
	                if (isFunction_1.isFunction(context.unsubscribe)) {
	                    this.add(context.unsubscribe.bind(context));
	                }
	                context.unsubscribe = this.unsubscribe.bind(this);
	            }
	        }
	        this._context = context;
	        this._next = next;
	        this._error = error;
	        this._complete = complete;
	    }
	    SafeSubscriber.prototype.next = function (value) {
	        if (!this.isStopped && this._next) {
	            var _parentSubscriber = this._parentSubscriber;
	            if (!_parentSubscriber.syncErrorThrowable) {
	                this.__tryOrUnsub(this._next, value);
	            }
	            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var _parentSubscriber = this._parentSubscriber;
	            if (this._error) {
	                if (!_parentSubscriber.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._error, err);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parentSubscriber, this._error, err);
	                    this.unsubscribe();
	                }
	            }
	            else if (!_parentSubscriber.syncErrorThrowable) {
	                this.unsubscribe();
	                throw err;
	            }
	            else {
	                _parentSubscriber.syncErrorValue = err;
	                _parentSubscriber.syncErrorThrown = true;
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.complete = function () {
	        var _this = this;
	        if (!this.isStopped) {
	            var _parentSubscriber = this._parentSubscriber;
	            if (this._complete) {
	                var wrappedComplete = function () { return _this._complete.call(_this._context); };
	                if (!_parentSubscriber.syncErrorThrowable) {
	                    this.__tryOrUnsub(wrappedComplete);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
	                    this.unsubscribe();
	                }
	            }
	            else {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            this.unsubscribe();
	            throw err;
	        }
	    };
	    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            parent.syncErrorValue = err;
	            parent.syncErrorThrown = true;
	            return true;
	        }
	        return false;
	    };
	    SafeSubscriber.prototype._unsubscribe = function () {
	        var _parentSubscriber = this._parentSubscriber;
	        this._context = null;
	        this._parentSubscriber = null;
	        _parentSubscriber.unsubscribe();
	    };
	    return SafeSubscriber;
	}(Subscriber));
	//# sourceMappingURL=Subscriber.js.map

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	var OuterSubscriber = (function (_Subscriber) {
	    _inherits(OuterSubscriber, _Subscriber);
	
	    function OuterSubscriber() {
	        _classCallCheck(this, OuterSubscriber);
	
	        _Subscriber.apply(this, arguments);
	    }
	
	    OuterSubscriber.prototype.notifyComplete = function notifyComplete(inner) {
	        this.destination.complete();
	    };
	
	    OuterSubscriber.prototype.notifyNext = function notifyNext(outerValue, innerValue, outerIndex, innerIndex) {
	        this.destination.next(innerValue);
	    };
	
	    OuterSubscriber.prototype.notifyError = function notifyError(error, inner) {
	        this.destination.error(error);
	    };
	
	    return OuterSubscriber;
	})(_Subscriber3['default']);
	
	exports['default'] = OuterSubscriber;
	module.exports = exports['default'];

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _ImmediateScheduler = __webpack_require__(55);
	
	var _ImmediateScheduler2 = _interopRequireDefault(_ImmediateScheduler);
	
	exports['default'] = new _ImmediateScheduler2['default']();
	module.exports = exports['default'];

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = subscribeToResult;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _Observable = __webpack_require__(4);
	
	var _Observable2 = _interopRequireDefault(_Observable);
	
	var _utilSymbol_iterator = __webpack_require__(26);
	
	var _utilSymbol_iterator2 = _interopRequireDefault(_utilSymbol_iterator);
	
	var _utilSymbol_observable = __webpack_require__(34);
	
	var _utilSymbol_observable2 = _interopRequireDefault(_utilSymbol_observable);
	
	var _InnerSubscriber = __webpack_require__(84);
	
	var _InnerSubscriber2 = _interopRequireDefault(_InnerSubscriber);
	
	var isArray = Array.isArray;
	
	function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
	    var destination = new _InnerSubscriber2['default'](outerSubscriber, outerValue, outerIndex);
	    if (destination.isUnsubscribed) {
	        return;
	    }
	    if (result instanceof _Observable2['default']) {
	        if (result._isScalar) {
	            destination.next(result.value);
	            destination.complete();
	            return;
	        } else {
	            return result.subscribe(destination);
	        }
	    }
	    if (isArray(result)) {
	        for (var i = 0, len = result.length; i < len && !destination.isUnsubscribed; i++) {
	            destination.next(result[i]);
	        }
	        if (!destination.isUnsubscribed) {
	            destination.complete();
	        }
	    } else if (typeof result.then === 'function') {
	        result.then(function (x) {
	            if (!destination.isUnsubscribed) {
	                destination.next(x);
	                destination.complete();
	            }
	        }, function (err) {
	            return destination.error(err);
	        }).then(null, function (err) {
	            // Escaping the Promise trap: globally throw unhandled errors
	            setTimeout(function () {
	                throw err;
	            });
	        });
	        return destination;
	    } else if (typeof result[_utilSymbol_iterator2['default']] === 'function') {
	        for (var _iterator = result, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	            var _ref;
	
	            if (_isArray) {
	                if (_i >= _iterator.length) break;
	                _ref = _iterator[_i++];
	            } else {
	                _i = _iterator.next();
	                if (_i.done) break;
	                _ref = _i.value;
	            }
	
	            var item = _ref;
	
	            destination.next(item);
	            if (destination.isUnsubscribed) {
	                break;
	            }
	        }
	        if (!destination.isUnsubscribed) {
	            destination.complete();
	        }
	    } else if (typeof result[_utilSymbol_observable2['default']] === 'function') {
	        var obs = result[_utilSymbol_observable2['default']]();
	        if (typeof obs.subscribe !== 'function') {
	            destination.error('invalid observable');
	        } else {
	            return obs.subscribe(new _InnerSubscriber2['default'](outerSubscriber, outerValue, outerIndex));
	        }
	    } else {
	        destination.error(new TypeError('unknown type returned'));
	    }
	}
	
	module.exports = exports['default'];

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * @license Angular v4.3.3
	 * (c) 2010-2017 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	(function (global, factory) {
		 true ? factory(exports, __webpack_require__(6), __webpack_require__(202), __webpack_require__(216), __webpack_require__(19)) :
		typeof define === 'function' && define.amd ? define(['exports', 'rxjs/Observable', 'rxjs/observable/merge', 'rxjs/operator/share', 'rxjs/Subject'], factory) :
		(factory((global.ng = global.ng || {}, global.ng.core = global.ng.core || {}),global.Rx,global.Rx.Observable,global.Rx.Observable.prototype,global.Rx));
	}(this, (function (exports,rxjs_Observable,rxjs_observable_merge,rxjs_operator_share,rxjs_Subject) { 'use strict';
	
	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0
	
	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.
	
	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
	/* global Reflect, Promise */
	
	var extendStatics = Object.setPrototypeOf ||
	    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	
	function __extends(d, b) {
	    extendStatics(d, b);
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}
	
	/**
	 * @license Angular v4.3.3
	 * (c) 2010-2017 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	/**
	 * Creates a token that can be used in a DI Provider.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/Ys9ezXpj2Mnoy3Uc8KBp?p=preview))
	 *
	 * ```typescript
	 * var t = new OpaqueToken("value");
	 *
	 * var injector = Injector.resolveAndCreate([
	 *   {provide: t, useValue: "bindingValue"}
	 * ]);
	 *
	 * expect(injector.get(t)).toEqual("bindingValue");
	 * ```
	 *
	 * Using an `OpaqueToken` is preferable to using strings as tokens because of possible collisions
	 * caused by multiple providers using the same string as two different tokens.
	 *
	 * Using an `OpaqueToken` is preferable to using an `Object` as tokens because it provides better
	 * error messages.
	 * @deprecated since v4.0.0 because it does not support type information, use `InjectionToken<?>`
	 * instead.
	 */
	var OpaqueToken = (function () {
	    /**
	     * @param {?} _desc
	     */
	    function OpaqueToken(_desc) {
	        this._desc = _desc;
	    }
	    /**
	     * @return {?}
	     */
	    OpaqueToken.prototype.toString = function () { return "Token " + this._desc; };
	    return OpaqueToken;
	}());
	/**
	 * Creates a token that can be used in a DI Provider.
	 *
	 * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a
	 * runtime representation) such as when injecting an interface, callable type, array or
	 * parametrized type.
	 *
	 * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by
	 * the `Injector`. This provides additional level of type safety.
	 *
	 * ```
	 * interface MyInterface {...}
	 * var myInterface = injector.get(new InjectionToken<MyInterface>('SomeToken'));
	 * // myInterface is inferred to be MyInterface.
	 * ```
	 *
	 * ### Example
	 *
	 * {\@example core/di/ts/injector_spec.ts region='InjectionToken'}
	 *
	 * \@stable
	 */
	var InjectionToken = (function (_super) {
	    __extends(InjectionToken, _super);
	    /**
	     * @param {?} desc
	     */
	    function InjectionToken(desc) {
	        return _super.call(this, desc) || this;
	    }
	    /**
	     * @return {?}
	     */
	    InjectionToken.prototype.toString = function () { return "InjectionToken " + this._desc; };
	    return InjectionToken;
	}(OpaqueToken));
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var __window = typeof window !== 'undefined' && window;
	var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&
	    self instanceof WorkerGlobalScope && self;
	var __global = typeof global !== 'undefined' && global;
	var _global = __window || __global || __self;
	var _symbolIterator = null;
	/**
	 * @return {?}
	 */
	function getSymbolIterator() {
	    if (!_symbolIterator) {
	        var /** @type {?} */ Symbol = _global['Symbol'];
	        if (Symbol && Symbol.iterator) {
	            _symbolIterator = Symbol.iterator;
	        }
	        else {
	            // es6-shim specific logic
	            var /** @type {?} */ keys = Object.getOwnPropertyNames(Map.prototype);
	            for (var /** @type {?} */ i = 0; i < keys.length; ++i) {
	                var /** @type {?} */ key = keys[i];
	                if (key !== 'entries' && key !== 'size' &&
	                    ((Map)).prototype[key] === Map.prototype['entries']) {
	                    _symbolIterator = key;
	                }
	            }
	        }
	    }
	    return _symbolIterator;
	}
	/**
	 * @param {?} fn
	 * @return {?}
	 */
	function scheduleMicroTask(fn) {
	    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
	}
	/**
	 * @param {?} a
	 * @param {?} b
	 * @return {?}
	 */
	function looseIdentical(a, b) {
	    return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);
	}
	/**
	 * @param {?} token
	 * @return {?}
	 */
	function stringify(token) {
	    if (typeof token === 'string') {
	        return token;
	    }
	    if (token == null) {
	        return '' + token;
	    }
	    if (token.overriddenName) {
	        return "" + token.overriddenName;
	    }
	    if (token.name) {
	        return "" + token.name;
	    }
	    var /** @type {?} */ res = token.toString();
	    if (res == null) {
	        return '' + res;
	    }
	    var /** @type {?} */ newLineIndex = res.indexOf('\n');
	    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var _nextClassId = 0;
	var Reflect$1 = _global['Reflect'];
	/**
	 * @param {?} annotation
	 * @return {?}
	 */
	function extractAnnotation(annotation) {
	    if (typeof annotation === 'function' && annotation.hasOwnProperty('annotation')) {
	        // it is a decorator, extract annotation
	        annotation = annotation.annotation;
	    }
	    return annotation;
	}
	/**
	 * @param {?} fnOrArray
	 * @param {?} key
	 * @return {?}
	 */
	function applyParams(fnOrArray, key) {
	    if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function ||
	        fnOrArray === Number || fnOrArray === Array) {
	        throw new Error("Can not use native " + stringify(fnOrArray) + " as constructor");
	    }
	    if (typeof fnOrArray === 'function') {
	        return fnOrArray;
	    }
	    if (Array.isArray(fnOrArray)) {
	        var /** @type {?} */ annotations = (fnOrArray);
	        var /** @type {?} */ annoLength = annotations.length - 1;
	        var /** @type {?} */ fn = fnOrArray[annoLength];
	        if (typeof fn !== 'function') {
	            throw new Error("Last position of Class method array must be Function in key " + key + " was '" + stringify(fn) + "'");
	        }
	        if (annoLength != fn.length) {
	            throw new Error("Number of annotations (" + annoLength + ") does not match number of arguments (" + fn.length + ") in the function: " + stringify(fn));
	        }
	        var /** @type {?} */ paramsAnnotations = [];
	        for (var /** @type {?} */ i = 0, /** @type {?} */ ii = annotations.length - 1; i < ii; i++) {
	            var /** @type {?} */ paramAnnotations = [];
	            paramsAnnotations.push(paramAnnotations);
	            var /** @type {?} */ annotation = annotations[i];
	            if (Array.isArray(annotation)) {
	                for (var /** @type {?} */ j = 0; j < annotation.length; j++) {
	                    paramAnnotations.push(extractAnnotation(annotation[j]));
	                }
	            }
	            else if (typeof annotation === 'function') {
	                paramAnnotations.push(extractAnnotation(annotation));
	            }
	            else {
	                paramAnnotations.push(annotation);
	            }
	        }
	        Reflect$1.defineMetadata('parameters', paramsAnnotations, fn);
	        return fn;
	    }
	    throw new Error("Only Function or Array is supported in Class definition for key '" + key + "' is '" + stringify(fnOrArray) + "'");
	}
	/**
	 * Provides a way for expressing ES6 classes with parameter annotations in ES5.
	 *
	 * ## Basic Example
	 *
	 * ```
	 * var Greeter = ng.Class({
	 *   constructor: function(name) {
	 *     this.name = name;
	 *   },
	 *
	 *   greet: function() {
	 *     alert('Hello ' + this.name + '!');
	 *   }
	 * });
	 * ```
	 *
	 * is equivalent to ES6:
	 *
	 * ```
	 * class Greeter {
	 *   constructor(name) {
	 *     this.name = name;
	 *   }
	 *
	 *   greet() {
	 *     alert('Hello ' + this.name + '!');
	 *   }
	 * }
	 * ```
	 *
	 * or equivalent to ES5:
	 *
	 * ```
	 * var Greeter = function (name) {
	 *   this.name = name;
	 * }
	 *
	 * Greeter.prototype.greet = function () {
	 *   alert('Hello ' + this.name + '!');
	 * }
	 * ```
	 *
	 * ### Example with parameter annotations
	 *
	 * ```
	 * var MyService = ng.Class({
	 *   constructor: [String, [new Optional(), Service], function(name, myService) {
	 *     ...
	 *   }]
	 * });
	 * ```
	 *
	 * is equivalent to ES6:
	 *
	 * ```
	 * class MyService {
	 *   constructor(name: string, \@Optional() myService: Service) {
	 *     ...
	 *   }
	 * }
	 * ```
	 *
	 * ### Example with inheritance
	 *
	 * ```
	 * var Shape = ng.Class({
	 *   constructor: (color) {
	 *     this.color = color;
	 *   }
	 * });
	 *
	 * var Square = ng.Class({
	 *   extends: Shape,
	 *   constructor: function(color, size) {
	 *     Shape.call(this, color);
	 *     this.size = size;
	 *   }
	 * });
	 * ```
	 * @suppress {globalThis}
	 * \@stable
	 * @param {?} clsDef
	 * @return {?}
	 */
	function Class(clsDef) {
	    var /** @type {?} */ constructor = applyParams(clsDef.hasOwnProperty('constructor') ? clsDef.constructor : undefined, 'constructor');
	    var /** @type {?} */ proto = constructor.prototype;
	    if (clsDef.hasOwnProperty('extends')) {
	        if (typeof clsDef.extends === 'function') {
	            ((constructor)).prototype = proto =
	                Object.create(((clsDef.extends)).prototype);
	        }
	        else {
	            throw new Error("Class definition 'extends' property must be a constructor function was: " + stringify(clsDef.extends));
	        }
	    }
	    for (var /** @type {?} */ key in clsDef) {
	        if (key !== 'extends' && key !== 'prototype' && clsDef.hasOwnProperty(key)) {
	            proto[key] = applyParams(clsDef[key], key);
	        }
	    }
	    if (this && this.annotations instanceof Array) {
	        Reflect$1.defineMetadata('annotations', this.annotations, constructor);
	    }
	    var /** @type {?} */ constructorName = constructor['name'];
	    if (!constructorName || constructorName === 'constructor') {
	        ((constructor))['overriddenName'] = "class" + _nextClassId++;
	    }
	    return (constructor);
	}
	/**
	 * @suppress {globalThis}
	 * @param {?} name
	 * @param {?=} props
	 * @param {?=} parentClass
	 * @param {?=} chainFn
	 * @return {?}
	 */
	function makeDecorator(name, props, parentClass, chainFn) {
	    var /** @type {?} */ metaCtor = makeMetadataCtor(props);
	    /**
	     * @param {?} objOrType
	     * @return {?}
	     */
	    function DecoratorFactory(objOrType) {
	        if (!(Reflect$1 && Reflect$1.getOwnMetadata)) {
	            throw 'reflect-metadata shim is required when using class decorators';
	        }
	        if (this instanceof DecoratorFactory) {
	            metaCtor.call(this, objOrType);
	            return this;
	        }
	        var /** @type {?} */ annotationInstance = new ((DecoratorFactory))(objOrType);
	        var /** @type {?} */ chainAnnotation = typeof this === 'function' && Array.isArray(this.annotations) ? this.annotations : [];
	        chainAnnotation.push(annotationInstance);
	        var /** @type {?} */ TypeDecorator = (function TypeDecorator(cls) {
	            var /** @type {?} */ annotations = Reflect$1.getOwnMetadata('annotations', cls) || [];
	            annotations.push(annotationInstance);
	            Reflect$1.defineMetadata('annotations', annotations, cls);
	            return cls;
	        });
	        TypeDecorator.annotations = chainAnnotation;
	        TypeDecorator.Class = Class;
	        if (chainFn)
	            chainFn(TypeDecorator);
	        return TypeDecorator;
	    }
	    if (parentClass) {
	        DecoratorFactory.prototype = Object.create(parentClass.prototype);
	    }
	    DecoratorFactory.prototype.toString = function () { return "@" + name; };
	    ((DecoratorFactory)).annotationCls = DecoratorFactory;
	    return DecoratorFactory;
	}
	/**
	 * @param {?=} props
	 * @return {?}
	 */
	function makeMetadataCtor(props) {
	    return function ctor() {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        if (props) {
	            var /** @type {?} */ values = props.apply(void 0, args);
	            for (var /** @type {?} */ propName in values) {
	                this[propName] = values[propName];
	            }
	        }
	    };
	}
	/**
	 * @param {?} name
	 * @param {?=} props
	 * @param {?=} parentClass
	 * @return {?}
	 */
	function makeParamDecorator(name, props, parentClass) {
	    var /** @type {?} */ metaCtor = makeMetadataCtor(props);
	    /**
	     * @param {...?} args
	     * @return {?}
	     */
	    function ParamDecoratorFactory() {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        if (this instanceof ParamDecoratorFactory) {
	            metaCtor.apply(this, args);
	            return this;
	        }
	        var /** @type {?} */ annotationInstance = new (((ParamDecoratorFactory)).bind.apply(((ParamDecoratorFactory)), [void 0].concat(args)))();
	        ((ParamDecorator)).annotation = annotationInstance;
	        return ParamDecorator;
	        /**
	         * @param {?} cls
	         * @param {?} unusedKey
	         * @param {?} index
	         * @return {?}
	         */
	        function ParamDecorator(cls, unusedKey, index) {
	            var /** @type {?} */ parameters = Reflect$1.getOwnMetadata('parameters', cls) || [];
	            // there might be gaps if some in between parameters do not have annotations.
	            // we pad with nulls.
	            while (parameters.length <= index) {
	                parameters.push(null);
	            }
	            parameters[index] = parameters[index] || []; /** @type {?} */
	            ((parameters[index])).push(annotationInstance);
	            Reflect$1.defineMetadata('parameters', parameters, cls);
	            return cls;
	        }
	    }
	    if (parentClass) {
	        ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);
	    }
	    ParamDecoratorFactory.prototype.toString = function () { return "@" + name; };
	    ((ParamDecoratorFactory)).annotationCls = ParamDecoratorFactory;
	    return ParamDecoratorFactory;
	}
	/**
	 * @param {?} name
	 * @param {?=} props
	 * @param {?=} parentClass
	 * @return {?}
	 */
	function makePropDecorator(name, props, parentClass) {
	    var /** @type {?} */ metaCtor = makeMetadataCtor(props);
	    /**
	     * @param {...?} args
	     * @return {?}
	     */
	    function PropDecoratorFactory() {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        if (this instanceof PropDecoratorFactory) {
	            metaCtor.apply(this, args);
	            return this;
	        }
	        var /** @type {?} */ decoratorInstance = new (((PropDecoratorFactory)).bind.apply(((PropDecoratorFactory)), [void 0].concat(args)))();
	        return function PropDecorator(target, name) {
	            var /** @type {?} */ meta = Reflect$1.getOwnMetadata('propMetadata', target.constructor) || {};
	            meta[name] = meta.hasOwnProperty(name) && meta[name] || [];
	            meta[name].unshift(decoratorInstance);
	            Reflect$1.defineMetadata('propMetadata', meta, target.constructor);
	        };
	    }
	    if (parentClass) {
	        PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
	    }
	    PropDecoratorFactory.prototype.toString = function () { return "@" + name; };
	    ((PropDecoratorFactory)).annotationCls = PropDecoratorFactory;
	    return PropDecoratorFactory;
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * This token can be used to create a virtual provider that will populate the
	 * `entryComponents` fields of components and ng modules based on its `useValue`.
	 * All components that are referenced in the `useValue` value (either directly
	 * or in a nested array or map) will be added to the `entryComponents` property.
	 *
	 * ### Example
	 * The following example shows how the router can populate the `entryComponents`
	 * field of an NgModule based on the router configuration which refers
	 * to components.
	 *
	 * ```typescript
	 * // helper function inside the router
	 * function provideRoutes(routes) {
	 *   return [
	 *     {provide: ROUTES, useValue: routes},
	 *     {provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: routes, multi: true}
	 *   ];
	 * }
	 *
	 * // user code
	 * let routes = [
	 *   {path: '/root', component: RootComp},
	 *   {path: '/teams', component: TeamsComp}
	 * ];
	 *
	 * \@NgModule({
	 *   providers: [provideRoutes(routes)]
	 * })
	 * class ModuleWithRoutes {}
	 * ```
	 *
	 * \@experimental
	 */
	var ANALYZE_FOR_ENTRY_COMPONENTS = new InjectionToken('AnalyzeForEntryComponents');
	/**
	 * Attribute decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var Attribute = makeParamDecorator('Attribute', function (attributeName) { return ({ attributeName: attributeName }); });
	/**
	 * Base class for query metadata.
	 *
	 * See {\@link ContentChildren}, {\@link ContentChild}, {\@link ViewChildren}, {\@link ViewChild} for
	 * more information.
	 *
	 * \@stable
	 * @abstract
	 */
	var Query = (function () {
	    function Query() {
	    }
	    return Query;
	}());
	/**
	 * ContentChildren decorator and metadata.
	 *
	 *  \@stable
	 *  \@Annotation
	 */
	var ContentChildren = makePropDecorator('ContentChildren', function (selector, data) {
	    if (data === void 0) { data = {}; }
	    return (Object.assign({ selector: selector, first: false, isViewQuery: false, descendants: false }, data));
	}, Query);
	/**
	 * ContentChild decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var ContentChild = makePropDecorator('ContentChild', function (selector, data) {
	    if (data === void 0) { data = {}; }
	    return (Object.assign({ selector: selector, first: true, isViewQuery: false, descendants: true }, data));
	}, Query);
	/**
	 * ViewChildren decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var ViewChildren = makePropDecorator('ViewChildren', function (selector, data) {
	    if (data === void 0) { data = {}; }
	    return (Object.assign({ selector: selector, first: false, isViewQuery: true, descendants: true }, data));
	}, Query);
	/**
	 * ViewChild decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var ViewChild = makePropDecorator('ViewChild', function (selector, data) { return (Object.assign({ selector: selector, first: true, isViewQuery: true, descendants: true }, data)); }, Query);
	var ChangeDetectionStrategy = {};
	ChangeDetectionStrategy.OnPush = 0;
	ChangeDetectionStrategy.Default = 1;
	ChangeDetectionStrategy[ChangeDetectionStrategy.OnPush] = "OnPush";
	ChangeDetectionStrategy[ChangeDetectionStrategy.Default] = "Default";
	var ChangeDetectorStatus = {};
	ChangeDetectorStatus.CheckOnce = 0;
	ChangeDetectorStatus.Checked = 1;
	ChangeDetectorStatus.CheckAlways = 2;
	ChangeDetectorStatus.Detached = 3;
	ChangeDetectorStatus.Errored = 4;
	ChangeDetectorStatus.Destroyed = 5;
	ChangeDetectorStatus[ChangeDetectorStatus.CheckOnce] = "CheckOnce";
	ChangeDetectorStatus[ChangeDetectorStatus.Checked] = "Checked";
	ChangeDetectorStatus[ChangeDetectorStatus.CheckAlways] = "CheckAlways";
	ChangeDetectorStatus[ChangeDetectorStatus.Detached] = "Detached";
	ChangeDetectorStatus[ChangeDetectorStatus.Errored] = "Errored";
	ChangeDetectorStatus[ChangeDetectorStatus.Destroyed] = "Destroyed";
	/**
	 * @param {?} changeDetectionStrategy
	 * @return {?}
	 */
	function isDefaultChangeDetectionStrategy(changeDetectionStrategy) {
	    return changeDetectionStrategy == null ||
	        changeDetectionStrategy === ChangeDetectionStrategy.Default;
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Directive decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var Directive = makeDecorator('Directive', function (dir) {
	    if (dir === void 0) { dir = {}; }
	    return dir;
	});
	/**
	 * Component decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var Component = makeDecorator('Component', function (c) {
	    if (c === void 0) { c = {}; }
	    return (Object.assign({ changeDetection: ChangeDetectionStrategy.Default }, c));
	}, Directive);
	/**
	 * Pipe decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var Pipe = makeDecorator('Pipe', function (p) { return (Object.assign({ pure: true }, p)); });
	/**
	 * Input decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var Input = makePropDecorator('Input', function (bindingPropertyName) { return ({ bindingPropertyName: bindingPropertyName }); });
	/**
	 * Output decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var Output = makePropDecorator('Output', function (bindingPropertyName) { return ({ bindingPropertyName: bindingPropertyName }); });
	/**
	 * HostBinding decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var HostBinding = makePropDecorator('HostBinding', function (hostPropertyName) { return ({ hostPropertyName: hostPropertyName }); });
	/**
	 * HostListener decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var HostListener = makePropDecorator('HostListener', function (eventName, args) { return ({ eventName: eventName, args: args }); });
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Defines a schema that will allow:
	 * - any non-Angular elements with a `-` in their name,
	 * - any properties on elements with a `-` in their name which is the common rule for custom
	 * elements.
	 *
	 * \@stable
	 */
	var CUSTOM_ELEMENTS_SCHEMA = {
	    name: 'custom-elements'
	};
	/**
	 * Defines a schema that will allow any property on any element.
	 *
	 * \@experimental
	 */
	var NO_ERRORS_SCHEMA = {
	    name: 'no-errors-schema'
	};
	/**
	 * NgModule decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var NgModule = makeDecorator('NgModule', function (ngModule) { return ngModule; });
	var ViewEncapsulation = {};
	ViewEncapsulation.Emulated = 0;
	ViewEncapsulation.Native = 1;
	ViewEncapsulation.None = 2;
	ViewEncapsulation[ViewEncapsulation.Emulated] = "Emulated";
	ViewEncapsulation[ViewEncapsulation.Native] = "Native";
	ViewEncapsulation[ViewEncapsulation.None] = "None";
	/**
	 * Metadata properties available for configuring Views.
	 *
	 * For details on the `\@Component` annotation, see {\@link Component}.
	 *
	 * ### Example
	 *
	 * ```
	 * \@Component({
	 *   selector: 'greet',
	 *   template: 'Hello {{name}}!',
	 * })
	 * class Greet {
	 *   name: string;
	 *
	 *   constructor() {
	 *     this.name = 'World';
	 *   }
	 * }
	 * ```
	 *
	 * @deprecated Use Component instead.
	 *
	 * {\@link Component}
	 */
	var ViewMetadata = (function () {
	    /**
	     * @param {?=} opts
	     */
	    function ViewMetadata(opts) {
	        if (opts === void 0) { opts = {}; }
	        this.templateUrl = opts.templateUrl;
	        this.template = opts.template;
	        this.styleUrls = opts.styleUrls;
	        this.styles = opts.styles;
	        this.encapsulation = opts.encapsulation;
	        this.animations = opts.animations;
	        this.interpolation = opts.interpolation;
	    }
	    return ViewMetadata;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@whatItDoes Represents the version of Angular
	 *
	 * \@stable
	 */
	var Version = (function () {
	    /**
	     * @param {?} full
	     */
	    function Version(full) {
	        this.full = full;
	    }
	    Object.defineProperty(Version.prototype, "major", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.full.split('.')[0]; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Version.prototype, "minor", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.full.split('.')[1]; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Version.prototype, "patch", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.full.split('.').slice(2).join('.'); },
	        enumerable: true,
	        configurable: true
	    });
	    return Version;
	}());
	/**
	 * \@stable
	 */
	var VERSION = new Version('4.3.3');
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Inject decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var Inject = makeParamDecorator('Inject', function (token) { return ({ token: token }); });
	/**
	 * Optional decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var Optional = makeParamDecorator('Optional');
	/**
	 * Injectable decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var Injectable = makeDecorator('Injectable');
	/**
	 * Self decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var Self = makeParamDecorator('Self');
	/**
	 * SkipSelf decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var SkipSelf = makeParamDecorator('SkipSelf');
	/**
	 * Host decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var Host = makeParamDecorator('Host');
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Allows to refer to references which are not yet defined.
	 *
	 * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of
	 * DI is declared,
	 * but not yet defined. It is also used when the `token` which we use when creating a query is not
	 * yet defined.
	 *
	 * ### Example
	 * {\@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}
	 * \@experimental
	 * @param {?} forwardRefFn
	 * @return {?}
	 */
	function forwardRef(forwardRefFn) {
	    ((forwardRefFn)).__forward_ref__ = forwardRef;
	    ((forwardRefFn)).toString = function () { return stringify(this()); };
	    return (((forwardRefFn)));
	}
	/**
	 * Lazily retrieves the reference value from a forwardRef.
	 *
	 * Acts as the identity function when given a non-forward-ref value.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/GU72mJrk1fiodChcmiDR?p=preview))
	 *
	 * {\@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}
	 *
	 * See: {\@link forwardRef}
	 * \@experimental
	 * @param {?} type
	 * @return {?}
	 */
	function resolveForwardRef(type) {
	    if (typeof type === 'function' && type.hasOwnProperty('__forward_ref__') &&
	        type.__forward_ref__ === forwardRef) {
	        return ((type))();
	    }
	    else {
	        return type;
	    }
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var _THROW_IF_NOT_FOUND = new Object();
	var THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
	var _NullInjector = (function () {
	    function _NullInjector() {
	    }
	    /**
	     * @param {?} token
	     * @param {?=} notFoundValue
	     * @return {?}
	     */
	    _NullInjector.prototype.get = function (token, notFoundValue) {
	        if (notFoundValue === void 0) { notFoundValue = _THROW_IF_NOT_FOUND; }
	        if (notFoundValue === _THROW_IF_NOT_FOUND) {
	            throw new Error("No provider for " + stringify(token) + "!");
	        }
	        return notFoundValue;
	    };
	    return _NullInjector;
	}());
	/**
	 * \@whatItDoes Injector interface
	 * \@howToUse
	 * ```
	 * const injector: Injector = ...;
	 * injector.get(...);
	 * ```
	 *
	 * \@description
	 * For more details, see the {\@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
	 *
	 * ### Example
	 *
	 * {\@example core/di/ts/injector_spec.ts region='Injector'}
	 *
	 * `Injector` returns itself when given `Injector` as a token:
	 * {\@example core/di/ts/injector_spec.ts region='injectInjector'}
	 *
	 * \@stable
	 * @abstract
	 */
	var Injector = (function () {
	    function Injector() {
	    }
	    /**
	     * Retrieves an instance from the injector based on the provided token.
	     * If not found:
	     * - Throws an error if no `notFoundValue` that is not equal to
	     * Injector.THROW_IF_NOT_FOUND is given
	     * - Returns the `notFoundValue` otherwise
	     * @abstract
	     * @template T
	     * @param {?} token
	     * @param {?=} notFoundValue
	     * @return {?}
	     */
	    Injector.prototype.get = function (token, notFoundValue) { };
	    /**
	     * @deprecated from v4.0.0 use Type<T> or InjectionToken<T>
	     * @suppress {duplicate}
	     * @abstract
	     * @param {?} token
	     * @param {?=} notFoundValue
	     * @return {?}
	     */
	    Injector.prototype.get = function (token, notFoundValue) { };
	    return Injector;
	}());
	Injector.THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
	Injector.NULL = new _NullInjector();
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var ERROR_COMPONENT_TYPE = 'ngComponentType';
	var ERROR_DEBUG_CONTEXT = 'ngDebugContext';
	var ERROR_ORIGINAL_ERROR = 'ngOriginalError';
	var ERROR_LOGGER = 'ngErrorLogger';
	/**
	 * @param {?} error
	 * @return {?}
	 */
	/**
	 * @param {?} error
	 * @return {?}
	 */
	function getDebugContext(error) {
	    return ((error))[ERROR_DEBUG_CONTEXT];
	}
	/**
	 * @param {?} error
	 * @return {?}
	 */
	function getOriginalError(error) {
	    return ((error))[ERROR_ORIGINAL_ERROR];
	}
	/**
	 * @param {?} error
	 * @return {?}
	 */
	function getErrorLogger(error) {
	    return ((error))[ERROR_LOGGER] || defaultErrorLogger;
	}
	/**
	 * @param {?} console
	 * @param {...?} values
	 * @return {?}
	 */
	function defaultErrorLogger(console) {
	    var values = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        values[_i - 1] = arguments[_i];
	    }
	    console.error.apply(console, values);
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@whatItDoes Provides a hook for centralized exception handling.
	 *
	 * \@description
	 *
	 * The default implementation of `ErrorHandler` prints error messages to the `console`. To
	 * intercept error handling, write a custom exception handler that replaces this default as
	 * appropriate for your app.
	 *
	 * ### Example
	 *
	 * ```
	 * class MyErrorHandler implements ErrorHandler {
	 *   handleError(error) {
	 *     // do something with the exception
	 *   }
	 * }
	 *
	 * \@NgModule({
	 *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]
	 * })
	 * class MyModule {}
	 * ```
	 *
	 * \@stable
	 */
	var ErrorHandler = (function () {
	    /**
	     * @param {?=} deprecatedParameter
	     */
	    function ErrorHandler(
	        /**
	         * @deprecated since v4.0 parameter no longer has an effect, as ErrorHandler will never
	         * rethrow.
	         */
	        deprecatedParameter) {
	        /**
	         * \@internal
	         */
	        this._console = console;
	    }
	    /**
	     * @param {?} error
	     * @return {?}
	     */
	    ErrorHandler.prototype.handleError = function (error) {
	        var /** @type {?} */ originalError = this._findOriginalError(error);
	        var /** @type {?} */ context = this._findContext(error);
	        // Note: Browser consoles show the place from where console.error was called.
	        // We can use this to give users additional information about the error.
	        var /** @type {?} */ errorLogger = getErrorLogger(error);
	        errorLogger(this._console, "ERROR", error);
	        if (originalError) {
	            errorLogger(this._console, "ORIGINAL ERROR", originalError);
	        }
	        if (context) {
	            errorLogger(this._console, 'ERROR CONTEXT', context);
	        }
	    };
	    /**
	     * \@internal
	     * @param {?} error
	     * @return {?}
	     */
	    ErrorHandler.prototype._findContext = function (error) {
	        if (error) {
	            return getDebugContext(error) ? getDebugContext(error) :
	                this._findContext(getOriginalError(error));
	        }
	        return null;
	    };
	    /**
	     * \@internal
	     * @param {?} error
	     * @return {?}
	     */
	    ErrorHandler.prototype._findOriginalError = function (error) {
	        var /** @type {?} */ e = getOriginalError(error);
	        while (e && getOriginalError(e)) {
	            e = getOriginalError(e);
	        }
	        return e;
	    };
	    return ErrorHandler;
	}());
	/**
	 * @param {?} message
	 * @param {?} originalError
	 * @return {?}
	 */
	function wrappedError(message, originalError) {
	    var /** @type {?} */ msg = message + " caused by: " + (originalError instanceof Error ? originalError.message : originalError);
	    var /** @type {?} */ error = Error(msg);
	    ((error))[ERROR_ORIGINAL_ERROR] = originalError;
	    return error;
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} keys
	 * @return {?}
	 */
	function findFirstClosedCycle(keys) {
	    var /** @type {?} */ res = [];
	    for (var /** @type {?} */ i = 0; i < keys.length; ++i) {
	        if (res.indexOf(keys[i]) > -1) {
	            res.push(keys[i]);
	            return res;
	        }
	        res.push(keys[i]);
	    }
	    return res;
	}
	/**
	 * @param {?} keys
	 * @return {?}
	 */
	function constructResolvingPath(keys) {
	    if (keys.length > 1) {
	        var /** @type {?} */ reversed = findFirstClosedCycle(keys.slice().reverse());
	        var /** @type {?} */ tokenStrs = reversed.map(function (k) { return stringify(k.token); });
	        return ' (' + tokenStrs.join(' -> ') + ')';
	    }
	    return '';
	}
	/**
	 * @param {?} injector
	 * @param {?} key
	 * @param {?} constructResolvingMessage
	 * @param {?=} originalError
	 * @return {?}
	 */
	function injectionError(injector, key, constructResolvingMessage, originalError) {
	    var /** @type {?} */ keys = [key];
	    var /** @type {?} */ errMsg = constructResolvingMessage(keys);
	    var /** @type {?} */ error = ((originalError ? wrappedError(errMsg, originalError) : Error(errMsg)));
	    error.addKey = addKey;
	    error.keys = keys;
	    error.injectors = [injector];
	    error.constructResolvingMessage = constructResolvingMessage;
	    ((error))[ERROR_ORIGINAL_ERROR] = originalError;
	    return error;
	}
	/**
	 * @this {?}
	 * @param {?} injector
	 * @param {?} key
	 * @return {?}
	 */
	function addKey(injector, key) {
	    this.injectors.push(injector);
	    this.keys.push(key);
	    // Note: This updated message won't be reflected in the `.stack` property
	    this.message = this.constructResolvingMessage(this.keys);
	}
	/**
	 * Thrown when trying to retrieve a dependency by key from {\@link Injector}, but the
	 * {\@link Injector} does not have a {\@link Provider} for the given key.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/vq8D3FRB9aGbnWJqtEPE?p=preview))
	 *
	 * ```typescript
	 * class A {
	 *   constructor(b:B) {}
	 * }
	 *
	 * expect(() => Injector.resolveAndCreate([A])).toThrowError();
	 * ```
	 * @param {?} injector
	 * @param {?} key
	 * @return {?}
	 */
	function noProviderError(injector, key) {
	    return injectionError(injector, key, function (keys) {
	        var /** @type {?} */ first = stringify(keys[0].token);
	        return "No provider for " + first + "!" + constructResolvingPath(keys);
	    });
	}
	/**
	 * Thrown when dependencies form a cycle.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/wYQdNos0Tzql3ei1EV9j?p=info))
	 *
	 * ```typescript
	 * var injector = Injector.resolveAndCreate([
	 *   {provide: "one", useFactory: (two) => "two", deps: [[new Inject("two")]]},
	 *   {provide: "two", useFactory: (one) => "one", deps: [[new Inject("one")]]}
	 * ]);
	 *
	 * expect(() => injector.get("one")).toThrowError();
	 * ```
	 *
	 * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.
	 * @param {?} injector
	 * @param {?} key
	 * @return {?}
	 */
	function cyclicDependencyError(injector, key) {
	    return injectionError(injector, key, function (keys) {
	        return "Cannot instantiate cyclic dependency!" + constructResolvingPath(keys);
	    });
	}
	/**
	 * Thrown when a constructing type returns with an Error.
	 *
	 * The `InstantiationError` class contains the original error plus the dependency graph which caused
	 * this object to be instantiated.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/7aWYdcqTQsP0eNqEdUAf?p=preview))
	 *
	 * ```typescript
	 * class A {
	 *   constructor() {
	 *     throw new Error('message');
	 *   }
	 * }
	 *
	 * var injector = Injector.resolveAndCreate([A]);
	 * try {
	 *   injector.get(A);
	 * } catch (e) {
	 *   expect(e instanceof InstantiationError).toBe(true);
	 *   expect(e.originalException.message).toEqual("message");
	 *   expect(e.originalStack).toBeDefined();
	 * }
	 * ```
	 * @param {?} injector
	 * @param {?} originalException
	 * @param {?} originalStack
	 * @param {?} key
	 * @return {?}
	 */
	function instantiationError(injector, originalException, originalStack, key) {
	    return injectionError(injector, key, function (keys) {
	        var /** @type {?} */ first = stringify(keys[0].token);
	        return originalException.message + ": Error during instantiation of " + first + "!" + constructResolvingPath(keys) + ".";
	    }, originalException);
	}
	/**
	 * Thrown when an object other then {\@link Provider} (or `Type`) is passed to {\@link Injector}
	 * creation.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/YatCFbPAMCL0JSSQ4mvH?p=preview))
	 *
	 * ```typescript
	 * expect(() => Injector.resolveAndCreate(["not a type"])).toThrowError();
	 * ```
	 * @param {?} provider
	 * @return {?}
	 */
	function invalidProviderError(provider) {
	    return Error("Invalid provider - only instances of Provider and Type are allowed, got: " + provider);
	}
	/**
	 * Thrown when the class has no annotation information.
	 *
	 * Lack of annotation information prevents the {\@link Injector} from determining which dependencies
	 * need to be injected into the constructor.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/rHnZtlNS7vJOPQ6pcVkm?p=preview))
	 *
	 * ```typescript
	 * class A {
	 *   constructor(b) {}
	 * }
	 *
	 * expect(() => Injector.resolveAndCreate([A])).toThrowError();
	 * ```
	 *
	 * This error is also thrown when the class not marked with {\@link Injectable} has parameter types.
	 *
	 * ```typescript
	 * class B {}
	 *
	 * class A {
	 *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.
	 * }
	 *
	 * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();
	 * ```
	 * \@stable
	 * @param {?} typeOrFunc
	 * @param {?} params
	 * @return {?}
	 */
	function noAnnotationError(typeOrFunc, params) {
	    var /** @type {?} */ signature = [];
	    for (var /** @type {?} */ i = 0, /** @type {?} */ ii = params.length; i < ii; i++) {
	        var /** @type {?} */ parameter = params[i];
	        if (!parameter || parameter.length == 0) {
	            signature.push('?');
	        }
	        else {
	            signature.push(parameter.map(stringify).join(' '));
	        }
	    }
	    return Error('Cannot resolve all parameters for \'' + stringify(typeOrFunc) + '\'(' +
	        signature.join(', ') + '). ' +
	        'Make sure that all the parameters are decorated with Inject or have valid type annotations and that \'' +
	        stringify(typeOrFunc) + '\' is decorated with Injectable.');
	}
	/**
	 * Thrown when getting an object by index.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/bRs0SX2OTQiJzqvjgl8P?p=preview))
	 *
	 * ```typescript
	 * class A {}
	 *
	 * var injector = Injector.resolveAndCreate([A]);
	 *
	 * expect(() => injector.getAt(100)).toThrowError();
	 * ```
	 * \@stable
	 * @param {?} index
	 * @return {?}
	 */
	function outOfBoundsError(index) {
	    return Error("Index " + index + " is out-of-bounds.");
	}
	/**
	 * Thrown when a multi provider and a regular provider are bound to the same token.
	 *
	 * ### Example
	 *
	 * ```typescript
	 * expect(() => Injector.resolveAndCreate([
	 *   { provide: "Strings", useValue: "string1", multi: true},
	 *   { provide: "Strings", useValue: "string2", multi: false}
	 * ])).toThrowError();
	 * ```
	 * @param {?} provider1
	 * @param {?} provider2
	 * @return {?}
	 */
	function mixingMultiProvidersWithRegularProvidersError(provider1, provider2) {
	    return Error("Cannot mix multi providers and regular providers, got: " + provider1 + " " + provider2);
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * A unique object used for retrieving items from the {\@link ReflectiveInjector}.
	 *
	 * Keys have:
	 * - a system-wide unique `id`.
	 * - a `token`.
	 *
	 * `Key` is used internally by {\@link ReflectiveInjector} because its system-wide unique `id` allows
	 * the
	 * injector to store created objects in a more efficient way.
	 *
	 * `Key` should not be created directly. {\@link ReflectiveInjector} creates keys automatically when
	 * resolving
	 * providers.
	 * \@experimental
	 */
	var ReflectiveKey = (function () {
	    /**
	     * Private
	     * @param {?} token
	     * @param {?} id
	     */
	    function ReflectiveKey(token, id) {
	        this.token = token;
	        this.id = id;
	        if (!token) {
	            throw new Error('Token must be defined!');
	        }
	    }
	    Object.defineProperty(ReflectiveKey.prototype, "displayName", {
	        /**
	         * Returns a stringified token.
	         * @return {?}
	         */
	        get: function () { return stringify(this.token); },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Retrieves a `Key` for a token.
	     * @param {?} token
	     * @return {?}
	     */
	    ReflectiveKey.get = function (token) {
	        return _globalKeyRegistry.get(resolveForwardRef(token));
	    };
	    Object.defineProperty(ReflectiveKey, "numberOfKeys", {
	        /**
	         * @return {?} the number of keys registered in the system.
	         */
	        get: function () { return _globalKeyRegistry.numberOfKeys; },
	        enumerable: true,
	        configurable: true
	    });
	    return ReflectiveKey;
	}());
	/**
	 * \@internal
	 */
	var KeyRegistry = (function () {
	    function KeyRegistry() {
	        this._allKeys = new Map();
	    }
	    /**
	     * @param {?} token
	     * @return {?}
	     */
	    KeyRegistry.prototype.get = function (token) {
	        if (token instanceof ReflectiveKey)
	            return token;
	        if (this._allKeys.has(token)) {
	            return ((this._allKeys.get(token)));
	        }
	        var /** @type {?} */ newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);
	        this._allKeys.set(token, newKey);
	        return newKey;
	    };
	    Object.defineProperty(KeyRegistry.prototype, "numberOfKeys", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._allKeys.size; },
	        enumerable: true,
	        configurable: true
	    });
	    return KeyRegistry;
	}());
	var _globalKeyRegistry = new KeyRegistry();
	/**
	 * \@whatItDoes Represents a type that a Component or other object is instances of.
	 *
	 * \@description
	 *
	 * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
	 * the `MyCustomComponent` constructor function.
	 *
	 * \@stable
	 */
	var Type = Function;
	/**
	 * @param {?} v
	 * @return {?}
	 */
	function isType(v) {
	    return typeof v === 'function';
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Attention: This regex has to hold even if the code is minified!
	 */
	var DELEGATE_CTOR = /^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*arguments\)/;
	var ReflectionCapabilities = (function () {
	    /**
	     * @param {?=} reflect
	     */
	    function ReflectionCapabilities(reflect) {
	        this._reflect = reflect || _global['Reflect'];
	    }
	    /**
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype.isReflectionEnabled = function () { return true; };
	    /**
	     * @template T
	     * @param {?} t
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype.factory = function (t) { return function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        return new (t.bind.apply(t, [void 0].concat(args)))();
	    }; };
	    /**
	     * \@internal
	     * @param {?} paramTypes
	     * @param {?} paramAnnotations
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype._zipTypesAndAnnotations = function (paramTypes, paramAnnotations) {
	        var /** @type {?} */ result;
	        if (typeof paramTypes === 'undefined') {
	            result = new Array(paramAnnotations.length);
	        }
	        else {
	            result = new Array(paramTypes.length);
	        }
	        for (var /** @type {?} */ i = 0; i < result.length; i++) {
	            // TS outputs Object for parameters without types, while Traceur omits
	            // the annotations. For now we preserve the Traceur behavior to aid
	            // migration, but this can be revisited.
	            if (typeof paramTypes === 'undefined') {
	                result[i] = [];
	            }
	            else if (paramTypes[i] != Object) {
	                result[i] = [paramTypes[i]];
	            }
	            else {
	                result[i] = [];
	            }
	            if (paramAnnotations && paramAnnotations[i] != null) {
	                result[i] = result[i].concat(paramAnnotations[i]);
	            }
	        }
	        return result;
	    };
	    /**
	     * @param {?} type
	     * @param {?} parentCtor
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype._ownParameters = function (type, parentCtor) {
	        // If we have no decorators, we only have function.length as metadata.
	        // In that case, to detect whether a child class declared an own constructor or not,
	        // we need to look inside of that constructor to check whether it is
	        // just calling the parent.
	        // This also helps to work around for https://github.com/Microsoft/TypeScript/issues/12439
	        // that sets 'design:paramtypes' to []
	        // if a class inherits from another class but has no ctor declared itself.
	        if (DELEGATE_CTOR.exec(type.toString())) {
	            return null;
	        }
	        // Prefer the direct API.
	        if (((type)).parameters && ((type)).parameters !== parentCtor.parameters) {
	            return ((type)).parameters;
	        }
	        // API of tsickle for lowering decorators to properties on the class.
	        var /** @type {?} */ tsickleCtorParams = ((type)).ctorParameters;
	        if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {
	            // Newer tsickle uses a function closure
	            // Retain the non-function case for compatibility with older tsickle
	            var /** @type {?} */ ctorParameters = typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;
	            var /** @type {?} */ paramTypes = ctorParameters.map(function (ctorParam) { return ctorParam && ctorParam.type; });
	            var /** @type {?} */ paramAnnotations = ctorParameters.map(function (ctorParam) { return ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators); });
	            return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
	        }
	        // API for metadata created by invoking the decorators.
	        if (this._reflect != null && this._reflect.getOwnMetadata != null) {
	            var /** @type {?} */ paramAnnotations = this._reflect.getOwnMetadata('parameters', type);
	            var /** @type {?} */ paramTypes = this._reflect.getOwnMetadata('design:paramtypes', type);
	            if (paramTypes || paramAnnotations) {
	                return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
	            }
	        }
	        // If a class has no decorators, at least create metadata
	        // based on function.length.
	        // Note: We know that this is a real constructor as we checked
	        // the content of the constructor above.
	        return new Array(((type.length))).fill(undefined);
	    };
	    /**
	     * @param {?} type
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype.parameters = function (type) {
	        // Note: only report metadata if we have at least one class decorator
	        // to stay in sync with the static reflector.
	        if (!isType(type)) {
	            return [];
	        }
	        var /** @type {?} */ parentCtor = getParentCtor(type);
	        var /** @type {?} */ parameters = this._ownParameters(type, parentCtor);
	        if (!parameters && parentCtor !== Object) {
	            parameters = this.parameters(parentCtor);
	        }
	        return parameters || [];
	    };
	    /**
	     * @param {?} typeOrFunc
	     * @param {?} parentCtor
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype._ownAnnotations = function (typeOrFunc, parentCtor) {
	        // Prefer the direct API.
	        if (((typeOrFunc)).annotations && ((typeOrFunc)).annotations !== parentCtor.annotations) {
	            var /** @type {?} */ annotations = ((typeOrFunc)).annotations;
	            if (typeof annotations === 'function' && annotations.annotations) {
	                annotations = annotations.annotations;
	            }
	            return annotations;
	        }
	        // API of tsickle for lowering decorators to properties on the class.
	        if (((typeOrFunc)).decorators && ((typeOrFunc)).decorators !== parentCtor.decorators) {
	            return convertTsickleDecoratorIntoMetadata(((typeOrFunc)).decorators);
	        }
	        // API for metadata created by invoking the decorators.
	        if (this._reflect && this._reflect.getOwnMetadata) {
	            return this._reflect.getOwnMetadata('annotations', typeOrFunc);
	        }
	        return null;
	    };
	    /**
	     * @param {?} typeOrFunc
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype.annotations = function (typeOrFunc) {
	        if (!isType(typeOrFunc)) {
	            return [];
	        }
	        var /** @type {?} */ parentCtor = getParentCtor(typeOrFunc);
	        var /** @type {?} */ ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];
	        var /** @type {?} */ parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];
	        return parentAnnotations.concat(ownAnnotations);
	    };
	    /**
	     * @param {?} typeOrFunc
	     * @param {?} parentCtor
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype._ownPropMetadata = function (typeOrFunc, parentCtor) {
	        // Prefer the direct API.
	        if (((typeOrFunc)).propMetadata &&
	            ((typeOrFunc)).propMetadata !== parentCtor.propMetadata) {
	            var /** @type {?} */ propMetadata = ((typeOrFunc)).propMetadata;
	            if (typeof propMetadata === 'function' && propMetadata.propMetadata) {
	                propMetadata = propMetadata.propMetadata;
	            }
	            return propMetadata;
	        }
	        // API of tsickle for lowering decorators to properties on the class.
	        if (((typeOrFunc)).propDecorators &&
	            ((typeOrFunc)).propDecorators !== parentCtor.propDecorators) {
	            var /** @type {?} */ propDecorators_1 = ((typeOrFunc)).propDecorators;
	            var /** @type {?} */ propMetadata_1 = ({});
	            Object.keys(propDecorators_1).forEach(function (prop) {
	                propMetadata_1[prop] = convertTsickleDecoratorIntoMetadata(propDecorators_1[prop]);
	            });
	            return propMetadata_1;
	        }
	        // API for metadata created by invoking the decorators.
	        if (this._reflect && this._reflect.getOwnMetadata) {
	            return this._reflect.getOwnMetadata('propMetadata', typeOrFunc);
	        }
	        return null;
	    };
	    /**
	     * @param {?} typeOrFunc
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype.propMetadata = function (typeOrFunc) {
	        if (!isType(typeOrFunc)) {
	            return {};
	        }
	        var /** @type {?} */ parentCtor = getParentCtor(typeOrFunc);
	        var /** @type {?} */ propMetadata = {};
	        if (parentCtor !== Object) {
	            var /** @type {?} */ parentPropMetadata_1 = this.propMetadata(parentCtor);
	            Object.keys(parentPropMetadata_1).forEach(function (propName) {
	                propMetadata[propName] = parentPropMetadata_1[propName];
	            });
	        }
	        var /** @type {?} */ ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);
	        if (ownPropMetadata) {
	            Object.keys(ownPropMetadata).forEach(function (propName) {
	                var /** @type {?} */ decorators = [];
	                if (propMetadata.hasOwnProperty(propName)) {
	                    decorators.push.apply(decorators, propMetadata[propName]);
	                }
	                decorators.push.apply(decorators, ownPropMetadata[propName]);
	                propMetadata[propName] = decorators;
	            });
	        }
	        return propMetadata;
	    };
	    /**
	     * @param {?} type
	     * @param {?} lcProperty
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype.hasLifecycleHook = function (type, lcProperty) {
	        return type instanceof Type && lcProperty in type.prototype;
	    };
	    /**
	     * @param {?} name
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype.getter = function (name) { return (new Function('o', 'return o.' + name + ';')); };
	    /**
	     * @param {?} name
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype.setter = function (name) {
	        return (new Function('o', 'v', 'return o.' + name + ' = v;'));
	    };
	    /**
	     * @param {?} name
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype.method = function (name) {
	        var /** @type {?} */ functionBody = "if (!o." + name + ") throw new Error('\"" + name + "\" is undefined');\n        return o." + name + ".apply(o, args);";
	        return (new Function('o', 'args', functionBody));
	    };
	    /**
	     * @param {?} type
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype.importUri = function (type) {
	        // StaticSymbol
	        if (typeof type === 'object' && type['filePath']) {
	            return type['filePath'];
	        }
	        // Runtime type
	        return "./" + stringify(type);
	    };
	    /**
	     * @param {?} type
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype.resourceUri = function (type) { return "./" + stringify(type); };
	    /**
	     * @param {?} name
	     * @param {?} moduleUrl
	     * @param {?} members
	     * @param {?} runtime
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype.resolveIdentifier = function (name, moduleUrl, members, runtime) {
	        return runtime;
	    };
	    /**
	     * @param {?} enumIdentifier
	     * @param {?} name
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype.resolveEnum = function (enumIdentifier, name) { return enumIdentifier[name]; };
	    return ReflectionCapabilities;
	}());
	/**
	 * @param {?} decoratorInvocations
	 * @return {?}
	 */
	function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
	    if (!decoratorInvocations) {
	        return [];
	    }
	    return decoratorInvocations.map(function (decoratorInvocation) {
	        var /** @type {?} */ decoratorType = decoratorInvocation.type;
	        var /** @type {?} */ annotationCls = decoratorType.annotationCls;
	        var /** @type {?} */ annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
	        return new (annotationCls.bind.apply(annotationCls, [void 0].concat(annotationArgs)))();
	    });
	}
	/**
	 * @param {?} ctor
	 * @return {?}
	 */
	function getParentCtor(ctor) {
	    var /** @type {?} */ parentProto = Object.getPrototypeOf(ctor.prototype);
	    var /** @type {?} */ parentCtor = parentProto ? parentProto.constructor : null;
	    // Note: We always use `Object` as the null value
	    // to simplify checking later on.
	    return parentCtor || Object;
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Provides access to reflection data about symbols. Used internally by Angular
	 * to power dependency injection and compilation.
	 */
	var Reflector = (function () {
	    /**
	     * @param {?} reflectionCapabilities
	     */
	    function Reflector(reflectionCapabilities) {
	        this.reflectionCapabilities = reflectionCapabilities;
	    }
	    /**
	     * @param {?} caps
	     * @return {?}
	     */
	    Reflector.prototype.updateCapabilities = function (caps) { this.reflectionCapabilities = caps; };
	    /**
	     * @param {?} type
	     * @return {?}
	     */
	    Reflector.prototype.factory = function (type) { return this.reflectionCapabilities.factory(type); };
	    /**
	     * @param {?} typeOrFunc
	     * @return {?}
	     */
	    Reflector.prototype.parameters = function (typeOrFunc) {
	        return this.reflectionCapabilities.parameters(typeOrFunc);
	    };
	    /**
	     * @param {?} typeOrFunc
	     * @return {?}
	     */
	    Reflector.prototype.annotations = function (typeOrFunc) {
	        return this.reflectionCapabilities.annotations(typeOrFunc);
	    };
	    /**
	     * @param {?} typeOrFunc
	     * @return {?}
	     */
	    Reflector.prototype.propMetadata = function (typeOrFunc) {
	        return this.reflectionCapabilities.propMetadata(typeOrFunc);
	    };
	    /**
	     * @param {?} type
	     * @param {?} lcProperty
	     * @return {?}
	     */
	    Reflector.prototype.hasLifecycleHook = function (type, lcProperty) {
	        return this.reflectionCapabilities.hasLifecycleHook(type, lcProperty);
	    };
	    /**
	     * @param {?} name
	     * @return {?}
	     */
	    Reflector.prototype.getter = function (name) { return this.reflectionCapabilities.getter(name); };
	    /**
	     * @param {?} name
	     * @return {?}
	     */
	    Reflector.prototype.setter = function (name) { return this.reflectionCapabilities.setter(name); };
	    /**
	     * @param {?} name
	     * @return {?}
	     */
	    Reflector.prototype.method = function (name) { return this.reflectionCapabilities.method(name); };
	    /**
	     * @param {?} type
	     * @return {?}
	     */
	    Reflector.prototype.importUri = function (type) { return this.reflectionCapabilities.importUri(type); };
	    /**
	     * @param {?} type
	     * @return {?}
	     */
	    Reflector.prototype.resourceUri = function (type) { return this.reflectionCapabilities.resourceUri(type); };
	    /**
	     * @param {?} name
	     * @param {?} moduleUrl
	     * @param {?} members
	     * @param {?} runtime
	     * @return {?}
	     */
	    Reflector.prototype.resolveIdentifier = function (name, moduleUrl, members, runtime) {
	        return this.reflectionCapabilities.resolveIdentifier(name, moduleUrl, members, runtime);
	    };
	    /**
	     * @param {?} identifier
	     * @param {?} name
	     * @return {?}
	     */
	    Reflector.prototype.resolveEnum = function (identifier, name) {
	        return this.reflectionCapabilities.resolveEnum(identifier, name);
	    };
	    return Reflector;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * The {\@link Reflector} used internally in Angular to access metadata
	 * about symbols.
	 */
	var reflector = new Reflector(new ReflectionCapabilities());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * `Dependency` is used by the framework to extend DI.
	 * This is internal to Angular and should not be used directly.
	 */
	var ReflectiveDependency = (function () {
	    /**
	     * @param {?} key
	     * @param {?} optional
	     * @param {?} visibility
	     */
	    function ReflectiveDependency(key, optional, visibility) {
	        this.key = key;
	        this.optional = optional;
	        this.visibility = visibility;
	    }
	    /**
	     * @param {?} key
	     * @return {?}
	     */
	    ReflectiveDependency.fromKey = function (key) {
	        return new ReflectiveDependency(key, false, null);
	    };
	    return ReflectiveDependency;
	}());
	var _EMPTY_LIST = [];
	var ResolvedReflectiveProvider_ = (function () {
	    /**
	     * @param {?} key
	     * @param {?} resolvedFactories
	     * @param {?} multiProvider
	     */
	    function ResolvedReflectiveProvider_(key, resolvedFactories, multiProvider) {
	        this.key = key;
	        this.resolvedFactories = resolvedFactories;
	        this.multiProvider = multiProvider;
	    }
	    Object.defineProperty(ResolvedReflectiveProvider_.prototype, "resolvedFactory", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.resolvedFactories[0]; },
	        enumerable: true,
	        configurable: true
	    });
	    return ResolvedReflectiveProvider_;
	}());
	/**
	 * An internal resolved representation of a factory function created by resolving {\@link
	 * Provider}.
	 * \@experimental
	 */
	var ResolvedReflectiveFactory = (function () {
	    /**
	     * @param {?} factory
	     * @param {?} dependencies
	     */
	    function ResolvedReflectiveFactory(factory, dependencies) {
	        this.factory = factory;
	        this.dependencies = dependencies;
	    }
	    return ResolvedReflectiveFactory;
	}());
	/**
	 * Resolve a single provider.
	 * @param {?} provider
	 * @return {?}
	 */
	function resolveReflectiveFactory(provider) {
	    var /** @type {?} */ factoryFn;
	    var /** @type {?} */ resolvedDeps;
	    if (provider.useClass) {
	        var /** @type {?} */ useClass = resolveForwardRef(provider.useClass);
	        factoryFn = reflector.factory(useClass);
	        resolvedDeps = _dependenciesFor(useClass);
	    }
	    else if (provider.useExisting) {
	        factoryFn = function (aliasInstance) { return aliasInstance; };
	        resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];
	    }
	    else if (provider.useFactory) {
	        factoryFn = provider.useFactory;
	        resolvedDeps = constructDependencies(provider.useFactory, provider.deps);
	    }
	    else {
	        factoryFn = function () { return provider.useValue; };
	        resolvedDeps = _EMPTY_LIST;
	    }
	    return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);
	}
	/**
	 * Converts the {\@link Provider} into {\@link ResolvedProvider}.
	 *
	 * {\@link Injector} internally only uses {\@link ResolvedProvider}, {\@link Provider} contains
	 * convenience provider syntax.
	 * @param {?} provider
	 * @return {?}
	 */
	function resolveReflectiveProvider(provider) {
	    return new ResolvedReflectiveProvider_(ReflectiveKey.get(provider.provide), [resolveReflectiveFactory(provider)], provider.multi || false);
	}
	/**
	 * Resolve a list of Providers.
	 * @param {?} providers
	 * @return {?}
	 */
	function resolveReflectiveProviders(providers) {
	    var /** @type {?} */ normalized = _normalizeProviders(providers, []);
	    var /** @type {?} */ resolved = normalized.map(resolveReflectiveProvider);
	    var /** @type {?} */ resolvedProviderMap = mergeResolvedReflectiveProviders(resolved, new Map());
	    return Array.from(resolvedProviderMap.values());
	}
	/**
	 * Merges a list of ResolvedProviders into a list where
	 * each key is contained exactly once and multi providers
	 * have been merged.
	 * @param {?} providers
	 * @param {?} normalizedProvidersMap
	 * @return {?}
	 */
	function mergeResolvedReflectiveProviders(providers, normalizedProvidersMap) {
	    for (var /** @type {?} */ i = 0; i < providers.length; i++) {
	        var /** @type {?} */ provider = providers[i];
	        var /** @type {?} */ existing = normalizedProvidersMap.get(provider.key.id);
	        if (existing) {
	            if (provider.multiProvider !== existing.multiProvider) {
	                throw mixingMultiProvidersWithRegularProvidersError(existing, provider);
	            }
	            if (provider.multiProvider) {
	                for (var /** @type {?} */ j = 0; j < provider.resolvedFactories.length; j++) {
	                    existing.resolvedFactories.push(provider.resolvedFactories[j]);
	                }
	            }
	            else {
	                normalizedProvidersMap.set(provider.key.id, provider);
	            }
	        }
	        else {
	            var /** @type {?} */ resolvedProvider = void 0;
	            if (provider.multiProvider) {
	                resolvedProvider = new ResolvedReflectiveProvider_(provider.key, provider.resolvedFactories.slice(), provider.multiProvider);
	            }
	            else {
	                resolvedProvider = provider;
	            }
	            normalizedProvidersMap.set(provider.key.id, resolvedProvider);
	        }
	    }
	    return normalizedProvidersMap;
	}
	/**
	 * @param {?} providers
	 * @param {?} res
	 * @return {?}
	 */
	function _normalizeProviders(providers, res) {
	    providers.forEach(function (b) {
	        if (b instanceof Type) {
	            res.push({ provide: b, useClass: b });
	        }
	        else if (b && typeof b == 'object' && ((b)).provide !== undefined) {
	            res.push(/** @type {?} */ (b));
	        }
	        else if (b instanceof Array) {
	            _normalizeProviders(b, res);
	        }
	        else {
	            throw invalidProviderError(b);
	        }
	    });
	    return res;
	}
	/**
	 * @param {?} typeOrFunc
	 * @param {?=} dependencies
	 * @return {?}
	 */
	function constructDependencies(typeOrFunc, dependencies) {
	    if (!dependencies) {
	        return _dependenciesFor(typeOrFunc);
	    }
	    else {
	        var /** @type {?} */ params_1 = dependencies.map(function (t) { return [t]; });
	        return dependencies.map(function (t) { return _extractToken(typeOrFunc, t, params_1); });
	    }
	}
	/**
	 * @param {?} typeOrFunc
	 * @return {?}
	 */
	function _dependenciesFor(typeOrFunc) {
	    var /** @type {?} */ params = reflector.parameters(typeOrFunc);
	    if (!params)
	        return [];
	    if (params.some(function (p) { return p == null; })) {
	        throw noAnnotationError(typeOrFunc, params);
	    }
	    return params.map(function (p) { return _extractToken(typeOrFunc, p, params); });
	}
	/**
	 * @param {?} typeOrFunc
	 * @param {?} metadata
	 * @param {?} params
	 * @return {?}
	 */
	function _extractToken(typeOrFunc, metadata, params) {
	    var /** @type {?} */ token = null;
	    var /** @type {?} */ optional = false;
	    if (!Array.isArray(metadata)) {
	        if (metadata instanceof Inject) {
	            return _createDependency(metadata.token, optional, null);
	        }
	        else {
	            return _createDependency(metadata, optional, null);
	        }
	    }
	    var /** @type {?} */ visibility = null;
	    for (var /** @type {?} */ i = 0; i < metadata.length; ++i) {
	        var /** @type {?} */ paramMetadata = metadata[i];
	        if (paramMetadata instanceof Type) {
	            token = paramMetadata;
	        }
	        else if (paramMetadata instanceof Inject) {
	            token = paramMetadata.token;
	        }
	        else if (paramMetadata instanceof Optional) {
	            optional = true;
	        }
	        else if (paramMetadata instanceof Self || paramMetadata instanceof SkipSelf) {
	            visibility = paramMetadata;
	        }
	        else if (paramMetadata instanceof InjectionToken) {
	            token = paramMetadata;
	        }
	    }
	    token = resolveForwardRef(token);
	    if (token != null) {
	        return _createDependency(token, optional, visibility);
	    }
	    else {
	        throw noAnnotationError(typeOrFunc, params);
	    }
	}
	/**
	 * @param {?} token
	 * @param {?} optional
	 * @param {?} visibility
	 * @return {?}
	 */
	function _createDependency(token, optional, visibility) {
	    return new ReflectiveDependency(ReflectiveKey.get(token), optional, visibility);
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	// Threshold for the dynamic version
	var UNDEFINED = new Object();
	/**
	 * A ReflectiveDependency injection container used for instantiating objects and resolving
	 * dependencies.
	 *
	 * An `Injector` is a replacement for a `new` operator, which can automatically resolve the
	 * constructor dependencies.
	 *
	 * In typical use, application code asks for the dependencies in the constructor and they are
	 * resolved by the `Injector`.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/jzjec0?p=preview))
	 *
	 * The following example creates an `Injector` configured to create `Engine` and `Car`.
	 *
	 * ```typescript
	 * \@Injectable()
	 * class Engine {
	 * }
	 *
	 * \@Injectable()
	 * class Car {
	 *   constructor(public engine:Engine) {}
	 * }
	 *
	 * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
	 * var car = injector.get(Car);
	 * expect(car instanceof Car).toBe(true);
	 * expect(car.engine instanceof Engine).toBe(true);
	 * ```
	 *
	 * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`
	 * resolve all of the object's dependencies automatically.
	 *
	 * \@stable
	 * @abstract
	 */
	var ReflectiveInjector = (function () {
	    function ReflectiveInjector() {
	    }
	    /**
	     * Turns an array of provider definitions into an array of resolved providers.
	     *
	     * A resolution is a process of flattening multiple nested arrays and converting individual
	     * providers into an array of {\@link ResolvedReflectiveProvider}s.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/AiXTHi?p=preview))
	     *
	     * ```typescript
	     * \@Injectable()
	     * class Engine {
	     * }
	     *
	     * \@Injectable()
	     * class Car {
	     *   constructor(public engine:Engine) {}
	     * }
	     *
	     * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);
	     *
	     * expect(providers.length).toEqual(2);
	     *
	     * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);
	     * expect(providers[0].key.displayName).toBe("Car");
	     * expect(providers[0].dependencies.length).toEqual(1);
	     * expect(providers[0].factory).toBeDefined();
	     *
	     * expect(providers[1].key.displayName).toBe("Engine");
	     * });
	     * ```
	     *
	     * See {\@link ReflectiveInjector#fromResolvedProviders} for more info.
	     * @param {?} providers
	     * @return {?}
	     */
	    ReflectiveInjector.resolve = function (providers) {
	        return resolveReflectiveProviders(providers);
	    };
	    /**
	     * Resolves an array of providers and creates an injector from those providers.
	     *
	     * The passed-in providers can be an array of `Type`, {\@link Provider},
	     * or a recursive array of more providers.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/ePOccA?p=preview))
	     *
	     * ```typescript
	     * \@Injectable()
	     * class Engine {
	     * }
	     *
	     * \@Injectable()
	     * class Car {
	     *   constructor(public engine:Engine) {}
	     * }
	     *
	     * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
	     * expect(injector.get(Car) instanceof Car).toBe(true);
	     * ```
	     *
	     * This function is slower than the corresponding `fromResolvedProviders`
	     * because it needs to resolve the passed-in providers first.
	     * See {\@link ReflectiveInjector#resolve} and {\@link ReflectiveInjector#fromResolvedProviders}.
	     * @param {?} providers
	     * @param {?=} parent
	     * @return {?}
	     */
	    ReflectiveInjector.resolveAndCreate = function (providers, parent) {
	        var /** @type {?} */ ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
	        return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);
	    };
	    /**
	     * Creates an injector from previously resolved providers.
	     *
	     * This API is the recommended way to construct injectors in performance-sensitive parts.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/KrSMci?p=preview))
	     *
	     * ```typescript
	     * \@Injectable()
	     * class Engine {
	     * }
	     *
	     * \@Injectable()
	     * class Car {
	     *   constructor(public engine:Engine) {}
	     * }
	     *
	     * var providers = ReflectiveInjector.resolve([Car, Engine]);
	     * var injector = ReflectiveInjector.fromResolvedProviders(providers);
	     * expect(injector.get(Car) instanceof Car).toBe(true);
	     * ```
	     * \@experimental
	     * @param {?} providers
	     * @param {?=} parent
	     * @return {?}
	     */
	    ReflectiveInjector.fromResolvedProviders = function (providers, parent) {
	        return new ReflectiveInjector_(providers, parent);
	    };
	    /**
	     * Parent of this injector.
	     *
	     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
	     * -->
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/eosMGo?p=preview))
	     *
	     * ```typescript
	     * var parent = ReflectiveInjector.resolveAndCreate([]);
	     * var child = parent.resolveAndCreateChild([]);
	     * expect(child.parent).toBe(parent);
	     * ```
	     * @abstract
	     * @return {?}
	     */
	    ReflectiveInjector.prototype.parent = function () { };
	    /**
	     * Resolves an array of providers and creates a child injector from those providers.
	     *
	     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
	     * -->
	     *
	     * The passed-in providers can be an array of `Type`, {\@link Provider},
	     * or a recursive array of more providers.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/opB3T4?p=preview))
	     *
	     * ```typescript
	     * class ParentProvider {}
	     * class ChildProvider {}
	     *
	     * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);
	     * var child = parent.resolveAndCreateChild([ChildProvider]);
	     *
	     * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
	     * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
	     * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
	     * ```
	     *
	     * This function is slower than the corresponding `createChildFromResolved`
	     * because it needs to resolve the passed-in providers first.
	     * See {\@link ReflectiveInjector#resolve} and {\@link ReflectiveInjector#createChildFromResolved}.
	     * @abstract
	     * @param {?} providers
	     * @return {?}
	     */
	    ReflectiveInjector.prototype.resolveAndCreateChild = function (providers) { };
	    /**
	     * Creates a child injector from previously resolved providers.
	     *
	     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
	     * -->
	     *
	     * This API is the recommended way to construct injectors in performance-sensitive parts.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/VhyfjN?p=preview))
	     *
	     * ```typescript
	     * class ParentProvider {}
	     * class ChildProvider {}
	     *
	     * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);
	     * var childProviders = ReflectiveInjector.resolve([ChildProvider]);
	     *
	     * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);
	     * var child = parent.createChildFromResolved(childProviders);
	     *
	     * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
	     * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
	     * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
	     * ```
	     * @abstract
	     * @param {?} providers
	     * @return {?}
	     */
	    ReflectiveInjector.prototype.createChildFromResolved = function (providers) { };
	    /**
	     * Resolves a provider and instantiates an object in the context of the injector.
	     *
	     * The created object does not get cached by the injector.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/yvVXoB?p=preview))
	     *
	     * ```typescript
	     * \@Injectable()
	     * class Engine {
	     * }
	     *
	     * \@Injectable()
	     * class Car {
	     *   constructor(public engine:Engine) {}
	     * }
	     *
	     * var injector = ReflectiveInjector.resolveAndCreate([Engine]);
	     *
	     * var car = injector.resolveAndInstantiate(Car);
	     * expect(car.engine).toBe(injector.get(Engine));
	     * expect(car).not.toBe(injector.resolveAndInstantiate(Car));
	     * ```
	     * @abstract
	     * @param {?} provider
	     * @return {?}
	     */
	    ReflectiveInjector.prototype.resolveAndInstantiate = function (provider) { };
	    /**
	     * Instantiates an object using a resolved provider in the context of the injector.
	     *
	     * The created object does not get cached by the injector.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/ptCImQ?p=preview))
	     *
	     * ```typescript
	     * \@Injectable()
	     * class Engine {
	     * }
	     *
	     * \@Injectable()
	     * class Car {
	     *   constructor(public engine:Engine) {}
	     * }
	     *
	     * var injector = ReflectiveInjector.resolveAndCreate([Engine]);
	     * var carProvider = ReflectiveInjector.resolve([Car])[0];
	     * var car = injector.instantiateResolved(carProvider);
	     * expect(car.engine).toBe(injector.get(Engine));
	     * expect(car).not.toBe(injector.instantiateResolved(carProvider));
	     * ```
	     * @abstract
	     * @param {?} provider
	     * @return {?}
	     */
	    ReflectiveInjector.prototype.instantiateResolved = function (provider) { };
	    /**
	     * @abstract
	     * @param {?} token
	     * @param {?=} notFoundValue
	     * @return {?}
	     */
	    ReflectiveInjector.prototype.get = function (token, notFoundValue) { };
	    return ReflectiveInjector;
	}());
	var ReflectiveInjector_ = (function () {
	    /**
	     * Private
	     * @param {?} _providers
	     * @param {?=} _parent
	     */
	    function ReflectiveInjector_(_providers, _parent) {
	        /**
	         * \@internal
	         */
	        this._constructionCounter = 0;
	        this._providers = _providers;
	        this._parent = _parent || null;
	        var len = _providers.length;
	        this.keyIds = new Array(len);
	        this.objs = new Array(len);
	        for (var i = 0; i < len; i++) {
	            this.keyIds[i] = _providers[i].key.id;
	            this.objs[i] = UNDEFINED;
	        }
	    }
	    /**
	     * @param {?} token
	     * @param {?=} notFoundValue
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype.get = function (token, notFoundValue) {
	        if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }
	        return this._getByKey(ReflectiveKey.get(token), null, notFoundValue);
	    };
	    Object.defineProperty(ReflectiveInjector_.prototype, "parent", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._parent; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @param {?} providers
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype.resolveAndCreateChild = function (providers) {
	        var /** @type {?} */ ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
	        return this.createChildFromResolved(ResolvedReflectiveProviders);
	    };
	    /**
	     * @param {?} providers
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype.createChildFromResolved = function (providers) {
	        var /** @type {?} */ inj = new ReflectiveInjector_(providers);
	        inj._parent = this;
	        return inj;
	    };
	    /**
	     * @param {?} provider
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype.resolveAndInstantiate = function (provider) {
	        return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);
	    };
	    /**
	     * @param {?} provider
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype.instantiateResolved = function (provider) {
	        return this._instantiateProvider(provider);
	    };
	    /**
	     * @param {?} index
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype.getProviderAtIndex = function (index) {
	        if (index < 0 || index >= this._providers.length) {
	            throw outOfBoundsError(index);
	        }
	        return this._providers[index];
	    };
	    /**
	     * \@internal
	     * @param {?} provider
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype._new = function (provider) {
	        if (this._constructionCounter++ > this._getMaxNumberOfObjects()) {
	            throw cyclicDependencyError(this, provider.key);
	        }
	        return this._instantiateProvider(provider);
	    };
	    /**
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype._getMaxNumberOfObjects = function () { return this.objs.length; };
	    /**
	     * @param {?} provider
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype._instantiateProvider = function (provider) {
	        if (provider.multiProvider) {
	            var /** @type {?} */ res = new Array(provider.resolvedFactories.length);
	            for (var /** @type {?} */ i = 0; i < provider.resolvedFactories.length; ++i) {
	                res[i] = this._instantiate(provider, provider.resolvedFactories[i]);
	            }
	            return res;
	        }
	        else {
	            return this._instantiate(provider, provider.resolvedFactories[0]);
	        }
	    };
	    /**
	     * @param {?} provider
	     * @param {?} ResolvedReflectiveFactory
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype._instantiate = function (provider, ResolvedReflectiveFactory$$1) {
	        var _this = this;
	        var /** @type {?} */ factory = ResolvedReflectiveFactory$$1.factory;
	        var /** @type {?} */ deps;
	        try {
	            deps =
	                ResolvedReflectiveFactory$$1.dependencies.map(function (dep) { return _this._getByReflectiveDependency(dep); });
	        }
	        catch (e) {
	            if (e.addKey) {
	                e.addKey(this, provider.key);
	            }
	            throw e;
	        }
	        var /** @type {?} */ obj;
	        try {
	            obj = factory.apply(void 0, deps);
	        }
	        catch (e) {
	            throw instantiationError(this, e, e.stack, provider.key);
	        }
	        return obj;
	    };
	    /**
	     * @param {?} dep
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype._getByReflectiveDependency = function (dep) {
	        return this._getByKey(dep.key, dep.visibility, dep.optional ? null : THROW_IF_NOT_FOUND);
	    };
	    /**
	     * @param {?} key
	     * @param {?} visibility
	     * @param {?} notFoundValue
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype._getByKey = function (key, visibility, notFoundValue) {
	        if (key === INJECTOR_KEY) {
	            return this;
	        }
	        if (visibility instanceof Self) {
	            return this._getByKeySelf(key, notFoundValue);
	        }
	        else {
	            return this._getByKeyDefault(key, notFoundValue, visibility);
	        }
	    };
	    /**
	     * @param {?} keyId
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype._getObjByKeyId = function (keyId) {
	        for (var /** @type {?} */ i = 0; i < this.keyIds.length; i++) {
	            if (this.keyIds[i] === keyId) {
	                if (this.objs[i] === UNDEFINED) {
	                    this.objs[i] = this._new(this._providers[i]);
	                }
	                return this.objs[i];
	            }
	        }
	        return UNDEFINED;
	    };
	    /**
	     * \@internal
	     * @param {?} key
	     * @param {?} notFoundValue
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype._throwOrNull = function (key, notFoundValue) {
	        if (notFoundValue !== THROW_IF_NOT_FOUND) {
	            return notFoundValue;
	        }
	        else {
	            throw noProviderError(this, key);
	        }
	    };
	    /**
	     * \@internal
	     * @param {?} key
	     * @param {?} notFoundValue
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype._getByKeySelf = function (key, notFoundValue) {
	        var /** @type {?} */ obj = this._getObjByKeyId(key.id);
	        return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);
	    };
	    /**
	     * \@internal
	     * @param {?} key
	     * @param {?} notFoundValue
	     * @param {?} visibility
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype._getByKeyDefault = function (key, notFoundValue, visibility) {
	        var /** @type {?} */ inj;
	        if (visibility instanceof SkipSelf) {
	            inj = this._parent;
	        }
	        else {
	            inj = this;
	        }
	        while (inj instanceof ReflectiveInjector_) {
	            var /** @type {?} */ inj_ = (inj);
	            var /** @type {?} */ obj = inj_._getObjByKeyId(key.id);
	            if (obj !== UNDEFINED)
	                return obj;
	            inj = inj_._parent;
	        }
	        if (inj !== null) {
	            return inj.get(key.token, notFoundValue);
	        }
	        else {
	            return this._throwOrNull(key, notFoundValue);
	        }
	    };
	    Object.defineProperty(ReflectiveInjector_.prototype, "displayName", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            var /** @type {?} */ providers = _mapProviders(this, function (b) { return ' "' + b.key.displayName + '" '; })
	                .join(', ');
	            return "ReflectiveInjector(providers: [" + providers + "])";
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype.toString = function () { return this.displayName; };
	    return ReflectiveInjector_;
	}());
	var INJECTOR_KEY = ReflectiveKey.get(Injector);
	/**
	 * @param {?} injector
	 * @param {?} fn
	 * @return {?}
	 */
	function _mapProviders(injector, fn) {
	    var /** @type {?} */ res = new Array(injector._providers.length);
	    for (var /** @type {?} */ i = 0; i < injector._providers.length; ++i) {
	        res[i] = fn(injector.getProviderAtIndex(i));
	    }
	    return res;
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @module
	 * @description
	 * The `di` module provides dependency injection container services.
	 */
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Determine if the argument is shaped like a Promise
	 * @param {?} obj
	 * @return {?}
	 */
	function isPromise(obj) {
	    // allow any Promise/A+ compliant thenable.
	    // It's up to the caller to ensure that obj.then conforms to the spec
	    return !!obj && typeof obj.then === 'function';
	}
	/**
	 * Determine if the argument is an Observable
	 * @param {?} obj
	 * @return {?}
	 */
	function isObservable(obj) {
	    // TODO use Symbol.observable when https://github.com/ReactiveX/rxjs/issues/2415 will be resolved
	    return !!obj && typeof obj.subscribe === 'function';
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * A function that will be executed when an application is initialized.
	 * \@experimental
	 */
	var APP_INITIALIZER = new InjectionToken('Application Initializer');
	/**
	 * A class that reflects the state of running {\@link APP_INITIALIZER}s.
	 *
	 * \@experimental
	 */
	var ApplicationInitStatus = (function () {
	    /**
	     * @param {?} appInits
	     */
	    function ApplicationInitStatus(appInits) {
	        var _this = this;
	        this.appInits = appInits;
	        this.initialized = false;
	        this._done = false;
	        this._donePromise = new Promise(function (res, rej) {
	            _this.resolve = res;
	            _this.reject = rej;
	        });
	    }
	    /**
	     * \@internal
	     * @return {?}
	     */
	    ApplicationInitStatus.prototype.runInitializers = function () {
	        var _this = this;
	        if (this.initialized) {
	            return;
	        }
	        var /** @type {?} */ asyncInitPromises = [];
	        var /** @type {?} */ complete = function () {
	            _this._done = true;
	            _this.resolve();
	        };
	        if (this.appInits) {
	            for (var /** @type {?} */ i = 0; i < this.appInits.length; i++) {
	                var /** @type {?} */ initResult = this.appInits[i]();
	                if (isPromise(initResult)) {
	                    asyncInitPromises.push(initResult);
	                }
	            }
	        }
	        Promise.all(asyncInitPromises).then(function () { complete(); }).catch(function (e) { _this.reject(e); });
	        if (asyncInitPromises.length === 0) {
	            complete();
	        }
	        this.initialized = true;
	    };
	    Object.defineProperty(ApplicationInitStatus.prototype, "done", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._done; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ApplicationInitStatus.prototype, "donePromise", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._donePromise; },
	        enumerable: true,
	        configurable: true
	    });
	    return ApplicationInitStatus;
	}());
	ApplicationInitStatus.decorators = [
	    { type: Injectable },
	];
	/**
	 * @nocollapse
	 */
	ApplicationInitStatus.ctorParameters = function () { return [
	    { type: Array, decorators: [{ type: Inject, args: [APP_INITIALIZER,] }, { type: Optional },] },
	]; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * A DI Token representing a unique string id assigned to the application by Angular and used
	 * primarily for prefixing application attributes and CSS styles when
	 * {\@link ViewEncapsulation#Emulated} is being used.
	 *
	 * If you need to avoid randomly generated value to be used as an application id, you can provide
	 * a custom value via a DI provider <!-- TODO: provider --> configuring the root {\@link Injector}
	 * using this token.
	 * \@experimental
	 */
	var APP_ID = new InjectionToken('AppId');
	/**
	 * @return {?}
	 */
	function _appIdRandomProviderFactory() {
	    return "" + _randomChar() + _randomChar() + _randomChar();
	}
	/**
	 * Providers that will generate a random APP_ID_TOKEN.
	 * \@experimental
	 */
	var APP_ID_RANDOM_PROVIDER = {
	    provide: APP_ID,
	    useFactory: _appIdRandomProviderFactory,
	    deps: [],
	};
	/**
	 * @return {?}
	 */
	function _randomChar() {
	    return String.fromCharCode(97 + Math.floor(Math.random() * 25));
	}
	/**
	 * A function that will be executed when a platform is initialized.
	 * \@experimental
	 */
	var PLATFORM_INITIALIZER = new InjectionToken('Platform Initializer');
	/**
	 * A token that indicates an opaque platform id.
	 * \@experimental
	 */
	var PLATFORM_ID = new InjectionToken('Platform ID');
	/**
	 * All callbacks provided via this token will be called for every component that is bootstrapped.
	 * Signature of the callback:
	 *
	 * `(componentRef: ComponentRef) => void`.
	 *
	 * \@experimental
	 */
	var APP_BOOTSTRAP_LISTENER = new InjectionToken('appBootstrapListener');
	/**
	 * A token which indicates the root directory of the application
	 * \@experimental
	 */
	var PACKAGE_ROOT_URL = new InjectionToken('Application Packages Root URL');
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var Console = (function () {
	    function Console() {
	    }
	    /**
	     * @param {?} message
	     * @return {?}
	     */
	    Console.prototype.log = function (message) {
	        // tslint:disable-next-line:no-console
	        console.log(message);
	    };
	    /**
	     * @param {?} message
	     * @return {?}
	     */
	    Console.prototype.warn = function (message) {
	        // tslint:disable-next-line:no-console
	        console.warn(message);
	    };
	    return Console;
	}());
	Console.decorators = [
	    { type: Injectable },
	];
	/**
	 * @nocollapse
	 */
	Console.ctorParameters = function () { return []; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Combination of NgModuleFactory and ComponentFactorys.
	 *
	 * \@experimental
	 */
	var ModuleWithComponentFactories = (function () {
	    /**
	     * @param {?} ngModuleFactory
	     * @param {?} componentFactories
	     */
	    function ModuleWithComponentFactories(ngModuleFactory, componentFactories) {
	        this.ngModuleFactory = ngModuleFactory;
	        this.componentFactories = componentFactories;
	    }
	    return ModuleWithComponentFactories;
	}());
	/**
	 * @return {?}
	 */
	function _throwError() {
	    throw new Error("Runtime compiler is not loaded");
	}
	/**
	 * Low-level service for running the angular compiler during runtime
	 * to create {\@link ComponentFactory}s, which
	 * can later be used to create and render a Component instance.
	 *
	 * Each `\@NgModule` provides an own `Compiler` to its injector,
	 * that will use the directives/pipes of the ng module for compilation
	 * of components.
	 * \@stable
	 */
	var Compiler = (function () {
	    function Compiler() {
	    }
	    /**
	     * Compiles the given NgModule and all of its components. All templates of the components listed
	     * in `entryComponents` have to be inlined.
	     * @template T
	     * @param {?} moduleType
	     * @return {?}
	     */
	    Compiler.prototype.compileModuleSync = function (moduleType) { throw _throwError(); };
	    /**
	     * Compiles the given NgModule and all of its components
	     * @template T
	     * @param {?} moduleType
	     * @return {?}
	     */
	    Compiler.prototype.compileModuleAsync = function (moduleType) { throw _throwError(); };
	    /**
	     * Same as {\@link #compileModuleSync} but also creates ComponentFactories for all components.
	     * @template T
	     * @param {?} moduleType
	     * @return {?}
	     */
	    Compiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {
	        throw _throwError();
	    };
	    /**
	     * Same as {\@link #compileModuleAsync} but also creates ComponentFactories for all components.
	     * @template T
	     * @param {?} moduleType
	     * @return {?}
	     */
	    Compiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {
	        throw _throwError();
	    };
	    /**
	     * Exposes the CSS-style selectors that have been used in `ngContent` directives within
	     * the template of the given component.
	     * This is used by the `upgrade` library to compile the appropriate transclude content
	     * in the AngularJS wrapper component.
	     *
	     * @deprecated since v4. Use ComponentFactory.ngContentSelectors instead.
	     * @param {?} component
	     * @return {?}
	     */
	    Compiler.prototype.getNgContentSelectors = function (component) { throw _throwError(); };
	    /**
	     * Clears all caches.
	     * @return {?}
	     */
	    Compiler.prototype.clearCache = function () { };
	    /**
	     * Clears the cache for the given component/ngModule.
	     * @param {?} type
	     * @return {?}
	     */
	    Compiler.prototype.clearCacheFor = function (type) { };
	    return Compiler;
	}());
	Compiler.decorators = [
	    { type: Injectable },
	];
	/**
	 * @nocollapse
	 */
	Compiler.ctorParameters = function () { return []; };
	/**
	 * Token to provide CompilerOptions in the platform injector.
	 *
	 * \@experimental
	 */
	var COMPILER_OPTIONS = new InjectionToken('compilerOptions');
	/**
	 * A factory for creating a Compiler
	 *
	 * \@experimental
	 * @abstract
	 */
	var CompilerFactory = (function () {
	    function CompilerFactory() {
	    }
	    /**
	     * @abstract
	     * @param {?=} options
	     * @return {?}
	     */
	    CompilerFactory.prototype.createCompiler = function (options) { };
	    return CompilerFactory;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Represents an instance of a Component created via a {\@link ComponentFactory}.
	 *
	 * `ComponentRef` provides access to the Component Instance as well other objects related to this
	 * Component Instance and allows you to destroy the Component Instance via the {\@link #destroy}
	 * method.
	 * \@stable
	 * @abstract
	 */
	var ComponentRef = (function () {
	    function ComponentRef() {
	    }
	    /**
	     * Location of the Host Element of this Component Instance.
	     * @abstract
	     * @return {?}
	     */
	    ComponentRef.prototype.location = function () { };
	    /**
	     * The injector on which the component instance exists.
	     * @abstract
	     * @return {?}
	     */
	    ComponentRef.prototype.injector = function () { };
	    /**
	     * The instance of the Component.
	     * @abstract
	     * @return {?}
	     */
	    ComponentRef.prototype.instance = function () { };
	    /**
	     * The {\@link ViewRef} of the Host View of this Component instance.
	     * @abstract
	     * @return {?}
	     */
	    ComponentRef.prototype.hostView = function () { };
	    /**
	     * The {\@link ChangeDetectorRef} of the Component instance.
	     * @abstract
	     * @return {?}
	     */
	    ComponentRef.prototype.changeDetectorRef = function () { };
	    /**
	     * The component type.
	     * @abstract
	     * @return {?}
	     */
	    ComponentRef.prototype.componentType = function () { };
	    /**
	     * Destroys the component instance and all of the data structures associated with it.
	     * @abstract
	     * @return {?}
	     */
	    ComponentRef.prototype.destroy = function () { };
	    /**
	     * Allows to register a callback that will be called when the component is destroyed.
	     * @abstract
	     * @param {?} callback
	     * @return {?}
	     */
	    ComponentRef.prototype.onDestroy = function (callback) { };
	    return ComponentRef;
	}());
	/**
	 * \@stable
	 * @abstract
	 */
	var ComponentFactory = (function () {
	    function ComponentFactory() {
	    }
	    /**
	     * @abstract
	     * @return {?}
	     */
	    ComponentFactory.prototype.selector = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    ComponentFactory.prototype.componentType = function () { };
	    /**
	     * selector for all <ng-content> elements in the component.
	     * @abstract
	     * @return {?}
	     */
	    ComponentFactory.prototype.ngContentSelectors = function () { };
	    /**
	     * the inputs of the component.
	     * @abstract
	     * @return {?}
	     */
	    ComponentFactory.prototype.inputs = function () { };
	    /**
	     * the outputs of the component.
	     * @abstract
	     * @return {?}
	     */
	    ComponentFactory.prototype.outputs = function () { };
	    /**
	     * Creates a new component.
	     * @abstract
	     * @param {?} injector
	     * @param {?=} projectableNodes
	     * @param {?=} rootSelectorOrNode
	     * @param {?=} ngModule
	     * @return {?}
	     */
	    ComponentFactory.prototype.create = function (injector, projectableNodes, rootSelectorOrNode, ngModule) { };
	    return ComponentFactory;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} component
	 * @return {?}
	 */
	function noComponentFactoryError(component) {
	    var /** @type {?} */ error = Error("No component factory found for " + stringify(component) + ". Did you add it to @NgModule.entryComponents?");
	    ((error))[ERROR_COMPONENT] = component;
	    return error;
	}
	var ERROR_COMPONENT = 'ngComponent';
	/**
	 * @param {?} error
	 * @return {?}
	 */
	var _NullComponentFactoryResolver = (function () {
	    function _NullComponentFactoryResolver() {
	    }
	    /**
	     * @template T
	     * @param {?} component
	     * @return {?}
	     */
	    _NullComponentFactoryResolver.prototype.resolveComponentFactory = function (component) {
	        throw noComponentFactoryError(component);
	    };
	    return _NullComponentFactoryResolver;
	}());
	/**
	 * \@stable
	 * @abstract
	 */
	var ComponentFactoryResolver = (function () {
	    function ComponentFactoryResolver() {
	    }
	    /**
	     * @abstract
	     * @template T
	     * @param {?} component
	     * @return {?}
	     */
	    ComponentFactoryResolver.prototype.resolveComponentFactory = function (component) { };
	    return ComponentFactoryResolver;
	}());
	ComponentFactoryResolver.NULL = new _NullComponentFactoryResolver();
	var CodegenComponentFactoryResolver = (function () {
	    /**
	     * @param {?} factories
	     * @param {?} _parent
	     * @param {?} _ngModule
	     */
	    function CodegenComponentFactoryResolver(factories, _parent, _ngModule) {
	        this._parent = _parent;
	        this._ngModule = _ngModule;
	        this._factories = new Map();
	        for (var i = 0; i < factories.length; i++) {
	            var factory = factories[i];
	            this._factories.set(factory.componentType, factory);
	        }
	    }
	    /**
	     * @template T
	     * @param {?} component
	     * @return {?}
	     */
	    CodegenComponentFactoryResolver.prototype.resolveComponentFactory = function (component) {
	        var /** @type {?} */ factory = this._factories.get(component);
	        if (!factory && this._parent) {
	            factory = this._parent.resolveComponentFactory(component);
	        }
	        if (!factory) {
	            throw noComponentFactoryError(component);
	        }
	        return new ComponentFactoryBoundToModule(factory, this._ngModule);
	    };
	    return CodegenComponentFactoryResolver;
	}());
	var ComponentFactoryBoundToModule = (function (_super) {
	    __extends(ComponentFactoryBoundToModule, _super);
	    /**
	     * @param {?} factory
	     * @param {?} ngModule
	     */
	    function ComponentFactoryBoundToModule(factory, ngModule) {
	        var _this = _super.call(this) || this;
	        _this.factory = factory;
	        _this.ngModule = ngModule;
	        return _this;
	    }
	    Object.defineProperty(ComponentFactoryBoundToModule.prototype, "selector", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.factory.selector; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ComponentFactoryBoundToModule.prototype, "componentType", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.factory.componentType; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ComponentFactoryBoundToModule.prototype, "ngContentSelectors", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.factory.ngContentSelectors; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ComponentFactoryBoundToModule.prototype, "inputs", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.factory.inputs; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ComponentFactoryBoundToModule.prototype, "outputs", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.factory.outputs; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @param {?} injector
	     * @param {?=} projectableNodes
	     * @param {?=} rootSelectorOrNode
	     * @param {?=} ngModule
	     * @return {?}
	     */
	    ComponentFactoryBoundToModule.prototype.create = function (injector, projectableNodes, rootSelectorOrNode, ngModule) {
	        return this.factory.create(injector, projectableNodes, rootSelectorOrNode, ngModule || this.ngModule);
	    };
	    return ComponentFactoryBoundToModule;
	}(ComponentFactory));
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Represents an instance of an NgModule created via a {\@link NgModuleFactory}.
	 *
	 * `NgModuleRef` provides access to the NgModule Instance as well other objects related to this
	 * NgModule Instance.
	 *
	 * \@stable
	 * @abstract
	 */
	var NgModuleRef = (function () {
	    function NgModuleRef() {
	    }
	    /**
	     * The injector that contains all of the providers of the NgModule.
	     * @abstract
	     * @return {?}
	     */
	    NgModuleRef.prototype.injector = function () { };
	    /**
	     * The ComponentFactoryResolver to get hold of the ComponentFactories
	     * declared in the `entryComponents` property of the module.
	     * @abstract
	     * @return {?}
	     */
	    NgModuleRef.prototype.componentFactoryResolver = function () { };
	    /**
	     * The NgModule instance.
	     * @abstract
	     * @return {?}
	     */
	    NgModuleRef.prototype.instance = function () { };
	    /**
	     * Destroys the module instance and all of the data structures associated with it.
	     * @abstract
	     * @return {?}
	     */
	    NgModuleRef.prototype.destroy = function () { };
	    /**
	     * Allows to register a callback that will be called when the module is destroyed.
	     * @abstract
	     * @param {?} callback
	     * @return {?}
	     */
	    NgModuleRef.prototype.onDestroy = function (callback) { };
	    return NgModuleRef;
	}());
	/**
	 * \@experimental
	 * @abstract
	 */
	var NgModuleFactory = (function () {
	    function NgModuleFactory() {
	    }
	    /**
	     * @abstract
	     * @return {?}
	     */
	    NgModuleFactory.prototype.moduleType = function () { };
	    /**
	     * @abstract
	     * @param {?} parentInjector
	     * @return {?}
	     */
	    NgModuleFactory.prototype.create = function (parentInjector) { };
	    return NgModuleFactory;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var trace;
	var events;
	/**
	 * @return {?}
	 */
	function detectWTF() {
	    var /** @type {?} */ wtf = ((_global) /** TODO #9100 */)['wtf'];
	    if (wtf) {
	        trace = wtf['trace'];
	        if (trace) {
	            events = trace['events'];
	            return true;
	        }
	    }
	    return false;
	}
	/**
	 * @param {?} signature
	 * @param {?=} flags
	 * @return {?}
	 */
	function createScope$1(signature, flags) {
	    if (flags === void 0) { flags = null; }
	    return events.createScope(signature, flags);
	}
	/**
	 * @template T
	 * @param {?} scope
	 * @param {?=} returnValue
	 * @return {?}
	 */
	function leave(scope, returnValue) {
	    trace.leaveScope(scope, returnValue);
	    return returnValue;
	}
	/**
	 * @param {?} rangeType
	 * @param {?} action
	 * @return {?}
	 */
	function startTimeRange(rangeType, action) {
	    return trace.beginTimeRange(rangeType, action);
	}
	/**
	 * @param {?} range
	 * @return {?}
	 */
	function endTimeRange(range) {
	    trace.endTimeRange(range);
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * True if WTF is enabled.
	 */
	var wtfEnabled = detectWTF();
	/**
	 * @param {?=} arg0
	 * @param {?=} arg1
	 * @return {?}
	 */
	function noopScope(arg0, arg1) {
	    return null;
	}
	/**
	 * Create trace scope.
	 *
	 * Scopes must be strictly nested and are analogous to stack frames, but
	 * do not have to follow the stack frames. Instead it is recommended that they follow logical
	 * nesting. You may want to use
	 * [Event
	 * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)
	 * as they are defined in WTF.
	 *
	 * Used to mark scope entry. The return value is used to leave the scope.
	 *
	 *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');
	 *
	 *     someMethod() {
	 *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI
	 *        // DO SOME WORK HERE
	 *        return wtfLeave(s, 123); // Return value 123
	 *     }
	 *
	 * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can
	 * negatively impact the performance of your application. For this reason we recommend that
	 * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and
	 * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to
	 * exception, will produce incorrect trace, but presence of exception signifies logic error which
	 * needs to be fixed before the app should be profiled. Add try-finally only when you expect that
	 * an exception is expected during normal execution while profiling.
	 *
	 * \@experimental
	 */
	var wtfCreateScope = wtfEnabled ? createScope$1 : function (signature, flags) { return noopScope; };
	/**
	 * Used to mark end of Scope.
	 *
	 * - `scope` to end.
	 * - `returnValue` (optional) to be passed to the WTF.
	 *
	 * Returns the `returnValue for easy chaining.
	 * \@experimental
	 */
	var wtfLeave = wtfEnabled ? leave : function (s, r) { return r; };
	/**
	 * Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.
	 * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been
	 * enabled.
	 *
	 *     someMethod() {
	 *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');
	 *        var future = new Future.delay(5).then((_) {
	 *          wtfEndTimeRange(s);
	 *        });
	 *     }
	 * \@experimental
	 */
	var wtfStartTimeRange = wtfEnabled ? startTimeRange : function (rangeType, action) { return null; };
	/**
	 * Ends a async time range operation.
	 * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been
	 * enabled.
	 * \@experimental
	 */
	var wtfEndTimeRange = wtfEnabled ? endTimeRange : function (r) { return null; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Use by directives and components to emit custom Events.
	 *
	 * ### Examples
	 *
	 * In the following example, `Zippy` alternatively emits `open` and `close` events when its
	 * title gets clicked:
	 *
	 * ```
	 * \@Component({
	 *   selector: 'zippy',
	 *   template: `
	 *   <div class="zippy">
	 *     <div (click)="toggle()">Toggle</div>
	 *     <div [hidden]="!visible">
	 *       <ng-content></ng-content>
	 *     </div>
	 *  </div>`})
	 * export class Zippy {
	 *   visible: boolean = true;
	 *   \@Output() open: EventEmitter<any> = new EventEmitter();
	 *   \@Output() close: EventEmitter<any> = new EventEmitter();
	 *
	 *   toggle() {
	 *     this.visible = !this.visible;
	 *     if (this.visible) {
	 *       this.open.emit(null);
	 *     } else {
	 *       this.close.emit(null);
	 *     }
	 *   }
	 * }
	 * ```
	 *
	 * The events payload can be accessed by the parameter `$event` on the components output event
	 * handler:
	 *
	 * ```
	 * <zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
	 * ```
	 *
	 * Uses Rx.Observable but provides an adapter to make it work as specified here:
	 * https://github.com/jhusain/observable-spec
	 *
	 * Once a reference implementation of the spec is available, switch to it.
	 * \@stable
	 */
	var EventEmitter = (function (_super) {
	    __extends(EventEmitter, _super);
	    /**
	     * Creates an instance of {\@link EventEmitter}, which depending on `isAsync`,
	     * delivers events synchronously or asynchronously.
	     *
	     * @param {?=} isAsync By default, events are delivered synchronously (default value: `false`).
	     * Set to `true` for asynchronous event delivery.
	     */
	    function EventEmitter(isAsync) {
	        if (isAsync === void 0) { isAsync = false; }
	        var _this = _super.call(this) || this;
	        _this.__isAsync = isAsync;
	        return _this;
	    }
	    /**
	     * @param {?=} value
	     * @return {?}
	     */
	    EventEmitter.prototype.emit = function (value) { _super.prototype.next.call(this, value); };
	    /**
	     * @param {?=} generatorOrNext
	     * @param {?=} error
	     * @param {?=} complete
	     * @return {?}
	     */
	    EventEmitter.prototype.subscribe = function (generatorOrNext, error, complete) {
	        var /** @type {?} */ schedulerFn;
	        var /** @type {?} */ errorFn = function (err) { return null; };
	        var /** @type {?} */ completeFn = function () { return null; };
	        if (generatorOrNext && typeof generatorOrNext === 'object') {
	            schedulerFn = this.__isAsync ? function (value) {
	                setTimeout(function () { return generatorOrNext.next(value); });
	            } : function (value) { generatorOrNext.next(value); };
	            if (generatorOrNext.error) {
	                errorFn = this.__isAsync ? function (err) { setTimeout(function () { return generatorOrNext.error(err); }); } :
	                    function (err) { generatorOrNext.error(err); };
	            }
	            if (generatorOrNext.complete) {
	                completeFn = this.__isAsync ? function () { setTimeout(function () { return generatorOrNext.complete(); }); } :
	                    function () { generatorOrNext.complete(); };
	            }
	        }
	        else {
	            schedulerFn = this.__isAsync ? function (value) { setTimeout(function () { return generatorOrNext(value); }); } :
	                function (value) { generatorOrNext(value); };
	            if (error) {
	                errorFn =
	                    this.__isAsync ? function (err) { setTimeout(function () { return error(err); }); } : function (err) { error(err); };
	            }
	            if (complete) {
	                completeFn =
	                    this.__isAsync ? function () { setTimeout(function () { return complete(); }); } : function () { complete(); };
	            }
	        }
	        return _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);
	    };
	    return EventEmitter;
	}(rxjs_Subject.Subject));
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * An injectable service for executing work inside or outside of the Angular zone.
	 *
	 * The most common use of this service is to optimize performance when starting a work consisting of
	 * one or more asynchronous tasks that don't require UI updates or error handling to be handled by
	 * Angular. Such tasks can be kicked off via {\@link #runOutsideAngular} and if needed, these tasks
	 * can reenter the Angular zone via {\@link #run}.
	 *
	 * <!-- TODO: add/fix links to:
	 *   - docs explaining zones and the use of zones in Angular and change-detection
	 *   - link to runOutsideAngular/run (throughout this file!)
	 *   -->
	 *
	 * ### Example
	 *
	 * ```
	 * import {Component, NgZone} from '\@angular/core';
	 * import {NgIf} from '\@angular/common';
	 *
	 * \@Component({
	 *   selector: 'ng-zone-demo'.
	 *   template: `
	 *     <h2>Demo: NgZone</h2>
	 *
	 *     <p>Progress: {{progress}}%</p>
	 *     <p *ngIf="progress >= 100">Done processing {{label}} of Angular zone!</p>
	 *
	 *     <button (click)="processWithinAngularZone()">Process within Angular zone</button>
	 *     <button (click)="processOutsideOfAngularZone()">Process outside of Angular zone</button>
	 *   `,
	 * })
	 * export class NgZoneDemo {
	 *   progress: number = 0;
	 *   label: string;
	 *
	 *   constructor(private _ngZone: NgZone) {}
	 *
	 *   // Loop inside the Angular zone
	 *   // so the UI DOES refresh after each setTimeout cycle
	 *   processWithinAngularZone() {
	 *     this.label = 'inside';
	 *     this.progress = 0;
	 *     this._increaseProgress(() => console.log('Inside Done!'));
	 *   }
	 *
	 *   // Loop outside of the Angular zone
	 *   // so the UI DOES NOT refresh after each setTimeout cycle
	 *   processOutsideOfAngularZone() {
	 *     this.label = 'outside';
	 *     this.progress = 0;
	 *     this._ngZone.runOutsideAngular(() => {
	 *       this._increaseProgress(() => {
	 *       // reenter the Angular zone and display done
	 *       this._ngZone.run(() => {console.log('Outside Done!') });
	 *     }}));
	 *   }
	 *
	 *   _increaseProgress(doneCallback: () => void) {
	 *     this.progress += 1;
	 *     console.log(`Current progress: ${this.progress}%`);
	 *
	 *     if (this.progress < 100) {
	 *       window.setTimeout(() => this._increaseProgress(doneCallback)), 10)
	 *     } else {
	 *       doneCallback();
	 *     }
	 *   }
	 * }
	 * ```
	 *
	 * \@experimental
	 */
	var NgZone = (function () {
	    /**
	     * @param {?} __0
	     */
	    function NgZone(_a) {
	        var _b = _a.enableLongStackTrace, enableLongStackTrace = _b === void 0 ? false : _b;
	        this.hasPendingMicrotasks = false;
	        this.hasPendingMacrotasks = false;
	        /**
	         * Whether there are no outstanding microtasks or macrotasks.
	         */
	        this.isStable = true;
	        /**
	         * Notifies when code enters Angular Zone. This gets fired first on VM Turn.
	         */
	        this.onUnstable = new EventEmitter(false);
	        /**
	         * Notifies when there is no more microtasks enqueue in the current VM Turn.
	         * This is a hint for Angular to do change detection, which may enqueue more microtasks.
	         * For this reason this event can fire multiple times per VM Turn.
	         */
	        this.onMicrotaskEmpty = new EventEmitter(false);
	        /**
	         * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which
	         * implies we are about to relinquish VM turn.
	         * This event gets called just once.
	         */
	        this.onStable = new EventEmitter(false);
	        /**
	         * Notifies that an error has been delivered.
	         */
	        this.onError = new EventEmitter(false);
	        if (typeof Zone == 'undefined') {
	            throw new Error('Angular requires Zone.js prolyfill.');
	        }
	        Zone.assertZonePatched();
	        var self = this;
	        self._nesting = 0;
	        self._outer = self._inner = Zone.current;
	        if (Zone['wtfZoneSpec']) {
	            self._inner = self._inner.fork(Zone['wtfZoneSpec']);
	        }
	        if (enableLongStackTrace && Zone['longStackTraceZoneSpec']) {
	            self._inner = self._inner.fork(Zone['longStackTraceZoneSpec']);
	        }
	        forkInnerZoneWithAngularBehavior(self);
	    }
	    /**
	     * @return {?}
	     */
	    NgZone.isInAngularZone = function () { return Zone.current.get('isAngularZone') === true; };
	    /**
	     * @return {?}
	     */
	    NgZone.assertInAngularZone = function () {
	        if (!NgZone.isInAngularZone()) {
	            throw new Error('Expected to be in Angular Zone, but it is not!');
	        }
	    };
	    /**
	     * @return {?}
	     */
	    NgZone.assertNotInAngularZone = function () {
	        if (NgZone.isInAngularZone()) {
	            throw new Error('Expected to not be in Angular Zone, but it is!');
	        }
	    };
	    /**
	     * Executes the `fn` function synchronously within the Angular zone and returns value returned by
	     * the function.
	     *
	     * Running functions via `run` allows you to reenter Angular zone from a task that was executed
	     * outside of the Angular zone (typically started via {\@link #runOutsideAngular}).
	     *
	     * Any future tasks or microtasks scheduled from within this function will continue executing from
	     * within the Angular zone.
	     *
	     * If a synchronous error happens it will be rethrown and not reported via `onError`.
	     * @param {?} fn
	     * @return {?}
	     */
	    NgZone.prototype.run = function (fn) { return (((this)))._inner.run(fn); };
	    /**
	     * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not
	     * rethrown.
	     * @param {?} fn
	     * @return {?}
	     */
	    NgZone.prototype.runGuarded = function (fn) { return (((this)))._inner.runGuarded(fn); };
	    /**
	     * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
	     * the function.
	     *
	     * Running functions via {\@link #runOutsideAngular} allows you to escape Angular's zone and do
	     * work that
	     * doesn't trigger Angular change-detection or is subject to Angular's error handling.
	     *
	     * Any future tasks or microtasks scheduled from within this function will continue executing from
	     * outside of the Angular zone.
	     *
	     * Use {\@link #run} to reenter the Angular zone and do work that updates the application model.
	     * @param {?} fn
	     * @return {?}
	     */
	    NgZone.prototype.runOutsideAngular = function (fn) { return (((this)))._outer.run(fn); };
	    return NgZone;
	}());
	/**
	 * @param {?} zone
	 * @return {?}
	 */
	function checkStable(zone) {
	    if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {
	        try {
	            zone._nesting++;
	            zone.onMicrotaskEmpty.emit(null);
	        }
	        finally {
	            zone._nesting--;
	            if (!zone.hasPendingMicrotasks) {
	                try {
	                    zone.runOutsideAngular(function () { return zone.onStable.emit(null); });
	                }
	                finally {
	                    zone.isStable = true;
	                }
	            }
	        }
	    }
	}
	/**
	 * @param {?} zone
	 * @return {?}
	 */
	function forkInnerZoneWithAngularBehavior(zone) {
	    zone._inner = zone._inner.fork({
	        name: 'angular',
	        properties: /** @type {?} */ ({ 'isAngularZone': true }),
	        onInvokeTask: function (delegate, current, target, task, applyThis, applyArgs) {
	            try {
	                onEnter(zone);
	                return delegate.invokeTask(target, task, applyThis, applyArgs);
	            }
	            finally {
	                onLeave(zone);
	            }
	        },
	        onInvoke: function (delegate, current, target, callback, applyThis, applyArgs, source) {
	            try {
	                onEnter(zone);
	                return delegate.invoke(target, callback, applyThis, applyArgs, source);
	            }
	            finally {
	                onLeave(zone);
	            }
	        },
	        onHasTask: function (delegate, current, target, hasTaskState) {
	            delegate.hasTask(target, hasTaskState);
	            if (current === target) {
	                // We are only interested in hasTask events which originate from our zone
	                // (A child hasTask event is not interesting to us)
	                if (hasTaskState.change == 'microTask') {
	                    zone.hasPendingMicrotasks = hasTaskState.microTask;
	                    checkStable(zone);
	                }
	                else if (hasTaskState.change == 'macroTask') {
	                    zone.hasPendingMacrotasks = hasTaskState.macroTask;
	                }
	            }
	        },
	        onHandleError: function (delegate, current, target, error) {
	            delegate.handleError(target, error);
	            zone.runOutsideAngular(function () { return zone.onError.emit(error); });
	            return false;
	        }
	    });
	}
	/**
	 * @param {?} zone
	 * @return {?}
	 */
	function onEnter(zone) {
	    zone._nesting++;
	    if (zone.isStable) {
	        zone.isStable = false;
	        zone.onUnstable.emit(null);
	    }
	}
	/**
	 * @param {?} zone
	 * @return {?}
	 */
	function onLeave(zone) {
	    zone._nesting--;
	    checkStable(zone);
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * The Testability service provides testing hooks that can be accessed from
	 * the browser and by services such as Protractor. Each bootstrapped Angular
	 * application on the page will have an instance of Testability.
	 * \@experimental
	 */
	var Testability = (function () {
	    /**
	     * @param {?} _ngZone
	     */
	    function Testability(_ngZone) {
	        this._ngZone = _ngZone;
	        /**
	         * \@internal
	         */
	        this._pendingCount = 0;
	        /**
	         * \@internal
	         */
	        this._isZoneStable = true;
	        /**
	         * Whether any work was done since the last 'whenStable' callback. This is
	         * useful to detect if this could have potentially destabilized another
	         * component while it is stabilizing.
	         * \@internal
	         */
	        this._didWork = false;
	        /**
	         * \@internal
	         */
	        this._callbacks = [];
	        this._watchAngularEvents();
	    }
	    /**
	     * \@internal
	     * @return {?}
	     */
	    Testability.prototype._watchAngularEvents = function () {
	        var _this = this;
	        this._ngZone.onUnstable.subscribe({
	            next: function () {
	                _this._didWork = true;
	                _this._isZoneStable = false;
	            }
	        });
	        this._ngZone.runOutsideAngular(function () {
	            _this._ngZone.onStable.subscribe({
	                next: function () {
	                    NgZone.assertNotInAngularZone();
	                    scheduleMicroTask(function () {
	                        _this._isZoneStable = true;
	                        _this._runCallbacksIfReady();
	                    });
	                }
	            });
	        });
	    };
	    /**
	     * @return {?}
	     */
	    Testability.prototype.increasePendingRequestCount = function () {
	        this._pendingCount += 1;
	        this._didWork = true;
	        return this._pendingCount;
	    };
	    /**
	     * @return {?}
	     */
	    Testability.prototype.decreasePendingRequestCount = function () {
	        this._pendingCount -= 1;
	        if (this._pendingCount < 0) {
	            throw new Error('pending async requests below zero');
	        }
	        this._runCallbacksIfReady();
	        return this._pendingCount;
	    };
	    /**
	     * @return {?}
	     */
	    Testability.prototype.isStable = function () {
	        return this._isZoneStable && this._pendingCount == 0 && !this._ngZone.hasPendingMacrotasks;
	    };
	    /**
	     * \@internal
	     * @return {?}
	     */
	    Testability.prototype._runCallbacksIfReady = function () {
	        var _this = this;
	        if (this.isStable()) {
	            // Schedules the call backs in a new frame so that it is always async.
	            scheduleMicroTask(function () {
	                while (_this._callbacks.length !== 0) {
	                    (((_this._callbacks.pop())))(_this._didWork);
	                }
	                _this._didWork = false;
	            });
	        }
	        else {
	            // Not Ready
	            this._didWork = true;
	        }
	    };
	    /**
	     * @param {?} callback
	     * @return {?}
	     */
	    Testability.prototype.whenStable = function (callback) {
	        this._callbacks.push(callback);
	        this._runCallbacksIfReady();
	    };
	    /**
	     * @return {?}
	     */
	    Testability.prototype.getPendingRequestCount = function () { return this._pendingCount; };
	    /**
	     * @deprecated use findProviders
	     * @param {?} using
	     * @param {?} provider
	     * @param {?} exactMatch
	     * @return {?}
	     */
	    Testability.prototype.findBindings = function (using, provider, exactMatch) {
	        // TODO(juliemr): implement.
	        return [];
	    };
	    /**
	     * @param {?} using
	     * @param {?} provider
	     * @param {?} exactMatch
	     * @return {?}
	     */
	    Testability.prototype.findProviders = function (using, provider, exactMatch) {
	        // TODO(juliemr): implement.
	        return [];
	    };
	    return Testability;
	}());
	Testability.decorators = [
	    { type: Injectable },
	];
	/**
	 * @nocollapse
	 */
	Testability.ctorParameters = function () { return [
	    { type: NgZone, },
	]; };
	/**
	 * A global registry of {\@link Testability} instances for specific elements.
	 * \@experimental
	 */
	var TestabilityRegistry = (function () {
	    function TestabilityRegistry() {
	        /**
	         * \@internal
	         */
	        this._applications = new Map();
	        _testabilityGetter.addToWindow(this);
	    }
	    /**
	     * @param {?} token
	     * @param {?} testability
	     * @return {?}
	     */
	    TestabilityRegistry.prototype.registerApplication = function (token, testability) {
	        this._applications.set(token, testability);
	    };
	    /**
	     * @param {?} elem
	     * @return {?}
	     */
	    TestabilityRegistry.prototype.getTestability = function (elem) { return this._applications.get(elem) || null; };
	    /**
	     * @return {?}
	     */
	    TestabilityRegistry.prototype.getAllTestabilities = function () { return Array.from(this._applications.values()); };
	    /**
	     * @return {?}
	     */
	    TestabilityRegistry.prototype.getAllRootElements = function () { return Array.from(this._applications.keys()); };
	    /**
	     * @param {?} elem
	     * @param {?=} findInAncestors
	     * @return {?}
	     */
	    TestabilityRegistry.prototype.findTestabilityInTree = function (elem, findInAncestors) {
	        if (findInAncestors === void 0) { findInAncestors = true; }
	        return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);
	    };
	    return TestabilityRegistry;
	}());
	TestabilityRegistry.decorators = [
	    { type: Injectable },
	];
	/**
	 * @nocollapse
	 */
	TestabilityRegistry.ctorParameters = function () { return []; };
	var _NoopGetTestability = (function () {
	    function _NoopGetTestability() {
	    }
	    /**
	     * @param {?} registry
	     * @return {?}
	     */
	    _NoopGetTestability.prototype.addToWindow = function (registry) { };
	    /**
	     * @param {?} registry
	     * @param {?} elem
	     * @param {?} findInAncestors
	     * @return {?}
	     */
	    _NoopGetTestability.prototype.findTestabilityInTree = function (registry, elem, findInAncestors) {
	        return null;
	    };
	    return _NoopGetTestability;
	}());
	/**
	 * Set the {\@link GetTestability} implementation used by the Angular testing framework.
	 * \@experimental
	 * @param {?} getter
	 * @return {?}
	 */
	function setTestabilityGetter(getter) {
	    _testabilityGetter = getter;
	}
	var _testabilityGetter = new _NoopGetTestability();
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var _devMode = true;
	var _runModeLocked = false;
	var _platform;
	var ALLOW_MULTIPLE_PLATFORMS = new InjectionToken('AllowMultipleToken');
	/**
	 * Disable Angular's development mode, which turns off assertions and other
	 * checks within the framework.
	 *
	 * One important assertion this disables verifies that a change detection pass
	 * does not result in additional changes to any bindings (also known as
	 * unidirectional data flow).
	 *
	 * \@stable
	 * @return {?}
	 */
	function enableProdMode() {
	    if (_runModeLocked) {
	        throw new Error('Cannot enable prod mode after platform setup.');
	    }
	    _devMode = false;
	}
	/**
	 * Returns whether Angular is in development mode. After called once,
	 * the value is locked and won't change any more.
	 *
	 * By default, this is true, unless a user calls `enableProdMode` before calling this.
	 *
	 * \@experimental APIs related to application bootstrap are currently under review.
	 * @return {?}
	 */
	function isDevMode() {
	    _runModeLocked = true;
	    return _devMode;
	}
	/**
	 * A token for third-party components that can register themselves with NgProbe.
	 *
	 * \@experimental
	 */
	var NgProbeToken = (function () {
	    /**
	     * @param {?} name
	     * @param {?} token
	     */
	    function NgProbeToken(name, token) {
	        this.name = name;
	        this.token = token;
	    }
	    return NgProbeToken;
	}());
	/**
	 * Creates a platform.
	 * Platforms have to be eagerly created via this function.
	 *
	 * \@experimental APIs related to application bootstrap are currently under review.
	 * @param {?} injector
	 * @return {?}
	 */
	function createPlatform(injector) {
	    if (_platform && !_platform.destroyed &&
	        !_platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
	        throw new Error('There can be only one platform. Destroy the previous one to create a new one.');
	    }
	    _platform = injector.get(PlatformRef);
	    var /** @type {?} */ inits = injector.get(PLATFORM_INITIALIZER, null);
	    if (inits)
	        inits.forEach(function (init) { return init(); });
	    return _platform;
	}
	/**
	 * Creates a factory for a platform
	 *
	 * \@experimental APIs related to application bootstrap are currently under review.
	 * @param {?} parentPlatformFactory
	 * @param {?} name
	 * @param {?=} providers
	 * @return {?}
	 */
	function createPlatformFactory(parentPlatformFactory, name, providers) {
	    if (providers === void 0) { providers = []; }
	    var /** @type {?} */ marker = new InjectionToken("Platform: " + name);
	    return function (extraProviders) {
	        if (extraProviders === void 0) { extraProviders = []; }
	        var /** @type {?} */ platform = getPlatform();
	        if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
	            if (parentPlatformFactory) {
	                parentPlatformFactory(providers.concat(extraProviders).concat({ provide: marker, useValue: true }));
	            }
	            else {
	                createPlatform(ReflectiveInjector.resolveAndCreate(providers.concat(extraProviders).concat({ provide: marker, useValue: true })));
	            }
	        }
	        return assertPlatform(marker);
	    };
	}
	/**
	 * Checks that there currently is a platform which contains the given token as a provider.
	 *
	 * \@experimental APIs related to application bootstrap are currently under review.
	 * @param {?} requiredToken
	 * @return {?}
	 */
	function assertPlatform(requiredToken) {
	    var /** @type {?} */ platform = getPlatform();
	    if (!platform) {
	        throw new Error('No platform exists!');
	    }
	    if (!platform.injector.get(requiredToken, null)) {
	        throw new Error('A platform with a different configuration has been created. Please destroy it first.');
	    }
	    return platform;
	}
	/**
	 * Destroy the existing platform.
	 *
	 * \@experimental APIs related to application bootstrap are currently under review.
	 * @return {?}
	 */
	function destroyPlatform() {
	    if (_platform && !_platform.destroyed) {
	        _platform.destroy();
	    }
	}
	/**
	 * Returns the current platform.
	 *
	 * \@experimental APIs related to application bootstrap are currently under review.
	 * @return {?}
	 */
	function getPlatform() {
	    return _platform && !_platform.destroyed ? _platform : null;
	}
	/**
	 * The Angular platform is the entry point for Angular on a web page. Each page
	 * has exactly one platform, and services (such as reflection) which are common
	 * to every Angular application running on the page are bound in its scope.
	 *
	 * A page's platform is initialized implicitly when a platform is created via a platform factory
	 * (e.g. {\@link platformBrowser}), or explicitly by calling the {\@link createPlatform} function.
	 *
	 * \@stable
	 * @abstract
	 */
	var PlatformRef = (function () {
	    function PlatformRef() {
	    }
	    /**
	     * Creates an instance of an `\@NgModule` for the given platform
	     * for offline compilation.
	     *
	     * ## Simple Example
	     *
	     * ```typescript
	     * my_module.ts:
	     *
	     * \@NgModule({
	     *   imports: [BrowserModule]
	     * })
	     * class MyModule {}
	     *
	     * main.ts:
	     * import {MyModuleNgFactory} from './my_module.ngfactory';
	     * import {platformBrowser} from '\@angular/platform-browser';
	     *
	     * let moduleRef = platformBrowser().bootstrapModuleFactory(MyModuleNgFactory);
	     * ```
	     *
	     * \@experimental APIs related to application bootstrap are currently under review.
	     * @abstract
	     * @template M
	     * @param {?} moduleFactory
	     * @return {?}
	     */
	    PlatformRef.prototype.bootstrapModuleFactory = function (moduleFactory) { };
	    /**
	     * Creates an instance of an `\@NgModule` for a given platform using the given runtime compiler.
	     *
	     * ## Simple Example
	     *
	     * ```typescript
	     * \@NgModule({
	     *   imports: [BrowserModule]
	     * })
	     * class MyModule {}
	     *
	     * let moduleRef = platformBrowser().bootstrapModule(MyModule);
	     * ```
	     * \@stable
	     * @abstract
	     * @template M
	     * @param {?} moduleType
	     * @param {?=} compilerOptions
	     * @return {?}
	     */
	    PlatformRef.prototype.bootstrapModule = function (moduleType, compilerOptions) { };
	    /**
	     * Register a listener to be called when the platform is disposed.
	     * @abstract
	     * @param {?} callback
	     * @return {?}
	     */
	    PlatformRef.prototype.onDestroy = function (callback) { };
	    /**
	     * Retrieve the platform {\@link Injector}, which is the parent injector for
	     * every Angular application on the page and provides singleton providers.
	     * @abstract
	     * @return {?}
	     */
	    PlatformRef.prototype.injector = function () { };
	    /**
	     * Destroy the Angular platform and all Angular applications on the page.
	     * @abstract
	     * @return {?}
	     */
	    PlatformRef.prototype.destroy = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    PlatformRef.prototype.destroyed = function () { };
	    return PlatformRef;
	}());
	/**
	 * @param {?} errorHandler
	 * @param {?} ngZone
	 * @param {?} callback
	 * @return {?}
	 */
	function _callAndReportToErrorHandler(errorHandler, ngZone, callback) {
	    try {
	        var /** @type {?} */ result = callback();
	        if (isPromise(result)) {
	            return result.catch(function (e) {
	                ngZone.runOutsideAngular(function () { return errorHandler.handleError(e); });
	                // rethrow as the exception handler might not do it
	                throw e;
	            });
	        }
	        return result;
	    }
	    catch (e) {
	        ngZone.runOutsideAngular(function () { return errorHandler.handleError(e); });
	        // rethrow as the exception handler might not do it
	        throw e;
	    }
	}
	/**
	 * workaround https://github.com/angular/tsickle/issues/350
	 * @suppress {checkTypes}
	 */
	var PlatformRef_ = (function (_super) {
	    __extends(PlatformRef_, _super);
	    /**
	     * @param {?} _injector
	     */
	    function PlatformRef_(_injector) {
	        var _this = _super.call(this) || this;
	        _this._injector = _injector;
	        _this._modules = [];
	        _this._destroyListeners = [];
	        _this._destroyed = false;
	        return _this;
	    }
	    /**
	     * @param {?} callback
	     * @return {?}
	     */
	    PlatformRef_.prototype.onDestroy = function (callback) { this._destroyListeners.push(callback); };
	    Object.defineProperty(PlatformRef_.prototype, "injector", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._injector; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PlatformRef_.prototype, "destroyed", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._destroyed; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @return {?}
	     */
	    PlatformRef_.prototype.destroy = function () {
	        if (this._destroyed) {
	            throw new Error('The platform has already been destroyed!');
	        }
	        this._modules.slice().forEach(function (module) { return module.destroy(); });
	        this._destroyListeners.forEach(function (listener) { return listener(); });
	        this._destroyed = true;
	    };
	    /**
	     * @template M
	     * @param {?} moduleFactory
	     * @return {?}
	     */
	    PlatformRef_.prototype.bootstrapModuleFactory = function (moduleFactory) {
	        return this._bootstrapModuleFactoryWithZone(moduleFactory);
	    };
	    /**
	     * @template M
	     * @param {?} moduleFactory
	     * @param {?=} ngZone
	     * @return {?}
	     */
	    PlatformRef_.prototype._bootstrapModuleFactoryWithZone = function (moduleFactory, ngZone) {
	        var _this = this;
	        // Note: We need to create the NgZone _before_ we instantiate the module,
	        // as instantiating the module creates some providers eagerly.
	        // So we create a mini parent injector that just contains the new NgZone and
	        // pass that as parent to the NgModuleFactory.
	        if (!ngZone)
	            ngZone = new NgZone({ enableLongStackTrace: isDevMode() });
	        // Attention: Don't use ApplicationRef.run here,
	        // as we want to be sure that all possible constructor calls are inside `ngZone.run`!
	        return ngZone.run(function () {
	            var /** @type {?} */ ngZoneInjector = ReflectiveInjector.resolveAndCreate([{ provide: NgZone, useValue: ngZone }], _this.injector);
	            var /** @type {?} */ moduleRef = (moduleFactory.create(ngZoneInjector));
	            var /** @type {?} */ exceptionHandler = moduleRef.injector.get(ErrorHandler, null);
	            if (!exceptionHandler) {
	                throw new Error('No ErrorHandler. Is platform module (BrowserModule) included?');
	            }
	            moduleRef.onDestroy(function () { return remove(_this._modules, moduleRef); }); /** @type {?} */
	            ((ngZone)).runOutsideAngular(function () { return ((ngZone)).onError.subscribe({ next: function (error) { exceptionHandler.handleError(error); } }); });
	            return _callAndReportToErrorHandler(exceptionHandler, /** @type {?} */ ((ngZone)), function () {
	                var /** @type {?} */ initStatus = moduleRef.injector.get(ApplicationInitStatus);
	                initStatus.runInitializers();
	                return initStatus.donePromise.then(function () {
	                    _this._moduleDoBootstrap(moduleRef);
	                    return moduleRef;
	                });
	            });
	        });
	    };
	    /**
	     * @template M
	     * @param {?} moduleType
	     * @param {?=} compilerOptions
	     * @return {?}
	     */
	    PlatformRef_.prototype.bootstrapModule = function (moduleType, compilerOptions) {
	        if (compilerOptions === void 0) { compilerOptions = []; }
	        return this._bootstrapModuleWithZone(moduleType, compilerOptions);
	    };
	    /**
	     * @template M
	     * @param {?} moduleType
	     * @param {?=} compilerOptions
	     * @param {?=} ngZone
	     * @return {?}
	     */
	    PlatformRef_.prototype._bootstrapModuleWithZone = function (moduleType, compilerOptions, ngZone) {
	        var _this = this;
	        if (compilerOptions === void 0) { compilerOptions = []; }
	        var /** @type {?} */ compilerFactory = this.injector.get(CompilerFactory);
	        var /** @type {?} */ compiler = compilerFactory.createCompiler(Array.isArray(compilerOptions) ? compilerOptions : [compilerOptions]);
	        return compiler.compileModuleAsync(moduleType)
	            .then(function (moduleFactory) { return _this._bootstrapModuleFactoryWithZone(moduleFactory, ngZone); });
	    };
	    /**
	     * @param {?} moduleRef
	     * @return {?}
	     */
	    PlatformRef_.prototype._moduleDoBootstrap = function (moduleRef) {
	        var /** @type {?} */ appRef = (moduleRef.injector.get(ApplicationRef));
	        if (moduleRef._bootstrapComponents.length > 0) {
	            moduleRef._bootstrapComponents.forEach(function (f) { return appRef.bootstrap(f); });
	        }
	        else if (moduleRef.instance.ngDoBootstrap) {
	            moduleRef.instance.ngDoBootstrap(appRef);
	        }
	        else {
	            throw new Error("The module " + stringify(moduleRef.instance.constructor) + " was bootstrapped, but it does not declare \"@NgModule.bootstrap\" components nor a \"ngDoBootstrap\" method. " +
	                "Please define one of these.");
	        }
	        this._modules.push(moduleRef);
	    };
	    return PlatformRef_;
	}(PlatformRef));
	PlatformRef_.decorators = [
	    { type: Injectable },
	];
	/**
	 * @nocollapse
	 */
	PlatformRef_.ctorParameters = function () { return [
	    { type: Injector, },
	]; };
	/**
	 * A reference to an Angular application running on a page.
	 *
	 * \@stable
	 * @abstract
	 */
	var ApplicationRef = (function () {
	    function ApplicationRef() {
	    }
	    /**
	     * Bootstrap a new component at the root level of the application.
	     *
	     * ### Bootstrap process
	     *
	     * When bootstrapping a new root component into an application, Angular mounts the
	     * specified application component onto DOM elements identified by the [componentType]'s
	     * selector and kicks off automatic change detection to finish initializing the component.
	     *
	     * Optionally, a component can be mounted onto a DOM element that does not match the
	     * [componentType]'s selector.
	     *
	     * ### Example
	     * {\@example core/ts/platform/platform.ts region='longform'}
	     * @abstract
	     * @template C
	     * @param {?} componentFactory
	     * @param {?=} rootSelectorOrNode
	     * @return {?}
	     */
	    ApplicationRef.prototype.bootstrap = function (componentFactory, rootSelectorOrNode) { };
	    /**
	     * Invoke this method to explicitly process change detection and its side-effects.
	     *
	     * In development mode, `tick()` also performs a second change detection cycle to ensure that no
	     * further changes are detected. If additional changes are picked up during this second cycle,
	     * bindings in the app have side-effects that cannot be resolved in a single change detection
	     * pass.
	     * In this case, Angular throws an error, since an Angular application can only have one change
	     * detection pass during which all change detection must complete.
	     * @abstract
	     * @return {?}
	     */
	    ApplicationRef.prototype.tick = function () { };
	    /**
	     * Get a list of component types registered to this application.
	     * This list is populated even before the component is created.
	     * @abstract
	     * @return {?}
	     */
	    ApplicationRef.prototype.componentTypes = function () { };
	    /**
	     * Get a list of components registered to this application.
	     * @abstract
	     * @return {?}
	     */
	    ApplicationRef.prototype.components = function () { };
	    /**
	     * Attaches a view so that it will be dirty checked.
	     * The view will be automatically detached when it is destroyed.
	     * This will throw if the view is already attached to a ViewContainer.
	     * @abstract
	     * @param {?} view
	     * @return {?}
	     */
	    ApplicationRef.prototype.attachView = function (view) { };
	    /**
	     * Detaches a view from dirty checking again.
	     * @abstract
	     * @param {?} view
	     * @return {?}
	     */
	    ApplicationRef.prototype.detachView = function (view) { };
	    /**
	     * Returns the number of attached views.
	     * @abstract
	     * @return {?}
	     */
	    ApplicationRef.prototype.viewCount = function () { };
	    /**
	     * Returns an Observable that indicates when the application is stable or unstable.
	     * @abstract
	     * @return {?}
	     */
	    ApplicationRef.prototype.isStable = function () { };
	    return ApplicationRef;
	}());
	/**
	 * workaround https://github.com/angular/tsickle/issues/350
	 * @suppress {checkTypes}
	 */
	var ApplicationRef_ = (function (_super) {
	    __extends(ApplicationRef_, _super);
	    /**
	     * @param {?} _zone
	     * @param {?} _console
	     * @param {?} _injector
	     * @param {?} _exceptionHandler
	     * @param {?} _componentFactoryResolver
	     * @param {?} _initStatus
	     */
	    function ApplicationRef_(_zone, _console, _injector, _exceptionHandler, _componentFactoryResolver, _initStatus) {
	        var _this = _super.call(this) || this;
	        _this._zone = _zone;
	        _this._console = _console;
	        _this._injector = _injector;
	        _this._exceptionHandler = _exceptionHandler;
	        _this._componentFactoryResolver = _componentFactoryResolver;
	        _this._initStatus = _initStatus;
	        _this._bootstrapListeners = [];
	        _this._rootComponents = [];
	        _this._rootComponentTypes = [];
	        _this._views = [];
	        _this._runningTick = false;
	        _this._enforceNoNewChanges = false;
	        _this._stable = true;
	        _this._enforceNoNewChanges = isDevMode();
	        _this._zone.onMicrotaskEmpty.subscribe({ next: function () { _this._zone.run(function () { _this.tick(); }); } });
	        var isCurrentlyStable = new rxjs_Observable.Observable(function (observer) {
	            _this._stable = _this._zone.isStable && !_this._zone.hasPendingMacrotasks &&
	                !_this._zone.hasPendingMicrotasks;
	            _this._zone.runOutsideAngular(function () {
	                observer.next(_this._stable);
	                observer.complete();
	            });
	        });
	        var isStable = new rxjs_Observable.Observable(function (observer) {
	            var stableSub = _this._zone.onStable.subscribe(function () {
	                NgZone.assertNotInAngularZone();
	                // Check whether there are no pending macro/micro tasks in the next tick
	                // to allow for NgZone to update the state.
	                scheduleMicroTask(function () {
	                    if (!_this._stable && !_this._zone.hasPendingMacrotasks &&
	                        !_this._zone.hasPendingMicrotasks) {
	                        _this._stable = true;
	                        observer.next(true);
	                    }
	                });
	            });
	            var unstableSub = _this._zone.onUnstable.subscribe(function () {
	                NgZone.assertInAngularZone();
	                if (_this._stable) {
	                    _this._stable = false;
	                    _this._zone.runOutsideAngular(function () { observer.next(false); });
	                }
	            });
	            return function () {
	                stableSub.unsubscribe();
	                unstableSub.unsubscribe();
	            };
	        });
	        _this._isStable = rxjs_observable_merge.merge(isCurrentlyStable, rxjs_operator_share.share.call(isStable));
	        return _this;
	    }
	    /**
	     * @param {?} viewRef
	     * @return {?}
	     */
	    ApplicationRef_.prototype.attachView = function (viewRef) {
	        var /** @type {?} */ view = ((viewRef));
	        this._views.push(view);
	        view.attachToAppRef(this);
	    };
	    /**
	     * @param {?} viewRef
	     * @return {?}
	     */
	    ApplicationRef_.prototype.detachView = function (viewRef) {
	        var /** @type {?} */ view = ((viewRef));
	        remove(this._views, view);
	        view.detachFromAppRef();
	    };
	    /**
	     * @template C
	     * @param {?} componentOrFactory
	     * @param {?=} rootSelectorOrNode
	     * @return {?}
	     */
	    ApplicationRef_.prototype.bootstrap = function (componentOrFactory, rootSelectorOrNode) {
	        var _this = this;
	        if (!this._initStatus.done) {
	            throw new Error('Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.');
	        }
	        var /** @type {?} */ componentFactory;
	        if (componentOrFactory instanceof ComponentFactory) {
	            componentFactory = componentOrFactory;
	        }
	        else {
	            componentFactory = ((this._componentFactoryResolver.resolveComponentFactory(componentOrFactory)));
	        }
	        this._rootComponentTypes.push(componentFactory.componentType);
	        // Create a factory associated with the current module if it's not bound to some other
	        var /** @type {?} */ ngModule = componentFactory instanceof ComponentFactoryBoundToModule ?
	            null :
	            this._injector.get(NgModuleRef);
	        var /** @type {?} */ selectorOrNode = rootSelectorOrNode || componentFactory.selector;
	        var /** @type {?} */ compRef = componentFactory.create(Injector.NULL, [], selectorOrNode, ngModule);
	        compRef.onDestroy(function () { _this._unloadComponent(compRef); });
	        var /** @type {?} */ testability = compRef.injector.get(Testability, null);
	        if (testability) {
	            compRef.injector.get(TestabilityRegistry)
	                .registerApplication(compRef.location.nativeElement, testability);
	        }
	        this._loadComponent(compRef);
	        if (isDevMode()) {
	            this._console.log("Angular is running in the development mode. Call enableProdMode() to enable the production mode.");
	        }
	        return compRef;
	    };
	    /**
	     * @param {?} componentRef
	     * @return {?}
	     */
	    ApplicationRef_.prototype._loadComponent = function (componentRef) {
	        this.attachView(componentRef.hostView);
	        this.tick();
	        this._rootComponents.push(componentRef);
	        // Get the listeners lazily to prevent DI cycles.
	        var /** @type {?} */ listeners = this._injector.get(APP_BOOTSTRAP_LISTENER, []).concat(this._bootstrapListeners);
	        listeners.forEach(function (listener) { return listener(componentRef); });
	    };
	    /**
	     * @param {?} componentRef
	     * @return {?}
	     */
	    ApplicationRef_.prototype._unloadComponent = function (componentRef) {
	        this.detachView(componentRef.hostView);
	        remove(this._rootComponents, componentRef);
	    };
	    /**
	     * @return {?}
	     */
	    ApplicationRef_.prototype.tick = function () {
	        var _this = this;
	        if (this._runningTick) {
	            throw new Error('ApplicationRef.tick is called recursively');
	        }
	        var /** @type {?} */ scope = ApplicationRef_._tickScope();
	        try {
	            this._runningTick = true;
	            this._views.forEach(function (view) { return view.detectChanges(); });
	            if (this._enforceNoNewChanges) {
	                this._views.forEach(function (view) { return view.checkNoChanges(); });
	            }
	        }
	        catch (e) {
	            // Attention: Don't rethrow as it could cancel subscriptions to Observables!
	            this._zone.runOutsideAngular(function () { return _this._exceptionHandler.handleError(e); });
	        }
	        finally {
	            this._runningTick = false;
	            wtfLeave(scope);
	        }
	    };
	    /**
	     * @return {?}
	     */
	    ApplicationRef_.prototype.ngOnDestroy = function () {
	        // TODO(alxhub): Dispose of the NgZone.
	        this._views.slice().forEach(function (view) { return view.destroy(); });
	    };
	    Object.defineProperty(ApplicationRef_.prototype, "viewCount", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._views.length; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ApplicationRef_.prototype, "componentTypes", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._rootComponentTypes; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ApplicationRef_.prototype, "components", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._rootComponents; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ApplicationRef_.prototype, "isStable", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._isStable; },
	        enumerable: true,
	        configurable: true
	    });
	    return ApplicationRef_;
	}(ApplicationRef));
	/**
	 * \@internal
	 */
	ApplicationRef_._tickScope = wtfCreateScope('ApplicationRef#tick()');
	ApplicationRef_.decorators = [
	    { type: Injectable },
	];
	/**
	 * @nocollapse
	 */
	ApplicationRef_.ctorParameters = function () { return [
	    { type: NgZone, },
	    { type: Console, },
	    { type: Injector, },
	    { type: ErrorHandler, },
	    { type: ComponentFactoryResolver, },
	    { type: ApplicationInitStatus, },
	]; };
	/**
	 * @template T
	 * @param {?} list
	 * @param {?} el
	 * @return {?}
	 */
	function remove(list, el) {
	    var /** @type {?} */ index = list.indexOf(el);
	    if (index > -1) {
	        list.splice(index, 1);
	    }
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	// Public API for Zone
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @deprecated Use `RendererType2` (and `Renderer2`) instead.
	 */
	var RenderComponentType = (function () {
	    /**
	     * @param {?} id
	     * @param {?} templateUrl
	     * @param {?} slotCount
	     * @param {?} encapsulation
	     * @param {?} styles
	     * @param {?} animations
	     */
	    function RenderComponentType(id, templateUrl, slotCount, encapsulation, styles, animations) {
	        this.id = id;
	        this.templateUrl = templateUrl;
	        this.slotCount = slotCount;
	        this.encapsulation = encapsulation;
	        this.styles = styles;
	        this.animations = animations;
	    }
	    return RenderComponentType;
	}());
	/**
	 * @deprecated Debug info is handeled internally in the view engine now.
	 * @abstract
	 */
	var RenderDebugInfo = (function () {
	    function RenderDebugInfo() {
	    }
	    /**
	     * @abstract
	     * @return {?}
	     */
	    RenderDebugInfo.prototype.injector = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    RenderDebugInfo.prototype.component = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    RenderDebugInfo.prototype.providerTokens = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    RenderDebugInfo.prototype.references = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    RenderDebugInfo.prototype.context = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    RenderDebugInfo.prototype.source = function () { };
	    return RenderDebugInfo;
	}());
	/**
	 * @deprecated Use the `Renderer2` instead.
	 * @abstract
	 */
	var Renderer = (function () {
	    function Renderer() {
	    }
	    /**
	     * @abstract
	     * @param {?} selectorOrNode
	     * @param {?=} debugInfo
	     * @return {?}
	     */
	    Renderer.prototype.selectRootElement = function (selectorOrNode, debugInfo) { };
	    /**
	     * @abstract
	     * @param {?} parentElement
	     * @param {?} name
	     * @param {?=} debugInfo
	     * @return {?}
	     */
	    Renderer.prototype.createElement = function (parentElement, name, debugInfo) { };
	    /**
	     * @abstract
	     * @param {?} hostElement
	     * @return {?}
	     */
	    Renderer.prototype.createViewRoot = function (hostElement) { };
	    /**
	     * @abstract
	     * @param {?} parentElement
	     * @param {?=} debugInfo
	     * @return {?}
	     */
	    Renderer.prototype.createTemplateAnchor = function (parentElement, debugInfo) { };
	    /**
	     * @abstract
	     * @param {?} parentElement
	     * @param {?} value
	     * @param {?=} debugInfo
	     * @return {?}
	     */
	    Renderer.prototype.createText = function (parentElement, value, debugInfo) { };
	    /**
	     * @abstract
	     * @param {?} parentElement
	     * @param {?} nodes
	     * @return {?}
	     */
	    Renderer.prototype.projectNodes = function (parentElement, nodes) { };
	    /**
	     * @abstract
	     * @param {?} node
	     * @param {?} viewRootNodes
	     * @return {?}
	     */
	    Renderer.prototype.attachViewAfter = function (node, viewRootNodes) { };
	    /**
	     * @abstract
	     * @param {?} viewRootNodes
	     * @return {?}
	     */
	    Renderer.prototype.detachView = function (viewRootNodes) { };
	    /**
	     * @abstract
	     * @param {?} hostElement
	     * @param {?} viewAllNodes
	     * @return {?}
	     */
	    Renderer.prototype.destroyView = function (hostElement, viewAllNodes) { };
	    /**
	     * @abstract
	     * @param {?} renderElement
	     * @param {?} name
	     * @param {?} callback
	     * @return {?}
	     */
	    Renderer.prototype.listen = function (renderElement, name, callback) { };
	    /**
	     * @abstract
	     * @param {?} target
	     * @param {?} name
	     * @param {?} callback
	     * @return {?}
	     */
	    Renderer.prototype.listenGlobal = function (target, name, callback) { };
	    /**
	     * @abstract
	     * @param {?} renderElement
	     * @param {?} propertyName
	     * @param {?} propertyValue
	     * @return {?}
	     */
	    Renderer.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) { };
	    /**
	     * @abstract
	     * @param {?} renderElement
	     * @param {?} attributeName
	     * @param {?} attributeValue
	     * @return {?}
	     */
	    Renderer.prototype.setElementAttribute = function (renderElement, attributeName, attributeValue) { };
	    /**
	     * Used only in debug mode to serialize property changes to dom nodes as attributes.
	     * @abstract
	     * @param {?} renderElement
	     * @param {?} propertyName
	     * @param {?} propertyValue
	     * @return {?}
	     */
	    Renderer.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) { };
	    /**
	     * @abstract
	     * @param {?} renderElement
	     * @param {?} className
	     * @param {?} isAdd
	     * @return {?}
	     */
	    Renderer.prototype.setElementClass = function (renderElement, className, isAdd) { };
	    /**
	     * @abstract
	     * @param {?} renderElement
	     * @param {?} styleName
	     * @param {?} styleValue
	     * @return {?}
	     */
	    Renderer.prototype.setElementStyle = function (renderElement, styleName, styleValue) { };
	    /**
	     * @abstract
	     * @param {?} renderElement
	     * @param {?} methodName
	     * @param {?=} args
	     * @return {?}
	     */
	    Renderer.prototype.invokeElementMethod = function (renderElement, methodName, args) { };
	    /**
	     * @abstract
	     * @param {?} renderNode
	     * @param {?} text
	     * @return {?}
	     */
	    Renderer.prototype.setText = function (renderNode, text) { };
	    /**
	     * @abstract
	     * @param {?} element
	     * @param {?} startingStyles
	     * @param {?} keyframes
	     * @param {?} duration
	     * @param {?} delay
	     * @param {?} easing
	     * @param {?=} previousPlayers
	     * @return {?}
	     */
	    Renderer.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing, previousPlayers) { };
	    return Renderer;
	}());
	var Renderer2Interceptor = new InjectionToken('Renderer2Interceptor');
	/**
	 * Injectable service that provides a low-level interface for modifying the UI.
	 *
	 * Use this service to bypass Angular's templating and make custom UI changes that can't be
	 * expressed declaratively. For example if you need to set a property or an attribute whose name is
	 * not statically known, use {\@link Renderer#setElementProperty} or {\@link
	 * Renderer#setElementAttribute}
	 * respectively.
	 *
	 * If you are implementing a custom renderer, you must implement this interface.
	 *
	 * The default Renderer implementation is `DomRenderer`. Also available is `WebWorkerRenderer`.
	 *
	 * @deprecated Use `RendererFactory2` instead.
	 * @abstract
	 */
	var RootRenderer = (function () {
	    function RootRenderer() {
	    }
	    /**
	     * @abstract
	     * @param {?} componentType
	     * @return {?}
	     */
	    RootRenderer.prototype.renderComponent = function (componentType) { };
	    return RootRenderer;
	}());
	/**
	 * \@experimental
	 * @abstract
	 */
	var RendererFactory2 = (function () {
	    function RendererFactory2() {
	    }
	    /**
	     * @abstract
	     * @param {?} hostElement
	     * @param {?} type
	     * @return {?}
	     */
	    RendererFactory2.prototype.createRenderer = function (hostElement, type) { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    RendererFactory2.prototype.begin = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    RendererFactory2.prototype.end = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    RendererFactory2.prototype.whenRenderingDone = function () { };
	    return RendererFactory2;
	}());
	var RendererStyleFlags2 = {};
	RendererStyleFlags2.Important = 1;
	RendererStyleFlags2.DashCase = 2;
	RendererStyleFlags2[RendererStyleFlags2.Important] = "Important";
	RendererStyleFlags2[RendererStyleFlags2.DashCase] = "DashCase";
	/**
	 * \@experimental
	 * @abstract
	 */
	var Renderer2 = (function () {
	    function Renderer2() {
	    }
	    /**
	     * This field can be used to store arbitrary data on this renderer instance.
	     * This is useful for renderers that delegate to other renderers.
	     * @abstract
	     * @return {?}
	     */
	    Renderer2.prototype.data = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    Renderer2.prototype.destroy = function () { };
	    /**
	     * @abstract
	     * @param {?} name
	     * @param {?=} namespace
	     * @return {?}
	     */
	    Renderer2.prototype.createElement = function (name, namespace) { };
	    /**
	     * @abstract
	     * @param {?} value
	     * @return {?}
	     */
	    Renderer2.prototype.createComment = function (value) { };
	    /**
	     * @abstract
	     * @param {?} value
	     * @return {?}
	     */
	    Renderer2.prototype.createText = function (value) { };
	    /**
	     * @abstract
	     * @param {?} parent
	     * @param {?} newChild
	     * @return {?}
	     */
	    Renderer2.prototype.appendChild = function (parent, newChild) { };
	    /**
	     * @abstract
	     * @param {?} parent
	     * @param {?} newChild
	     * @param {?} refChild
	     * @return {?}
	     */
	    Renderer2.prototype.insertBefore = function (parent, newChild, refChild) { };
	    /**
	     * @abstract
	     * @param {?} parent
	     * @param {?} oldChild
	     * @return {?}
	     */
	    Renderer2.prototype.removeChild = function (parent, oldChild) { };
	    /**
	     * @abstract
	     * @param {?} selectorOrNode
	     * @return {?}
	     */
	    Renderer2.prototype.selectRootElement = function (selectorOrNode) { };
	    /**
	     * Attention: On WebWorkers, this will always return a value,
	     * as we are asking for a result synchronously. I.e.
	     * the caller can't rely on checking whether this is null or not.
	     * @abstract
	     * @param {?} node
	     * @return {?}
	     */
	    Renderer2.prototype.parentNode = function (node) { };
	    /**
	     * Attention: On WebWorkers, this will always return a value,
	     * as we are asking for a result synchronously. I.e.
	     * the caller can't rely on checking whether this is null or not.
	     * @abstract
	     * @param {?} node
	     * @return {?}
	     */
	    Renderer2.prototype.nextSibling = function (node) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @param {?} name
	     * @param {?} value
	     * @param {?=} namespace
	     * @return {?}
	     */
	    Renderer2.prototype.setAttribute = function (el, name, value, namespace) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @param {?} name
	     * @param {?=} namespace
	     * @return {?}
	     */
	    Renderer2.prototype.removeAttribute = function (el, name, namespace) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @param {?} name
	     * @return {?}
	     */
	    Renderer2.prototype.addClass = function (el, name) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @param {?} name
	     * @return {?}
	     */
	    Renderer2.prototype.removeClass = function (el, name) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @param {?} style
	     * @param {?} value
	     * @param {?=} flags
	     * @return {?}
	     */
	    Renderer2.prototype.setStyle = function (el, style, value, flags) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @param {?} style
	     * @param {?=} flags
	     * @return {?}
	     */
	    Renderer2.prototype.removeStyle = function (el, style, flags) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @param {?} name
	     * @param {?} value
	     * @return {?}
	     */
	    Renderer2.prototype.setProperty = function (el, name, value) { };
	    /**
	     * @abstract
	     * @param {?} node
	     * @param {?} value
	     * @return {?}
	     */
	    Renderer2.prototype.setValue = function (node, value) { };
	    /**
	     * @abstract
	     * @param {?} target
	     * @param {?} eventName
	     * @param {?} callback
	     * @return {?}
	     */
	    Renderer2.prototype.listen = function (target, eventName, callback) { };
	    return Renderer2;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	// Public API for render
	var ElementRef = (function () {
	    /**
	     * @param {?} nativeElement
	     */
	    function ElementRef(nativeElement) {
	        this.nativeElement = nativeElement;
	    }
	    return ElementRef;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Used to load ng module factories.
	 * \@stable
	 * @abstract
	 */
	var NgModuleFactoryLoader = (function () {
	    function NgModuleFactoryLoader() {
	    }
	    /**
	     * @abstract
	     * @param {?} path
	     * @return {?}
	     */
	    NgModuleFactoryLoader.prototype.load = function (path) { };
	    return NgModuleFactoryLoader;
	}());
	var moduleFactories = new Map();
	/**
	 * Registers a loaded module. Should only be called from generated NgModuleFactory code.
	 * \@experimental
	 * @param {?} id
	 * @param {?} factory
	 * @return {?}
	 */
	function registerModuleFactory(id, factory) {
	    var /** @type {?} */ existing = moduleFactories.get(id);
	    if (existing) {
	        throw new Error("Duplicate module registered for " + id + " - " + existing.moduleType.name + " vs " + factory.moduleType.name);
	    }
	    moduleFactories.set(id, factory);
	}
	/**
	 * @return {?}
	 */
	/**
	 * Returns the NgModuleFactory with the given id, if it exists and has been loaded.
	 * Factories for modules that do not specify an `id` cannot be retrieved. Throws if the module
	 * cannot be found.
	 * \@experimental
	 * @param {?} id
	 * @return {?}
	 */
	function getModuleFactory(id) {
	    var /** @type {?} */ factory = moduleFactories.get(id);
	    if (!factory)
	        throw new Error("No module with ID " + id + " loaded");
	    return factory;
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * An unmodifiable list of items that Angular keeps up to date when the state
	 * of the application changes.
	 *
	 * The type of object that {\@link ViewChildren}, {\@link ContentChildren}, and {\@link QueryList}
	 * provide.
	 *
	 * Implements an iterable interface, therefore it can be used in both ES6
	 * javascript `for (var i of items)` loops as well as in Angular templates with
	 * `*ngFor="let i of myList"`.
	 *
	 * Changes can be observed by subscribing to the changes `Observable`.
	 *
	 * NOTE: In the future this class will implement an `Observable` interface.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/RX8sJnQYl9FWuSCWme5z?p=preview))
	 * ```typescript
	 * \@Component({...})
	 * class Container {
	 *   \@ViewChildren(Item) items:QueryList<Item>;
	 * }
	 * ```
	 * \@stable
	 */
	var QueryList = (function () {
	    function QueryList() {
	        this._dirty = true;
	        this._results = [];
	        this._emitter = new EventEmitter();
	    }
	    Object.defineProperty(QueryList.prototype, "changes", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._emitter; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(QueryList.prototype, "length", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._results.length; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(QueryList.prototype, "first", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._results[0]; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(QueryList.prototype, "last", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._results[this.length - 1]; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * See
	     * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
	     * @template U
	     * @param {?} fn
	     * @return {?}
	     */
	    QueryList.prototype.map = function (fn) { return this._results.map(fn); };
	    /**
	     * See
	     * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
	     * @param {?} fn
	     * @return {?}
	     */
	    QueryList.prototype.filter = function (fn) {
	        return this._results.filter(fn);
	    };
	    /**
	     * See
	     * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)
	     * @param {?} fn
	     * @return {?}
	     */
	    QueryList.prototype.find = function (fn) {
	        return this._results.find(fn);
	    };
	    /**
	     * See
	     * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
	     * @template U
	     * @param {?} fn
	     * @param {?} init
	     * @return {?}
	     */
	    QueryList.prototype.reduce = function (fn, init) {
	        return this._results.reduce(fn, init);
	    };
	    /**
	     * See
	     * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
	     * @param {?} fn
	     * @return {?}
	     */
	    QueryList.prototype.forEach = function (fn) { this._results.forEach(fn); };
	    /**
	     * See
	     * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
	     * @param {?} fn
	     * @return {?}
	     */
	    QueryList.prototype.some = function (fn) {
	        return this._results.some(fn);
	    };
	    /**
	     * @return {?}
	     */
	    QueryList.prototype.toArray = function () { return this._results.slice(); };
	    /**
	     * @return {?}
	     */
	    QueryList.prototype[getSymbolIterator()] = function () { return ((this._results))[getSymbolIterator()](); };
	    /**
	     * @return {?}
	     */
	    QueryList.prototype.toString = function () { return this._results.toString(); };
	    /**
	     * @param {?} res
	     * @return {?}
	     */
	    QueryList.prototype.reset = function (res) {
	        this._results = flatten(res);
	        this._dirty = false;
	    };
	    /**
	     * @return {?}
	     */
	    QueryList.prototype.notifyOnChanges = function () { this._emitter.emit(this); };
	    /**
	     * internal
	     * @return {?}
	     */
	    QueryList.prototype.setDirty = function () { this._dirty = true; };
	    Object.defineProperty(QueryList.prototype, "dirty", {
	        /**
	         * internal
	         * @return {?}
	         */
	        get: function () { return this._dirty; },
	        enumerable: true,
	        configurable: true
	    });
	    return QueryList;
	}());
	/**
	 * @template T
	 * @param {?} list
	 * @return {?}
	 */
	function flatten(list) {
	    return list.reduce(function (flat, item) {
	        var /** @type {?} */ flatItem = Array.isArray(item) ? flatten(item) : item;
	        return ((flat)).concat(flatItem);
	    }, []);
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var _SEPARATOR = '#';
	var FACTORY_CLASS_SUFFIX = 'NgFactory';
	/**
	 * Configuration for SystemJsNgModuleLoader.
	 * token.
	 *
	 * \@experimental
	 * @abstract
	 */
	var SystemJsNgModuleLoaderConfig = (function () {
	    function SystemJsNgModuleLoaderConfig() {
	    }
	    return SystemJsNgModuleLoaderConfig;
	}());
	var DEFAULT_CONFIG = {
	    factoryPathPrefix: '',
	    factoryPathSuffix: '.ngfactory',
	};
	/**
	 * NgModuleFactoryLoader that uses SystemJS to load NgModuleFactory
	 * \@experimental
	 */
	var SystemJsNgModuleLoader = (function () {
	    /**
	     * @param {?} _compiler
	     * @param {?=} config
	     */
	    function SystemJsNgModuleLoader(_compiler, config) {
	        this._compiler = _compiler;
	        this._config = config || DEFAULT_CONFIG;
	    }
	    /**
	     * @param {?} path
	     * @return {?}
	     */
	    SystemJsNgModuleLoader.prototype.load = function (path) {
	        var /** @type {?} */ offlineMode = this._compiler instanceof Compiler;
	        return offlineMode ? this.loadFactory(path) : this.loadAndCompile(path);
	    };
	    /**
	     * @param {?} path
	     * @return {?}
	     */
	    SystemJsNgModuleLoader.prototype.loadAndCompile = function (path) {
	        var _this = this;
	        var _a = path.split(_SEPARATOR), module = _a[0], exportName = _a[1];
	        if (exportName === undefined) {
	            exportName = 'default';
	        }
	        return System.import(module)
	            .then(function (module) { return module[exportName]; })
	            .then(function (type) { return checkNotEmpty(type, module, exportName); })
	            .then(function (type) { return _this._compiler.compileModuleAsync(type); });
	    };
	    /**
	     * @param {?} path
	     * @return {?}
	     */
	    SystemJsNgModuleLoader.prototype.loadFactory = function (path) {
	        var _a = path.split(_SEPARATOR), module = _a[0], exportName = _a[1];
	        var /** @type {?} */ factoryClassSuffix = FACTORY_CLASS_SUFFIX;
	        if (exportName === undefined) {
	            exportName = 'default';
	            factoryClassSuffix = '';
	        }
	        return System.import(this._config.factoryPathPrefix + module + this._config.factoryPathSuffix)
	            .then(function (module) { return module[exportName + factoryClassSuffix]; })
	            .then(function (factory) { return checkNotEmpty(factory, module, exportName); });
	    };
	    return SystemJsNgModuleLoader;
	}());
	SystemJsNgModuleLoader.decorators = [
	    { type: Injectable },
	];
	/**
	 * @nocollapse
	 */
	SystemJsNgModuleLoader.ctorParameters = function () { return [
	    { type: Compiler, },
	    { type: SystemJsNgModuleLoaderConfig, decorators: [{ type: Optional },] },
	]; };
	/**
	 * @param {?} value
	 * @param {?} modulePath
	 * @param {?} exportName
	 * @return {?}
	 */
	function checkNotEmpty(value, modulePath, exportName) {
	    if (!value) {
	        throw new Error("Cannot find '" + exportName + "' in '" + modulePath + "'");
	    }
	    return value;
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Represents an Embedded Template that can be used to instantiate Embedded Views.
	 *
	 * You can access a `TemplateRef`, in two ways. Via a directive placed on a `<ng-template>` element
	 * (or directive prefixed with `*`) and have the `TemplateRef` for this Embedded View injected into
	 * the constructor of the directive using the `TemplateRef` Token. Alternatively you can query for
	 * the `TemplateRef` from a Component or a Directive via {\@link Query}.
	 *
	 * To instantiate Embedded Views based on a Template, use
	 * {\@link ViewContainerRef#createEmbeddedView}, which will create the View and attach it to the
	 * View Container.
	 * \@stable
	 * @abstract
	 */
	var TemplateRef = (function () {
	    function TemplateRef() {
	    }
	    /**
	     * @abstract
	     * @return {?}
	     */
	    TemplateRef.prototype.elementRef = function () { };
	    /**
	     * @abstract
	     * @param {?} context
	     * @return {?}
	     */
	    TemplateRef.prototype.createEmbeddedView = function (context) { };
	    return TemplateRef;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Represents a container where one or more Views can be attached.
	 *
	 * The container can contain two kinds of Views. Host Views, created by instantiating a
	 * {\@link Component} via {\@link #createComponent}, and Embedded Views, created by instantiating an
	 * {\@link TemplateRef Embedded Template} via {\@link #createEmbeddedView}.
	 *
	 * The location of the View Container within the containing View is specified by the Anchor
	 * `element`. Each View Container can have only one Anchor Element and each Anchor Element can only
	 * have a single View Container.
	 *
	 * Root elements of Views attached to this container become siblings of the Anchor Element in
	 * the Rendered View.
	 *
	 * To access a `ViewContainerRef` of an Element, you can either place a {\@link Directive} injected
	 * with `ViewContainerRef` on the Element, or you obtain it via a {\@link ViewChild} query.
	 * \@stable
	 * @abstract
	 */
	var ViewContainerRef = (function () {
	    function ViewContainerRef() {
	    }
	    /**
	     * Anchor element that specifies the location of this container in the containing View.
	     * <!-- TODO: rename to anchorElement -->
	     * @abstract
	     * @return {?}
	     */
	    ViewContainerRef.prototype.element = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    ViewContainerRef.prototype.injector = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    ViewContainerRef.prototype.parentInjector = function () { };
	    /**
	     * Destroys all Views in this container.
	     * @abstract
	     * @return {?}
	     */
	    ViewContainerRef.prototype.clear = function () { };
	    /**
	     * Returns the {\@link ViewRef} for the View located in this container at the specified index.
	     * @abstract
	     * @param {?} index
	     * @return {?}
	     */
	    ViewContainerRef.prototype.get = function (index) { };
	    /**
	     * Returns the number of Views currently attached to this container.
	     * @abstract
	     * @return {?}
	     */
	    ViewContainerRef.prototype.length = function () { };
	    /**
	     * Instantiates an Embedded View based on the {\@link TemplateRef `templateRef`} and inserts it
	     * into this container at the specified `index`.
	     *
	     * If `index` is not specified, the new View will be inserted as the last View in the container.
	     *
	     * Returns the {\@link ViewRef} for the newly created View.
	     * @abstract
	     * @template C
	     * @param {?} templateRef
	     * @param {?=} context
	     * @param {?=} index
	     * @return {?}
	     */
	    ViewContainerRef.prototype.createEmbeddedView = function (templateRef, context, index) { };
	    /**
	     * Instantiates a single {\@link Component} and inserts its Host View into this container at the
	     * specified `index`.
	     *
	     * The component is instantiated using its {\@link ComponentFactory} which can be
	     * obtained via {\@link ComponentFactoryResolver#resolveComponentFactory}.
	     *
	     * If `index` is not specified, the new View will be inserted as the last View in the container.
	     *
	     * You can optionally specify the {\@link Injector} that will be used as parent for the Component.
	     *
	     * Returns the {\@link ComponentRef} of the Host View created for the newly instantiated Component.
	     * @abstract
	     * @template C
	     * @param {?} componentFactory
	     * @param {?=} index
	     * @param {?=} injector
	     * @param {?=} projectableNodes
	     * @param {?=} ngModule
	     * @return {?}
	     */
	    ViewContainerRef.prototype.createComponent = function (componentFactory, index, injector, projectableNodes, ngModule) { };
	    /**
	     * Inserts a View identified by a {\@link ViewRef} into the container at the specified `index`.
	     *
	     * If `index` is not specified, the new View will be inserted as the last View in the container.
	     *
	     * Returns the inserted {\@link ViewRef}.
	     * @abstract
	     * @param {?} viewRef
	     * @param {?=} index
	     * @return {?}
	     */
	    ViewContainerRef.prototype.insert = function (viewRef, index) { };
	    /**
	     * Moves a View identified by a {\@link ViewRef} into the container at the specified `index`.
	     *
	     * Returns the inserted {\@link ViewRef}.
	     * @abstract
	     * @param {?} viewRef
	     * @param {?} currentIndex
	     * @return {?}
	     */
	    ViewContainerRef.prototype.move = function (viewRef, currentIndex) { };
	    /**
	     * Returns the index of the View, specified via {\@link ViewRef}, within the current container or
	     * `-1` if this container doesn't contain the View.
	     * @abstract
	     * @param {?} viewRef
	     * @return {?}
	     */
	    ViewContainerRef.prototype.indexOf = function (viewRef) { };
	    /**
	     * Destroys a View attached to this container at the specified `index`.
	     *
	     * If `index` is not specified, the last View in the container will be removed.
	     * @abstract
	     * @param {?=} index
	     * @return {?}
	     */
	    ViewContainerRef.prototype.remove = function (index) { };
	    /**
	     * Use along with {\@link #insert} to move a View within the current container.
	     *
	     * If the `index` param is omitted, the last {\@link ViewRef} is detached.
	     * @abstract
	     * @param {?=} index
	     * @return {?}
	     */
	    ViewContainerRef.prototype.detach = function (index) { };
	    return ViewContainerRef;
	}());
	/**
	 * \@stable
	 * @abstract
	 */
	var ChangeDetectorRef = (function () {
	    function ChangeDetectorRef() {
	    }
	    /**
	     * Marks all {\@link ChangeDetectionStrategy#OnPush} ancestors as to be checked.
	     *
	     * <!-- TODO: Add a link to a chapter on OnPush components -->
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/GC512b?p=preview))
	     *
	     * ```typescript
	     * \@Component({
	     *   selector: 'cmp',
	     *   changeDetection: ChangeDetectionStrategy.OnPush,
	     *   template: `Number of ticks: {{numberOfTicks}}`
	     * })
	     * class Cmp {
	     *   numberOfTicks = 0;
	     *
	     *   constructor(private ref: ChangeDetectorRef) {
	     *     setInterval(() => {
	     *       this.numberOfTicks ++
	     *       // the following is required, otherwise the view will not be updated
	     *       this.ref.markForCheck();
	     *     }, 1000);
	     *   }
	     * }
	     *
	     * \@Component({
	     *   selector: 'app',
	     *   changeDetection: ChangeDetectionStrategy.OnPush,
	     *   template: `
	     *     <cmp><cmp>
	     *   `,
	     * })
	     * class App {
	     * }
	     * ```
	     * @abstract
	     * @return {?}
	     */
	    ChangeDetectorRef.prototype.markForCheck = function () { };
	    /**
	     * Detaches the change detector from the change detector tree.
	     *
	     * The detached change detector will not be checked until it is reattached.
	     *
	     * This can also be used in combination with {\@link ChangeDetectorRef#detectChanges} to implement
	     * local change
	     * detection checks.
	     *
	     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
	     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
	     *
	     * ### Example
	     *
	     * The following example defines a component with a large list of readonly data.
	     * Imagine the data changes constantly, many times per second. For performance reasons,
	     * we want to check and update the list every five seconds. We can do that by detaching
	     * the component's change detector and doing a local check every five seconds.
	     *
	     * ```typescript
	     * class DataProvider {
	     *   // in a real application the returned data will be different every time
	     *   get data() {
	     *     return [1,2,3,4,5];
	     *   }
	     * }
	     *
	     * \@Component({
	     *   selector: 'giant-list',
	     *   template: `
	     *     <li *ngFor="let d of dataProvider.data">Data {{d}}</lig>
	     *   `,
	     * })
	     * class GiantList {
	     *   constructor(private ref: ChangeDetectorRef, private dataProvider:DataProvider) {
	     *     ref.detach();
	     *     setInterval(() => {
	     *       this.ref.detectChanges();
	     *     }, 5000);
	     *   }
	     * }
	     *
	     * \@Component({
	     *   selector: 'app',
	     *   providers: [DataProvider],
	     *   template: `
	     *     <giant-list><giant-list>
	     *   `,
	     * })
	     * class App {
	     * }
	     * ```
	     * @abstract
	     * @return {?}
	     */
	    ChangeDetectorRef.prototype.detach = function () { };
	    /**
	     * Checks the change detector and its children.
	     *
	     * This can also be used in combination with {\@link ChangeDetectorRef#detach} to implement local
	     * change detection
	     * checks.
	     *
	     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
	     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
	     *
	     * ### Example
	     *
	     * The following example defines a component with a large list of readonly data.
	     * Imagine, the data changes constantly, many times per second. For performance reasons,
	     * we want to check and update the list every five seconds.
	     *
	     * We can do that by detaching the component's change detector and doing a local change detection
	     * check
	     * every five seconds.
	     *
	     * See {\@link ChangeDetectorRef#detach} for more information.
	     * @abstract
	     * @return {?}
	     */
	    ChangeDetectorRef.prototype.detectChanges = function () { };
	    /**
	     * Checks the change detector and its children, and throws if any changes are detected.
	     *
	     * This is used in development mode to verify that running change detection doesn't introduce
	     * other changes.
	     * @abstract
	     * @return {?}
	     */
	    ChangeDetectorRef.prototype.checkNoChanges = function () { };
	    /**
	     * Reattach the change detector to the change detector tree.
	     *
	     * This also marks OnPush ancestors as to be checked. This reattached change detector will be
	     * checked during the next change detection run.
	     *
	     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/aUhZha?p=preview))
	     *
	     * The following example creates a component displaying `live` data. The component will detach
	     * its change detector from the main change detector tree when the component's live property
	     * is set to false.
	     *
	     * ```typescript
	     * class DataProvider {
	     *   data = 1;
	     *
	     *   constructor() {
	     *     setInterval(() => {
	     *       this.data = this.data * 2;
	     *     }, 500);
	     *   }
	     * }
	     *
	     * \@Component({
	     *   selector: 'live-data',
	     *   inputs: ['live'],
	     *   template: 'Data: {{dataProvider.data}}'
	     * })
	     * class LiveData {
	     *   constructor(private ref: ChangeDetectorRef, private dataProvider:DataProvider) {}
	     *
	     *   set live(value) {
	     *     if (value)
	     *       this.ref.reattach();
	     *     else
	     *       this.ref.detach();
	     *   }
	     * }
	     *
	     * \@Component({
	     *   selector: 'app',
	     *   providers: [DataProvider],
	     *   template: `
	     *     Live Update: <input type="checkbox" [(ngModel)]="live">
	     *     <live-data [live]="live"><live-data>
	     *   `,
	     * })
	     * class App {
	     *   live = true;
	     * }
	     * ```
	     * @abstract
	     * @return {?}
	     */
	    ChangeDetectorRef.prototype.reattach = function () { };
	    return ChangeDetectorRef;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@stable
	 * @abstract
	 */
	var ViewRef = (function (_super) {
	    __extends(ViewRef, _super);
	    function ViewRef() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    /**
	     * Destroys the view and all of the data structures associated with it.
	     * @abstract
	     * @return {?}
	     */
	    ViewRef.prototype.destroy = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    ViewRef.prototype.destroyed = function () { };
	    /**
	     * @abstract
	     * @param {?} callback
	     * @return {?}
	     */
	    ViewRef.prototype.onDestroy = function (callback) { };
	    return ViewRef;
	}(ChangeDetectorRef));
	/**
	 * Represents an Angular View.
	 *
	 * <!-- TODO: move the next two paragraphs to the dev guide -->
	 * A View is a fundamental building block of the application UI. It is the smallest grouping of
	 * Elements which are created and destroyed together.
	 *
	 * Properties of elements in a View can change, but the structure (number and order) of elements in
	 * a View cannot. Changing the structure of Elements can only be done by inserting, moving or
	 * removing nested Views via a {\@link ViewContainerRef}. Each View can contain many View Containers.
	 * <!-- /TODO -->
	 *
	 * ### Example
	 *
	 * Given this template...
	 *
	 * ```
	 * Count: {{items.length}}
	 * <ul>
	 *   <li *ngFor="let  item of items">{{item}}</li>
	 * </ul>
	 * ```
	 *
	 * We have two {\@link TemplateRef}s:
	 *
	 * Outer {\@link TemplateRef}:
	 * ```
	 * Count: {{items.length}}
	 * <ul>
	 *   <ng-template ngFor let-item [ngForOf]="items"></ng-template>
	 * </ul>
	 * ```
	 *
	 * Inner {\@link TemplateRef}:
	 * ```
	 *   <li>{{item}}</li>
	 * ```
	 *
	 * Notice that the original template is broken down into two separate {\@link TemplateRef}s.
	 *
	 * The outer/inner {\@link TemplateRef}s are then assembled into views like so:
	 *
	 * ```
	 * <!-- ViewRef: outer-0 -->
	 * Count: 2
	 * <ul>
	 *   <ng-template view-container-ref></ng-template>
	 *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->
	 *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->
	 * </ul>
	 * <!-- /ViewRef: outer-0 -->
	 * ```
	 * \@experimental
	 * @abstract
	 */
	var EmbeddedViewRef = (function (_super) {
	    __extends(EmbeddedViewRef, _super);
	    function EmbeddedViewRef() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    /**
	     * @abstract
	     * @return {?}
	     */
	    EmbeddedViewRef.prototype.context = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    EmbeddedViewRef.prototype.rootNodes = function () { };
	    return EmbeddedViewRef;
	}(ViewRef));
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	// Public API for compiler
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var EventListener = (function () {
	    /**
	     * @param {?} name
	     * @param {?} callback
	     */
	    function EventListener(name, callback) {
	        this.name = name;
	        this.callback = callback;
	    }
	    
	    return EventListener;
	}());
	/**
	 * \@experimental All debugging apis are currently experimental.
	 */
	var DebugNode = (function () {
	    /**
	     * @param {?} nativeNode
	     * @param {?} parent
	     * @param {?} _debugContext
	     */
	    function DebugNode(nativeNode, parent, _debugContext) {
	        this._debugContext = _debugContext;
	        this.nativeNode = nativeNode;
	        if (parent && parent instanceof DebugElement) {
	            parent.addChild(this);
	        }
	        else {
	            this.parent = null;
	        }
	        this.listeners = [];
	    }
	    Object.defineProperty(DebugNode.prototype, "injector", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._debugContext.injector; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugNode.prototype, "componentInstance", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._debugContext.component; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugNode.prototype, "context", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._debugContext.context; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugNode.prototype, "references", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._debugContext.references; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugNode.prototype, "providerTokens", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._debugContext.providerTokens; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugNode.prototype, "source", {
	        /**
	         * @deprecated since v4
	         * @return {?}
	         */
	        get: function () { return 'Deprecated since v4'; },
	        enumerable: true,
	        configurable: true
	    });
	    return DebugNode;
	}());
	/**
	 * \@experimental All debugging apis are currently experimental.
	 */
	var DebugElement = (function (_super) {
	    __extends(DebugElement, _super);
	    /**
	     * @param {?} nativeNode
	     * @param {?} parent
	     * @param {?} _debugContext
	     */
	    function DebugElement(nativeNode, parent, _debugContext) {
	        var _this = _super.call(this, nativeNode, parent, _debugContext) || this;
	        _this.properties = {};
	        _this.attributes = {};
	        _this.classes = {};
	        _this.styles = {};
	        _this.childNodes = [];
	        _this.nativeElement = nativeNode;
	        return _this;
	    }
	    /**
	     * @param {?} child
	     * @return {?}
	     */
	    DebugElement.prototype.addChild = function (child) {
	        if (child) {
	            this.childNodes.push(child);
	            child.parent = this;
	        }
	    };
	    /**
	     * @param {?} child
	     * @return {?}
	     */
	    DebugElement.prototype.removeChild = function (child) {
	        var /** @type {?} */ childIndex = this.childNodes.indexOf(child);
	        if (childIndex !== -1) {
	            child.parent = null;
	            this.childNodes.splice(childIndex, 1);
	        }
	    };
	    /**
	     * @param {?} child
	     * @param {?} newChildren
	     * @return {?}
	     */
	    DebugElement.prototype.insertChildrenAfter = function (child, newChildren) {
	        var _this = this;
	        var /** @type {?} */ siblingIndex = this.childNodes.indexOf(child);
	        if (siblingIndex !== -1) {
	            (_a = this.childNodes).splice.apply(_a, [siblingIndex + 1, 0].concat(newChildren));
	            newChildren.forEach(function (c) {
	                if (c.parent) {
	                    c.parent.removeChild(c);
	                }
	                c.parent = _this;
	            });
	        }
	        var _a;
	    };
	    /**
	     * @param {?} refChild
	     * @param {?} newChild
	     * @return {?}
	     */
	    DebugElement.prototype.insertBefore = function (refChild, newChild) {
	        var /** @type {?} */ refIndex = this.childNodes.indexOf(refChild);
	        if (refIndex === -1) {
	            this.addChild(newChild);
	        }
	        else {
	            if (newChild.parent) {
	                newChild.parent.removeChild(newChild);
	            }
	            newChild.parent = this;
	            this.childNodes.splice(refIndex, 0, newChild);
	        }
	    };
	    /**
	     * @param {?} predicate
	     * @return {?}
	     */
	    DebugElement.prototype.query = function (predicate) {
	        var /** @type {?} */ results = this.queryAll(predicate);
	        return results[0] || null;
	    };
	    /**
	     * @param {?} predicate
	     * @return {?}
	     */
	    DebugElement.prototype.queryAll = function (predicate) {
	        var /** @type {?} */ matches = [];
	        _queryElementChildren(this, predicate, matches);
	        return matches;
	    };
	    /**
	     * @param {?} predicate
	     * @return {?}
	     */
	    DebugElement.prototype.queryAllNodes = function (predicate) {
	        var /** @type {?} */ matches = [];
	        _queryNodeChildren(this, predicate, matches);
	        return matches;
	    };
	    Object.defineProperty(DebugElement.prototype, "children", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            return (this.childNodes.filter(function (node) { return node instanceof DebugElement; }));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @param {?} eventName
	     * @param {?} eventObj
	     * @return {?}
	     */
	    DebugElement.prototype.triggerEventHandler = function (eventName, eventObj) {
	        this.listeners.forEach(function (listener) {
	            if (listener.name == eventName) {
	                listener.callback(eventObj);
	            }
	        });
	    };
	    return DebugElement;
	}(DebugNode));
	/**
	 * \@experimental
	 * @param {?} debugEls
	 * @return {?}
	 */
	function asNativeElements(debugEls) {
	    return debugEls.map(function (el) { return el.nativeElement; });
	}
	/**
	 * @param {?} element
	 * @param {?} predicate
	 * @param {?} matches
	 * @return {?}
	 */
	function _queryElementChildren(element, predicate, matches) {
	    element.childNodes.forEach(function (node) {
	        if (node instanceof DebugElement) {
	            if (predicate(node)) {
	                matches.push(node);
	            }
	            _queryElementChildren(node, predicate, matches);
	        }
	    });
	}
	/**
	 * @param {?} parentNode
	 * @param {?} predicate
	 * @param {?} matches
	 * @return {?}
	 */
	function _queryNodeChildren(parentNode, predicate, matches) {
	    if (parentNode instanceof DebugElement) {
	        parentNode.childNodes.forEach(function (node) {
	            if (predicate(node)) {
	                matches.push(node);
	            }
	            if (node instanceof DebugElement) {
	                _queryNodeChildren(node, predicate, matches);
	            }
	        });
	    }
	}
	// Need to keep the nodes in a global Map so that multiple angular apps are supported.
	var _nativeNodeToDebugNode = new Map();
	/**
	 * \@experimental
	 * @param {?} nativeNode
	 * @return {?}
	 */
	function getDebugNode(nativeNode) {
	    return _nativeNodeToDebugNode.get(nativeNode) || null;
	}
	/**
	 * @return {?}
	 */
	/**
	 * @param {?} node
	 * @return {?}
	 */
	function indexDebugNode(node) {
	    _nativeNodeToDebugNode.set(node.nativeNode, node);
	}
	/**
	 * @param {?} node
	 * @return {?}
	 */
	function removeDebugNodeFromIndex(node) {
	    _nativeNodeToDebugNode.delete(node.nativeNode);
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} a
	 * @param {?} b
	 * @return {?}
	 */
	function devModeEqual(a, b) {
	    var /** @type {?} */ isListLikeIterableA = isListLikeIterable(a);
	    var /** @type {?} */ isListLikeIterableB = isListLikeIterable(b);
	    if (isListLikeIterableA && isListLikeIterableB) {
	        return areIterablesEqual(a, b, devModeEqual);
	    }
	    else {
	        var /** @type {?} */ isAObject = a && (typeof a === 'object' || typeof a === 'function');
	        var /** @type {?} */ isBObject = b && (typeof b === 'object' || typeof b === 'function');
	        if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {
	            return true;
	        }
	        else {
	            return looseIdentical(a, b);
	        }
	    }
	}
	/**
	 * Indicates that the result of a {\@link Pipe} transformation has changed even though the
	 * reference
	 * has not changed.
	 *
	 * The wrapped value will be unwrapped by change detection, and the unwrapped value will be stored.
	 *
	 * Example:
	 *
	 * ```
	 * if (this._latestValue === this._latestReturnedValue) {
	 *    return this._latestReturnedValue;
	 *  } else {
	 *    this._latestReturnedValue = this._latestValue;
	 *    return WrappedValue.wrap(this._latestValue); // this will force update
	 *  }
	 * ```
	 * \@stable
	 */
	var WrappedValue = (function () {
	    /**
	     * @param {?} wrapped
	     */
	    function WrappedValue(wrapped) {
	        this.wrapped = wrapped;
	    }
	    /**
	     * @param {?} value
	     * @return {?}
	     */
	    WrappedValue.wrap = function (value) { return new WrappedValue(value); };
	    return WrappedValue;
	}());
	/**
	 * Helper class for unwrapping WrappedValue s
	 */
	var ValueUnwrapper = (function () {
	    function ValueUnwrapper() {
	        this.hasWrappedValue = false;
	    }
	    /**
	     * @param {?} value
	     * @return {?}
	     */
	    ValueUnwrapper.prototype.unwrap = function (value) {
	        if (value instanceof WrappedValue) {
	            this.hasWrappedValue = true;
	            return value.wrapped;
	        }
	        return value;
	    };
	    /**
	     * @return {?}
	     */
	    ValueUnwrapper.prototype.reset = function () { this.hasWrappedValue = false; };
	    return ValueUnwrapper;
	}());
	/**
	 * Represents a basic change from a previous to a new value.
	 * \@stable
	 */
	var SimpleChange = (function () {
	    /**
	     * @param {?} previousValue
	     * @param {?} currentValue
	     * @param {?} firstChange
	     */
	    function SimpleChange(previousValue, currentValue, firstChange) {
	        this.previousValue = previousValue;
	        this.currentValue = currentValue;
	        this.firstChange = firstChange;
	    }
	    /**
	     * Check whether the new value is the first value assigned.
	     * @return {?}
	     */
	    SimpleChange.prototype.isFirstChange = function () { return this.firstChange; };
	    return SimpleChange;
	}());
	/**
	 * @param {?} obj
	 * @return {?}
	 */
	function isListLikeIterable(obj) {
	    if (!isJsObject(obj))
	        return false;
	    return Array.isArray(obj) ||
	        (!(obj instanceof Map) &&
	            getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop
	}
	/**
	 * @param {?} a
	 * @param {?} b
	 * @param {?} comparator
	 * @return {?}
	 */
	function areIterablesEqual(a, b, comparator) {
	    var /** @type {?} */ iterator1 = a[getSymbolIterator()]();
	    var /** @type {?} */ iterator2 = b[getSymbolIterator()]();
	    while (true) {
	        var /** @type {?} */ item1 = iterator1.next();
	        var /** @type {?} */ item2 = iterator2.next();
	        if (item1.done && item2.done)
	            return true;
	        if (item1.done || item2.done)
	            return false;
	        if (!comparator(item1.value, item2.value))
	            return false;
	    }
	}
	/**
	 * @param {?} obj
	 * @param {?} fn
	 * @return {?}
	 */
	function iterateListLike(obj, fn) {
	    if (Array.isArray(obj)) {
	        for (var /** @type {?} */ i = 0; i < obj.length; i++) {
	            fn(obj[i]);
	        }
	    }
	    else {
	        var /** @type {?} */ iterator = obj[getSymbolIterator()]();
	        var /** @type {?} */ item = void 0;
	        while (!((item = iterator.next()).done)) {
	            fn(item.value);
	        }
	    }
	}
	/**
	 * @param {?} o
	 * @return {?}
	 */
	function isJsObject(o) {
	    return o !== null && (typeof o === 'function' || typeof o === 'object');
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var DefaultIterableDifferFactory = (function () {
	    function DefaultIterableDifferFactory() {
	    }
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    DefaultIterableDifferFactory.prototype.supports = function (obj) { return isListLikeIterable(obj); };
	    /**
	     * @deprecated v4.0.0 - ChangeDetectorRef is not used and is no longer a parameter
	     * @template V
	     * @param {?=} cdRefOrTrackBy
	     * @param {?=} trackByFn
	     * @return {?}
	     */
	    DefaultIterableDifferFactory.prototype.create = function (cdRefOrTrackBy, trackByFn) {
	        return new DefaultIterableDiffer(trackByFn || (cdRefOrTrackBy));
	    };
	    return DefaultIterableDifferFactory;
	}());
	var trackByIdentity = function (index, item) { return item; };
	/**
	 * @deprecated v4.0.0 - Should not be part of public API.
	 */
	var DefaultIterableDiffer = (function () {
	    /**
	     * @param {?=} trackByFn
	     */
	    function DefaultIterableDiffer(trackByFn) {
	        this._length = 0;
	        this._collection = null;
	        this._linkedRecords = null;
	        this._unlinkedRecords = null;
	        this._previousItHead = null;
	        this._itHead = null;
	        this._itTail = null;
	        this._additionsHead = null;
	        this._additionsTail = null;
	        this._movesHead = null;
	        this._movesTail = null;
	        this._removalsHead = null;
	        this._removalsTail = null;
	        this._identityChangesHead = null;
	        this._identityChangesTail = null;
	        this._trackByFn = trackByFn || trackByIdentity;
	    }
	    Object.defineProperty(DefaultIterableDiffer.prototype, "collection", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._collection; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DefaultIterableDiffer.prototype, "length", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._length; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype.forEachItem = function (fn) {
	        var /** @type {?} */ record;
	        for (record = this._itHead; record !== null; record = record._next) {
	            fn(record);
	        }
	    };
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype.forEachOperation = function (fn) {
	        var /** @type {?} */ nextIt = this._itHead;
	        var /** @type {?} */ nextRemove = this._removalsHead;
	        var /** @type {?} */ addRemoveOffset = 0;
	        var /** @type {?} */ moveOffsets = null;
	        while (nextIt || nextRemove) {
	            // Figure out which is the next record to process
	            // Order: remove, add, move
	            var /** @type {?} */ record = !nextRemove ||
	                nextIt && ((nextIt.currentIndex)) <
	                    getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ? ((nextIt)) :
	                nextRemove;
	            var /** @type {?} */ adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
	            var /** @type {?} */ currentIndex = record.currentIndex;
	            // consume the item, and adjust the addRemoveOffset and update moveDistance if necessary
	            if (record === nextRemove) {
	                addRemoveOffset--;
	                nextRemove = nextRemove._nextRemoved;
	            }
	            else {
	                nextIt = ((nextIt))._next;
	                if (record.previousIndex == null) {
	                    addRemoveOffset++;
	                }
	                else {
	                    // INVARIANT:  currentIndex < previousIndex
	                    if (!moveOffsets)
	                        moveOffsets = [];
	                    var /** @type {?} */ localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
	                    var /** @type {?} */ localCurrentIndex = ((currentIndex)) - addRemoveOffset;
	                    if (localMovePreviousIndex != localCurrentIndex) {
	                        for (var /** @type {?} */ i = 0; i < localMovePreviousIndex; i++) {
	                            var /** @type {?} */ offset = i < moveOffsets.length ? moveOffsets[i] : (moveOffsets[i] = 0);
	                            var /** @type {?} */ index = offset + i;
	                            if (localCurrentIndex <= index && index < localMovePreviousIndex) {
	                                moveOffsets[i] = offset + 1;
	                            }
	                        }
	                        var /** @type {?} */ previousIndex = record.previousIndex;
	                        moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
	                    }
	                }
	            }
	            if (adjPreviousIndex !== currentIndex) {
	                fn(record, adjPreviousIndex, currentIndex);
	            }
	        }
	    };
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype.forEachPreviousItem = function (fn) {
	        var /** @type {?} */ record;
	        for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
	            fn(record);
	        }
	    };
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype.forEachAddedItem = function (fn) {
	        var /** @type {?} */ record;
	        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	            fn(record);
	        }
	    };
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype.forEachMovedItem = function (fn) {
	        var /** @type {?} */ record;
	        for (record = this._movesHead; record !== null; record = record._nextMoved) {
	            fn(record);
	        }
	    };
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype.forEachRemovedItem = function (fn) {
	        var /** @type {?} */ record;
	        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
	            fn(record);
	        }
	    };
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype.forEachIdentityChange = function (fn) {
	        var /** @type {?} */ record;
	        for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
	            fn(record);
	        }
	    };
	    /**
	     * @param {?} collection
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype.diff = function (collection) {
	        if (collection == null)
	            collection = [];
	        if (!isListLikeIterable(collection)) {
	            throw new Error("Error trying to diff '" + stringify(collection) + "'. Only arrays and iterables are allowed");
	        }
	        if (this.check(collection)) {
	            return this;
	        }
	        else {
	            return null;
	        }
	    };
	    /**
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype.onDestroy = function () { };
	    /**
	     * @param {?} collection
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype.check = function (collection) {
	        var _this = this;
	        this._reset();
	        var /** @type {?} */ record = this._itHead;
	        var /** @type {?} */ mayBeDirty = false;
	        var /** @type {?} */ index;
	        var /** @type {?} */ item;
	        var /** @type {?} */ itemTrackBy;
	        if (Array.isArray(collection)) {
	            this._length = collection.length;
	            for (var /** @type {?} */ index_1 = 0; index_1 < this._length; index_1++) {
	                item = collection[index_1];
	                itemTrackBy = this._trackByFn(index_1, item);
	                if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {
	                    record = this._mismatch(record, item, itemTrackBy, index_1);
	                    mayBeDirty = true;
	                }
	                else {
	                    if (mayBeDirty) {
	                        // TODO(misko): can we limit this to duplicates only?
	                        record = this._verifyReinsertion(record, item, itemTrackBy, index_1);
	                    }
	                    if (!looseIdentical(record.item, item))
	                        this._addIdentityChange(record, item);
	                }
	                record = record._next;
	            }
	        }
	        else {
	            index = 0;
	            iterateListLike(collection, function (item) {
	                itemTrackBy = _this._trackByFn(index, item);
	                if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {
	                    record = _this._mismatch(record, item, itemTrackBy, index);
	                    mayBeDirty = true;
	                }
	                else {
	                    if (mayBeDirty) {
	                        // TODO(misko): can we limit this to duplicates only?
	                        record = _this._verifyReinsertion(record, item, itemTrackBy, index);
	                    }
	                    if (!looseIdentical(record.item, item))
	                        _this._addIdentityChange(record, item);
	                }
	                record = record._next;
	                index++;
	            });
	            this._length = index;
	        }
	        this._truncate(record);
	        this._collection = collection;
	        return this.isDirty;
	    };
	    Object.defineProperty(DefaultIterableDiffer.prototype, "isDirty", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            return this._additionsHead !== null || this._movesHead !== null ||
	                this._removalsHead !== null || this._identityChangesHead !== null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Reset the state of the change objects to show no changes. This means set previousKey to
	     * currentKey, and clear all of the queues (additions, moves, removals).
	     * Set the previousIndexes of moved and added items to their currentIndexes
	     * Reset the list of additions, moves and removals
	     *
	     * \@internal
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype._reset = function () {
	        if (this.isDirty) {
	            var /** @type {?} */ record = void 0;
	            var /** @type {?} */ nextRecord = void 0;
	            for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
	                record._nextPrevious = record._next;
	            }
	            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	                record.previousIndex = record.currentIndex;
	            }
	            this._additionsHead = this._additionsTail = null;
	            for (record = this._movesHead; record !== null; record = nextRecord) {
	                record.previousIndex = record.currentIndex;
	                nextRecord = record._nextMoved;
	            }
	            this._movesHead = this._movesTail = null;
	            this._removalsHead = this._removalsTail = null;
	            this._identityChangesHead = this._identityChangesTail = null;
	            // todo(vicb) when assert gets supported
	            // assert(!this.isDirty);
	        }
	    };
	    /**
	     * This is the core function which handles differences between collections.
	     *
	     * - `record` is the record which we saw at this position last time. If null then it is a new
	     *   item.
	     * - `item` is the current item in the collection
	     * - `index` is the position of the item in the collection
	     *
	     * \@internal
	     * @param {?} record
	     * @param {?} item
	     * @param {?} itemTrackBy
	     * @param {?} index
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype._mismatch = function (record, item, itemTrackBy, index) {
	        // The previous record after which we will append the current one.
	        var /** @type {?} */ previousRecord;
	        if (record === null) {
	            previousRecord = this._itTail;
	        }
	        else {
	            previousRecord = record._prev;
	            // Remove the record from the collection since we know it does not match the item.
	            this._remove(record);
	        }
	        // Attempt to see if we have seen the item before.
	        record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
	        if (record !== null) {
	            // We have seen this before, we need to move it forward in the collection.
	            // But first we need to check if identity changed, so we can update in view if necessary
	            if (!looseIdentical(record.item, item))
	                this._addIdentityChange(record, item);
	            this._moveAfter(record, previousRecord, index);
	        }
	        else {
	            // Never seen it, check evicted list.
	            record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
	            if (record !== null) {
	                // It is an item which we have evicted earlier: reinsert it back into the list.
	                // But first we need to check if identity changed, so we can update in view if necessary
	                if (!looseIdentical(record.item, item))
	                    this._addIdentityChange(record, item);
	                this._reinsertAfter(record, previousRecord, index);
	            }
	            else {
	                // It is a new item: add it.
	                record =
	                    this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index);
	            }
	        }
	        return record;
	    };
	    /**
	     * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)
	     *
	     * Use case: `[a, a]` => `[b, a, a]`
	     *
	     * If we did not have this check then the insertion of `b` would:
	     *   1) evict first `a`
	     *   2) insert `b` at `0` index.
	     *   3) leave `a` at index `1` as is. <-- this is wrong!
	     *   3) reinsert `a` at index 2. <-- this is wrong!
	     *
	     * The correct behavior is:
	     *   1) evict first `a`
	     *   2) insert `b` at `0` index.
	     *   3) reinsert `a` at index 1.
	     *   3) move `a` at from `1` to `2`.
	     *
	     *
	     * Double check that we have not evicted a duplicate item. We need to check if the item type may
	     * have already been removed:
	     * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted
	     * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a
	     * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'
	     * at the end.
	     *
	     * \@internal
	     * @param {?} record
	     * @param {?} item
	     * @param {?} itemTrackBy
	     * @param {?} index
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype._verifyReinsertion = function (record, item, itemTrackBy, index) {
	        var /** @type {?} */ reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
	        if (reinsertRecord !== null) {
	            record = this._reinsertAfter(reinsertRecord, /** @type {?} */ ((record._prev)), index);
	        }
	        else if (record.currentIndex != index) {
	            record.currentIndex = index;
	            this._addToMoves(record, index);
	        }
	        return record;
	    };
	    /**
	     * Get rid of any excess {\@link IterableChangeRecord_}s from the previous collection
	     *
	     * - `record` The first excess {\@link IterableChangeRecord_}.
	     *
	     * \@internal
	     * @param {?} record
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype._truncate = function (record) {
	        // Anything after that needs to be removed;
	        while (record !== null) {
	            var /** @type {?} */ nextRecord = record._next;
	            this._addToRemovals(this._unlink(record));
	            record = nextRecord;
	        }
	        if (this._unlinkedRecords !== null) {
	            this._unlinkedRecords.clear();
	        }
	        if (this._additionsTail !== null) {
	            this._additionsTail._nextAdded = null;
	        }
	        if (this._movesTail !== null) {
	            this._movesTail._nextMoved = null;
	        }
	        if (this._itTail !== null) {
	            this._itTail._next = null;
	        }
	        if (this._removalsTail !== null) {
	            this._removalsTail._nextRemoved = null;
	        }
	        if (this._identityChangesTail !== null) {
	            this._identityChangesTail._nextIdentityChange = null;
	        }
	    };
	    /**
	     * \@internal
	     * @param {?} record
	     * @param {?} prevRecord
	     * @param {?} index
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype._reinsertAfter = function (record, prevRecord, index) {
	        if (this._unlinkedRecords !== null) {
	            this._unlinkedRecords.remove(record);
	        }
	        var /** @type {?} */ prev = record._prevRemoved;
	        var /** @type {?} */ next = record._nextRemoved;
	        if (prev === null) {
	            this._removalsHead = next;
	        }
	        else {
	            prev._nextRemoved = next;
	        }
	        if (next === null) {
	            this._removalsTail = prev;
	        }
	        else {
	            next._prevRemoved = prev;
	        }
	        this._insertAfter(record, prevRecord, index);
	        this._addToMoves(record, index);
	        return record;
	    };
	    /**
	     * \@internal
	     * @param {?} record
	     * @param {?} prevRecord
	     * @param {?} index
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype._moveAfter = function (record, prevRecord, index) {
	        this._unlink(record);
	        this._insertAfter(record, prevRecord, index);
	        this._addToMoves(record, index);
	        return record;
	    };
	    /**
	     * \@internal
	     * @param {?} record
	     * @param {?} prevRecord
	     * @param {?} index
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype._addAfter = function (record, prevRecord, index) {
	        this._insertAfter(record, prevRecord, index);
	        if (this._additionsTail === null) {
	            // todo(vicb)
	            // assert(this._additionsHead === null);
	            this._additionsTail = this._additionsHead = record;
	        }
	        else {
	            // todo(vicb)
	            // assert(_additionsTail._nextAdded === null);
	            // assert(record._nextAdded === null);
	            this._additionsTail = this._additionsTail._nextAdded = record;
	        }
	        return record;
	    };
	    /**
	     * \@internal
	     * @param {?} record
	     * @param {?} prevRecord
	     * @param {?} index
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype._insertAfter = function (record, prevRecord, index) {
	        // todo(vicb)
	        // assert(record != prevRecord);
	        // assert(record._next === null);
	        // assert(record._prev === null);
	        var /** @type {?} */ next = prevRecord === null ? this._itHead : prevRecord._next;
	        // todo(vicb)
	        // assert(next != record);
	        // assert(prevRecord != record);
	        record._next = next;
	        record._prev = prevRecord;
	        if (next === null) {
	            this._itTail = record;
	        }
	        else {
	            next._prev = record;
	        }
	        if (prevRecord === null) {
	            this._itHead = record;
	        }
	        else {
	            prevRecord._next = record;
	        }
	        if (this._linkedRecords === null) {
	            this._linkedRecords = new _DuplicateMap();
	        }
	        this._linkedRecords.put(record);
	        record.currentIndex = index;
	        return record;
	    };
	    /**
	     * \@internal
	     * @param {?} record
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype._remove = function (record) {
	        return this._addToRemovals(this._unlink(record));
	    };
	    /**
	     * \@internal
	     * @param {?} record
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype._unlink = function (record) {
	        if (this._linkedRecords !== null) {
	            this._linkedRecords.remove(record);
	        }
	        var /** @type {?} */ prev = record._prev;
	        var /** @type {?} */ next = record._next;
	        // todo(vicb)
	        // assert((record._prev = null) === null);
	        // assert((record._next = null) === null);
	        if (prev === null) {
	            this._itHead = next;
	        }
	        else {
	            prev._next = next;
	        }
	        if (next === null) {
	            this._itTail = prev;
	        }
	        else {
	            next._prev = prev;
	        }
	        return record;
	    };
	    /**
	     * \@internal
	     * @param {?} record
	     * @param {?} toIndex
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype._addToMoves = function (record, toIndex) {
	        // todo(vicb)
	        // assert(record._nextMoved === null);
	        if (record.previousIndex === toIndex) {
	            return record;
	        }
	        if (this._movesTail === null) {
	            // todo(vicb)
	            // assert(_movesHead === null);
	            this._movesTail = this._movesHead = record;
	        }
	        else {
	            // todo(vicb)
	            // assert(_movesTail._nextMoved === null);
	            this._movesTail = this._movesTail._nextMoved = record;
	        }
	        return record;
	    };
	    /**
	     * @param {?} record
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype._addToRemovals = function (record) {
	        if (this._unlinkedRecords === null) {
	            this._unlinkedRecords = new _DuplicateMap();
	        }
	        this._unlinkedRecords.put(record);
	        record.currentIndex = null;
	        record._nextRemoved = null;
	        if (this._removalsTail === null) {
	            // todo(vicb)
	            // assert(_removalsHead === null);
	            this._removalsTail = this._removalsHead = record;
	            record._prevRemoved = null;
	        }
	        else {
	            // todo(vicb)
	            // assert(_removalsTail._nextRemoved === null);
	            // assert(record._nextRemoved === null);
	            record._prevRemoved = this._removalsTail;
	            this._removalsTail = this._removalsTail._nextRemoved = record;
	        }
	        return record;
	    };
	    /**
	     * \@internal
	     * @param {?} record
	     * @param {?} item
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype._addIdentityChange = function (record, item) {
	        record.item = item;
	        if (this._identityChangesTail === null) {
	            this._identityChangesTail = this._identityChangesHead = record;
	        }
	        else {
	            this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
	        }
	        return record;
	    };
	    /**
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype.toString = function () {
	        var /** @type {?} */ list = [];
	        this.forEachItem(function (record) { return list.push(record); });
	        var /** @type {?} */ previous = [];
	        this.forEachPreviousItem(function (record) { return previous.push(record); });
	        var /** @type {?} */ additions = [];
	        this.forEachAddedItem(function (record) { return additions.push(record); });
	        var /** @type {?} */ moves = [];
	        this.forEachMovedItem(function (record) { return moves.push(record); });
	        var /** @type {?} */ removals = [];
	        this.forEachRemovedItem(function (record) { return removals.push(record); });
	        var /** @type {?} */ identityChanges = [];
	        this.forEachIdentityChange(function (record) { return identityChanges.push(record); });
	        return 'collection: ' + list.join(', ') + '\n' +
	            'previous: ' + previous.join(', ') + '\n' +
	            'additions: ' + additions.join(', ') + '\n' +
	            'moves: ' + moves.join(', ') + '\n' +
	            'removals: ' + removals.join(', ') + '\n' +
	            'identityChanges: ' + identityChanges.join(', ') + '\n';
	    };
	    return DefaultIterableDiffer;
	}());
	/**
	 * \@stable
	 */
	var IterableChangeRecord_ = (function () {
	    /**
	     * @param {?} item
	     * @param {?} trackById
	     */
	    function IterableChangeRecord_(item, trackById) {
	        this.item = item;
	        this.trackById = trackById;
	        this.currentIndex = null;
	        this.previousIndex = null;
	        /**
	         * \@internal
	         */
	        this._nextPrevious = null;
	        /**
	         * \@internal
	         */
	        this._prev = null;
	        /**
	         * \@internal
	         */
	        this._next = null;
	        /**
	         * \@internal
	         */
	        this._prevDup = null;
	        /**
	         * \@internal
	         */
	        this._nextDup = null;
	        /**
	         * \@internal
	         */
	        this._prevRemoved = null;
	        /**
	         * \@internal
	         */
	        this._nextRemoved = null;
	        /**
	         * \@internal
	         */
	        this._nextAdded = null;
	        /**
	         * \@internal
	         */
	        this._nextMoved = null;
	        /**
	         * \@internal
	         */
	        this._nextIdentityChange = null;
	    }
	    /**
	     * @return {?}
	     */
	    IterableChangeRecord_.prototype.toString = function () {
	        return this.previousIndex === this.currentIndex ? stringify(this.item) :
	            stringify(this.item) + '[' +
	                stringify(this.previousIndex) + '->' + stringify(this.currentIndex) + ']';
	    };
	    return IterableChangeRecord_;
	}());
	var _DuplicateItemRecordList = (function () {
	    function _DuplicateItemRecordList() {
	        /**
	         * \@internal
	         */
	        this._head = null;
	        /**
	         * \@internal
	         */
	        this._tail = null;
	    }
	    /**
	     * Append the record to the list of duplicates.
	     *
	     * Note: by design all records in the list of duplicates hold the same value in record.item.
	     * @param {?} record
	     * @return {?}
	     */
	    _DuplicateItemRecordList.prototype.add = function (record) {
	        if (this._head === null) {
	            this._head = this._tail = record;
	            record._nextDup = null;
	            record._prevDup = null;
	        }
	        else {
	            ((
	            // todo(vicb)
	            // assert(record.item ==  _head.item ||
	            //       record.item is num && record.item.isNaN && _head.item is num && _head.item.isNaN);
	            this._tail))._nextDup = record;
	            record._prevDup = this._tail;
	            record._nextDup = null;
	            this._tail = record;
	        }
	    };
	    /**
	     * @param {?} trackById
	     * @param {?} atOrAfterIndex
	     * @return {?}
	     */
	    _DuplicateItemRecordList.prototype.get = function (trackById, atOrAfterIndex) {
	        var /** @type {?} */ record;
	        for (record = this._head; record !== null; record = record._nextDup) {
	            if ((atOrAfterIndex === null || atOrAfterIndex <= ((record.currentIndex))) &&
	                looseIdentical(record.trackById, trackById)) {
	                return record;
	            }
	        }
	        return null;
	    };
	    /**
	     * Remove one {\@link IterableChangeRecord_} from the list of duplicates.
	     *
	     * Returns whether the list of duplicates is empty.
	     * @param {?} record
	     * @return {?}
	     */
	    _DuplicateItemRecordList.prototype.remove = function (record) {
	        // todo(vicb)
	        // assert(() {
	        //  // verify that the record being removed is in the list.
	        //  for (IterableChangeRecord_ cursor = _head; cursor != null; cursor = cursor._nextDup) {
	        //    if (identical(cursor, record)) return true;
	        //  }
	        //  return false;
	        //});
	        var /** @type {?} */ prev = record._prevDup;
	        var /** @type {?} */ next = record._nextDup;
	        if (prev === null) {
	            this._head = next;
	        }
	        else {
	            prev._nextDup = next;
	        }
	        if (next === null) {
	            this._tail = prev;
	        }
	        else {
	            next._prevDup = prev;
	        }
	        return this._head === null;
	    };
	    return _DuplicateItemRecordList;
	}());
	var _DuplicateMap = (function () {
	    function _DuplicateMap() {
	        this.map = new Map();
	    }
	    /**
	     * @param {?} record
	     * @return {?}
	     */
	    _DuplicateMap.prototype.put = function (record) {
	        var /** @type {?} */ key = record.trackById;
	        var /** @type {?} */ duplicates = this.map.get(key);
	        if (!duplicates) {
	            duplicates = new _DuplicateItemRecordList();
	            this.map.set(key, duplicates);
	        }
	        duplicates.add(record);
	    };
	    /**
	     * Retrieve the `value` using key. Because the IterableChangeRecord_ value may be one which we
	     * have already iterated over, we use the `atOrAfterIndex` to pretend it is not there.
	     *
	     * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we
	     * have any more `a`s needs to return the second `a`.
	     * @param {?} trackById
	     * @param {?} atOrAfterIndex
	     * @return {?}
	     */
	    _DuplicateMap.prototype.get = function (trackById, atOrAfterIndex) {
	        var /** @type {?} */ key = trackById;
	        var /** @type {?} */ recordList = this.map.get(key);
	        return recordList ? recordList.get(trackById, atOrAfterIndex) : null;
	    };
	    /**
	     * Removes a {\@link IterableChangeRecord_} from the list of duplicates.
	     *
	     * The list of duplicates also is removed from the map if it gets empty.
	     * @param {?} record
	     * @return {?}
	     */
	    _DuplicateMap.prototype.remove = function (record) {
	        var /** @type {?} */ key = record.trackById;
	        var /** @type {?} */ recordList = ((this.map.get(key)));
	        // Remove the list of duplicates when it gets empty
	        if (recordList.remove(record)) {
	            this.map.delete(key);
	        }
	        return record;
	    };
	    Object.defineProperty(_DuplicateMap.prototype, "isEmpty", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.map.size === 0; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @return {?}
	     */
	    _DuplicateMap.prototype.clear = function () { this.map.clear(); };
	    /**
	     * @return {?}
	     */
	    _DuplicateMap.prototype.toString = function () { return '_DuplicateMap(' + stringify(this.map) + ')'; };
	    return _DuplicateMap;
	}());
	/**
	 * @param {?} item
	 * @param {?} addRemoveOffset
	 * @param {?} moveOffsets
	 * @return {?}
	 */
	function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
	    var /** @type {?} */ previousIndex = item.previousIndex;
	    if (previousIndex === null)
	        return previousIndex;
	    var /** @type {?} */ moveOffset = 0;
	    if (moveOffsets && previousIndex < moveOffsets.length) {
	        moveOffset = moveOffsets[previousIndex];
	    }
	    return previousIndex + addRemoveOffset + moveOffset;
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var DefaultKeyValueDifferFactory = (function () {
	    function DefaultKeyValueDifferFactory() {
	    }
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    DefaultKeyValueDifferFactory.prototype.supports = function (obj) { return obj instanceof Map || isJsObject(obj); };
	    /**
	     * @deprecated v4.0.0 - ChangeDetectorRef is not used and is no longer a parameter
	     * @template K, V
	     * @param {?=} cd
	     * @return {?}
	     */
	    DefaultKeyValueDifferFactory.prototype.create = function (cd) {
	        return new DefaultKeyValueDiffer();
	    };
	    return DefaultKeyValueDifferFactory;
	}());
	var DefaultKeyValueDiffer = (function () {
	    function DefaultKeyValueDiffer() {
	        this._records = new Map();
	        this._mapHead = null;
	        this._appendAfter = null;
	        this._previousMapHead = null;
	        this._changesHead = null;
	        this._changesTail = null;
	        this._additionsHead = null;
	        this._additionsTail = null;
	        this._removalsHead = null;
	        this._removalsTail = null;
	    }
	    Object.defineProperty(DefaultKeyValueDiffer.prototype, "isDirty", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            return this._additionsHead !== null || this._changesHead !== null ||
	                this._removalsHead !== null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype.forEachItem = function (fn) {
	        var /** @type {?} */ record;
	        for (record = this._mapHead; record !== null; record = record._next) {
	            fn(record);
	        }
	    };
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype.forEachPreviousItem = function (fn) {
	        var /** @type {?} */ record;
	        for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
	            fn(record);
	        }
	    };
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype.forEachChangedItem = function (fn) {
	        var /** @type {?} */ record;
	        for (record = this._changesHead; record !== null; record = record._nextChanged) {
	            fn(record);
	        }
	    };
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype.forEachAddedItem = function (fn) {
	        var /** @type {?} */ record;
	        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	            fn(record);
	        }
	    };
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype.forEachRemovedItem = function (fn) {
	        var /** @type {?} */ record;
	        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
	            fn(record);
	        }
	    };
	    /**
	     * @param {?=} map
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype.diff = function (map) {
	        if (!map) {
	            map = new Map();
	        }
	        else if (!(map instanceof Map || isJsObject(map))) {
	            throw new Error("Error trying to diff '" + stringify(map) + "'. Only maps and objects are allowed");
	        }
	        return this.check(map) ? this : null;
	    };
	    /**
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype.onDestroy = function () { };
	    /**
	     * Check the current state of the map vs the previous.
	     * The algorithm is optimised for when the keys do no change.
	     * @param {?} map
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype.check = function (map) {
	        var _this = this;
	        this._reset();
	        var /** @type {?} */ insertBefore = this._mapHead;
	        this._appendAfter = null;
	        this._forEach(map, function (value, key) {
	            if (insertBefore && insertBefore.key === key) {
	                _this._maybeAddToChanges(insertBefore, value);
	                _this._appendAfter = insertBefore;
	                insertBefore = insertBefore._next;
	            }
	            else {
	                var /** @type {?} */ record = _this._getOrCreateRecordForKey(key, value);
	                insertBefore = _this._insertBeforeOrAppend(insertBefore, record);
	            }
	        });
	        // Items remaining at the end of the list have been deleted
	        if (insertBefore) {
	            if (insertBefore._prev) {
	                insertBefore._prev._next = null;
	            }
	            this._removalsHead = insertBefore;
	            for (var /** @type {?} */ record = insertBefore; record !== null; record = record._nextRemoved) {
	                if (record === this._mapHead) {
	                    this._mapHead = null;
	                }
	                this._records.delete(record.key);
	                record._nextRemoved = record._next;
	                record.previousValue = record.currentValue;
	                record.currentValue = null;
	                record._prev = null;
	                record._next = null;
	            }
	        }
	        // Make sure tails have no next records from previous runs
	        if (this._changesTail)
	            this._changesTail._nextChanged = null;
	        if (this._additionsTail)
	            this._additionsTail._nextAdded = null;
	        return this.isDirty;
	    };
	    /**
	     * Inserts a record before `before` or append at the end of the list when `before` is null.
	     *
	     * Notes:
	     * - This method appends at `this._appendAfter`,
	     * - This method updates `this._appendAfter`,
	     * - The return value is the new value for the insertion pointer.
	     * @param {?} before
	     * @param {?} record
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype._insertBeforeOrAppend = function (before, record) {
	        if (before) {
	            var /** @type {?} */ prev = before._prev;
	            record._next = before;
	            record._prev = prev;
	            before._prev = record;
	            if (prev) {
	                prev._next = record;
	            }
	            if (before === this._mapHead) {
	                this._mapHead = record;
	            }
	            this._appendAfter = before;
	            return before;
	        }
	        if (this._appendAfter) {
	            this._appendAfter._next = record;
	            record._prev = this._appendAfter;
	        }
	        else {
	            this._mapHead = record;
	        }
	        this._appendAfter = record;
	        return null;
	    };
	    /**
	     * @param {?} key
	     * @param {?} value
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype._getOrCreateRecordForKey = function (key, value) {
	        if (this._records.has(key)) {
	            var /** @type {?} */ record_1 = ((this._records.get(key)));
	            this._maybeAddToChanges(record_1, value);
	            var /** @type {?} */ prev = record_1._prev;
	            var /** @type {?} */ next = record_1._next;
	            if (prev) {
	                prev._next = next;
	            }
	            if (next) {
	                next._prev = prev;
	            }
	            record_1._next = null;
	            record_1._prev = null;
	            return record_1;
	        }
	        var /** @type {?} */ record = new KeyValueChangeRecord_(key);
	        this._records.set(key, record);
	        record.currentValue = value;
	        this._addToAdditions(record);
	        return record;
	    };
	    /**
	     * \@internal
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype._reset = function () {
	        if (this.isDirty) {
	            var /** @type {?} */ record = void 0;
	            // let `_previousMapHead` contain the state of the map before the changes
	            this._previousMapHead = this._mapHead;
	            for (record = this._previousMapHead; record !== null; record = record._next) {
	                record._nextPrevious = record._next;
	            }
	            // Update `record.previousValue` with the value of the item before the changes
	            // We need to update all changed items (that's those which have been added and changed)
	            for (record = this._changesHead; record !== null; record = record._nextChanged) {
	                record.previousValue = record.currentValue;
	            }
	            for (record = this._additionsHead; record != null; record = record._nextAdded) {
	                record.previousValue = record.currentValue;
	            }
	            this._changesHead = this._changesTail = null;
	            this._additionsHead = this._additionsTail = null;
	            this._removalsHead = null;
	        }
	    };
	    /**
	     * @param {?} record
	     * @param {?} newValue
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype._maybeAddToChanges = function (record, newValue) {
	        if (!looseIdentical(newValue, record.currentValue)) {
	            record.previousValue = record.currentValue;
	            record.currentValue = newValue;
	            this._addToChanges(record);
	        }
	    };
	    /**
	     * @param {?} record
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype._addToAdditions = function (record) {
	        if (this._additionsHead === null) {
	            this._additionsHead = this._additionsTail = record;
	        }
	        else {
	            ((this._additionsTail))._nextAdded = record;
	            this._additionsTail = record;
	        }
	    };
	    /**
	     * @param {?} record
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype._addToChanges = function (record) {
	        if (this._changesHead === null) {
	            this._changesHead = this._changesTail = record;
	        }
	        else {
	            ((this._changesTail))._nextChanged = record;
	            this._changesTail = record;
	        }
	    };
	    /**
	     * \@internal
	     * @template K, V
	     * @param {?} obj
	     * @param {?} fn
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype._forEach = function (obj, fn) {
	        if (obj instanceof Map) {
	            obj.forEach(fn);
	        }
	        else {
	            Object.keys(obj).forEach(function (k) { return fn(obj[k], k); });
	        }
	    };
	    return DefaultKeyValueDiffer;
	}());
	/**
	 * \@stable
	 */
	var KeyValueChangeRecord_ = (function () {
	    /**
	     * @param {?} key
	     */
	    function KeyValueChangeRecord_(key) {
	        this.key = key;
	        this.previousValue = null;
	        this.currentValue = null;
	        /**
	         * \@internal
	         */
	        this._nextPrevious = null;
	        /**
	         * \@internal
	         */
	        this._next = null;
	        /**
	         * \@internal
	         */
	        this._prev = null;
	        /**
	         * \@internal
	         */
	        this._nextAdded = null;
	        /**
	         * \@internal
	         */
	        this._nextRemoved = null;
	        /**
	         * \@internal
	         */
	        this._nextChanged = null;
	    }
	    return KeyValueChangeRecord_;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.
	 * \@stable
	 */
	var IterableDiffers = (function () {
	    /**
	     * @param {?} factories
	     */
	    function IterableDiffers(factories) {
	        this.factories = factories;
	    }
	    /**
	     * @param {?} factories
	     * @param {?=} parent
	     * @return {?}
	     */
	    IterableDiffers.create = function (factories, parent) {
	        if (parent != null) {
	            var /** @type {?} */ copied = parent.factories.slice();
	            factories = factories.concat(copied);
	            return new IterableDiffers(factories);
	        }
	        else {
	            return new IterableDiffers(factories);
	        }
	    };
	    /**
	     * Takes an array of {\@link IterableDifferFactory} and returns a provider used to extend the
	     * inherited {\@link IterableDiffers} instance with the provided factories and return a new
	     * {\@link IterableDiffers} instance.
	     *
	     * The following example shows how to extend an existing list of factories,
	     * which will only be applied to the injector for this component and its children.
	     * This step is all that's required to make a new {\@link IterableDiffer} available.
	     *
	     * ### Example
	     *
	     * ```
	     * \@Component({
	     *   viewProviders: [
	     *     IterableDiffers.extend([new ImmutableListDiffer()])
	     *   ]
	     * })
	     * ```
	     * @param {?} factories
	     * @return {?}
	     */
	    IterableDiffers.extend = function (factories) {
	        return {
	            provide: IterableDiffers,
	            useFactory: function (parent) {
	                if (!parent) {
	                    // Typically would occur when calling IterableDiffers.extend inside of dependencies passed
	                    // to
	                    // bootstrap(), which would override default pipes instead of extending them.
	                    throw new Error('Cannot extend IterableDiffers without a parent injector');
	                }
	                return IterableDiffers.create(factories, parent);
	            },
	            // Dependency technically isn't optional, but we can provide a better error message this way.
	            deps: [[IterableDiffers, new SkipSelf(), new Optional()]]
	        };
	    };
	    /**
	     * @param {?} iterable
	     * @return {?}
	     */
	    IterableDiffers.prototype.find = function (iterable) {
	        var /** @type {?} */ factory = this.factories.find(function (f) { return f.supports(iterable); });
	        if (factory != null) {
	            return factory;
	        }
	        else {
	            throw new Error("Cannot find a differ supporting object '" + iterable + "' of type '" + getTypeNameForDebugging(iterable) + "'");
	        }
	    };
	    return IterableDiffers;
	}());
	/**
	 * @param {?} type
	 * @return {?}
	 */
	function getTypeNameForDebugging(type) {
	    return type['name'] || typeof type;
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.
	 * \@stable
	 */
	var KeyValueDiffers = (function () {
	    /**
	     * @param {?} factories
	     */
	    function KeyValueDiffers(factories) {
	        this.factories = factories;
	    }
	    /**
	     * @template S
	     * @param {?} factories
	     * @param {?=} parent
	     * @return {?}
	     */
	    KeyValueDiffers.create = function (factories, parent) {
	        if (parent) {
	            var /** @type {?} */ copied = parent.factories.slice();
	            factories = factories.concat(copied);
	        }
	        return new KeyValueDiffers(factories);
	    };
	    /**
	     * Takes an array of {\@link KeyValueDifferFactory} and returns a provider used to extend the
	     * inherited {\@link KeyValueDiffers} instance with the provided factories and return a new
	     * {\@link KeyValueDiffers} instance.
	     *
	     * The following example shows how to extend an existing list of factories,
	     * which will only be applied to the injector for this component and its children.
	     * This step is all that's required to make a new {\@link KeyValueDiffer} available.
	     *
	     * ### Example
	     *
	     * ```
	     * \@Component({
	     *   viewProviders: [
	     *     KeyValueDiffers.extend([new ImmutableMapDiffer()])
	     *   ]
	     * })
	     * ```
	     * @template S
	     * @param {?} factories
	     * @return {?}
	     */
	    KeyValueDiffers.extend = function (factories) {
	        return {
	            provide: KeyValueDiffers,
	            useFactory: function (parent) {
	                if (!parent) {
	                    // Typically would occur when calling KeyValueDiffers.extend inside of dependencies passed
	                    // to bootstrap(), which would override default pipes instead of extending them.
	                    throw new Error('Cannot extend KeyValueDiffers without a parent injector');
	                }
	                return KeyValueDiffers.create(factories, parent);
	            },
	            // Dependency technically isn't optional, but we can provide a better error message this way.
	            deps: [[KeyValueDiffers, new SkipSelf(), new Optional()]]
	        };
	    };
	    /**
	     * @param {?} kv
	     * @return {?}
	     */
	    KeyValueDiffers.prototype.find = function (kv) {
	        var /** @type {?} */ factory = this.factories.find(function (f) { return f.supports(kv); });
	        if (factory) {
	            return factory;
	        }
	        throw new Error("Cannot find a differ supporting object '" + kv + "'");
	    };
	    return KeyValueDiffers;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Structural diffing for `Object`s and `Map`s.
	 */
	var keyValDiff = [new DefaultKeyValueDifferFactory()];
	/**
	 * Structural diffing for `Iterable` types such as `Array`s.
	 */
	var iterableDiff = [new DefaultIterableDifferFactory()];
	var defaultIterableDiffers = new IterableDiffers(iterableDiff);
	var defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @module
	 * @description
	 * Change detection enables data binding in Angular.
	 */
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @return {?}
	 */
	function _reflector() {
	    return reflector;
	}
	var _CORE_PLATFORM_PROVIDERS = [
	    // Set a default platform name for platforms that don't set it explicitly.
	    { provide: PLATFORM_ID, useValue: 'unknown' },
	    PlatformRef_,
	    { provide: PlatformRef, useExisting: PlatformRef_ },
	    { provide: Reflector, useFactory: _reflector, deps: [] },
	    TestabilityRegistry,
	    Console,
	];
	/**
	 * This platform has to be included in any other platform
	 *
	 * \@experimental
	 */
	var platformCore = createPlatformFactory(null, 'core', _CORE_PLATFORM_PROVIDERS);
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@experimental i18n support is experimental.
	 */
	var LOCALE_ID = new InjectionToken('LocaleId');
	/**
	 * \@experimental i18n support is experimental.
	 */
	var TRANSLATIONS = new InjectionToken('Translations');
	/**
	 * \@experimental i18n support is experimental.
	 */
	var TRANSLATIONS_FORMAT = new InjectionToken('TranslationsFormat');
	var MissingTranslationStrategy = {};
	MissingTranslationStrategy.Error = 0;
	MissingTranslationStrategy.Warning = 1;
	MissingTranslationStrategy.Ignore = 2;
	MissingTranslationStrategy[MissingTranslationStrategy.Error] = "Error";
	MissingTranslationStrategy[MissingTranslationStrategy.Warning] = "Warning";
	MissingTranslationStrategy[MissingTranslationStrategy.Ignore] = "Ignore";
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @return {?}
	 */
	function _iterableDiffersFactory() {
	    return defaultIterableDiffers;
	}
	/**
	 * @return {?}
	 */
	function _keyValueDiffersFactory() {
	    return defaultKeyValueDiffers;
	}
	/**
	 * @param {?=} locale
	 * @return {?}
	 */
	function _localeFactory(locale) {
	    return locale || 'en-US';
	}
	/**
	 * This module includes the providers of \@angular/core that are needed
	 * to bootstrap components via `ApplicationRef`.
	 *
	 * \@experimental
	 */
	var ApplicationModule = (function () {
	    /**
	     * @param {?} appRef
	     */
	    function ApplicationModule(appRef) {
	    }
	    return ApplicationModule;
	}());
	ApplicationModule.decorators = [
	    { type: NgModule, args: [{
	                providers: [
	                    ApplicationRef_,
	                    { provide: ApplicationRef, useExisting: ApplicationRef_ },
	                    ApplicationInitStatus,
	                    Compiler,
	                    APP_ID_RANDOM_PROVIDER,
	                    { provide: IterableDiffers, useFactory: _iterableDiffersFactory },
	                    { provide: KeyValueDiffers, useFactory: _keyValueDiffersFactory },
	                    {
	                        provide: LOCALE_ID,
	                        useFactory: _localeFactory,
	                        deps: [[new Inject(LOCALE_ID), new Optional(), new SkipSelf()]]
	                    },
	                ]
	            },] },
	];
	/**
	 * @nocollapse
	 */
	ApplicationModule.ctorParameters = function () { return [
	    { type: ApplicationRef, },
	]; };
	var SecurityContext = {};
	SecurityContext.NONE = 0;
	SecurityContext.HTML = 1;
	SecurityContext.STYLE = 2;
	SecurityContext.SCRIPT = 3;
	SecurityContext.URL = 4;
	SecurityContext.RESOURCE_URL = 5;
	SecurityContext[SecurityContext.NONE] = "NONE";
	SecurityContext[SecurityContext.HTML] = "HTML";
	SecurityContext[SecurityContext.STYLE] = "STYLE";
	SecurityContext[SecurityContext.SCRIPT] = "SCRIPT";
	SecurityContext[SecurityContext.URL] = "URL";
	SecurityContext[SecurityContext.RESOURCE_URL] = "RESOURCE_URL";
	/**
	 * Sanitizer is used by the views to sanitize potentially dangerous values.
	 *
	 * \@stable
	 * @abstract
	 */
	var Sanitizer = (function () {
	    function Sanitizer() {
	    }
	    /**
	     * @abstract
	     * @param {?} context
	     * @param {?} value
	     * @return {?}
	     */
	    Sanitizer.prototype.sanitize = function (context, value) { };
	    return Sanitizer;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Node instance data.
	 *
	 * We have a separate type per NodeType to save memory
	 * (TextData | ElementData | ProviderData | PureExpressionData | QueryList<any>)
	 *
	 * To keep our code monomorphic,
	 * we prohibit using `NodeData` directly but enforce the use of accessors (`asElementData`, ...).
	 * This way, no usage site can get a `NodeData` from view.nodes and then use it for different
	 * purposes.
	 */
	/**
	 * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
	 * @param {?} view
	 * @param {?} index
	 * @return {?}
	 */
	function asTextData(view, index) {
	    return (view.nodes[index]);
	}
	/**
	 * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
	 * @param {?} view
	 * @param {?} index
	 * @return {?}
	 */
	function asElementData(view, index) {
	    return (view.nodes[index]);
	}
	/**
	 * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
	 * @param {?} view
	 * @param {?} index
	 * @return {?}
	 */
	function asProviderData(view, index) {
	    return (view.nodes[index]);
	}
	/**
	 * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
	 * @param {?} view
	 * @param {?} index
	 * @return {?}
	 */
	function asPureExpressionData(view, index) {
	    return (view.nodes[index]);
	}
	/**
	 * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
	 * @param {?} view
	 * @param {?} index
	 * @return {?}
	 */
	function asQueryList(view, index) {
	    return (view.nodes[index]);
	}
	/**
	 * @abstract
	 */
	var DebugContext = (function () {
	    function DebugContext() {
	    }
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DebugContext.prototype.view = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DebugContext.prototype.nodeIndex = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DebugContext.prototype.injector = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DebugContext.prototype.component = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DebugContext.prototype.providerTokens = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DebugContext.prototype.references = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DebugContext.prototype.context = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DebugContext.prototype.componentRenderElement = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DebugContext.prototype.renderNode = function () { };
	    /**
	     * @abstract
	     * @param {?} console
	     * @param {...?} values
	     * @return {?}
	     */
	    DebugContext.prototype.logError = function (console) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	    };
	    return DebugContext;
	}());
	/**
	 * This object is used to prevent cycles in the source files and to have a place where
	 * debug mode can hook it. It is lazily filled when `isDevMode` is known.
	 */
	var Services = {
	    setCurrentNode: undefined,
	    createRootView: undefined,
	    createEmbeddedView: undefined,
	    createComponentView: undefined,
	    createNgModuleRef: undefined,
	    overrideProvider: undefined,
	    clearProviderOverrides: undefined,
	    checkAndUpdateView: undefined,
	    checkNoChangesView: undefined,
	    destroyView: undefined,
	    resolveDep: undefined,
	    createDebugContext: undefined,
	    handleEvent: undefined,
	    updateDirectives: undefined,
	    updateRenderer: undefined,
	    dirtyParentQueries: undefined,
	};
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} context
	 * @param {?} oldValue
	 * @param {?} currValue
	 * @param {?} isFirstCheck
	 * @return {?}
	 */
	function expressionChangedAfterItHasBeenCheckedError(context, oldValue, currValue, isFirstCheck) {
	    var /** @type {?} */ msg = "ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: '" + oldValue + "'. Current value: '" + currValue + "'.";
	    if (isFirstCheck) {
	        msg +=
	            " It seems like the view has been created after its parent and its children have been dirty checked." +
	                " Has it been created in a change detection hook ?";
	    }
	    return viewDebugError(msg, context);
	}
	/**
	 * @param {?} err
	 * @param {?} context
	 * @return {?}
	 */
	function viewWrappedDebugError(err, context) {
	    if (!(err instanceof Error)) {
	        // errors that are not Error instances don't have a stack,
	        // so it is ok to wrap them into a new Error object...
	        err = new Error(err.toString());
	    }
	    _addDebugContext(err, context);
	    return err;
	}
	/**
	 * @param {?} msg
	 * @param {?} context
	 * @return {?}
	 */
	function viewDebugError(msg, context) {
	    var /** @type {?} */ err = new Error(msg);
	    _addDebugContext(err, context);
	    return err;
	}
	/**
	 * @param {?} err
	 * @param {?} context
	 * @return {?}
	 */
	function _addDebugContext(err, context) {
	    ((err))[ERROR_DEBUG_CONTEXT] = context;
	    ((err))[ERROR_LOGGER] = context.logError.bind(context);
	}
	/**
	 * @param {?} err
	 * @return {?}
	 */
	function isViewDebugError(err) {
	    return !!getDebugContext(err);
	}
	/**
	 * @param {?} action
	 * @return {?}
	 */
	function viewDestroyedError(action) {
	    return new Error("ViewDestroyedError: Attempt to use a destroyed view: " + action);
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var NOOP = function () { };
	var _tokenKeyCache = new Map();
	/**
	 * @param {?} token
	 * @return {?}
	 */
	function tokenKey(token) {
	    var /** @type {?} */ key = _tokenKeyCache.get(token);
	    if (!key) {
	        key = stringify(token) + '_' + _tokenKeyCache.size;
	        _tokenKeyCache.set(token, key);
	    }
	    return key;
	}
	/**
	 * @param {?} view
	 * @param {?} nodeIdx
	 * @param {?} bindingIdx
	 * @param {?} value
	 * @return {?}
	 */
	function unwrapValue(view, nodeIdx, bindingIdx, value) {
	    if (value instanceof WrappedValue) {
	        value = value.wrapped;
	        var /** @type {?} */ globalBindingIdx = view.def.nodes[nodeIdx].bindingIndex + bindingIdx;
	        var /** @type {?} */ oldValue = view.oldValues[globalBindingIdx];
	        if (oldValue instanceof WrappedValue) {
	            oldValue = oldValue.wrapped;
	        }
	        view.oldValues[globalBindingIdx] = new WrappedValue(oldValue);
	    }
	    return value;
	}
	var UNDEFINED_RENDERER_TYPE_ID = '$$undefined';
	var EMPTY_RENDERER_TYPE_ID = '$$empty';
	/**
	 * @param {?} values
	 * @return {?}
	 */
	function createRendererType2(values) {
	    return {
	        id: UNDEFINED_RENDERER_TYPE_ID,
	        styles: values.styles,
	        encapsulation: values.encapsulation,
	        data: values.data
	    };
	}
	var _renderCompCount = 0;
	/**
	 * @param {?=} type
	 * @return {?}
	 */
	function resolveRendererType2(type) {
	    if (type && type.id === UNDEFINED_RENDERER_TYPE_ID) {
	        // first time we see this RendererType2. Initialize it...
	        var /** @type {?} */ isFilled = ((type.encapsulation != null && type.encapsulation !== ViewEncapsulation.None) ||
	            type.styles.length || Object.keys(type.data).length);
	        if (isFilled) {
	            type.id = "c" + _renderCompCount++;
	        }
	        else {
	            type.id = EMPTY_RENDERER_TYPE_ID;
	        }
	    }
	    if (type && type.id === EMPTY_RENDERER_TYPE_ID) {
	        type = null;
	    }
	    return type || null;
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @param {?} bindingIdx
	 * @param {?} value
	 * @return {?}
	 */
	function checkBinding(view, def, bindingIdx, value) {
	    var /** @type {?} */ oldValues = view.oldValues;
	    if ((view.state & 2 /* FirstCheck */) ||
	        !looseIdentical(oldValues[def.bindingIndex + bindingIdx], value)) {
	        return true;
	    }
	    return false;
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @param {?} bindingIdx
	 * @param {?} value
	 * @return {?}
	 */
	function checkAndUpdateBinding(view, def, bindingIdx, value) {
	    if (checkBinding(view, def, bindingIdx, value)) {
	        view.oldValues[def.bindingIndex + bindingIdx] = value;
	        return true;
	    }
	    return false;
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @param {?} bindingIdx
	 * @param {?} value
	 * @return {?}
	 */
	function checkBindingNoChanges(view, def, bindingIdx, value) {
	    var /** @type {?} */ oldValue = view.oldValues[def.bindingIndex + bindingIdx];
	    if ((view.state & 1 /* BeforeFirstCheck */) || !devModeEqual(oldValue, value)) {
	        throw expressionChangedAfterItHasBeenCheckedError(Services.createDebugContext(view, def.index), oldValue, value, (view.state & 1 /* BeforeFirstCheck */) !== 0);
	    }
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function markParentViewsForCheck(view) {
	    var /** @type {?} */ currView = view;
	    while (currView) {
	        if (currView.def.flags & 2 /* OnPush */) {
	            currView.state |= 8 /* ChecksEnabled */;
	        }
	        currView = currView.viewContainerParent || currView.parent;
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} endView
	 * @return {?}
	 */
	function markParentViewsForCheckProjectedViews(view, endView) {
	    var /** @type {?} */ currView = view;
	    while (currView && currView !== endView) {
	        currView.state |= 64 /* CheckProjectedViews */;
	        currView = currView.viewContainerParent || currView.parent;
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} nodeIndex
	 * @param {?} eventName
	 * @param {?} event
	 * @return {?}
	 */
	function dispatchEvent(view, nodeIndex, eventName, event) {
	    var /** @type {?} */ nodeDef = view.def.nodes[nodeIndex];
	    var /** @type {?} */ startView = nodeDef.flags & 33554432 /* ComponentView */ ? asElementData(view, nodeIndex).componentView : view;
	    markParentViewsForCheck(startView);
	    return Services.handleEvent(view, nodeIndex, eventName, event);
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function declaredViewContainer(view) {
	    if (view.parent) {
	        var /** @type {?} */ parentView = view.parent;
	        return asElementData(parentView, /** @type {?} */ ((view.parentNodeDef)).index);
	    }
	    return null;
	}
	/**
	 * for component views, this is the host element.
	 * for embedded views, this is the index of the parent node
	 * that contains the view container.
	 * @param {?} view
	 * @return {?}
	 */
	function viewParentEl(view) {
	    var /** @type {?} */ parentView = view.parent;
	    if (parentView) {
	        return ((view.parentNodeDef)).parent;
	    }
	    else {
	        return null;
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @return {?}
	 */
	function renderNode(view, def) {
	    switch (def.flags & 201347067 /* Types */) {
	        case 1 /* TypeElement */:
	            return asElementData(view, def.index).renderElement;
	        case 2 /* TypeText */:
	            return asTextData(view, def.index).renderText;
	    }
	}
	/**
	 * @param {?} target
	 * @param {?} name
	 * @return {?}
	 */
	function elementEventFullName(target, name) {
	    return target ? target + ":" + name : name;
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function isComponentView(view) {
	    return !!view.parent && !!(((view.parentNodeDef)).flags & 32768 /* Component */);
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function isEmbeddedView(view) {
	    return !!view.parent && !(((view.parentNodeDef)).flags & 32768 /* Component */);
	}
	/**
	 * @param {?} queryId
	 * @return {?}
	 */
	function filterQueryId(queryId) {
	    return 1 << (queryId % 32);
	}
	/**
	 * @param {?} matchedQueriesDsl
	 * @return {?}
	 */
	function splitMatchedQueriesDsl(matchedQueriesDsl) {
	    var /** @type {?} */ matchedQueries = {};
	    var /** @type {?} */ matchedQueryIds = 0;
	    var /** @type {?} */ references = {};
	    if (matchedQueriesDsl) {
	        matchedQueriesDsl.forEach(function (_a) {
	            var queryId = _a[0], valueType = _a[1];
	            if (typeof queryId === 'number') {
	                matchedQueries[queryId] = valueType;
	                matchedQueryIds |= filterQueryId(queryId);
	            }
	            else {
	                references[queryId] = valueType;
	            }
	        });
	    }
	    return { matchedQueries: matchedQueries, references: references, matchedQueryIds: matchedQueryIds };
	}
	/**
	 * @param {?} deps
	 * @return {?}
	 */
	function splitDepsDsl(deps) {
	    return deps.map(function (value) {
	        var /** @type {?} */ token;
	        var /** @type {?} */ flags;
	        if (Array.isArray(value)) {
	            flags = value[0], token = value[1];
	        }
	        else {
	            flags = 0 /* None */;
	            token = value;
	        }
	        return { flags: flags, token: token, tokenKey: tokenKey(token) };
	    });
	}
	/**
	 * @param {?} view
	 * @param {?} renderHost
	 * @param {?} def
	 * @return {?}
	 */
	function getParentRenderElement(view, renderHost, def) {
	    var /** @type {?} */ renderParent = def.renderParent;
	    if (renderParent) {
	        if ((renderParent.flags & 1 /* TypeElement */) === 0 ||
	            (renderParent.flags & 33554432 /* ComponentView */) === 0 ||
	            (((renderParent.element)).componentRendererType && ((((renderParent.element)).componentRendererType)).encapsulation ===
	                ViewEncapsulation.Native)) {
	            // only children of non components, or children of components with native encapsulation should
	            // be attached.
	            return asElementData(view, /** @type {?} */ ((def.renderParent)).index).renderElement;
	        }
	    }
	    else {
	        return renderHost;
	    }
	}
	var DEFINITION_CACHE = new WeakMap();
	/**
	 * @template D
	 * @param {?} factory
	 * @return {?}
	 */
	function resolveDefinition(factory) {
	    var /** @type {?} */ value = (((DEFINITION_CACHE.get(factory))));
	    if (!value) {
	        value = factory(function () { return NOOP; });
	        value.factory = factory;
	        DEFINITION_CACHE.set(factory, value);
	    }
	    return value;
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function rootRenderNodes(view) {
	    var /** @type {?} */ renderNodes = [];
	    visitRootRenderNodes(view, 0 /* Collect */, undefined, undefined, renderNodes);
	    return renderNodes;
	}
	/**
	 * @param {?} view
	 * @param {?} action
	 * @param {?} parentNode
	 * @param {?} nextSibling
	 * @param {?=} target
	 * @return {?}
	 */
	function visitRootRenderNodes(view, action, parentNode, nextSibling, target) {
	    // We need to re-compute the parent node in case the nodes have been moved around manually
	    if (action === 3 /* RemoveChild */) {
	        parentNode = view.renderer.parentNode(renderNode(view, /** @type {?} */ ((view.def.lastRenderRootNode))));
	    }
	    visitSiblingRenderNodes(view, action, 0, view.def.nodes.length - 1, parentNode, nextSibling, target);
	}
	/**
	 * @param {?} view
	 * @param {?} action
	 * @param {?} startIndex
	 * @param {?} endIndex
	 * @param {?} parentNode
	 * @param {?} nextSibling
	 * @param {?=} target
	 * @return {?}
	 */
	function visitSiblingRenderNodes(view, action, startIndex, endIndex, parentNode, nextSibling, target) {
	    for (var /** @type {?} */ i = startIndex; i <= endIndex; i++) {
	        var /** @type {?} */ nodeDef = view.def.nodes[i];
	        if (nodeDef.flags & (1 /* TypeElement */ | 2 /* TypeText */ | 8 /* TypeNgContent */)) {
	            visitRenderNode(view, nodeDef, action, parentNode, nextSibling, target);
	        }
	        // jump to next sibling
	        i += nodeDef.childCount;
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} ngContentIndex
	 * @param {?} action
	 * @param {?} parentNode
	 * @param {?} nextSibling
	 * @param {?=} target
	 * @return {?}
	 */
	function visitProjectedRenderNodes(view, ngContentIndex, action, parentNode, nextSibling, target) {
	    var /** @type {?} */ compView = view;
	    while (compView && !isComponentView(compView)) {
	        compView = compView.parent;
	    }
	    var /** @type {?} */ hostView = ((compView)).parent;
	    var /** @type {?} */ hostElDef = viewParentEl(/** @type {?} */ ((compView)));
	    var /** @type {?} */ startIndex = ((hostElDef)).index + 1;
	    var /** @type {?} */ endIndex = ((hostElDef)).index + ((hostElDef)).childCount;
	    for (var /** @type {?} */ i = startIndex; i <= endIndex; i++) {
	        var /** @type {?} */ nodeDef = ((hostView)).def.nodes[i];
	        if (nodeDef.ngContentIndex === ngContentIndex) {
	            visitRenderNode(/** @type {?} */ ((hostView)), nodeDef, action, parentNode, nextSibling, target);
	        }
	        // jump to next sibling
	        i += nodeDef.childCount;
	    }
	    if (!((hostView)).parent) {
	        // a root view
	        var /** @type {?} */ projectedNodes = view.root.projectableNodes[ngContentIndex];
	        if (projectedNodes) {
	            for (var /** @type {?} */ i = 0; i < projectedNodes.length; i++) {
	                execRenderNodeAction(view, projectedNodes[i], action, parentNode, nextSibling, target);
	            }
	        }
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} nodeDef
	 * @param {?} action
	 * @param {?} parentNode
	 * @param {?} nextSibling
	 * @param {?=} target
	 * @return {?}
	 */
	function visitRenderNode(view, nodeDef, action, parentNode, nextSibling, target) {
	    if (nodeDef.flags & 8 /* TypeNgContent */) {
	        visitProjectedRenderNodes(view, /** @type {?} */ ((nodeDef.ngContent)).index, action, parentNode, nextSibling, target);
	    }
	    else {
	        var /** @type {?} */ rn = renderNode(view, nodeDef);
	        if (action === 3 /* RemoveChild */ && (nodeDef.flags & 33554432 /* ComponentView */) &&
	            (nodeDef.bindingFlags & 48 /* CatSyntheticProperty */)) {
	            // Note: we might need to do both actions.
	            if (nodeDef.bindingFlags & (16 /* SyntheticProperty */)) {
	                execRenderNodeAction(view, rn, action, parentNode, nextSibling, target);
	            }
	            if (nodeDef.bindingFlags & (32 /* SyntheticHostProperty */)) {
	                var /** @type {?} */ compView = asElementData(view, nodeDef.index).componentView;
	                execRenderNodeAction(compView, rn, action, parentNode, nextSibling, target);
	            }
	        }
	        else {
	            execRenderNodeAction(view, rn, action, parentNode, nextSibling, target);
	        }
	        if (nodeDef.flags & 16777216 /* EmbeddedViews */) {
	            var /** @type {?} */ embeddedViews = ((asElementData(view, nodeDef.index).viewContainer))._embeddedViews;
	            for (var /** @type {?} */ k = 0; k < embeddedViews.length; k++) {
	                visitRootRenderNodes(embeddedViews[k], action, parentNode, nextSibling, target);
	            }
	        }
	        if (nodeDef.flags & 1 /* TypeElement */ && !((nodeDef.element)).name) {
	            visitSiblingRenderNodes(view, action, nodeDef.index + 1, nodeDef.index + nodeDef.childCount, parentNode, nextSibling, target);
	        }
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} renderNode
	 * @param {?} action
	 * @param {?} parentNode
	 * @param {?} nextSibling
	 * @param {?=} target
	 * @return {?}
	 */
	function execRenderNodeAction(view, renderNode, action, parentNode, nextSibling, target) {
	    var /** @type {?} */ renderer = view.renderer;
	    switch (action) {
	        case 1 /* AppendChild */:
	            renderer.appendChild(parentNode, renderNode);
	            break;
	        case 2 /* InsertBefore */:
	            renderer.insertBefore(parentNode, renderNode, nextSibling);
	            break;
	        case 3 /* RemoveChild */:
	            renderer.removeChild(parentNode, renderNode);
	            break;
	        case 0 /* Collect */:
	            ((target)).push(renderNode);
	            break;
	    }
	}
	var NS_PREFIX_RE = /^:([^:]+):(.+)$/;
	/**
	 * @param {?} name
	 * @return {?}
	 */
	function splitNamespace(name) {
	    if (name[0] === ':') {
	        var /** @type {?} */ match = ((name.match(NS_PREFIX_RE)));
	        return [match[1], match[2]];
	    }
	    return ['', name];
	}
	/**
	 * @param {?} bindings
	 * @return {?}
	 */
	function calcBindingFlags(bindings) {
	    var /** @type {?} */ flags = 0;
	    for (var /** @type {?} */ i = 0; i < bindings.length; i++) {
	        flags |= bindings[i].flags;
	    }
	    return flags;
	}
	/**
	 * @param {?} valueCount
	 * @param {?} constAndInterp
	 * @return {?}
	 */
	function interpolate(valueCount, constAndInterp) {
	    var /** @type {?} */ result = '';
	    for (var /** @type {?} */ i = 0; i < valueCount * 2; i = i + 2) {
	        result = result + constAndInterp[i] + _toStringWithNull(constAndInterp[i + 1]);
	    }
	    return result + constAndInterp[valueCount * 2];
	}
	/**
	 * @param {?} valueCount
	 * @param {?} c0
	 * @param {?} a1
	 * @param {?} c1
	 * @param {?=} a2
	 * @param {?=} c2
	 * @param {?=} a3
	 * @param {?=} c3
	 * @param {?=} a4
	 * @param {?=} c4
	 * @param {?=} a5
	 * @param {?=} c5
	 * @param {?=} a6
	 * @param {?=} c6
	 * @param {?=} a7
	 * @param {?=} c7
	 * @param {?=} a8
	 * @param {?=} c8
	 * @param {?=} a9
	 * @param {?=} c9
	 * @return {?}
	 */
	function inlineInterpolate(valueCount, c0, a1, c1, a2, c2, a3, c3, a4, c4, a5, c5, a6, c6, a7, c7, a8, c8, a9, c9) {
	    switch (valueCount) {
	        case 1:
	            return c0 + _toStringWithNull(a1) + c1;
	        case 2:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2;
	        case 3:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                c3;
	        case 4:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                c3 + _toStringWithNull(a4) + c4;
	        case 5:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5;
	        case 6:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6;
	        case 7:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
	                c6 + _toStringWithNull(a7) + c7;
	        case 8:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
	                c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8;
	        case 9:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
	                c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8 + _toStringWithNull(a9) + c9;
	        default:
	            throw new Error("Does not support more than 9 expressions");
	    }
	}
	/**
	 * @param {?} v
	 * @return {?}
	 */
	function _toStringWithNull(v) {
	    return v != null ? v.toString() : '';
	}
	var EMPTY_ARRAY = [];
	var EMPTY_MAP = {};
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} flags
	 * @param {?} matchedQueriesDsl
	 * @param {?} ngContentIndex
	 * @param {?} childCount
	 * @param {?=} handleEvent
	 * @param {?=} templateFactory
	 * @return {?}
	 */
	function anchorDef(flags, matchedQueriesDsl, ngContentIndex, childCount, handleEvent, templateFactory) {
	    flags |= 1 /* TypeElement */;
	    var _a = splitMatchedQueriesDsl(matchedQueriesDsl), matchedQueries = _a.matchedQueries, references = _a.references, matchedQueryIds = _a.matchedQueryIds;
	    var /** @type {?} */ template = templateFactory ? resolveDefinition(templateFactory) : null;
	    return {
	        // will bet set by the view definition
	        index: -1,
	        parent: null,
	        renderParent: null,
	        bindingIndex: -1,
	        outputIndex: -1,
	        // regular values
	        flags: flags,
	        childFlags: 0,
	        directChildFlags: 0,
	        childMatchedQueries: 0, matchedQueries: matchedQueries, matchedQueryIds: matchedQueryIds, references: references, ngContentIndex: ngContentIndex, childCount: childCount,
	        bindings: [],
	        bindingFlags: 0,
	        outputs: [],
	        element: {
	            ns: null,
	            name: null,
	            attrs: null, template: template,
	            componentProvider: null,
	            componentView: null,
	            componentRendererType: null,
	            publicProviders: null,
	            allProviders: null,
	            handleEvent: handleEvent || NOOP
	        },
	        provider: null,
	        text: null,
	        query: null,
	        ngContent: null
	    };
	}
	/**
	 * @param {?} flags
	 * @param {?} matchedQueriesDsl
	 * @param {?} ngContentIndex
	 * @param {?} childCount
	 * @param {?} namespaceAndName
	 * @param {?=} fixedAttrs
	 * @param {?=} bindings
	 * @param {?=} outputs
	 * @param {?=} handleEvent
	 * @param {?=} componentView
	 * @param {?=} componentRendererType
	 * @return {?}
	 */
	function elementDef(flags, matchedQueriesDsl, ngContentIndex, childCount, namespaceAndName, fixedAttrs, bindings, outputs, handleEvent, componentView, componentRendererType) {
	    if (fixedAttrs === void 0) { fixedAttrs = []; }
	    if (!handleEvent) {
	        handleEvent = NOOP;
	    }
	    var _a = splitMatchedQueriesDsl(matchedQueriesDsl), matchedQueries = _a.matchedQueries, references = _a.references, matchedQueryIds = _a.matchedQueryIds;
	    var /** @type {?} */ ns = ((null));
	    var /** @type {?} */ name = ((null));
	    if (namespaceAndName) {
	        _b = splitNamespace(namespaceAndName), ns = _b[0], name = _b[1];
	    }
	    bindings = bindings || [];
	    var /** @type {?} */ bindingDefs = new Array(bindings.length);
	    for (var /** @type {?} */ i = 0; i < bindings.length; i++) {
	        var _c = bindings[i], bindingFlags = _c[0], namespaceAndName_1 = _c[1], suffixOrSecurityContext = _c[2];
	        var _d = splitNamespace(namespaceAndName_1), ns_1 = _d[0], name_1 = _d[1];
	        var /** @type {?} */ securityContext = ((undefined));
	        var /** @type {?} */ suffix = ((undefined));
	        switch (bindingFlags & 15 /* Types */) {
	            case 4 /* TypeElementStyle */:
	                suffix = (suffixOrSecurityContext);
	                break;
	            case 1 /* TypeElementAttribute */:
	            case 8 /* TypeProperty */:
	                securityContext = (suffixOrSecurityContext);
	                break;
	        }
	        bindingDefs[i] =
	            { flags: bindingFlags, ns: ns_1, name: name_1, nonMinifiedName: name_1, securityContext: securityContext, suffix: suffix };
	    }
	    outputs = outputs || [];
	    var /** @type {?} */ outputDefs = new Array(outputs.length);
	    for (var /** @type {?} */ i = 0; i < outputs.length; i++) {
	        var _e = outputs[i], target = _e[0], eventName = _e[1];
	        outputDefs[i] = {
	            type: 0 /* ElementOutput */,
	            target: /** @type {?} */ (target), eventName: eventName,
	            propName: null
	        };
	    }
	    fixedAttrs = fixedAttrs || [];
	    var /** @type {?} */ attrs = (fixedAttrs.map(function (_a) {
	        var namespaceAndName = _a[0], value = _a[1];
	        var _b = splitNamespace(namespaceAndName), ns = _b[0], name = _b[1];
	        return [ns, name, value];
	    }));
	    componentRendererType = resolveRendererType2(componentRendererType);
	    if (componentView) {
	        flags |= 33554432 /* ComponentView */;
	    }
	    flags |= 1 /* TypeElement */;
	    return {
	        // will bet set by the view definition
	        index: -1,
	        parent: null,
	        renderParent: null,
	        bindingIndex: -1,
	        outputIndex: -1,
	        // regular values
	        flags: flags,
	        childFlags: 0,
	        directChildFlags: 0,
	        childMatchedQueries: 0, matchedQueries: matchedQueries, matchedQueryIds: matchedQueryIds, references: references, ngContentIndex: ngContentIndex, childCount: childCount,
	        bindings: bindingDefs,
	        bindingFlags: calcBindingFlags(bindingDefs),
	        outputs: outputDefs,
	        element: {
	            ns: ns,
	            name: name,
	            attrs: attrs,
	            template: null,
	            // will bet set by the view definition
	            componentProvider: null,
	            componentView: componentView || null,
	            componentRendererType: componentRendererType,
	            publicProviders: null,
	            allProviders: null,
	            handleEvent: handleEvent || NOOP,
	        },
	        provider: null,
	        text: null,
	        query: null,
	        ngContent: null
	    };
	    var _b;
	}
	/**
	 * @param {?} view
	 * @param {?} renderHost
	 * @param {?} def
	 * @return {?}
	 */
	function createElement(view, renderHost, def) {
	    var /** @type {?} */ elDef = ((def.element));
	    var /** @type {?} */ rootSelectorOrNode = view.root.selectorOrNode;
	    var /** @type {?} */ renderer = view.renderer;
	    var /** @type {?} */ el;
	    if (view.parent || !rootSelectorOrNode) {
	        if (elDef.name) {
	            el = renderer.createElement(elDef.name, elDef.ns);
	        }
	        else {
	            el = renderer.createComment('');
	        }
	        var /** @type {?} */ parentEl = getParentRenderElement(view, renderHost, def);
	        if (parentEl) {
	            renderer.appendChild(parentEl, el);
	        }
	    }
	    else {
	        el = renderer.selectRootElement(rootSelectorOrNode);
	    }
	    if (elDef.attrs) {
	        for (var /** @type {?} */ i = 0; i < elDef.attrs.length; i++) {
	            var _a = elDef.attrs[i], ns = _a[0], name = _a[1], value = _a[2];
	            renderer.setAttribute(el, name, value, ns);
	        }
	    }
	    return el;
	}
	/**
	 * @param {?} view
	 * @param {?} compView
	 * @param {?} def
	 * @param {?} el
	 * @return {?}
	 */
	function listenToElementOutputs(view, compView, def, el) {
	    for (var /** @type {?} */ i = 0; i < def.outputs.length; i++) {
	        var /** @type {?} */ output = def.outputs[i];
	        var /** @type {?} */ handleEventClosure = renderEventHandlerClosure(view, def.index, elementEventFullName(output.target, output.eventName));
	        var /** @type {?} */ listenTarget = output.target;
	        var /** @type {?} */ listenerView = view;
	        if (output.target === 'component') {
	            listenTarget = null;
	            listenerView = compView;
	        }
	        var /** @type {?} */ disposable = (listenerView.renderer.listen(listenTarget || el, output.eventName, handleEventClosure)); /** @type {?} */
	        ((view.disposables))[def.outputIndex + i] = disposable;
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} index
	 * @param {?} eventName
	 * @return {?}
	 */
	function renderEventHandlerClosure(view, index, eventName) {
	    return function (event) {
	        try {
	            return dispatchEvent(view, index, eventName, event);
	        }
	        catch (e) {
	            // Attention: Don't rethrow, to keep in sync with directive events.
	            view.root.errorHandler.handleError(e);
	        }
	    };
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @param {?} v0
	 * @param {?} v1
	 * @param {?} v2
	 * @param {?} v3
	 * @param {?} v4
	 * @param {?} v5
	 * @param {?} v6
	 * @param {?} v7
	 * @param {?} v8
	 * @param {?} v9
	 * @return {?}
	 */
	function checkAndUpdateElementInline(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
	    var /** @type {?} */ bindLen = def.bindings.length;
	    var /** @type {?} */ changed = false;
	    if (bindLen > 0 && checkAndUpdateElementValue(view, def, 0, v0))
	        changed = true;
	    if (bindLen > 1 && checkAndUpdateElementValue(view, def, 1, v1))
	        changed = true;
	    if (bindLen > 2 && checkAndUpdateElementValue(view, def, 2, v2))
	        changed = true;
	    if (bindLen > 3 && checkAndUpdateElementValue(view, def, 3, v3))
	        changed = true;
	    if (bindLen > 4 && checkAndUpdateElementValue(view, def, 4, v4))
	        changed = true;
	    if (bindLen > 5 && checkAndUpdateElementValue(view, def, 5, v5))
	        changed = true;
	    if (bindLen > 6 && checkAndUpdateElementValue(view, def, 6, v6))
	        changed = true;
	    if (bindLen > 7 && checkAndUpdateElementValue(view, def, 7, v7))
	        changed = true;
	    if (bindLen > 8 && checkAndUpdateElementValue(view, def, 8, v8))
	        changed = true;
	    if (bindLen > 9 && checkAndUpdateElementValue(view, def, 9, v9))
	        changed = true;
	    return changed;
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @param {?} values
	 * @return {?}
	 */
	function checkAndUpdateElementDynamic(view, def, values) {
	    var /** @type {?} */ changed = false;
	    for (var /** @type {?} */ i = 0; i < values.length; i++) {
	        if (checkAndUpdateElementValue(view, def, i, values[i]))
	            changed = true;
	    }
	    return changed;
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @param {?} bindingIdx
	 * @param {?} value
	 * @return {?}
	 */
	function checkAndUpdateElementValue(view, def, bindingIdx, value) {
	    if (!checkAndUpdateBinding(view, def, bindingIdx, value)) {
	        return false;
	    }
	    var /** @type {?} */ binding = def.bindings[bindingIdx];
	    var /** @type {?} */ elData = asElementData(view, def.index);
	    var /** @type {?} */ renderNode$$1 = elData.renderElement;
	    var /** @type {?} */ name = ((binding.name));
	    switch (binding.flags & 15 /* Types */) {
	        case 1 /* TypeElementAttribute */:
	            setElementAttribute(view, binding, renderNode$$1, binding.ns, name, value);
	            break;
	        case 2 /* TypeElementClass */:
	            setElementClass(view, renderNode$$1, name, value);
	            break;
	        case 4 /* TypeElementStyle */:
	            setElementStyle(view, binding, renderNode$$1, name, value);
	            break;
	        case 8 /* TypeProperty */:
	            var /** @type {?} */ bindView = (def.flags & 33554432 /* ComponentView */ &&
	                binding.flags & 32 /* SyntheticHostProperty */) ?
	                elData.componentView :
	                view;
	            setElementProperty(bindView, binding, renderNode$$1, name, value);
	            break;
	    }
	    return true;
	}
	/**
	 * @param {?} view
	 * @param {?} binding
	 * @param {?} renderNode
	 * @param {?} ns
	 * @param {?} name
	 * @param {?} value
	 * @return {?}
	 */
	function setElementAttribute(view, binding, renderNode$$1, ns, name, value) {
	    var /** @type {?} */ securityContext = binding.securityContext;
	    var /** @type {?} */ renderValue = securityContext ? view.root.sanitizer.sanitize(securityContext, value) : value;
	    renderValue = renderValue != null ? renderValue.toString() : null;
	    var /** @type {?} */ renderer = view.renderer;
	    if (value != null) {
	        renderer.setAttribute(renderNode$$1, name, renderValue, ns);
	    }
	    else {
	        renderer.removeAttribute(renderNode$$1, name, ns);
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} renderNode
	 * @param {?} name
	 * @param {?} value
	 * @return {?}
	 */
	function setElementClass(view, renderNode$$1, name, value) {
	    var /** @type {?} */ renderer = view.renderer;
	    if (value) {
	        renderer.addClass(renderNode$$1, name);
	    }
	    else {
	        renderer.removeClass(renderNode$$1, name);
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} binding
	 * @param {?} renderNode
	 * @param {?} name
	 * @param {?} value
	 * @return {?}
	 */
	function setElementStyle(view, binding, renderNode$$1, name, value) {
	    var /** @type {?} */ renderValue = view.root.sanitizer.sanitize(SecurityContext.STYLE, /** @type {?} */ (value));
	    if (renderValue != null) {
	        renderValue = renderValue.toString();
	        var /** @type {?} */ unit = binding.suffix;
	        if (unit != null) {
	            renderValue = renderValue + unit;
	        }
	    }
	    else {
	        renderValue = null;
	    }
	    var /** @type {?} */ renderer = view.renderer;
	    if (renderValue != null) {
	        renderer.setStyle(renderNode$$1, name, renderValue);
	    }
	    else {
	        renderer.removeStyle(renderNode$$1, name);
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} binding
	 * @param {?} renderNode
	 * @param {?} name
	 * @param {?} value
	 * @return {?}
	 */
	function setElementProperty(view, binding, renderNode$$1, name, value) {
	    var /** @type {?} */ securityContext = binding.securityContext;
	    var /** @type {?} */ renderValue = securityContext ? view.root.sanitizer.sanitize(securityContext, value) : value;
	    view.renderer.setProperty(renderNode$$1, name, renderValue);
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var NOT_CREATED$1 = new Object();
	var InjectorRefTokenKey$1 = tokenKey(Injector);
	var NgModuleRefTokenKey = tokenKey(NgModuleRef);
	/**
	 * @param {?} flags
	 * @param {?} token
	 * @param {?} value
	 * @param {?} deps
	 * @return {?}
	 */
	function moduleProvideDef(flags, token, value, deps) {
	    var /** @type {?} */ depDefs = splitDepsDsl(deps);
	    return {
	        // will bet set by the module definition
	        index: -1,
	        deps: depDefs, flags: flags, token: token, value: value
	    };
	}
	/**
	 * @param {?} providers
	 * @return {?}
	 */
	function moduleDef(providers) {
	    var /** @type {?} */ providersByKey = {};
	    for (var /** @type {?} */ i = 0; i < providers.length; i++) {
	        var /** @type {?} */ provider = providers[i];
	        provider.index = i;
	        providersByKey[tokenKey(provider.token)] = provider;
	    }
	    return {
	        // Will be filled later...
	        factory: null,
	        providersByKey: providersByKey,
	        providers: providers
	    };
	}
	/**
	 * @param {?} data
	 * @return {?}
	 */
	function initNgModule(data) {
	    var /** @type {?} */ def = data._def;
	    var /** @type {?} */ providers = data._providers = new Array(def.providers.length);
	    for (var /** @type {?} */ i = 0; i < def.providers.length; i++) {
	        var /** @type {?} */ provDef = def.providers[i];
	        providers[i] = provDef.flags & 4096 /* LazyProvider */ ? NOT_CREATED$1 :
	            _createProviderInstance$1(data, provDef);
	    }
	}
	/**
	 * @param {?} data
	 * @param {?} depDef
	 * @param {?=} notFoundValue
	 * @return {?}
	 */
	function resolveNgModuleDep(data, depDef, notFoundValue) {
	    if (notFoundValue === void 0) { notFoundValue = Injector.THROW_IF_NOT_FOUND; }
	    if (depDef.flags & 8 /* Value */) {
	        return depDef.token;
	    }
	    if (depDef.flags & 2 /* Optional */) {
	        notFoundValue = null;
	    }
	    if (depDef.flags & 1 /* SkipSelf */) {
	        return data._parent.get(depDef.token, notFoundValue);
	    }
	    var /** @type {?} */ tokenKey$$1 = depDef.tokenKey;
	    switch (tokenKey$$1) {
	        case InjectorRefTokenKey$1:
	        case NgModuleRefTokenKey:
	            return data;
	    }
	    var /** @type {?} */ providerDef = data._def.providersByKey[tokenKey$$1];
	    if (providerDef) {
	        var /** @type {?} */ providerInstance = data._providers[providerDef.index];
	        if (providerInstance === NOT_CREATED$1) {
	            providerInstance = data._providers[providerDef.index] =
	                _createProviderInstance$1(data, providerDef);
	        }
	        return providerInstance;
	    }
	    return data._parent.get(depDef.token, notFoundValue);
	}
	/**
	 * @param {?} ngModule
	 * @param {?} providerDef
	 * @return {?}
	 */
	function _createProviderInstance$1(ngModule, providerDef) {
	    var /** @type {?} */ injectable;
	    switch (providerDef.flags & 201347067 /* Types */) {
	        case 512 /* TypeClassProvider */:
	            injectable = _createClass(ngModule, providerDef.value, providerDef.deps);
	            break;
	        case 1024 /* TypeFactoryProvider */:
	            injectable = _callFactory(ngModule, providerDef.value, providerDef.deps);
	            break;
	        case 2048 /* TypeUseExistingProvider */:
	            injectable = resolveNgModuleDep(ngModule, providerDef.deps[0]);
	            break;
	        case 256 /* TypeValueProvider */:
	            injectable = providerDef.value;
	            break;
	    }
	    return injectable;
	}
	/**
	 * @param {?} ngModule
	 * @param {?} ctor
	 * @param {?} deps
	 * @return {?}
	 */
	function _createClass(ngModule, ctor, deps) {
	    var /** @type {?} */ len = deps.length;
	    var /** @type {?} */ injectable;
	    switch (len) {
	        case 0:
	            injectable = new ctor();
	            break;
	        case 1:
	            injectable = new ctor(resolveNgModuleDep(ngModule, deps[0]));
	            break;
	        case 2:
	            injectable =
	                new ctor(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]));
	            break;
	        case 3:
	            injectable = new ctor(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]), resolveNgModuleDep(ngModule, deps[2]));
	            break;
	        default:
	            var /** @type {?} */ depValues = new Array(len);
	            for (var /** @type {?} */ i = 0; i < len; i++) {
	                depValues[i] = resolveNgModuleDep(ngModule, deps[i]);
	            }
	            injectable = new (ctor.bind.apply(ctor, [void 0].concat(depValues)))();
	    }
	    return injectable;
	}
	/**
	 * @param {?} ngModule
	 * @param {?} factory
	 * @param {?} deps
	 * @return {?}
	 */
	function _callFactory(ngModule, factory, deps) {
	    var /** @type {?} */ len = deps.length;
	    var /** @type {?} */ injectable;
	    switch (len) {
	        case 0:
	            injectable = factory();
	            break;
	        case 1:
	            injectable = factory(resolveNgModuleDep(ngModule, deps[0]));
	            break;
	        case 2:
	            injectable =
	                factory(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]));
	            break;
	        case 3:
	            injectable = factory(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]), resolveNgModuleDep(ngModule, deps[2]));
	            break;
	        default:
	            var /** @type {?} */ depValues = Array(len);
	            for (var /** @type {?} */ i = 0; i < len; i++) {
	                depValues[i] = resolveNgModuleDep(ngModule, deps[i]);
	            }
	            injectable = factory.apply(void 0, depValues);
	    }
	    return injectable;
	}
	/**
	 * @param {?} ngModule
	 * @param {?} lifecycles
	 * @return {?}
	 */
	function callNgModuleLifecycle(ngModule, lifecycles) {
	    var /** @type {?} */ def = ngModule._def;
	    for (var /** @type {?} */ i = 0; i < def.providers.length; i++) {
	        var /** @type {?} */ provDef = def.providers[i];
	        if (provDef.flags & 131072 /* OnDestroy */) {
	            var /** @type {?} */ instance = ngModule._providers[i];
	            if (instance && instance !== NOT_CREATED$1) {
	                instance.ngOnDestroy();
	            }
	        }
	    }
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} parentView
	 * @param {?} elementData
	 * @param {?} viewIndex
	 * @param {?} view
	 * @return {?}
	 */
	function attachEmbeddedView(parentView, elementData, viewIndex, view) {
	    var /** @type {?} */ embeddedViews = ((elementData.viewContainer))._embeddedViews;
	    if (viewIndex === null || viewIndex === undefined) {
	        viewIndex = embeddedViews.length;
	    }
	    view.viewContainerParent = parentView;
	    addToArray(embeddedViews, /** @type {?} */ ((viewIndex)), view);
	    attachProjectedView(elementData, view);
	    Services.dirtyParentQueries(view);
	    var /** @type {?} */ prevView = ((viewIndex)) > 0 ? embeddedViews[((viewIndex)) - 1] : null;
	    renderAttachEmbeddedView(elementData, prevView, view);
	}
	/**
	 * @param {?} vcElementData
	 * @param {?} view
	 * @return {?}
	 */
	function attachProjectedView(vcElementData, view) {
	    var /** @type {?} */ dvcElementData = declaredViewContainer(view);
	    if (!dvcElementData || dvcElementData === vcElementData ||
	        view.state & 16 /* IsProjectedView */) {
	        return;
	    }
	    // Note: For performance reasons, we
	    // - add a view to template._projectedViews only 1x throughout its lifetime,
	    //   and remove it not until the view is destroyed.
	    //   (hard, as when a parent view is attached/detached we would need to attach/detach all
	    //    nested projected views as well, even accross component boundaries).
	    // - don't track the insertion order of views in the projected views array
	    //   (hard, as when the views of the same template are inserted different view containers)
	    view.state |= 16 /* IsProjectedView */;
	    var /** @type {?} */ projectedViews = dvcElementData.template._projectedViews;
	    if (!projectedViews) {
	        projectedViews = dvcElementData.template._projectedViews = [];
	    }
	    projectedViews.push(view);
	    // Note: we are changing the NodeDef here as we cannot calculate
	    // the fact whether a template is used for projection during compilation.
	    markNodeAsProjectedTemplate(/** @type {?} */ ((view.parent)).def, /** @type {?} */ ((view.parentNodeDef)));
	}
	/**
	 * @param {?} viewDef
	 * @param {?} nodeDef
	 * @return {?}
	 */
	function markNodeAsProjectedTemplate(viewDef, nodeDef) {
	    if (nodeDef.flags & 4 /* ProjectedTemplate */) {
	        return;
	    }
	    viewDef.nodeFlags |= 4 /* ProjectedTemplate */;
	    nodeDef.flags |= 4 /* ProjectedTemplate */;
	    var /** @type {?} */ parentNodeDef = nodeDef.parent;
	    while (parentNodeDef) {
	        parentNodeDef.childFlags |= 4 /* ProjectedTemplate */;
	        parentNodeDef = parentNodeDef.parent;
	    }
	}
	/**
	 * @param {?} elementData
	 * @param {?=} viewIndex
	 * @return {?}
	 */
	function detachEmbeddedView(elementData, viewIndex) {
	    var /** @type {?} */ embeddedViews = ((elementData.viewContainer))._embeddedViews;
	    if (viewIndex == null || viewIndex >= embeddedViews.length) {
	        viewIndex = embeddedViews.length - 1;
	    }
	    if (viewIndex < 0) {
	        return null;
	    }
	    var /** @type {?} */ view = embeddedViews[viewIndex];
	    view.viewContainerParent = null;
	    removeFromArray(embeddedViews, viewIndex);
	    // See attachProjectedView for why we don't update projectedViews here.
	    Services.dirtyParentQueries(view);
	    renderDetachView(view);
	    return view;
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function detachProjectedView(view) {
	    if (!(view.state & 16 /* IsProjectedView */)) {
	        return;
	    }
	    var /** @type {?} */ dvcElementData = declaredViewContainer(view);
	    if (dvcElementData) {
	        var /** @type {?} */ projectedViews = dvcElementData.template._projectedViews;
	        if (projectedViews) {
	            removeFromArray(projectedViews, projectedViews.indexOf(view));
	            Services.dirtyParentQueries(view);
	        }
	    }
	}
	/**
	 * @param {?} elementData
	 * @param {?} oldViewIndex
	 * @param {?} newViewIndex
	 * @return {?}
	 */
	function moveEmbeddedView(elementData, oldViewIndex, newViewIndex) {
	    var /** @type {?} */ embeddedViews = ((elementData.viewContainer))._embeddedViews;
	    var /** @type {?} */ view = embeddedViews[oldViewIndex];
	    removeFromArray(embeddedViews, oldViewIndex);
	    if (newViewIndex == null) {
	        newViewIndex = embeddedViews.length;
	    }
	    addToArray(embeddedViews, newViewIndex, view);
	    // Note: Don't need to change projectedViews as the order in there
	    // as always invalid...
	    Services.dirtyParentQueries(view);
	    renderDetachView(view);
	    var /** @type {?} */ prevView = newViewIndex > 0 ? embeddedViews[newViewIndex - 1] : null;
	    renderAttachEmbeddedView(elementData, prevView, view);
	    return view;
	}
	/**
	 * @param {?} elementData
	 * @param {?} prevView
	 * @param {?} view
	 * @return {?}
	 */
	function renderAttachEmbeddedView(elementData, prevView, view) {
	    var /** @type {?} */ prevRenderNode = prevView ? renderNode(prevView, /** @type {?} */ ((prevView.def.lastRenderRootNode))) :
	        elementData.renderElement;
	    var /** @type {?} */ parentNode = view.renderer.parentNode(prevRenderNode);
	    var /** @type {?} */ nextSibling = view.renderer.nextSibling(prevRenderNode);
	    // Note: We can't check if `nextSibling` is present, as on WebWorkers it will always be!
	    // However, browsers automatically do `appendChild` when there is no `nextSibling`.
	    visitRootRenderNodes(view, 2 /* InsertBefore */, parentNode, nextSibling, undefined);
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function renderDetachView(view) {
	    visitRootRenderNodes(view, 3 /* RemoveChild */, null, null, undefined);
	}
	/**
	 * @param {?} arr
	 * @param {?} index
	 * @param {?} value
	 * @return {?}
	 */
	function addToArray(arr, index, value) {
	    // perf: array.push is faster than array.splice!
	    if (index >= arr.length) {
	        arr.push(value);
	    }
	    else {
	        arr.splice(index, 0, value);
	    }
	}
	/**
	 * @param {?} arr
	 * @param {?} index
	 * @return {?}
	 */
	function removeFromArray(arr, index) {
	    // perf: array.pop is faster than array.splice!
	    if (index >= arr.length - 1) {
	        arr.pop();
	    }
	    else {
	        arr.splice(index, 1);
	    }
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var EMPTY_CONTEXT = new Object();
	/**
	 * @param {?} selector
	 * @param {?} componentType
	 * @param {?} viewDefFactory
	 * @param {?} inputs
	 * @param {?} outputs
	 * @param {?} ngContentSelectors
	 * @return {?}
	 */
	function createComponentFactory(selector, componentType, viewDefFactory, inputs, outputs, ngContentSelectors) {
	    return new ComponentFactory_(selector, componentType, viewDefFactory, inputs, outputs, ngContentSelectors);
	}
	/**
	 * @param {?} componentFactory
	 * @return {?}
	 */
	function getComponentViewDefinitionFactory(componentFactory) {
	    return ((componentFactory)).viewDefFactory;
	}
	var ComponentFactory_ = (function (_super) {
	    __extends(ComponentFactory_, _super);
	    /**
	     * @param {?} selector
	     * @param {?} componentType
	     * @param {?} viewDefFactory
	     * @param {?} _inputs
	     * @param {?} _outputs
	     * @param {?} ngContentSelectors
	     */
	    function ComponentFactory_(selector, componentType, viewDefFactory, _inputs, _outputs, ngContentSelectors) {
	        var _this = 
	        // Attention: this ctor is called as top level function.
	        // Putting any logic in here will destroy closure tree shaking!
	        _super.call(this) || this;
	        _this.selector = selector;
	        _this.componentType = componentType;
	        _this._inputs = _inputs;
	        _this._outputs = _outputs;
	        _this.ngContentSelectors = ngContentSelectors;
	        _this.viewDefFactory = viewDefFactory;
	        return _this;
	    }
	    Object.defineProperty(ComponentFactory_.prototype, "inputs", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            var /** @type {?} */ inputsArr = [];
	            var /** @type {?} */ inputs = ((this._inputs));
	            for (var /** @type {?} */ propName in inputs) {
	                var /** @type {?} */ templateName = inputs[propName];
	                inputsArr.push({ propName: propName, templateName: templateName });
	            }
	            return inputsArr;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ComponentFactory_.prototype, "outputs", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            var /** @type {?} */ outputsArr = [];
	            for (var /** @type {?} */ propName in this._outputs) {
	                var /** @type {?} */ templateName = this._outputs[propName];
	                outputsArr.push({ propName: propName, templateName: templateName });
	            }
	            return outputsArr;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Creates a new component.
	     * @param {?} injector
	     * @param {?=} projectableNodes
	     * @param {?=} rootSelectorOrNode
	     * @param {?=} ngModule
	     * @return {?}
	     */
	    ComponentFactory_.prototype.create = function (injector, projectableNodes, rootSelectorOrNode, ngModule) {
	        if (!ngModule) {
	            throw new Error('ngModule should be provided');
	        }
	        var /** @type {?} */ viewDef = resolveDefinition(this.viewDefFactory);
	        var /** @type {?} */ componentNodeIndex = ((((viewDef.nodes[0].element)).componentProvider)).index;
	        var /** @type {?} */ view = Services.createRootView(injector, projectableNodes || [], rootSelectorOrNode, viewDef, ngModule, EMPTY_CONTEXT);
	        var /** @type {?} */ component = asProviderData(view, componentNodeIndex).instance;
	        if (rootSelectorOrNode) {
	            view.renderer.setAttribute(asElementData(view, 0).renderElement, 'ng-version', VERSION.full);
	        }
	        return new ComponentRef_(view, new ViewRef_(view), component);
	    };
	    return ComponentFactory_;
	}(ComponentFactory));
	var ComponentRef_ = (function (_super) {
	    __extends(ComponentRef_, _super);
	    /**
	     * @param {?} _view
	     * @param {?} _viewRef
	     * @param {?} _component
	     */
	    function ComponentRef_(_view, _viewRef, _component) {
	        var _this = _super.call(this) || this;
	        _this._view = _view;
	        _this._viewRef = _viewRef;
	        _this._component = _component;
	        _this._elDef = _this._view.def.nodes[0];
	        return _this;
	    }
	    Object.defineProperty(ComponentRef_.prototype, "location", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            return new ElementRef(asElementData(this._view, this._elDef.index).renderElement);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ComponentRef_.prototype, "injector", {
	        /**
	         * @return {?}
	         */
	        get: function () { return new Injector_(this._view, this._elDef); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ComponentRef_.prototype, "instance", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._component; },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(ComponentRef_.prototype, "hostView", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._viewRef; },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(ComponentRef_.prototype, "changeDetectorRef", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._viewRef; },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(ComponentRef_.prototype, "componentType", {
	        /**
	         * @return {?}
	         */
	        get: function () { return (this._component.constructor); },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @return {?}
	     */
	    ComponentRef_.prototype.destroy = function () { this._viewRef.destroy(); };
	    /**
	     * @param {?} callback
	     * @return {?}
	     */
	    ComponentRef_.prototype.onDestroy = function (callback) { this._viewRef.onDestroy(callback); };
	    return ComponentRef_;
	}(ComponentRef));
	/**
	 * @param {?} view
	 * @param {?} elDef
	 * @param {?} elData
	 * @return {?}
	 */
	function createViewContainerData(view, elDef, elData) {
	    return new ViewContainerRef_(view, elDef, elData);
	}
	var ViewContainerRef_ = (function () {
	    /**
	     * @param {?} _view
	     * @param {?} _elDef
	     * @param {?} _data
	     */
	    function ViewContainerRef_(_view, _elDef, _data) {
	        this._view = _view;
	        this._elDef = _elDef;
	        this._data = _data;
	        /**
	         * \@internal
	         */
	        this._embeddedViews = [];
	    }
	    Object.defineProperty(ViewContainerRef_.prototype, "element", {
	        /**
	         * @return {?}
	         */
	        get: function () { return new ElementRef(this._data.renderElement); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ViewContainerRef_.prototype, "injector", {
	        /**
	         * @return {?}
	         */
	        get: function () { return new Injector_(this._view, this._elDef); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ViewContainerRef_.prototype, "parentInjector", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            var /** @type {?} */ view = this._view;
	            var /** @type {?} */ elDef = this._elDef.parent;
	            while (!elDef && view) {
	                elDef = viewParentEl(view);
	                view = ((view.parent));
	            }
	            return view ? new Injector_(view, elDef) : new Injector_(this._view, null);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @return {?}
	     */
	    ViewContainerRef_.prototype.clear = function () {
	        var /** @type {?} */ len = this._embeddedViews.length;
	        for (var /** @type {?} */ i = len - 1; i >= 0; i--) {
	            var /** @type {?} */ view = ((detachEmbeddedView(this._data, i)));
	            Services.destroyView(view);
	        }
	    };
	    /**
	     * @param {?} index
	     * @return {?}
	     */
	    ViewContainerRef_.prototype.get = function (index) {
	        var /** @type {?} */ view = this._embeddedViews[index];
	        if (view) {
	            var /** @type {?} */ ref = new ViewRef_(view);
	            ref.attachToViewContainerRef(this);
	            return ref;
	        }
	        return null;
	    };
	    Object.defineProperty(ViewContainerRef_.prototype, "length", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._embeddedViews.length; },
	        enumerable: true,
	        configurable: true
	    });
	    
	    /**
	     * @template C
	     * @param {?} templateRef
	     * @param {?=} context
	     * @param {?=} index
	     * @return {?}
	     */
	    ViewContainerRef_.prototype.createEmbeddedView = function (templateRef, context, index) {
	        var /** @type {?} */ viewRef = templateRef.createEmbeddedView(context || ({}));
	        this.insert(viewRef, index);
	        return viewRef;
	    };
	    /**
	     * @template C
	     * @param {?} componentFactory
	     * @param {?=} index
	     * @param {?=} injector
	     * @param {?=} projectableNodes
	     * @param {?=} ngModuleRef
	     * @return {?}
	     */
	    ViewContainerRef_.prototype.createComponent = function (componentFactory, index, injector, projectableNodes, ngModuleRef) {
	        var /** @type {?} */ contextInjector = injector || this.parentInjector;
	        if (!ngModuleRef && !(componentFactory instanceof ComponentFactoryBoundToModule)) {
	            ngModuleRef = contextInjector.get(NgModuleRef);
	        }
	        var /** @type {?} */ componentRef = componentFactory.create(contextInjector, projectableNodes, undefined, ngModuleRef);
	        this.insert(componentRef.hostView, index);
	        return componentRef;
	    };
	    /**
	     * @param {?} viewRef
	     * @param {?=} index
	     * @return {?}
	     */
	    ViewContainerRef_.prototype.insert = function (viewRef, index) {
	        var /** @type {?} */ viewRef_ = (viewRef);
	        var /** @type {?} */ viewData = viewRef_._view;
	        attachEmbeddedView(this._view, this._data, index, viewData);
	        viewRef_.attachToViewContainerRef(this);
	        return viewRef;
	    };
	    /**
	     * @param {?} viewRef
	     * @param {?} currentIndex
	     * @return {?}
	     */
	    ViewContainerRef_.prototype.move = function (viewRef, currentIndex) {
	        var /** @type {?} */ previousIndex = this._embeddedViews.indexOf(viewRef._view);
	        moveEmbeddedView(this._data, previousIndex, currentIndex);
	        return viewRef;
	    };
	    /**
	     * @param {?} viewRef
	     * @return {?}
	     */
	    ViewContainerRef_.prototype.indexOf = function (viewRef) {
	        return this._embeddedViews.indexOf(((viewRef))._view);
	    };
	    /**
	     * @param {?=} index
	     * @return {?}
	     */
	    ViewContainerRef_.prototype.remove = function (index) {
	        var /** @type {?} */ viewData = detachEmbeddedView(this._data, index);
	        if (viewData) {
	            Services.destroyView(viewData);
	        }
	    };
	    /**
	     * @param {?=} index
	     * @return {?}
	     */
	    ViewContainerRef_.prototype.detach = function (index) {
	        var /** @type {?} */ view = detachEmbeddedView(this._data, index);
	        return view ? new ViewRef_(view) : null;
	    };
	    return ViewContainerRef_;
	}());
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function createChangeDetectorRef(view) {
	    return new ViewRef_(view);
	}
	var ViewRef_ = (function () {
	    /**
	     * @param {?} _view
	     */
	    function ViewRef_(_view) {
	        this._view = _view;
	        this._viewContainerRef = null;
	        this._appRef = null;
	    }
	    Object.defineProperty(ViewRef_.prototype, "rootNodes", {
	        /**
	         * @return {?}
	         */
	        get: function () { return rootRenderNodes(this._view); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ViewRef_.prototype, "context", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._view.context; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ViewRef_.prototype, "destroyed", {
	        /**
	         * @return {?}
	         */
	        get: function () { return (this._view.state & 128 /* Destroyed */) !== 0; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @return {?}
	     */
	    ViewRef_.prototype.markForCheck = function () { markParentViewsForCheck(this._view); };
	    /**
	     * @return {?}
	     */
	    ViewRef_.prototype.detach = function () { this._view.state &= ~4 /* Attached */; };
	    /**
	     * @return {?}
	     */
	    ViewRef_.prototype.detectChanges = function () {
	        var /** @type {?} */ fs = this._view.root.rendererFactory;
	        if (fs.begin) {
	            fs.begin();
	        }
	        Services.checkAndUpdateView(this._view);
	        if (fs.end) {
	            fs.end();
	        }
	    };
	    /**
	     * @return {?}
	     */
	    ViewRef_.prototype.checkNoChanges = function () { Services.checkNoChangesView(this._view); };
	    /**
	     * @return {?}
	     */
	    ViewRef_.prototype.reattach = function () { this._view.state |= 4 /* Attached */; };
	    /**
	     * @param {?} callback
	     * @return {?}
	     */
	    ViewRef_.prototype.onDestroy = function (callback) {
	        if (!this._view.disposables) {
	            this._view.disposables = [];
	        }
	        this._view.disposables.push(/** @type {?} */ (callback));
	    };
	    /**
	     * @return {?}
	     */
	    ViewRef_.prototype.destroy = function () {
	        if (this._appRef) {
	            this._appRef.detachView(this);
	        }
	        else if (this._viewContainerRef) {
	            this._viewContainerRef.detach(this._viewContainerRef.indexOf(this));
	        }
	        Services.destroyView(this._view);
	    };
	    /**
	     * @return {?}
	     */
	    ViewRef_.prototype.detachFromAppRef = function () {
	        this._appRef = null;
	        renderDetachView(this._view);
	        Services.dirtyParentQueries(this._view);
	    };
	    /**
	     * @param {?} appRef
	     * @return {?}
	     */
	    ViewRef_.prototype.attachToAppRef = function (appRef) {
	        if (this._viewContainerRef) {
	            throw new Error('This view is already attached to a ViewContainer!');
	        }
	        this._appRef = appRef;
	    };
	    /**
	     * @param {?} vcRef
	     * @return {?}
	     */
	    ViewRef_.prototype.attachToViewContainerRef = function (vcRef) {
	        if (this._appRef) {
	            throw new Error('This view is already attached directly to the ApplicationRef!');
	        }
	        this._viewContainerRef = vcRef;
	    };
	    return ViewRef_;
	}());
	/**
	 * @param {?} view
	 * @param {?} def
	 * @return {?}
	 */
	function createTemplateData(view, def) {
	    return new TemplateRef_(view, def);
	}
	var TemplateRef_ = (function (_super) {
	    __extends(TemplateRef_, _super);
	    /**
	     * @param {?} _parentView
	     * @param {?} _def
	     */
	    function TemplateRef_(_parentView, _def) {
	        var _this = _super.call(this) || this;
	        _this._parentView = _parentView;
	        _this._def = _def;
	        return _this;
	    }
	    /**
	     * @param {?} context
	     * @return {?}
	     */
	    TemplateRef_.prototype.createEmbeddedView = function (context) {
	        return new ViewRef_(Services.createEmbeddedView(this._parentView, this._def, /** @type {?} */ ((((this._def.element)).template)), context));
	    };
	    Object.defineProperty(TemplateRef_.prototype, "elementRef", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            return new ElementRef(asElementData(this._parentView, this._def.index).renderElement);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return TemplateRef_;
	}(TemplateRef));
	/**
	 * @param {?} view
	 * @param {?} elDef
	 * @return {?}
	 */
	function createInjector(view, elDef) {
	    return new Injector_(view, elDef);
	}
	var Injector_ = (function () {
	    /**
	     * @param {?} view
	     * @param {?} elDef
	     */
	    function Injector_(view, elDef) {
	        this.view = view;
	        this.elDef = elDef;
	    }
	    /**
	     * @param {?} token
	     * @param {?=} notFoundValue
	     * @return {?}
	     */
	    Injector_.prototype.get = function (token, notFoundValue) {
	        if (notFoundValue === void 0) { notFoundValue = Injector.THROW_IF_NOT_FOUND; }
	        var /** @type {?} */ allowPrivateServices = this.elDef ? (this.elDef.flags & 33554432 /* ComponentView */) !== 0 : false;
	        return Services.resolveDep(this.view, this.elDef, allowPrivateServices, { flags: 0 /* None */, token: token, tokenKey: tokenKey(token) }, notFoundValue);
	    };
	    return Injector_;
	}());
	/**
	 * @param {?} view
	 * @param {?} index
	 * @return {?}
	 */
	function nodeValue(view, index) {
	    var /** @type {?} */ def = view.def.nodes[index];
	    if (def.flags & 1 /* TypeElement */) {
	        var /** @type {?} */ elData = asElementData(view, def.index);
	        return ((def.element)).template ? elData.template : elData.renderElement;
	    }
	    else if (def.flags & 2 /* TypeText */) {
	        return asTextData(view, def.index).renderText;
	    }
	    else if (def.flags & (20224 /* CatProvider */ | 16 /* TypePipe */)) {
	        return asProviderData(view, def.index).instance;
	    }
	    throw new Error("Illegal state: read nodeValue for node index " + index);
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function createRendererV1(view) {
	    return new RendererAdapter(view.renderer);
	}
	var RendererAdapter = (function () {
	    /**
	     * @param {?} delegate
	     */
	    function RendererAdapter(delegate) {
	        this.delegate = delegate;
	    }
	    /**
	     * @param {?} selectorOrNode
	     * @return {?}
	     */
	    RendererAdapter.prototype.selectRootElement = function (selectorOrNode) {
	        return this.delegate.selectRootElement(selectorOrNode);
	    };
	    /**
	     * @param {?} parent
	     * @param {?} namespaceAndName
	     * @return {?}
	     */
	    RendererAdapter.prototype.createElement = function (parent, namespaceAndName) {
	        var _a = splitNamespace(namespaceAndName), ns = _a[0], name = _a[1];
	        var /** @type {?} */ el = this.delegate.createElement(name, ns);
	        if (parent) {
	            this.delegate.appendChild(parent, el);
	        }
	        return el;
	    };
	    /**
	     * @param {?} hostElement
	     * @return {?}
	     */
	    RendererAdapter.prototype.createViewRoot = function (hostElement) { return hostElement; };
	    /**
	     * @param {?} parentElement
	     * @return {?}
	     */
	    RendererAdapter.prototype.createTemplateAnchor = function (parentElement) {
	        var /** @type {?} */ comment = this.delegate.createComment('');
	        if (parentElement) {
	            this.delegate.appendChild(parentElement, comment);
	        }
	        return comment;
	    };
	    /**
	     * @param {?} parentElement
	     * @param {?} value
	     * @return {?}
	     */
	    RendererAdapter.prototype.createText = function (parentElement, value) {
	        var /** @type {?} */ node = this.delegate.createText(value);
	        if (parentElement) {
	            this.delegate.appendChild(parentElement, node);
	        }
	        return node;
	    };
	    /**
	     * @param {?} parentElement
	     * @param {?} nodes
	     * @return {?}
	     */
	    RendererAdapter.prototype.projectNodes = function (parentElement, nodes) {
	        for (var /** @type {?} */ i = 0; i < nodes.length; i++) {
	            this.delegate.appendChild(parentElement, nodes[i]);
	        }
	    };
	    /**
	     * @param {?} node
	     * @param {?} viewRootNodes
	     * @return {?}
	     */
	    RendererAdapter.prototype.attachViewAfter = function (node, viewRootNodes) {
	        var /** @type {?} */ parentElement = this.delegate.parentNode(node);
	        var /** @type {?} */ nextSibling = this.delegate.nextSibling(node);
	        for (var /** @type {?} */ i = 0; i < viewRootNodes.length; i++) {
	            this.delegate.insertBefore(parentElement, viewRootNodes[i], nextSibling);
	        }
	    };
	    /**
	     * @param {?} viewRootNodes
	     * @return {?}
	     */
	    RendererAdapter.prototype.detachView = function (viewRootNodes) {
	        for (var /** @type {?} */ i = 0; i < viewRootNodes.length; i++) {
	            var /** @type {?} */ node = viewRootNodes[i];
	            var /** @type {?} */ parentElement = this.delegate.parentNode(node);
	            this.delegate.removeChild(parentElement, node);
	        }
	    };
	    /**
	     * @param {?} hostElement
	     * @param {?} viewAllNodes
	     * @return {?}
	     */
	    RendererAdapter.prototype.destroyView = function (hostElement, viewAllNodes) {
	        for (var /** @type {?} */ i = 0; i < viewAllNodes.length; i++) {
	            ((this.delegate.destroyNode))(viewAllNodes[i]);
	        }
	    };
	    /**
	     * @param {?} renderElement
	     * @param {?} name
	     * @param {?} callback
	     * @return {?}
	     */
	    RendererAdapter.prototype.listen = function (renderElement, name, callback) {
	        return this.delegate.listen(renderElement, name, /** @type {?} */ (callback));
	    };
	    /**
	     * @param {?} target
	     * @param {?} name
	     * @param {?} callback
	     * @return {?}
	     */
	    RendererAdapter.prototype.listenGlobal = function (target, name, callback) {
	        return this.delegate.listen(target, name, /** @type {?} */ (callback));
	    };
	    /**
	     * @param {?} renderElement
	     * @param {?} propertyName
	     * @param {?} propertyValue
	     * @return {?}
	     */
	    RendererAdapter.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) {
	        this.delegate.setProperty(renderElement, propertyName, propertyValue);
	    };
	    /**
	     * @param {?} renderElement
	     * @param {?} namespaceAndName
	     * @param {?} attributeValue
	     * @return {?}
	     */
	    RendererAdapter.prototype.setElementAttribute = function (renderElement, namespaceAndName, attributeValue) {
	        var _a = splitNamespace(namespaceAndName), ns = _a[0], name = _a[1];
	        if (attributeValue != null) {
	            this.delegate.setAttribute(renderElement, name, attributeValue, ns);
	        }
	        else {
	            this.delegate.removeAttribute(renderElement, name, ns);
	        }
	    };
	    /**
	     * @param {?} renderElement
	     * @param {?} propertyName
	     * @param {?} propertyValue
	     * @return {?}
	     */
	    RendererAdapter.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) { };
	    /**
	     * @param {?} renderElement
	     * @param {?} className
	     * @param {?} isAdd
	     * @return {?}
	     */
	    RendererAdapter.prototype.setElementClass = function (renderElement, className, isAdd) {
	        if (isAdd) {
	            this.delegate.addClass(renderElement, className);
	        }
	        else {
	            this.delegate.removeClass(renderElement, className);
	        }
	    };
	    /**
	     * @param {?} renderElement
	     * @param {?} styleName
	     * @param {?} styleValue
	     * @return {?}
	     */
	    RendererAdapter.prototype.setElementStyle = function (renderElement, styleName, styleValue) {
	        if (styleValue != null) {
	            this.delegate.setStyle(renderElement, styleName, styleValue);
	        }
	        else {
	            this.delegate.removeStyle(renderElement, styleName);
	        }
	    };
	    /**
	     * @param {?} renderElement
	     * @param {?} methodName
	     * @param {?} args
	     * @return {?}
	     */
	    RendererAdapter.prototype.invokeElementMethod = function (renderElement, methodName, args) {
	        ((renderElement))[methodName].apply(renderElement, args);
	    };
	    /**
	     * @param {?} renderNode
	     * @param {?} text
	     * @return {?}
	     */
	    RendererAdapter.prototype.setText = function (renderNode$$1, text) { this.delegate.setValue(renderNode$$1, text); };
	    /**
	     * @return {?}
	     */
	    RendererAdapter.prototype.animate = function () { throw new Error('Renderer.animate is no longer supported!'); };
	    return RendererAdapter;
	}());
	/**
	 * @param {?} moduleType
	 * @param {?} parent
	 * @param {?} bootstrapComponents
	 * @param {?} def
	 * @return {?}
	 */
	function createNgModuleRef(moduleType, parent, bootstrapComponents, def) {
	    return new NgModuleRef_(moduleType, parent, bootstrapComponents, def);
	}
	var NgModuleRef_ = (function () {
	    /**
	     * @param {?} _moduleType
	     * @param {?} _parent
	     * @param {?} _bootstrapComponents
	     * @param {?} _def
	     */
	    function NgModuleRef_(_moduleType, _parent, _bootstrapComponents, _def) {
	        this._moduleType = _moduleType;
	        this._parent = _parent;
	        this._bootstrapComponents = _bootstrapComponents;
	        this._def = _def;
	        this._destroyListeners = [];
	        this._destroyed = false;
	        initNgModule(this);
	    }
	    /**
	     * @param {?} token
	     * @param {?=} notFoundValue
	     * @return {?}
	     */
	    NgModuleRef_.prototype.get = function (token, notFoundValue) {
	        if (notFoundValue === void 0) { notFoundValue = Injector.THROW_IF_NOT_FOUND; }
	        return resolveNgModuleDep(this, { token: token, tokenKey: tokenKey(token), flags: 0 /* None */ }, notFoundValue);
	    };
	    Object.defineProperty(NgModuleRef_.prototype, "instance", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.get(this._moduleType); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgModuleRef_.prototype, "componentFactoryResolver", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.get(ComponentFactoryResolver); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgModuleRef_.prototype, "injector", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @return {?}
	     */
	    NgModuleRef_.prototype.destroy = function () {
	        if (this._destroyed) {
	            throw new Error("The ng module " + stringify(this.instance.constructor) + " has already been destroyed.");
	        }
	        this._destroyed = true;
	        callNgModuleLifecycle(this, 131072 /* OnDestroy */);
	        this._destroyListeners.forEach(function (listener) { return listener(); });
	    };
	    /**
	     * @param {?} callback
	     * @return {?}
	     */
	    NgModuleRef_.prototype.onDestroy = function (callback) { this._destroyListeners.push(callback); };
	    return NgModuleRef_;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var RendererV1TokenKey = tokenKey(Renderer);
	var Renderer2TokenKey = tokenKey(Renderer2);
	var ElementRefTokenKey = tokenKey(ElementRef);
	var ViewContainerRefTokenKey = tokenKey(ViewContainerRef);
	var TemplateRefTokenKey = tokenKey(TemplateRef);
	var ChangeDetectorRefTokenKey = tokenKey(ChangeDetectorRef);
	var InjectorRefTokenKey = tokenKey(Injector);
	var NOT_CREATED = new Object();
	/**
	 * @param {?} flags
	 * @param {?} matchedQueries
	 * @param {?} childCount
	 * @param {?} ctor
	 * @param {?} deps
	 * @param {?=} props
	 * @param {?=} outputs
	 * @return {?}
	 */
	function directiveDef(flags, matchedQueries, childCount, ctor, deps, props, outputs) {
	    var /** @type {?} */ bindings = [];
	    if (props) {
	        for (var /** @type {?} */ prop in props) {
	            var _a = props[prop], bindingIndex = _a[0], nonMinifiedName = _a[1];
	            bindings[bindingIndex] = {
	                flags: 8 /* TypeProperty */,
	                name: prop, nonMinifiedName: nonMinifiedName,
	                ns: null,
	                securityContext: null,
	                suffix: null
	            };
	        }
	    }
	    var /** @type {?} */ outputDefs = [];
	    if (outputs) {
	        for (var /** @type {?} */ propName in outputs) {
	            outputDefs.push({ type: 1 /* DirectiveOutput */, propName: propName, target: null, eventName: outputs[propName] });
	        }
	    }
	    flags |= 16384 /* TypeDirective */;
	    return _def(flags, matchedQueries, childCount, ctor, ctor, deps, bindings, outputDefs);
	}
	/**
	 * @param {?} flags
	 * @param {?} ctor
	 * @param {?} deps
	 * @return {?}
	 */
	function pipeDef(flags, ctor, deps) {
	    flags |= 16 /* TypePipe */;
	    return _def(flags, null, 0, ctor, ctor, deps);
	}
	/**
	 * @param {?} flags
	 * @param {?} matchedQueries
	 * @param {?} token
	 * @param {?} value
	 * @param {?} deps
	 * @return {?}
	 */
	function providerDef(flags, matchedQueries, token, value, deps) {
	    return _def(flags, matchedQueries, 0, token, value, deps);
	}
	/**
	 * @param {?} flags
	 * @param {?} matchedQueriesDsl
	 * @param {?} childCount
	 * @param {?} token
	 * @param {?} value
	 * @param {?} deps
	 * @param {?=} bindings
	 * @param {?=} outputs
	 * @return {?}
	 */
	function _def(flags, matchedQueriesDsl, childCount, token, value, deps, bindings, outputs) {
	    var _a = splitMatchedQueriesDsl(matchedQueriesDsl), matchedQueries = _a.matchedQueries, references = _a.references, matchedQueryIds = _a.matchedQueryIds;
	    if (!outputs) {
	        outputs = [];
	    }
	    if (!bindings) {
	        bindings = [];
	    }
	    var /** @type {?} */ depDefs = splitDepsDsl(deps);
	    return {
	        // will bet set by the view definition
	        index: -1,
	        parent: null,
	        renderParent: null,
	        bindingIndex: -1,
	        outputIndex: -1,
	        // regular values
	        flags: flags,
	        childFlags: 0,
	        directChildFlags: 0,
	        childMatchedQueries: 0, matchedQueries: matchedQueries, matchedQueryIds: matchedQueryIds, references: references,
	        ngContentIndex: -1, childCount: childCount, bindings: bindings,
	        bindingFlags: calcBindingFlags(bindings), outputs: outputs,
	        element: null,
	        provider: { token: token, value: value, deps: depDefs },
	        text: null,
	        query: null,
	        ngContent: null
	    };
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @return {?}
	 */
	function createProviderInstance(view, def) {
	    return def.flags & 4096 /* LazyProvider */ ? NOT_CREATED : _createProviderInstance(view, def);
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @return {?}
	 */
	function createPipeInstance(view, def) {
	    // deps are looked up from component.
	    var /** @type {?} */ compView = view;
	    while (compView.parent && !isComponentView(compView)) {
	        compView = compView.parent;
	    }
	    // pipes can see the private services of the component
	    var /** @type {?} */ allowPrivateServices = true;
	    // pipes are always eager and classes!
	    return createClass(/** @type {?} */ ((compView.parent)), /** @type {?} */ ((viewParentEl(compView))), allowPrivateServices, /** @type {?} */ ((def.provider)).value, /** @type {?} */ ((def.provider)).deps);
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @return {?}
	 */
	function createDirectiveInstance(view, def) {
	    // components can see other private services, other directives can't.
	    var /** @type {?} */ allowPrivateServices = (def.flags & 32768 /* Component */) > 0;
	    // directives are always eager and classes!
	    var /** @type {?} */ instance = createClass(view, /** @type {?} */ ((def.parent)), allowPrivateServices, /** @type {?} */ ((def.provider)).value, /** @type {?} */ ((def.provider)).deps);
	    if (def.outputs.length) {
	        for (var /** @type {?} */ i = 0; i < def.outputs.length; i++) {
	            var /** @type {?} */ output = def.outputs[i];
	            var /** @type {?} */ subscription = instance[((output.propName))].subscribe(eventHandlerClosure(view, /** @type {?} */ ((def.parent)).index, output.eventName)); /** @type {?} */
	            ((view.disposables))[def.outputIndex + i] = subscription.unsubscribe.bind(subscription);
	        }
	    }
	    return instance;
	}
	/**
	 * @param {?} view
	 * @param {?} index
	 * @param {?} eventName
	 * @return {?}
	 */
	function eventHandlerClosure(view, index, eventName) {
	    return function (event) {
	        try {
	            return dispatchEvent(view, index, eventName, event);
	        }
	        catch (e) {
	            // Attention: Don't rethrow, as it would cancel Observable subscriptions!
	            view.root.errorHandler.handleError(e);
	        }
	    };
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @param {?} v0
	 * @param {?} v1
	 * @param {?} v2
	 * @param {?} v3
	 * @param {?} v4
	 * @param {?} v5
	 * @param {?} v6
	 * @param {?} v7
	 * @param {?} v8
	 * @param {?} v9
	 * @return {?}
	 */
	function checkAndUpdateDirectiveInline(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
	    var /** @type {?} */ providerData = asProviderData(view, def.index);
	    var /** @type {?} */ directive = providerData.instance;
	    var /** @type {?} */ changed = false;
	    var /** @type {?} */ changes = ((undefined));
	    var /** @type {?} */ bindLen = def.bindings.length;
	    if (bindLen > 0 && checkBinding(view, def, 0, v0)) {
	        changed = true;
	        changes = updateProp(view, providerData, def, 0, v0, changes);
	    }
	    if (bindLen > 1 && checkBinding(view, def, 1, v1)) {
	        changed = true;
	        changes = updateProp(view, providerData, def, 1, v1, changes);
	    }
	    if (bindLen > 2 && checkBinding(view, def, 2, v2)) {
	        changed = true;
	        changes = updateProp(view, providerData, def, 2, v2, changes);
	    }
	    if (bindLen > 3 && checkBinding(view, def, 3, v3)) {
	        changed = true;
	        changes = updateProp(view, providerData, def, 3, v3, changes);
	    }
	    if (bindLen > 4 && checkBinding(view, def, 4, v4)) {
	        changed = true;
	        changes = updateProp(view, providerData, def, 4, v4, changes);
	    }
	    if (bindLen > 5 && checkBinding(view, def, 5, v5)) {
	        changed = true;
	        changes = updateProp(view, providerData, def, 5, v5, changes);
	    }
	    if (bindLen > 6 && checkBinding(view, def, 6, v6)) {
	        changed = true;
	        changes = updateProp(view, providerData, def, 6, v6, changes);
	    }
	    if (bindLen > 7 && checkBinding(view, def, 7, v7)) {
	        changed = true;
	        changes = updateProp(view, providerData, def, 7, v7, changes);
	    }
	    if (bindLen > 8 && checkBinding(view, def, 8, v8)) {
	        changed = true;
	        changes = updateProp(view, providerData, def, 8, v8, changes);
	    }
	    if (bindLen > 9 && checkBinding(view, def, 9, v9)) {
	        changed = true;
	        changes = updateProp(view, providerData, def, 9, v9, changes);
	    }
	    if (changes) {
	        directive.ngOnChanges(changes);
	    }
	    if ((view.state & 2 /* FirstCheck */) && (def.flags & 65536 /* OnInit */)) {
	        directive.ngOnInit();
	    }
	    if (def.flags & 262144 /* DoCheck */) {
	        directive.ngDoCheck();
	    }
	    return changed;
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @param {?} values
	 * @return {?}
	 */
	function checkAndUpdateDirectiveDynamic(view, def, values) {
	    var /** @type {?} */ providerData = asProviderData(view, def.index);
	    var /** @type {?} */ directive = providerData.instance;
	    var /** @type {?} */ changed = false;
	    var /** @type {?} */ changes = ((undefined));
	    for (var /** @type {?} */ i = 0; i < values.length; i++) {
	        if (checkBinding(view, def, i, values[i])) {
	            changed = true;
	            changes = updateProp(view, providerData, def, i, values[i], changes);
	        }
	    }
	    if (changes) {
	        directive.ngOnChanges(changes);
	    }
	    if ((view.state & 2 /* FirstCheck */) && (def.flags & 65536 /* OnInit */)) {
	        directive.ngOnInit();
	    }
	    if (def.flags & 262144 /* DoCheck */) {
	        directive.ngDoCheck();
	    }
	    return changed;
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @return {?}
	 */
	function _createProviderInstance(view, def) {
	    // private services can see other private services
	    var /** @type {?} */ allowPrivateServices = (def.flags & 8192 /* PrivateProvider */) > 0;
	    var /** @type {?} */ providerDef = def.provider;
	    var /** @type {?} */ injectable;
	    switch (def.flags & 201347067 /* Types */) {
	        case 512 /* TypeClassProvider */:
	            injectable = createClass(view, /** @type {?} */ ((def.parent)), allowPrivateServices, /** @type {?} */ ((providerDef)).value, /** @type {?} */ ((providerDef)).deps);
	            break;
	        case 1024 /* TypeFactoryProvider */:
	            injectable = callFactory(view, /** @type {?} */ ((def.parent)), allowPrivateServices, /** @type {?} */ ((providerDef)).value, /** @type {?} */ ((providerDef)).deps);
	            break;
	        case 2048 /* TypeUseExistingProvider */:
	            injectable = resolveDep(view, /** @type {?} */ ((def.parent)), allowPrivateServices, /** @type {?} */ ((providerDef)).deps[0]);
	            break;
	        case 256 /* TypeValueProvider */:
	            injectable = ((providerDef)).value;
	            break;
	    }
	    return injectable;
	}
	/**
	 * @param {?} view
	 * @param {?} elDef
	 * @param {?} allowPrivateServices
	 * @param {?} ctor
	 * @param {?} deps
	 * @return {?}
	 */
	function createClass(view, elDef, allowPrivateServices, ctor, deps) {
	    var /** @type {?} */ len = deps.length;
	    var /** @type {?} */ injectable;
	    switch (len) {
	        case 0:
	            injectable = new ctor();
	            break;
	        case 1:
	            injectable = new ctor(resolveDep(view, elDef, allowPrivateServices, deps[0]));
	            break;
	        case 2:
	            injectable = new ctor(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]));
	            break;
	        case 3:
	            injectable = new ctor(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]), resolveDep(view, elDef, allowPrivateServices, deps[2]));
	            break;
	        default:
	            var /** @type {?} */ depValues = new Array(len);
	            for (var /** @type {?} */ i = 0; i < len; i++) {
	                depValues[i] = resolveDep(view, elDef, allowPrivateServices, deps[i]);
	            }
	            injectable = new (ctor.bind.apply(ctor, [void 0].concat(depValues)))();
	    }
	    return injectable;
	}
	/**
	 * @param {?} view
	 * @param {?} elDef
	 * @param {?} allowPrivateServices
	 * @param {?} factory
	 * @param {?} deps
	 * @return {?}
	 */
	function callFactory(view, elDef, allowPrivateServices, factory, deps) {
	    var /** @type {?} */ len = deps.length;
	    var /** @type {?} */ injectable;
	    switch (len) {
	        case 0:
	            injectable = factory();
	            break;
	        case 1:
	            injectable = factory(resolveDep(view, elDef, allowPrivateServices, deps[0]));
	            break;
	        case 2:
	            injectable = factory(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]));
	            break;
	        case 3:
	            injectable = factory(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]), resolveDep(view, elDef, allowPrivateServices, deps[2]));
	            break;
	        default:
	            var /** @type {?} */ depValues = Array(len);
	            for (var /** @type {?} */ i = 0; i < len; i++) {
	                depValues[i] = resolveDep(view, elDef, allowPrivateServices, deps[i]);
	            }
	            injectable = factory.apply(void 0, depValues);
	    }
	    return injectable;
	}
	// This default value is when checking the hierarchy for a token.
	//
	// It means both:
	// - the token is not provided by the current injector,
	// - only the element injectors should be checked (ie do not check module injectors
	//
	//          mod1
	//         /
	//       el1   mod2
	//         \  /
	//         el2
	//
	// When requesting el2.injector.get(token), we should check in the following order and return the
	// first found value:
	// - el2.injector.get(token, default)
	// - el1.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) -> do not check the module
	// - mod2.injector.get(token, default)
	var NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};
	/**
	 * @param {?} view
	 * @param {?} elDef
	 * @param {?} allowPrivateServices
	 * @param {?} depDef
	 * @param {?=} notFoundValue
	 * @return {?}
	 */
	function resolveDep(view, elDef, allowPrivateServices, depDef, notFoundValue) {
	    if (notFoundValue === void 0) { notFoundValue = Injector.THROW_IF_NOT_FOUND; }
	    if (depDef.flags & 8 /* Value */) {
	        return depDef.token;
	    }
	    var /** @type {?} */ startView = view;
	    if (depDef.flags & 2 /* Optional */) {
	        notFoundValue = null;
	    }
	    var /** @type {?} */ tokenKey$$1 = depDef.tokenKey;
	    if (tokenKey$$1 === ChangeDetectorRefTokenKey) {
	        // directives on the same element as a component should be able to control the change detector
	        // of that component as well.
	        allowPrivateServices = !!(elDef && ((elDef.element)).componentView);
	    }
	    if (elDef && (depDef.flags & 1 /* SkipSelf */)) {
	        allowPrivateServices = false;
	        elDef = ((elDef.parent));
	    }
	    while (view) {
	        if (elDef) {
	            switch (tokenKey$$1) {
	                case RendererV1TokenKey: {
	                    var /** @type {?} */ compView = findCompView(view, elDef, allowPrivateServices);
	                    return createRendererV1(compView);
	                }
	                case Renderer2TokenKey: {
	                    var /** @type {?} */ compView = findCompView(view, elDef, allowPrivateServices);
	                    return compView.renderer;
	                }
	                case ElementRefTokenKey:
	                    return new ElementRef(asElementData(view, elDef.index).renderElement);
	                case ViewContainerRefTokenKey:
	                    return asElementData(view, elDef.index).viewContainer;
	                case TemplateRefTokenKey: {
	                    if (((elDef.element)).template) {
	                        return asElementData(view, elDef.index).template;
	                    }
	                    break;
	                }
	                case ChangeDetectorRefTokenKey: {
	                    var /** @type {?} */ cdView = findCompView(view, elDef, allowPrivateServices);
	                    return createChangeDetectorRef(cdView);
	                }
	                case InjectorRefTokenKey:
	                    return createInjector(view, elDef);
	                default:
	                    var /** @type {?} */ providerDef_1 = (((allowPrivateServices ? ((elDef.element)).allProviders : ((elDef.element)).publicProviders)))[tokenKey$$1];
	                    if (providerDef_1) {
	                        var /** @type {?} */ providerData = asProviderData(view, providerDef_1.index);
	                        if (providerData.instance === NOT_CREATED) {
	                            providerData.instance = _createProviderInstance(view, providerDef_1);
	                        }
	                        return providerData.instance;
	                    }
	            }
	        }
	        allowPrivateServices = isComponentView(view);
	        elDef = ((viewParentEl(view)));
	        view = ((view.parent));
	    }
	    var /** @type {?} */ value = startView.root.injector.get(depDef.token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR);
	    if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR ||
	        notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {
	        // Return the value from the root element injector when
	        // - it provides it
	        //   (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)
	        // - the module injector should not be checked
	        //   (notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)
	        return value;
	    }
	    return startView.root.ngModule.injector.get(depDef.token, notFoundValue);
	}
	/**
	 * @param {?} view
	 * @param {?} elDef
	 * @param {?} allowPrivateServices
	 * @return {?}
	 */
	function findCompView(view, elDef, allowPrivateServices) {
	    var /** @type {?} */ compView;
	    if (allowPrivateServices) {
	        compView = asElementData(view, elDef.index).componentView;
	    }
	    else {
	        compView = view;
	        while (compView.parent && !isComponentView(compView)) {
	            compView = compView.parent;
	        }
	    }
	    return compView;
	}
	/**
	 * @param {?} view
	 * @param {?} providerData
	 * @param {?} def
	 * @param {?} bindingIdx
	 * @param {?} value
	 * @param {?} changes
	 * @return {?}
	 */
	function updateProp(view, providerData, def, bindingIdx, value, changes) {
	    if (def.flags & 32768 /* Component */) {
	        var /** @type {?} */ compView = asElementData(view, /** @type {?} */ ((def.parent)).index).componentView;
	        if (compView.def.flags & 2 /* OnPush */) {
	            compView.state |= 8 /* ChecksEnabled */;
	        }
	    }
	    var /** @type {?} */ binding = def.bindings[bindingIdx];
	    var /** @type {?} */ propName = ((binding.name));
	    // Note: This is still safe with Closure Compiler as
	    // the user passed in the property name as an object has to `providerDef`,
	    // so Closure Compiler will have renamed the property correctly already.
	    providerData.instance[propName] = value;
	    if (def.flags & 524288 /* OnChanges */) {
	        changes = changes || {};
	        var /** @type {?} */ oldValue = view.oldValues[def.bindingIndex + bindingIdx];
	        if (oldValue instanceof WrappedValue) {
	            oldValue = oldValue.wrapped;
	        }
	        var /** @type {?} */ binding_1 = def.bindings[bindingIdx];
	        changes[((binding_1.nonMinifiedName))] =
	            new SimpleChange(oldValue, value, (view.state & 2 /* FirstCheck */) !== 0);
	    }
	    view.oldValues[def.bindingIndex + bindingIdx] = value;
	    return changes;
	}
	/**
	 * @param {?} view
	 * @param {?} lifecycles
	 * @return {?}
	 */
	function callLifecycleHooksChildrenFirst(view, lifecycles) {
	    if (!(view.def.nodeFlags & lifecycles)) {
	        return;
	    }
	    var /** @type {?} */ nodes = view.def.nodes;
	    for (var /** @type {?} */ i = 0; i < nodes.length; i++) {
	        var /** @type {?} */ nodeDef = nodes[i];
	        var /** @type {?} */ parent = nodeDef.parent;
	        if (!parent && nodeDef.flags & lifecycles) {
	            // matching root node (e.g. a pipe)
	            callProviderLifecycles(view, i, nodeDef.flags & lifecycles);
	        }
	        if ((nodeDef.childFlags & lifecycles) === 0) {
	            // no child matches one of the lifecycles
	            i += nodeDef.childCount;
	        }
	        while (parent && (parent.flags & 1 /* TypeElement */) &&
	            i === parent.index + parent.childCount) {
	            // last child of an element
	            if (parent.directChildFlags & lifecycles) {
	                callElementProvidersLifecycles(view, parent, lifecycles);
	            }
	            parent = parent.parent;
	        }
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} elDef
	 * @param {?} lifecycles
	 * @return {?}
	 */
	function callElementProvidersLifecycles(view, elDef, lifecycles) {
	    for (var /** @type {?} */ i = elDef.index + 1; i <= elDef.index + elDef.childCount; i++) {
	        var /** @type {?} */ nodeDef = view.def.nodes[i];
	        if (nodeDef.flags & lifecycles) {
	            callProviderLifecycles(view, i, nodeDef.flags & lifecycles);
	        }
	        // only visit direct children
	        i += nodeDef.childCount;
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} index
	 * @param {?} lifecycles
	 * @return {?}
	 */
	function callProviderLifecycles(view, index, lifecycles) {
	    var /** @type {?} */ provider = asProviderData(view, index).instance;
	    if (provider === NOT_CREATED) {
	        return;
	    }
	    Services.setCurrentNode(view, index);
	    if (lifecycles & 1048576 /* AfterContentInit */) {
	        provider.ngAfterContentInit();
	    }
	    if (lifecycles & 2097152 /* AfterContentChecked */) {
	        provider.ngAfterContentChecked();
	    }
	    if (lifecycles & 4194304 /* AfterViewInit */) {
	        provider.ngAfterViewInit();
	    }
	    if (lifecycles & 8388608 /* AfterViewChecked */) {
	        provider.ngAfterViewChecked();
	    }
	    if (lifecycles & 131072 /* OnDestroy */) {
	        provider.ngOnDestroy();
	    }
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} flags
	 * @param {?} id
	 * @param {?} bindings
	 * @return {?}
	 */
	function queryDef(flags, id, bindings) {
	    var /** @type {?} */ bindingDefs = [];
	    for (var /** @type {?} */ propName in bindings) {
	        var /** @type {?} */ bindingType = bindings[propName];
	        bindingDefs.push({ propName: propName, bindingType: bindingType });
	    }
	    return {
	        // will bet set by the view definition
	        index: -1,
	        parent: null,
	        renderParent: null,
	        bindingIndex: -1,
	        outputIndex: -1,
	        // regular values
	        flags: flags,
	        childFlags: 0,
	        directChildFlags: 0,
	        childMatchedQueries: 0,
	        ngContentIndex: -1,
	        matchedQueries: {},
	        matchedQueryIds: 0,
	        references: {},
	        childCount: 0,
	        bindings: [],
	        bindingFlags: 0,
	        outputs: [],
	        element: null,
	        provider: null,
	        text: null,
	        query: { id: id, filterId: filterQueryId(id), bindings: bindingDefs },
	        ngContent: null
	    };
	}
	/**
	 * @return {?}
	 */
	function createQuery() {
	    return new QueryList();
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function dirtyParentQueries(view) {
	    var /** @type {?} */ queryIds = view.def.nodeMatchedQueries;
	    while (view.parent && isEmbeddedView(view)) {
	        var /** @type {?} */ tplDef = ((view.parentNodeDef));
	        view = view.parent;
	        // content queries
	        var /** @type {?} */ end = tplDef.index + tplDef.childCount;
	        for (var /** @type {?} */ i = 0; i <= end; i++) {
	            var /** @type {?} */ nodeDef = view.def.nodes[i];
	            if ((nodeDef.flags & 67108864 /* TypeContentQuery */) &&
	                (nodeDef.flags & 536870912 /* DynamicQuery */) &&
	                (((nodeDef.query)).filterId & queryIds) === ((nodeDef.query)).filterId) {
	                asQueryList(view, i).setDirty();
	            }
	            if ((nodeDef.flags & 1 /* TypeElement */ && i + nodeDef.childCount < tplDef.index) ||
	                !(nodeDef.childFlags & 67108864 /* TypeContentQuery */) ||
	                !(nodeDef.childFlags & 536870912 /* DynamicQuery */)) {
	                // skip elements that don't contain the template element or no query.
	                i += nodeDef.childCount;
	            }
	        }
	    }
	    // view queries
	    if (view.def.nodeFlags & 134217728 /* TypeViewQuery */) {
	        for (var /** @type {?} */ i = 0; i < view.def.nodes.length; i++) {
	            var /** @type {?} */ nodeDef = view.def.nodes[i];
	            if ((nodeDef.flags & 134217728 /* TypeViewQuery */) && (nodeDef.flags & 536870912 /* DynamicQuery */)) {
	                asQueryList(view, i).setDirty();
	            }
	            // only visit the root nodes
	            i += nodeDef.childCount;
	        }
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} nodeDef
	 * @return {?}
	 */
	function checkAndUpdateQuery(view, nodeDef) {
	    var /** @type {?} */ queryList = asQueryList(view, nodeDef.index);
	    if (!queryList.dirty) {
	        return;
	    }
	    var /** @type {?} */ directiveInstance;
	    var /** @type {?} */ newValues = ((undefined));
	    if (nodeDef.flags & 67108864 /* TypeContentQuery */) {
	        var /** @type {?} */ elementDef_1 = ((((nodeDef.parent)).parent));
	        newValues = calcQueryValues(view, elementDef_1.index, elementDef_1.index + elementDef_1.childCount, /** @type {?} */ ((nodeDef.query)), []);
	        directiveInstance = asProviderData(view, /** @type {?} */ ((nodeDef.parent)).index).instance;
	    }
	    else if (nodeDef.flags & 134217728 /* TypeViewQuery */) {
	        newValues = calcQueryValues(view, 0, view.def.nodes.length - 1, /** @type {?} */ ((nodeDef.query)), []);
	        directiveInstance = view.component;
	    }
	    queryList.reset(newValues);
	    var /** @type {?} */ bindings = ((nodeDef.query)).bindings;
	    var /** @type {?} */ notify = false;
	    for (var /** @type {?} */ i = 0; i < bindings.length; i++) {
	        var /** @type {?} */ binding = bindings[i];
	        var /** @type {?} */ boundValue = void 0;
	        switch (binding.bindingType) {
	            case 0 /* First */:
	                boundValue = queryList.first;
	                break;
	            case 1 /* All */:
	                boundValue = queryList;
	                notify = true;
	                break;
	        }
	        directiveInstance[binding.propName] = boundValue;
	    }
	    if (notify) {
	        queryList.notifyOnChanges();
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} startIndex
	 * @param {?} endIndex
	 * @param {?} queryDef
	 * @param {?} values
	 * @return {?}
	 */
	function calcQueryValues(view, startIndex, endIndex, queryDef, values) {
	    for (var /** @type {?} */ i = startIndex; i <= endIndex; i++) {
	        var /** @type {?} */ nodeDef = view.def.nodes[i];
	        var /** @type {?} */ valueType = nodeDef.matchedQueries[queryDef.id];
	        if (valueType != null) {
	            values.push(getQueryValue(view, nodeDef, valueType));
	        }
	        if (nodeDef.flags & 1 /* TypeElement */ && ((nodeDef.element)).template &&
	            (((((nodeDef.element)).template)).nodeMatchedQueries & queryDef.filterId) ===
	                queryDef.filterId) {
	            // check embedded views that were attached at the place of their template.
	            var /** @type {?} */ elementData = asElementData(view, i);
	            if (nodeDef.flags & 16777216 /* EmbeddedViews */) {
	                var /** @type {?} */ embeddedViews = ((elementData.viewContainer))._embeddedViews;
	                for (var /** @type {?} */ k = 0; k < embeddedViews.length; k++) {
	                    var /** @type {?} */ embeddedView = embeddedViews[k];
	                    var /** @type {?} */ dvc = declaredViewContainer(embeddedView);
	                    if (dvc && dvc === elementData) {
	                        calcQueryValues(embeddedView, 0, embeddedView.def.nodes.length - 1, queryDef, values);
	                    }
	                }
	            }
	            var /** @type {?} */ projectedViews = elementData.template._projectedViews;
	            if (projectedViews) {
	                for (var /** @type {?} */ k = 0; k < projectedViews.length; k++) {
	                    var /** @type {?} */ projectedView = projectedViews[k];
	                    calcQueryValues(projectedView, 0, projectedView.def.nodes.length - 1, queryDef, values);
	                }
	            }
	        }
	        if ((nodeDef.childMatchedQueries & queryDef.filterId) !== queryDef.filterId) {
	            // if no child matches the query, skip the children.
	            i += nodeDef.childCount;
	        }
	    }
	    return values;
	}
	/**
	 * @param {?} view
	 * @param {?} nodeDef
	 * @param {?} queryValueType
	 * @return {?}
	 */
	function getQueryValue(view, nodeDef, queryValueType) {
	    if (queryValueType != null) {
	        // a match
	        var /** @type {?} */ value = void 0;
	        switch (queryValueType) {
	            case 1 /* RenderElement */:
	                value = asElementData(view, nodeDef.index).renderElement;
	                break;
	            case 0 /* ElementRef */:
	                value = new ElementRef(asElementData(view, nodeDef.index).renderElement);
	                break;
	            case 2 /* TemplateRef */:
	                value = asElementData(view, nodeDef.index).template;
	                break;
	            case 3 /* ViewContainerRef */:
	                value = asElementData(view, nodeDef.index).viewContainer;
	                break;
	            case 4 /* Provider */:
	                value = asProviderData(view, nodeDef.index).instance;
	                break;
	        }
	        return value;
	    }
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} ngContentIndex
	 * @param {?} index
	 * @return {?}
	 */
	function ngContentDef(ngContentIndex, index) {
	    return {
	        // will bet set by the view definition
	        index: -1,
	        parent: null,
	        renderParent: null,
	        bindingIndex: -1,
	        outputIndex: -1,
	        // regular values
	        flags: 8 /* TypeNgContent */,
	        childFlags: 0,
	        directChildFlags: 0,
	        childMatchedQueries: 0,
	        matchedQueries: {},
	        matchedQueryIds: 0,
	        references: {}, ngContentIndex: ngContentIndex,
	        childCount: 0,
	        bindings: [],
	        bindingFlags: 0,
	        outputs: [],
	        element: null,
	        provider: null,
	        text: null,
	        query: null,
	        ngContent: { index: index }
	    };
	}
	/**
	 * @param {?} view
	 * @param {?} renderHost
	 * @param {?} def
	 * @return {?}
	 */
	function appendNgContent(view, renderHost, def) {
	    var /** @type {?} */ parentEl = getParentRenderElement(view, renderHost, def);
	    if (!parentEl) {
	        // Nothing to do if there is no parent element.
	        return;
	    }
	    var /** @type {?} */ ngContentIndex = ((def.ngContent)).index;
	    visitProjectedRenderNodes(view, ngContentIndex, 1 /* AppendChild */, parentEl, null, undefined);
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} argCount
	 * @return {?}
	 */
	function purePipeDef(argCount) {
	    // argCount + 1 to include the pipe as first arg
	    return _pureExpressionDef(128 /* TypePurePipe */, new Array(argCount + 1));
	}
	/**
	 * @param {?} argCount
	 * @return {?}
	 */
	function pureArrayDef(argCount) {
	    return _pureExpressionDef(32 /* TypePureArray */, new Array(argCount));
	}
	/**
	 * @param {?} propToIndex
	 * @return {?}
	 */
	function pureObjectDef(propToIndex) {
	    var /** @type {?} */ keys = Object.keys(propToIndex);
	    var /** @type {?} */ nbKeys = keys.length;
	    var /** @type {?} */ propertyNames = new Array(nbKeys);
	    for (var /** @type {?} */ i = 0; i < nbKeys; i++) {
	        var /** @type {?} */ key = keys[i];
	        var /** @type {?} */ index = propToIndex[key];
	        propertyNames[index] = key;
	    }
	    return _pureExpressionDef(64 /* TypePureObject */, propertyNames);
	}
	/**
	 * @param {?} flags
	 * @param {?} propertyNames
	 * @return {?}
	 */
	function _pureExpressionDef(flags, propertyNames) {
	    var /** @type {?} */ bindings = new Array(propertyNames.length);
	    for (var /** @type {?} */ i = 0; i < propertyNames.length; i++) {
	        var /** @type {?} */ prop = propertyNames[i];
	        bindings[i] = {
	            flags: 8 /* TypeProperty */,
	            name: prop,
	            ns: null,
	            nonMinifiedName: prop,
	            securityContext: null,
	            suffix: null
	        };
	    }
	    return {
	        // will bet set by the view definition
	        index: -1,
	        parent: null,
	        renderParent: null,
	        bindingIndex: -1,
	        outputIndex: -1,
	        // regular values
	        flags: flags,
	        childFlags: 0,
	        directChildFlags: 0,
	        childMatchedQueries: 0,
	        matchedQueries: {},
	        matchedQueryIds: 0,
	        references: {},
	        ngContentIndex: -1,
	        childCount: 0, bindings: bindings,
	        bindingFlags: calcBindingFlags(bindings),
	        outputs: [],
	        element: null,
	        provider: null,
	        text: null,
	        query: null,
	        ngContent: null
	    };
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @return {?}
	 */
	function createPureExpression(view, def) {
	    return { value: undefined };
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @param {?} v0
	 * @param {?} v1
	 * @param {?} v2
	 * @param {?} v3
	 * @param {?} v4
	 * @param {?} v5
	 * @param {?} v6
	 * @param {?} v7
	 * @param {?} v8
	 * @param {?} v9
	 * @return {?}
	 */
	function checkAndUpdatePureExpressionInline(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
	    var /** @type {?} */ bindings = def.bindings;
	    var /** @type {?} */ changed = false;
	    var /** @type {?} */ bindLen = bindings.length;
	    if (bindLen > 0 && checkAndUpdateBinding(view, def, 0, v0))
	        changed = true;
	    if (bindLen > 1 && checkAndUpdateBinding(view, def, 1, v1))
	        changed = true;
	    if (bindLen > 2 && checkAndUpdateBinding(view, def, 2, v2))
	        changed = true;
	    if (bindLen > 3 && checkAndUpdateBinding(view, def, 3, v3))
	        changed = true;
	    if (bindLen > 4 && checkAndUpdateBinding(view, def, 4, v4))
	        changed = true;
	    if (bindLen > 5 && checkAndUpdateBinding(view, def, 5, v5))
	        changed = true;
	    if (bindLen > 6 && checkAndUpdateBinding(view, def, 6, v6))
	        changed = true;
	    if (bindLen > 7 && checkAndUpdateBinding(view, def, 7, v7))
	        changed = true;
	    if (bindLen > 8 && checkAndUpdateBinding(view, def, 8, v8))
	        changed = true;
	    if (bindLen > 9 && checkAndUpdateBinding(view, def, 9, v9))
	        changed = true;
	    if (changed) {
	        var /** @type {?} */ data = asPureExpressionData(view, def.index);
	        var /** @type {?} */ value = void 0;
	        switch (def.flags & 201347067 /* Types */) {
	            case 32 /* TypePureArray */:
	                value = new Array(bindings.length);
	                if (bindLen > 0)
	                    value[0] = v0;
	                if (bindLen > 1)
	                    value[1] = v1;
	                if (bindLen > 2)
	                    value[2] = v2;
	                if (bindLen > 3)
	                    value[3] = v3;
	                if (bindLen > 4)
	                    value[4] = v4;
	                if (bindLen > 5)
	                    value[5] = v5;
	                if (bindLen > 6)
	                    value[6] = v6;
	                if (bindLen > 7)
	                    value[7] = v7;
	                if (bindLen > 8)
	                    value[8] = v8;
	                if (bindLen > 9)
	                    value[9] = v9;
	                break;
	            case 64 /* TypePureObject */:
	                value = {};
	                if (bindLen > 0)
	                    value[((bindings[0].name))] = v0;
	                if (bindLen > 1)
	                    value[((bindings[1].name))] = v1;
	                if (bindLen > 2)
	                    value[((bindings[2].name))] = v2;
	                if (bindLen > 3)
	                    value[((bindings[3].name))] = v3;
	                if (bindLen > 4)
	                    value[((bindings[4].name))] = v4;
	                if (bindLen > 5)
	                    value[((bindings[5].name))] = v5;
	                if (bindLen > 6)
	                    value[((bindings[6].name))] = v6;
	                if (bindLen > 7)
	                    value[((bindings[7].name))] = v7;
	                if (bindLen > 8)
	                    value[((bindings[8].name))] = v8;
	                if (bindLen > 9)
	                    value[((bindings[9].name))] = v9;
	                break;
	            case 128 /* TypePurePipe */:
	                var /** @type {?} */ pipe = v0;
	                switch (bindLen) {
	                    case 1:
	                        value = pipe.transform(v0);
	                        break;
	                    case 2:
	                        value = pipe.transform(v1);
	                        break;
	                    case 3:
	                        value = pipe.transform(v1, v2);
	                        break;
	                    case 4:
	                        value = pipe.transform(v1, v2, v3);
	                        break;
	                    case 5:
	                        value = pipe.transform(v1, v2, v3, v4);
	                        break;
	                    case 6:
	                        value = pipe.transform(v1, v2, v3, v4, v5);
	                        break;
	                    case 7:
	                        value = pipe.transform(v1, v2, v3, v4, v5, v6);
	                        break;
	                    case 8:
	                        value = pipe.transform(v1, v2, v3, v4, v5, v6, v7);
	                        break;
	                    case 9:
	                        value = pipe.transform(v1, v2, v3, v4, v5, v6, v7, v8);
	                        break;
	                    case 10:
	                        value = pipe.transform(v1, v2, v3, v4, v5, v6, v7, v8, v9);
	                        break;
	                }
	                break;
	        }
	        data.value = value;
	    }
	    return changed;
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @param {?} values
	 * @return {?}
	 */
	function checkAndUpdatePureExpressionDynamic(view, def, values) {
	    var /** @type {?} */ bindings = def.bindings;
	    var /** @type {?} */ changed = false;
	    for (var /** @type {?} */ i = 0; i < values.length; i++) {
	        // Note: We need to loop over all values, so that
	        // the old values are updates as well!
	        if (checkAndUpdateBinding(view, def, i, values[i])) {
	            changed = true;
	        }
	    }
	    if (changed) {
	        var /** @type {?} */ data = asPureExpressionData(view, def.index);
	        var /** @type {?} */ value = void 0;
	        switch (def.flags & 201347067 /* Types */) {
	            case 32 /* TypePureArray */:
	                value = values;
	                break;
	            case 64 /* TypePureObject */:
	                value = {};
	                for (var /** @type {?} */ i = 0; i < values.length; i++) {
	                    value[((bindings[i].name))] = values[i];
	                }
	                break;
	            case 128 /* TypePurePipe */:
	                var /** @type {?} */ pipe = values[0];
	                var /** @type {?} */ params = values.slice(1);
	                value = pipe.transform.apply(pipe, params);
	                break;
	        }
	        data.value = value;
	    }
	    return changed;
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} ngContentIndex
	 * @param {?} constants
	 * @return {?}
	 */
	function textDef(ngContentIndex, constants) {
	    var /** @type {?} */ bindings = new Array(constants.length - 1);
	    for (var /** @type {?} */ i = 1; i < constants.length; i++) {
	        bindings[i - 1] = {
	            flags: 8 /* TypeProperty */,
	            name: null,
	            ns: null,
	            nonMinifiedName: null,
	            securityContext: null,
	            suffix: constants[i]
	        };
	    }
	    var /** @type {?} */ flags = 2;
	    return {
	        // will bet set by the view definition
	        index: -1,
	        parent: null,
	        renderParent: null,
	        bindingIndex: -1,
	        outputIndex: -1,
	        // regular values
	        flags: flags,
	        childFlags: 0,
	        directChildFlags: 0,
	        childMatchedQueries: 0,
	        matchedQueries: {},
	        matchedQueryIds: 0,
	        references: {}, ngContentIndex: ngContentIndex,
	        childCount: 0, bindings: bindings,
	        bindingFlags: calcBindingFlags(bindings),
	        outputs: [],
	        element: null,
	        provider: null,
	        text: { prefix: constants[0] },
	        query: null,
	        ngContent: null
	    };
	}
	/**
	 * @param {?} view
	 * @param {?} renderHost
	 * @param {?} def
	 * @return {?}
	 */
	function createText(view, renderHost, def) {
	    var /** @type {?} */ renderNode$$1;
	    var /** @type {?} */ renderer = view.renderer;
	    renderNode$$1 = renderer.createText(/** @type {?} */ ((def.text)).prefix);
	    var /** @type {?} */ parentEl = getParentRenderElement(view, renderHost, def);
	    if (parentEl) {
	        renderer.appendChild(parentEl, renderNode$$1);
	    }
	    return { renderText: renderNode$$1 };
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @param {?} v0
	 * @param {?} v1
	 * @param {?} v2
	 * @param {?} v3
	 * @param {?} v4
	 * @param {?} v5
	 * @param {?} v6
	 * @param {?} v7
	 * @param {?} v8
	 * @param {?} v9
	 * @return {?}
	 */
	function checkAndUpdateTextInline(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
	    var /** @type {?} */ changed = false;
	    var /** @type {?} */ bindings = def.bindings;
	    var /** @type {?} */ bindLen = bindings.length;
	    if (bindLen > 0 && checkAndUpdateBinding(view, def, 0, v0))
	        changed = true;
	    if (bindLen > 1 && checkAndUpdateBinding(view, def, 1, v1))
	        changed = true;
	    if (bindLen > 2 && checkAndUpdateBinding(view, def, 2, v2))
	        changed = true;
	    if (bindLen > 3 && checkAndUpdateBinding(view, def, 3, v3))
	        changed = true;
	    if (bindLen > 4 && checkAndUpdateBinding(view, def, 4, v4))
	        changed = true;
	    if (bindLen > 5 && checkAndUpdateBinding(view, def, 5, v5))
	        changed = true;
	    if (bindLen > 6 && checkAndUpdateBinding(view, def, 6, v6))
	        changed = true;
	    if (bindLen > 7 && checkAndUpdateBinding(view, def, 7, v7))
	        changed = true;
	    if (bindLen > 8 && checkAndUpdateBinding(view, def, 8, v8))
	        changed = true;
	    if (bindLen > 9 && checkAndUpdateBinding(view, def, 9, v9))
	        changed = true;
	    if (changed) {
	        var /** @type {?} */ value = ((def.text)).prefix;
	        if (bindLen > 0)
	            value += _addInterpolationPart(v0, bindings[0]);
	        if (bindLen > 1)
	            value += _addInterpolationPart(v1, bindings[1]);
	        if (bindLen > 2)
	            value += _addInterpolationPart(v2, bindings[2]);
	        if (bindLen > 3)
	            value += _addInterpolationPart(v3, bindings[3]);
	        if (bindLen > 4)
	            value += _addInterpolationPart(v4, bindings[4]);
	        if (bindLen > 5)
	            value += _addInterpolationPart(v5, bindings[5]);
	        if (bindLen > 6)
	            value += _addInterpolationPart(v6, bindings[6]);
	        if (bindLen > 7)
	            value += _addInterpolationPart(v7, bindings[7]);
	        if (bindLen > 8)
	            value += _addInterpolationPart(v8, bindings[8]);
	        if (bindLen > 9)
	            value += _addInterpolationPart(v9, bindings[9]);
	        var /** @type {?} */ renderNode$$1 = asTextData(view, def.index).renderText;
	        view.renderer.setValue(renderNode$$1, value);
	    }
	    return changed;
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @param {?} values
	 * @return {?}
	 */
	function checkAndUpdateTextDynamic(view, def, values) {
	    var /** @type {?} */ bindings = def.bindings;
	    var /** @type {?} */ changed = false;
	    for (var /** @type {?} */ i = 0; i < values.length; i++) {
	        // Note: We need to loop over all values, so that
	        // the old values are updates as well!
	        if (checkAndUpdateBinding(view, def, i, values[i])) {
	            changed = true;
	        }
	    }
	    if (changed) {
	        var /** @type {?} */ value = '';
	        for (var /** @type {?} */ i = 0; i < values.length; i++) {
	            value = value + _addInterpolationPart(values[i], bindings[i]);
	        }
	        value = ((def.text)).prefix + value;
	        var /** @type {?} */ renderNode$$1 = asTextData(view, def.index).renderText;
	        view.renderer.setValue(renderNode$$1, value);
	    }
	    return changed;
	}
	/**
	 * @param {?} value
	 * @param {?} binding
	 * @return {?}
	 */
	function _addInterpolationPart(value, binding) {
	    var /** @type {?} */ valueStr = value != null ? value.toString() : '';
	    return valueStr + binding.suffix;
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} flags
	 * @param {?} nodes
	 * @param {?=} updateDirectives
	 * @param {?=} updateRenderer
	 * @return {?}
	 */
	function viewDef(flags, nodes, updateDirectives, updateRenderer) {
	    // clone nodes and set auto calculated values
	    var /** @type {?} */ viewBindingCount = 0;
	    var /** @type {?} */ viewDisposableCount = 0;
	    var /** @type {?} */ viewNodeFlags = 0;
	    var /** @type {?} */ viewRootNodeFlags = 0;
	    var /** @type {?} */ viewMatchedQueries = 0;
	    var /** @type {?} */ currentParent = null;
	    var /** @type {?} */ currentElementHasPublicProviders = false;
	    var /** @type {?} */ currentElementHasPrivateProviders = false;
	    var /** @type {?} */ lastRenderRootNode = null;
	    for (var /** @type {?} */ i = 0; i < nodes.length; i++) {
	        while (currentParent && i > currentParent.index + currentParent.childCount) {
	            var /** @type {?} */ newParent = currentParent.parent;
	            if (newParent) {
	                newParent.childFlags |= ((currentParent.childFlags));
	                newParent.childMatchedQueries |= currentParent.childMatchedQueries;
	            }
	            currentParent = newParent;
	        }
	        var /** @type {?} */ node = nodes[i];
	        node.index = i;
	        node.parent = currentParent;
	        node.bindingIndex = viewBindingCount;
	        node.outputIndex = viewDisposableCount;
	        // renderParent needs to account for ng-container!
	        var /** @type {?} */ currentRenderParent = void 0;
	        if (currentParent && currentParent.flags & 1 /* TypeElement */ &&
	            !((currentParent.element)).name) {
	            currentRenderParent = currentParent.renderParent;
	        }
	        else {
	            currentRenderParent = currentParent;
	        }
	        node.renderParent = currentRenderParent;
	        if (node.element) {
	            var /** @type {?} */ elDef = node.element;
	            elDef.publicProviders =
	                currentParent ? ((currentParent.element)).publicProviders : Object.create(null);
	            elDef.allProviders = elDef.publicProviders;
	            // Note: We assume that all providers of an element are before any child element!
	            currentElementHasPublicProviders = false;
	            currentElementHasPrivateProviders = false;
	        }
	        validateNode(currentParent, node, nodes.length);
	        viewNodeFlags |= node.flags;
	        viewMatchedQueries |= node.matchedQueryIds;
	        if (node.element && node.element.template) {
	            viewMatchedQueries |= node.element.template.nodeMatchedQueries;
	        }
	        if (currentParent) {
	            currentParent.childFlags |= node.flags;
	            currentParent.directChildFlags |= node.flags;
	            currentParent.childMatchedQueries |= node.matchedQueryIds;
	            if (node.element && node.element.template) {
	                currentParent.childMatchedQueries |= node.element.template.nodeMatchedQueries;
	            }
	        }
	        else {
	            viewRootNodeFlags |= node.flags;
	        }
	        viewBindingCount += node.bindings.length;
	        viewDisposableCount += node.outputs.length;
	        if (!currentRenderParent && (node.flags & 3 /* CatRenderNode */)) {
	            lastRenderRootNode = node;
	        }
	        if (node.flags & 20224 /* CatProvider */) {
	            if (!currentElementHasPublicProviders) {
	                currentElementHasPublicProviders = true; /** @type {?} */
	                ((((
	                // Use prototypical inheritance to not get O(n^2) complexity...
	                currentParent)).element)).publicProviders =
	                    Object.create(/** @type {?} */ ((((currentParent)).element)).publicProviders); /** @type {?} */
	                ((((currentParent)).element)).allProviders = ((((currentParent)).element)).publicProviders;
	            }
	            var /** @type {?} */ isPrivateService = (node.flags & 8192 /* PrivateProvider */) !== 0;
	            var /** @type {?} */ isComponent = (node.flags & 32768 /* Component */) !== 0;
	            if (!isPrivateService || isComponent) {
	                ((((((currentParent)).element)).publicProviders))[tokenKey(/** @type {?} */ ((node.provider)).token)] = node;
	            }
	            else {
	                if (!currentElementHasPrivateProviders) {
	                    currentElementHasPrivateProviders = true; /** @type {?} */
	                    ((((
	                    // Use protoyypical inheritance to not get O(n^2) complexity...
	                    currentParent)).element)).allProviders =
	                        Object.create(/** @type {?} */ ((((currentParent)).element)).publicProviders);
	                } /** @type {?} */
	                ((((((currentParent)).element)).allProviders))[tokenKey(/** @type {?} */ ((node.provider)).token)] = node;
	            }
	            if (isComponent) {
	                ((((currentParent)).element)).componentProvider = node;
	            }
	        }
	        if (node.childCount) {
	            currentParent = node;
	        }
	    }
	    while (currentParent) {
	        var /** @type {?} */ newParent = currentParent.parent;
	        if (newParent) {
	            newParent.childFlags |= currentParent.childFlags;
	            newParent.childMatchedQueries |= currentParent.childMatchedQueries;
	        }
	        currentParent = newParent;
	    }
	    var /** @type {?} */ handleEvent = function (view, nodeIndex, eventName, event) { return ((((nodes[nodeIndex].element)).handleEvent))(view, eventName, event); };
	    return {
	        // Will be filled later...
	        factory: null,
	        nodeFlags: viewNodeFlags,
	        rootNodeFlags: viewRootNodeFlags,
	        nodeMatchedQueries: viewMatchedQueries, flags: flags,
	        nodes: nodes,
	        updateDirectives: updateDirectives || NOOP,
	        updateRenderer: updateRenderer || NOOP,
	        handleEvent: handleEvent || NOOP,
	        bindingCount: viewBindingCount,
	        outputCount: viewDisposableCount, lastRenderRootNode: lastRenderRootNode
	    };
	}
	/**
	 * @param {?} parent
	 * @param {?} node
	 * @param {?} nodeCount
	 * @return {?}
	 */
	function validateNode(parent, node, nodeCount) {
	    var /** @type {?} */ template = node.element && node.element.template;
	    if (template) {
	        if (!template.lastRenderRootNode) {
	            throw new Error("Illegal State: Embedded templates without nodes are not allowed!");
	        }
	        if (template.lastRenderRootNode &&
	            template.lastRenderRootNode.flags & 16777216 /* EmbeddedViews */) {
	            throw new Error("Illegal State: Last root node of a template can't have embedded views, at index " + node.index + "!");
	        }
	    }
	    if (node.flags & 20224 /* CatProvider */) {
	        var /** @type {?} */ parentFlags = parent ? parent.flags : 0;
	        if ((parentFlags & 1 /* TypeElement */) === 0) {
	            throw new Error("Illegal State: Provider/Directive nodes need to be children of elements or anchors, at index " + node.index + "!");
	        }
	    }
	    if (node.query) {
	        if (node.flags & 67108864 /* TypeContentQuery */ &&
	            (!parent || (parent.flags & 16384 /* TypeDirective */) === 0)) {
	            throw new Error("Illegal State: Content Query nodes need to be children of directives, at index " + node.index + "!");
	        }
	        if (node.flags & 134217728 /* TypeViewQuery */ && parent) {
	            throw new Error("Illegal State: View Query nodes have to be top level nodes, at index " + node.index + "!");
	        }
	    }
	    if (node.childCount) {
	        var /** @type {?} */ parentEnd = parent ? parent.index + parent.childCount : nodeCount - 1;
	        if (node.index <= parentEnd && node.index + node.childCount > parentEnd) {
	            throw new Error("Illegal State: childCount of node leads outside of parent, at index " + node.index + "!");
	        }
	    }
	}
	/**
	 * @param {?} parent
	 * @param {?} anchorDef
	 * @param {?} viewDef
	 * @param {?=} context
	 * @return {?}
	 */
	function createEmbeddedView(parent, anchorDef$$1, viewDef, context) {
	    // embedded views are seen as siblings to the anchor, so we need
	    // to get the parent of the anchor and use it as parentIndex.
	    var /** @type {?} */ view = createView(parent.root, parent.renderer, parent, anchorDef$$1, viewDef);
	    initView(view, parent.component, context);
	    createViewNodes(view);
	    return view;
	}
	/**
	 * @param {?} root
	 * @param {?} def
	 * @param {?=} context
	 * @return {?}
	 */
	function createRootView(root, def, context) {
	    var /** @type {?} */ view = createView(root, root.renderer, null, null, def);
	    initView(view, context, context);
	    createViewNodes(view);
	    return view;
	}
	/**
	 * @param {?} parentView
	 * @param {?} nodeDef
	 * @param {?} viewDef
	 * @param {?} hostElement
	 * @return {?}
	 */
	function createComponentView(parentView, nodeDef, viewDef, hostElement) {
	    var /** @type {?} */ rendererType = ((nodeDef.element)).componentRendererType;
	    var /** @type {?} */ compRenderer;
	    if (!rendererType) {
	        compRenderer = parentView.root.renderer;
	    }
	    else {
	        compRenderer = parentView.root.rendererFactory.createRenderer(hostElement, rendererType);
	    }
	    return createView(parentView.root, compRenderer, parentView, /** @type {?} */ ((nodeDef.element)).componentProvider, viewDef);
	}
	/**
	 * @param {?} root
	 * @param {?} renderer
	 * @param {?} parent
	 * @param {?} parentNodeDef
	 * @param {?} def
	 * @return {?}
	 */
	function createView(root, renderer, parent, parentNodeDef, def) {
	    var /** @type {?} */ nodes = new Array(def.nodes.length);
	    var /** @type {?} */ disposables = def.outputCount ? new Array(def.outputCount) : null;
	    var /** @type {?} */ view = {
	        def: def,
	        parent: parent,
	        viewContainerParent: null, parentNodeDef: parentNodeDef,
	        context: null,
	        component: null, nodes: nodes,
	        state: 13 /* CatInit */, root: root, renderer: renderer,
	        oldValues: new Array(def.bindingCount), disposables: disposables
	    };
	    return view;
	}
	/**
	 * @param {?} view
	 * @param {?} component
	 * @param {?} context
	 * @return {?}
	 */
	function initView(view, component, context) {
	    view.component = component;
	    view.context = context;
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function createViewNodes(view) {
	    var /** @type {?} */ renderHost;
	    if (isComponentView(view)) {
	        var /** @type {?} */ hostDef = view.parentNodeDef;
	        renderHost = asElementData(/** @type {?} */ ((view.parent)), /** @type {?} */ ((((hostDef)).parent)).index).renderElement;
	    }
	    var /** @type {?} */ def = view.def;
	    var /** @type {?} */ nodes = view.nodes;
	    for (var /** @type {?} */ i = 0; i < def.nodes.length; i++) {
	        var /** @type {?} */ nodeDef = def.nodes[i];
	        Services.setCurrentNode(view, i);
	        var /** @type {?} */ nodeData = void 0;
	        switch (nodeDef.flags & 201347067 /* Types */) {
	            case 1 /* TypeElement */:
	                var /** @type {?} */ el = (createElement(view, renderHost, nodeDef));
	                var /** @type {?} */ componentView = ((undefined));
	                if (nodeDef.flags & 33554432 /* ComponentView */) {
	                    var /** @type {?} */ compViewDef = resolveDefinition(/** @type {?} */ ((((nodeDef.element)).componentView)));
	                    componentView = Services.createComponentView(view, nodeDef, compViewDef, el);
	                }
	                listenToElementOutputs(view, componentView, nodeDef, el);
	                nodeData = ({
	                    renderElement: el,
	                    componentView: componentView,
	                    viewContainer: null,
	                    template: /** @type {?} */ ((nodeDef.element)).template ? createTemplateData(view, nodeDef) : undefined
	                });
	                if (nodeDef.flags & 16777216 /* EmbeddedViews */) {
	                    nodeData.viewContainer = createViewContainerData(view, nodeDef, nodeData);
	                }
	                break;
	            case 2 /* TypeText */:
	                nodeData = (createText(view, renderHost, nodeDef));
	                break;
	            case 512 /* TypeClassProvider */:
	            case 1024 /* TypeFactoryProvider */:
	            case 2048 /* TypeUseExistingProvider */:
	            case 256 /* TypeValueProvider */: {
	                var /** @type {?} */ instance = createProviderInstance(view, nodeDef);
	                nodeData = ({ instance: instance });
	                break;
	            }
	            case 16 /* TypePipe */: {
	                var /** @type {?} */ instance = createPipeInstance(view, nodeDef);
	                nodeData = ({ instance: instance });
	                break;
	            }
	            case 16384 /* TypeDirective */: {
	                var /** @type {?} */ instance = createDirectiveInstance(view, nodeDef);
	                nodeData = ({ instance: instance });
	                if (nodeDef.flags & 32768 /* Component */) {
	                    var /** @type {?} */ compView = asElementData(view, /** @type {?} */ ((nodeDef.parent)).index).componentView;
	                    initView(compView, instance, instance);
	                }
	                break;
	            }
	            case 32 /* TypePureArray */:
	            case 64 /* TypePureObject */:
	            case 128 /* TypePurePipe */:
	                nodeData = (createPureExpression(view, nodeDef));
	                break;
	            case 67108864 /* TypeContentQuery */:
	            case 134217728 /* TypeViewQuery */:
	                nodeData = (createQuery());
	                break;
	            case 8 /* TypeNgContent */:
	                appendNgContent(view, renderHost, nodeDef);
	                // no runtime data needed for NgContent...
	                nodeData = undefined;
	                break;
	        }
	        nodes[i] = nodeData;
	    }
	    // Create the ViewData.nodes of component views after we created everything else,
	    // so that e.g. ng-content works
	    execComponentViewsAction(view, ViewAction.CreateViewNodes);
	    // fill static content and view queries
	    execQueriesAction(view, 67108864 /* TypeContentQuery */ | 134217728 /* TypeViewQuery */, 268435456 /* StaticQuery */, 0 /* CheckAndUpdate */);
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function checkNoChangesView(view) {
	    markProjectedViewsForCheck(view);
	    Services.updateDirectives(view, 1 /* CheckNoChanges */);
	    execEmbeddedViewsAction(view, ViewAction.CheckNoChanges);
	    Services.updateRenderer(view, 1 /* CheckNoChanges */);
	    execComponentViewsAction(view, ViewAction.CheckNoChanges);
	    // Note: We don't check queries for changes as we didn't do this in v2.x.
	    // TODO(tbosch): investigate if we can enable the check again in v5.x with a nicer error message.
	    view.state &= ~(64 /* CheckProjectedViews */ | 32 /* CheckProjectedView */);
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function checkAndUpdateView(view) {
	    if (view.state & 1 /* BeforeFirstCheck */) {
	        view.state &= ~1 /* BeforeFirstCheck */;
	        view.state |= 2 /* FirstCheck */;
	    }
	    else {
	        view.state &= ~2 /* FirstCheck */;
	    }
	    markProjectedViewsForCheck(view);
	    Services.updateDirectives(view, 0 /* CheckAndUpdate */);
	    execEmbeddedViewsAction(view, ViewAction.CheckAndUpdate);
	    execQueriesAction(view, 67108864 /* TypeContentQuery */, 536870912 /* DynamicQuery */, 0 /* CheckAndUpdate */);
	    callLifecycleHooksChildrenFirst(view, 2097152 /* AfterContentChecked */ |
	        (view.state & 2 /* FirstCheck */ ? 1048576 /* AfterContentInit */ : 0));
	    Services.updateRenderer(view, 0 /* CheckAndUpdate */);
	    execComponentViewsAction(view, ViewAction.CheckAndUpdate);
	    execQueriesAction(view, 134217728 /* TypeViewQuery */, 536870912 /* DynamicQuery */, 0 /* CheckAndUpdate */);
	    callLifecycleHooksChildrenFirst(view, 8388608 /* AfterViewChecked */ |
	        (view.state & 2 /* FirstCheck */ ? 4194304 /* AfterViewInit */ : 0));
	    if (view.def.flags & 2 /* OnPush */) {
	        view.state &= ~8 /* ChecksEnabled */;
	    }
	    view.state &= ~(64 /* CheckProjectedViews */ | 32 /* CheckProjectedView */);
	}
	/**
	 * @param {?} view
	 * @param {?} nodeDef
	 * @param {?} argStyle
	 * @param {?=} v0
	 * @param {?=} v1
	 * @param {?=} v2
	 * @param {?=} v3
	 * @param {?=} v4
	 * @param {?=} v5
	 * @param {?=} v6
	 * @param {?=} v7
	 * @param {?=} v8
	 * @param {?=} v9
	 * @return {?}
	 */
	function checkAndUpdateNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
	    if (argStyle === 0 /* Inline */) {
	        return checkAndUpdateNodeInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
	    }
	    else {
	        return checkAndUpdateNodeDynamic(view, nodeDef, v0);
	    }
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function markProjectedViewsForCheck(view) {
	    var /** @type {?} */ def = view.def;
	    if (!(def.nodeFlags & 4 /* ProjectedTemplate */)) {
	        return;
	    }
	    for (var /** @type {?} */ i = 0; i < def.nodes.length; i++) {
	        var /** @type {?} */ nodeDef = def.nodes[i];
	        if (nodeDef.flags & 4 /* ProjectedTemplate */) {
	            var /** @type {?} */ projectedViews = asElementData(view, i).template._projectedViews;
	            if (projectedViews) {
	                for (var /** @type {?} */ i_1 = 0; i_1 < projectedViews.length; i_1++) {
	                    var /** @type {?} */ projectedView = projectedViews[i_1];
	                    projectedView.state |= 32 /* CheckProjectedView */;
	                    markParentViewsForCheckProjectedViews(projectedView, view);
	                }
	            }
	        }
	        else if ((nodeDef.childFlags & 4 /* ProjectedTemplate */) === 0) {
	            // a parent with leafs
	            // no child is a component,
	            // then skip the children
	            i += nodeDef.childCount;
	        }
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} nodeDef
	 * @param {?=} v0
	 * @param {?=} v1
	 * @param {?=} v2
	 * @param {?=} v3
	 * @param {?=} v4
	 * @param {?=} v5
	 * @param {?=} v6
	 * @param {?=} v7
	 * @param {?=} v8
	 * @param {?=} v9
	 * @return {?}
	 */
	function checkAndUpdateNodeInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
	    var /** @type {?} */ changed = false;
	    switch (nodeDef.flags & 201347067 /* Types */) {
	        case 1 /* TypeElement */:
	            changed = checkAndUpdateElementInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
	            break;
	        case 2 /* TypeText */:
	            changed = checkAndUpdateTextInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
	            break;
	        case 16384 /* TypeDirective */:
	            changed =
	                checkAndUpdateDirectiveInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
	            break;
	        case 32 /* TypePureArray */:
	        case 64 /* TypePureObject */:
	        case 128 /* TypePurePipe */:
	            changed =
	                checkAndUpdatePureExpressionInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
	            break;
	    }
	    return changed;
	}
	/**
	 * @param {?} view
	 * @param {?} nodeDef
	 * @param {?} values
	 * @return {?}
	 */
	function checkAndUpdateNodeDynamic(view, nodeDef, values) {
	    var /** @type {?} */ changed = false;
	    switch (nodeDef.flags & 201347067 /* Types */) {
	        case 1 /* TypeElement */:
	            changed = checkAndUpdateElementDynamic(view, nodeDef, values);
	            break;
	        case 2 /* TypeText */:
	            changed = checkAndUpdateTextDynamic(view, nodeDef, values);
	            break;
	        case 16384 /* TypeDirective */:
	            changed = checkAndUpdateDirectiveDynamic(view, nodeDef, values);
	            break;
	        case 32 /* TypePureArray */:
	        case 64 /* TypePureObject */:
	        case 128 /* TypePurePipe */:
	            changed = checkAndUpdatePureExpressionDynamic(view, nodeDef, values);
	            break;
	    }
	    if (changed) {
	        // Update oldValues after all bindings have been updated,
	        // as a setter for a property might update other properties.
	        var /** @type {?} */ bindLen = nodeDef.bindings.length;
	        var /** @type {?} */ bindingStart = nodeDef.bindingIndex;
	        var /** @type {?} */ oldValues = view.oldValues;
	        for (var /** @type {?} */ i = 0; i < bindLen; i++) {
	            oldValues[bindingStart + i] = values[i];
	        }
	    }
	    return changed;
	}
	/**
	 * @param {?} view
	 * @param {?} nodeDef
	 * @param {?} argStyle
	 * @param {?=} v0
	 * @param {?=} v1
	 * @param {?=} v2
	 * @param {?=} v3
	 * @param {?=} v4
	 * @param {?=} v5
	 * @param {?=} v6
	 * @param {?=} v7
	 * @param {?=} v8
	 * @param {?=} v9
	 * @return {?}
	 */
	function checkNoChangesNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
	    if (argStyle === 0 /* Inline */) {
	        checkNoChangesNodeInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
	    }
	    else {
	        checkNoChangesNodeDynamic(view, nodeDef, v0);
	    }
	    // Returning false is ok here as we would have thrown in case of a change.
	    return false;
	}
	/**
	 * @param {?} view
	 * @param {?} nodeDef
	 * @param {?} v0
	 * @param {?} v1
	 * @param {?} v2
	 * @param {?} v3
	 * @param {?} v4
	 * @param {?} v5
	 * @param {?} v6
	 * @param {?} v7
	 * @param {?} v8
	 * @param {?} v9
	 * @return {?}
	 */
	function checkNoChangesNodeInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
	    var /** @type {?} */ bindLen = nodeDef.bindings.length;
	    if (bindLen > 0)
	        checkBindingNoChanges(view, nodeDef, 0, v0);
	    if (bindLen > 1)
	        checkBindingNoChanges(view, nodeDef, 1, v1);
	    if (bindLen > 2)
	        checkBindingNoChanges(view, nodeDef, 2, v2);
	    if (bindLen > 3)
	        checkBindingNoChanges(view, nodeDef, 3, v3);
	    if (bindLen > 4)
	        checkBindingNoChanges(view, nodeDef, 4, v4);
	    if (bindLen > 5)
	        checkBindingNoChanges(view, nodeDef, 5, v5);
	    if (bindLen > 6)
	        checkBindingNoChanges(view, nodeDef, 6, v6);
	    if (bindLen > 7)
	        checkBindingNoChanges(view, nodeDef, 7, v7);
	    if (bindLen > 8)
	        checkBindingNoChanges(view, nodeDef, 8, v8);
	    if (bindLen > 9)
	        checkBindingNoChanges(view, nodeDef, 9, v9);
	}
	/**
	 * @param {?} view
	 * @param {?} nodeDef
	 * @param {?} values
	 * @return {?}
	 */
	function checkNoChangesNodeDynamic(view, nodeDef, values) {
	    for (var /** @type {?} */ i = 0; i < values.length; i++) {
	        checkBindingNoChanges(view, nodeDef, i, values[i]);
	    }
	}
	/**
	 * Workaround https://github.com/angular/tsickle/issues/497
	 * @suppress {misplacedTypeAnnotation}
	 * @param {?} view
	 * @param {?} nodeDef
	 * @return {?}
	 */
	function checkNoChangesQuery(view, nodeDef) {
	    var /** @type {?} */ queryList = asQueryList(view, nodeDef.index);
	    if (queryList.dirty) {
	        throw expressionChangedAfterItHasBeenCheckedError(Services.createDebugContext(view, nodeDef.index), "Query " + ((nodeDef.query)).id + " not dirty", "Query " + ((nodeDef.query)).id + " dirty", (view.state & 1 /* BeforeFirstCheck */) !== 0);
	    }
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function destroyView(view) {
	    if (view.state & 128 /* Destroyed */) {
	        return;
	    }
	    execEmbeddedViewsAction(view, ViewAction.Destroy);
	    execComponentViewsAction(view, ViewAction.Destroy);
	    callLifecycleHooksChildrenFirst(view, 131072 /* OnDestroy */);
	    if (view.disposables) {
	        for (var /** @type {?} */ i = 0; i < view.disposables.length; i++) {
	            view.disposables[i]();
	        }
	    }
	    detachProjectedView(view);
	    if (view.renderer.destroyNode) {
	        destroyViewNodes(view);
	    }
	    if (isComponentView(view)) {
	        view.renderer.destroy();
	    }
	    view.state |= 128 /* Destroyed */;
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function destroyViewNodes(view) {
	    var /** @type {?} */ len = view.def.nodes.length;
	    for (var /** @type {?} */ i = 0; i < len; i++) {
	        var /** @type {?} */ def = view.def.nodes[i];
	        if (def.flags & 1 /* TypeElement */) {
	            ((view.renderer.destroyNode))(asElementData(view, i).renderElement);
	        }
	        else if (def.flags & 2 /* TypeText */) {
	            ((view.renderer.destroyNode))(asTextData(view, i).renderText);
	        }
	    }
	}
	var ViewAction = {};
	ViewAction.CreateViewNodes = 0;
	ViewAction.CheckNoChanges = 1;
	ViewAction.CheckNoChangesProjectedViews = 2;
	ViewAction.CheckAndUpdate = 3;
	ViewAction.CheckAndUpdateProjectedViews = 4;
	ViewAction.Destroy = 5;
	ViewAction[ViewAction.CreateViewNodes] = "CreateViewNodes";
	ViewAction[ViewAction.CheckNoChanges] = "CheckNoChanges";
	ViewAction[ViewAction.CheckNoChangesProjectedViews] = "CheckNoChangesProjectedViews";
	ViewAction[ViewAction.CheckAndUpdate] = "CheckAndUpdate";
	ViewAction[ViewAction.CheckAndUpdateProjectedViews] = "CheckAndUpdateProjectedViews";
	ViewAction[ViewAction.Destroy] = "Destroy";
	/**
	 * @param {?} view
	 * @param {?} action
	 * @return {?}
	 */
	function execComponentViewsAction(view, action) {
	    var /** @type {?} */ def = view.def;
	    if (!(def.nodeFlags & 33554432 /* ComponentView */)) {
	        return;
	    }
	    for (var /** @type {?} */ i = 0; i < def.nodes.length; i++) {
	        var /** @type {?} */ nodeDef = def.nodes[i];
	        if (nodeDef.flags & 33554432 /* ComponentView */) {
	            // a leaf
	            callViewAction(asElementData(view, i).componentView, action);
	        }
	        else if ((nodeDef.childFlags & 33554432 /* ComponentView */) === 0) {
	            // a parent with leafs
	            // no child is a component,
	            // then skip the children
	            i += nodeDef.childCount;
	        }
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} action
	 * @return {?}
	 */
	function execEmbeddedViewsAction(view, action) {
	    var /** @type {?} */ def = view.def;
	    if (!(def.nodeFlags & 16777216 /* EmbeddedViews */)) {
	        return;
	    }
	    for (var /** @type {?} */ i = 0; i < def.nodes.length; i++) {
	        var /** @type {?} */ nodeDef = def.nodes[i];
	        if (nodeDef.flags & 16777216 /* EmbeddedViews */) {
	            // a leaf
	            var /** @type {?} */ embeddedViews = ((asElementData(view, i).viewContainer))._embeddedViews;
	            for (var /** @type {?} */ k = 0; k < embeddedViews.length; k++) {
	                callViewAction(embeddedViews[k], action);
	            }
	        }
	        else if ((nodeDef.childFlags & 16777216 /* EmbeddedViews */) === 0) {
	            // a parent with leafs
	            // no child is a component,
	            // then skip the children
	            i += nodeDef.childCount;
	        }
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} action
	 * @return {?}
	 */
	function callViewAction(view, action) {
	    var /** @type {?} */ viewState = view.state;
	    switch (action) {
	        case ViewAction.CheckNoChanges:
	            if ((viewState & 128 /* Destroyed */) === 0) {
	                if ((viewState & 12 /* CatDetectChanges */) === 12 /* CatDetectChanges */) {
	                    checkNoChangesView(view);
	                }
	                else if (viewState & 64 /* CheckProjectedViews */) {
	                    execProjectedViewsAction(view, ViewAction.CheckNoChangesProjectedViews);
	                }
	            }
	            break;
	        case ViewAction.CheckNoChangesProjectedViews:
	            if ((viewState & 128 /* Destroyed */) === 0) {
	                if (viewState & 32 /* CheckProjectedView */) {
	                    checkNoChangesView(view);
	                }
	                else if (viewState & 64 /* CheckProjectedViews */) {
	                    execProjectedViewsAction(view, action);
	                }
	            }
	            break;
	        case ViewAction.CheckAndUpdate:
	            if ((viewState & 128 /* Destroyed */) === 0) {
	                if ((viewState & 12 /* CatDetectChanges */) === 12 /* CatDetectChanges */) {
	                    checkAndUpdateView(view);
	                }
	                else if (viewState & 64 /* CheckProjectedViews */) {
	                    execProjectedViewsAction(view, ViewAction.CheckAndUpdateProjectedViews);
	                }
	            }
	            break;
	        case ViewAction.CheckAndUpdateProjectedViews:
	            if ((viewState & 128 /* Destroyed */) === 0) {
	                if (viewState & 32 /* CheckProjectedView */) {
	                    checkAndUpdateView(view);
	                }
	                else if (viewState & 64 /* CheckProjectedViews */) {
	                    execProjectedViewsAction(view, action);
	                }
	            }
	            break;
	        case ViewAction.Destroy:
	            // Note: destroyView recurses over all views,
	            // so we don't need to special case projected views here.
	            destroyView(view);
	            break;
	        case ViewAction.CreateViewNodes:
	            createViewNodes(view);
	            break;
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} action
	 * @return {?}
	 */
	function execProjectedViewsAction(view, action) {
	    execEmbeddedViewsAction(view, action);
	    execComponentViewsAction(view, action);
	}
	/**
	 * @param {?} view
	 * @param {?} queryFlags
	 * @param {?} staticDynamicQueryFlag
	 * @param {?} checkType
	 * @return {?}
	 */
	function execQueriesAction(view, queryFlags, staticDynamicQueryFlag, checkType) {
	    if (!(view.def.nodeFlags & queryFlags) || !(view.def.nodeFlags & staticDynamicQueryFlag)) {
	        return;
	    }
	    var /** @type {?} */ nodeCount = view.def.nodes.length;
	    for (var /** @type {?} */ i = 0; i < nodeCount; i++) {
	        var /** @type {?} */ nodeDef = view.def.nodes[i];
	        if ((nodeDef.flags & queryFlags) && (nodeDef.flags & staticDynamicQueryFlag)) {
	            Services.setCurrentNode(view, nodeDef.index);
	            switch (checkType) {
	                case 0 /* CheckAndUpdate */:
	                    checkAndUpdateQuery(view, nodeDef);
	                    break;
	                case 1 /* CheckNoChanges */:
	                    checkNoChangesQuery(view, nodeDef);
	                    break;
	            }
	        }
	        if (!(nodeDef.childFlags & queryFlags) || !(nodeDef.childFlags & staticDynamicQueryFlag)) {
	            // no child has a matching query
	            // then skip the children
	            i += nodeDef.childCount;
	        }
	    }
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var initialized = false;
	/**
	 * @return {?}
	 */
	function initServicesIfNeeded() {
	    if (initialized) {
	        return;
	    }
	    initialized = true;
	    var /** @type {?} */ services = isDevMode() ? createDebugServices() : createProdServices();
	    Services.setCurrentNode = services.setCurrentNode;
	    Services.createRootView = services.createRootView;
	    Services.createEmbeddedView = services.createEmbeddedView;
	    Services.createComponentView = services.createComponentView;
	    Services.createNgModuleRef = services.createNgModuleRef;
	    Services.overrideProvider = services.overrideProvider;
	    Services.clearProviderOverrides = services.clearProviderOverrides;
	    Services.checkAndUpdateView = services.checkAndUpdateView;
	    Services.checkNoChangesView = services.checkNoChangesView;
	    Services.destroyView = services.destroyView;
	    Services.resolveDep = resolveDep;
	    Services.createDebugContext = services.createDebugContext;
	    Services.handleEvent = services.handleEvent;
	    Services.updateDirectives = services.updateDirectives;
	    Services.updateRenderer = services.updateRenderer;
	    Services.dirtyParentQueries = dirtyParentQueries;
	}
	/**
	 * @return {?}
	 */
	function createProdServices() {
	    return {
	        setCurrentNode: function () { },
	        createRootView: createProdRootView,
	        createEmbeddedView: createEmbeddedView,
	        createComponentView: createComponentView,
	        createNgModuleRef: createNgModuleRef,
	        overrideProvider: NOOP,
	        clearProviderOverrides: NOOP,
	        checkAndUpdateView: checkAndUpdateView,
	        checkNoChangesView: checkNoChangesView,
	        destroyView: destroyView,
	        createDebugContext: function (view, nodeIndex) { return new DebugContext_(view, nodeIndex); },
	        handleEvent: function (view, nodeIndex, eventName, event) { return view.def.handleEvent(view, nodeIndex, eventName, event); },
	        updateDirectives: function (view, checkType) { return view.def.updateDirectives(checkType === 0 /* CheckAndUpdate */ ? prodCheckAndUpdateNode :
	            prodCheckNoChangesNode, view); },
	        updateRenderer: function (view, checkType) { return view.def.updateRenderer(checkType === 0 /* CheckAndUpdate */ ? prodCheckAndUpdateNode :
	            prodCheckNoChangesNode, view); },
	    };
	}
	/**
	 * @return {?}
	 */
	function createDebugServices() {
	    return {
	        setCurrentNode: debugSetCurrentNode,
	        createRootView: debugCreateRootView,
	        createEmbeddedView: debugCreateEmbeddedView,
	        createComponentView: debugCreateComponentView,
	        createNgModuleRef: debugCreateNgModuleRef,
	        overrideProvider: debugOverrideProvider,
	        clearProviderOverrides: debugClearProviderOverrides,
	        checkAndUpdateView: debugCheckAndUpdateView,
	        checkNoChangesView: debugCheckNoChangesView,
	        destroyView: debugDestroyView,
	        createDebugContext: function (view, nodeIndex) { return new DebugContext_(view, nodeIndex); },
	        handleEvent: debugHandleEvent,
	        updateDirectives: debugUpdateDirectives,
	        updateRenderer: debugUpdateRenderer,
	    };
	}
	/**
	 * @param {?} elInjector
	 * @param {?} projectableNodes
	 * @param {?} rootSelectorOrNode
	 * @param {?} def
	 * @param {?} ngModule
	 * @param {?=} context
	 * @return {?}
	 */
	function createProdRootView(elInjector, projectableNodes, rootSelectorOrNode, def, ngModule, context) {
	    var /** @type {?} */ rendererFactory = ngModule.injector.get(RendererFactory2);
	    return createRootView(createRootData(elInjector, ngModule, rendererFactory, projectableNodes, rootSelectorOrNode), def, context);
	}
	/**
	 * @param {?} elInjector
	 * @param {?} projectableNodes
	 * @param {?} rootSelectorOrNode
	 * @param {?} def
	 * @param {?} ngModule
	 * @param {?=} context
	 * @return {?}
	 */
	function debugCreateRootView(elInjector, projectableNodes, rootSelectorOrNode, def, ngModule, context) {
	    var /** @type {?} */ rendererFactory = ngModule.injector.get(RendererFactory2);
	    var /** @type {?} */ root = createRootData(elInjector, ngModule, new DebugRendererFactory2(rendererFactory), projectableNodes, rootSelectorOrNode);
	    var /** @type {?} */ defWithOverride = applyProviderOverridesToView(def);
	    return callWithDebugContext(DebugAction.create, createRootView, null, [root, defWithOverride, context]);
	}
	/**
	 * @param {?} elInjector
	 * @param {?} ngModule
	 * @param {?} rendererFactory
	 * @param {?} projectableNodes
	 * @param {?} rootSelectorOrNode
	 * @return {?}
	 */
	function createRootData(elInjector, ngModule, rendererFactory, projectableNodes, rootSelectorOrNode) {
	    var /** @type {?} */ sanitizer = ngModule.injector.get(Sanitizer);
	    var /** @type {?} */ errorHandler = ngModule.injector.get(ErrorHandler);
	    var /** @type {?} */ renderer = rendererFactory.createRenderer(null, null);
	    return {
	        ngModule: ngModule,
	        injector: elInjector, projectableNodes: projectableNodes,
	        selectorOrNode: rootSelectorOrNode, sanitizer: sanitizer, rendererFactory: rendererFactory, renderer: renderer, errorHandler: errorHandler
	    };
	}
	/**
	 * @param {?} parentView
	 * @param {?} anchorDef
	 * @param {?} viewDef
	 * @param {?=} context
	 * @return {?}
	 */
	function debugCreateEmbeddedView(parentView, anchorDef, viewDef$$1, context) {
	    var /** @type {?} */ defWithOverride = applyProviderOverridesToView(viewDef$$1);
	    return callWithDebugContext(DebugAction.create, createEmbeddedView, null, [parentView, anchorDef, defWithOverride, context]);
	}
	/**
	 * @param {?} parentView
	 * @param {?} nodeDef
	 * @param {?} viewDef
	 * @param {?} hostElement
	 * @return {?}
	 */
	function debugCreateComponentView(parentView, nodeDef, viewDef$$1, hostElement) {
	    var /** @type {?} */ defWithOverride = applyProviderOverridesToView(viewDef$$1);
	    return callWithDebugContext(DebugAction.create, createComponentView, null, [parentView, nodeDef, defWithOverride, hostElement]);
	}
	/**
	 * @param {?} moduleType
	 * @param {?} parentInjector
	 * @param {?} bootstrapComponents
	 * @param {?} def
	 * @return {?}
	 */
	function debugCreateNgModuleRef(moduleType, parentInjector, bootstrapComponents, def) {
	    var /** @type {?} */ defWithOverride = applyProviderOverridesToNgModule(def);
	    return createNgModuleRef(moduleType, parentInjector, bootstrapComponents, defWithOverride);
	}
	var providerOverrides = new Map();
	/**
	 * @param {?} override
	 * @return {?}
	 */
	function debugOverrideProvider(override) {
	    providerOverrides.set(override.token, override);
	}
	/**
	 * @return {?}
	 */
	function debugClearProviderOverrides() {
	    providerOverrides.clear();
	}
	/**
	 * @param {?} def
	 * @return {?}
	 */
	function applyProviderOverridesToView(def) {
	    if (providerOverrides.size === 0) {
	        return def;
	    }
	    var /** @type {?} */ elementIndicesWithOverwrittenProviders = findElementIndicesWithOverwrittenProviders(def);
	    if (elementIndicesWithOverwrittenProviders.length === 0) {
	        return def;
	    }
	    // clone the whole view definition,
	    // as it maintains references between the nodes that are hard to update.
	    def = ((def.factory))(function () { return NOOP; });
	    for (var /** @type {?} */ i = 0; i < elementIndicesWithOverwrittenProviders.length; i++) {
	        applyProviderOverridesToElement(def, elementIndicesWithOverwrittenProviders[i]);
	    }
	    return def;
	    /**
	     * @param {?} def
	     * @return {?}
	     */
	    function findElementIndicesWithOverwrittenProviders(def) {
	        var /** @type {?} */ elIndicesWithOverwrittenProviders = [];
	        var /** @type {?} */ lastElementDef = null;
	        for (var /** @type {?} */ i = 0; i < def.nodes.length; i++) {
	            var /** @type {?} */ nodeDef = def.nodes[i];
	            if (nodeDef.flags & 1 /* TypeElement */) {
	                lastElementDef = nodeDef;
	            }
	            if (lastElementDef && nodeDef.flags & 3840 /* CatProviderNoDirective */ &&
	                providerOverrides.has(/** @type {?} */ ((nodeDef.provider)).token)) {
	                elIndicesWithOverwrittenProviders.push(/** @type {?} */ ((lastElementDef)).index);
	                lastElementDef = null;
	            }
	        }
	        return elIndicesWithOverwrittenProviders;
	    }
	    /**
	     * @param {?} viewDef
	     * @param {?} elIndex
	     * @return {?}
	     */
	    function applyProviderOverridesToElement(viewDef$$1, elIndex) {
	        for (var /** @type {?} */ i = elIndex + 1; i < viewDef$$1.nodes.length; i++) {
	            var /** @type {?} */ nodeDef = viewDef$$1.nodes[i];
	            if (nodeDef.flags & 1 /* TypeElement */) {
	                // stop at the next element
	                return;
	            }
	            if (nodeDef.flags & 3840 /* CatProviderNoDirective */) {
	                // Make all providers lazy, so that we don't get into trouble
	                // with ordering problems of providers on the same element
	                nodeDef.flags |= 4096 /* LazyProvider */;
	                var /** @type {?} */ provider = ((nodeDef.provider));
	                var /** @type {?} */ override = providerOverrides.get(provider.token);
	                if (override) {
	                    nodeDef.flags = (nodeDef.flags & ~3840 /* CatProviderNoDirective */) | override.flags;
	                    provider.deps = splitDepsDsl(override.deps);
	                    provider.value = override.value;
	                }
	            }
	        }
	    }
	}
	/**
	 * @param {?} def
	 * @return {?}
	 */
	function applyProviderOverridesToNgModule(def) {
	    if (providerOverrides.size === 0 || !hasOverrrides(def)) {
	        return def;
	    }
	    // clone the whole view definition,
	    // as it maintains references between the nodes that are hard to update.
	    def = ((def.factory))(function () { return NOOP; });
	    applyProviderOverrides(def);
	    return def;
	    /**
	     * @param {?} def
	     * @return {?}
	     */
	    function hasOverrrides(def) {
	        return def.providers.some(function (node) { return !!(node.flags & 3840 /* CatProviderNoDirective */) && providerOverrides.has(node.token); });
	    }
	    /**
	     * @param {?} def
	     * @return {?}
	     */
	    function applyProviderOverrides(def) {
	        for (var /** @type {?} */ i = 0; i < def.providers.length; i++) {
	            var /** @type {?} */ provider = def.providers[i];
	            // Make all providers lazy, so that we don't get into trouble
	            // with ordering problems of providers on the same element
	            provider.flags |= 4096 /* LazyProvider */;
	            var /** @type {?} */ override = providerOverrides.get(provider.token);
	            if (override) {
	                provider.flags = (provider.flags & ~3840 /* CatProviderNoDirective */) | override.flags;
	                provider.deps = splitDepsDsl(override.deps);
	                provider.value = override.value;
	            }
	        }
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} nodeIndex
	 * @param {?} argStyle
	 * @param {?=} v0
	 * @param {?=} v1
	 * @param {?=} v2
	 * @param {?=} v3
	 * @param {?=} v4
	 * @param {?=} v5
	 * @param {?=} v6
	 * @param {?=} v7
	 * @param {?=} v8
	 * @param {?=} v9
	 * @return {?}
	 */
	function prodCheckAndUpdateNode(view, nodeIndex, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
	    var /** @type {?} */ nodeDef = view.def.nodes[nodeIndex];
	    checkAndUpdateNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
	    return (nodeDef.flags & 224 /* CatPureExpression */) ?
	        asPureExpressionData(view, nodeIndex).value :
	        undefined;
	}
	/**
	 * @param {?} view
	 * @param {?} nodeIndex
	 * @param {?} argStyle
	 * @param {?=} v0
	 * @param {?=} v1
	 * @param {?=} v2
	 * @param {?=} v3
	 * @param {?=} v4
	 * @param {?=} v5
	 * @param {?=} v6
	 * @param {?=} v7
	 * @param {?=} v8
	 * @param {?=} v9
	 * @return {?}
	 */
	function prodCheckNoChangesNode(view, nodeIndex, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
	    var /** @type {?} */ nodeDef = view.def.nodes[nodeIndex];
	    checkNoChangesNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
	    return (nodeDef.flags & 224 /* CatPureExpression */) ?
	        asPureExpressionData(view, nodeIndex).value :
	        undefined;
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function debugCheckAndUpdateView(view) {
	    return callWithDebugContext(DebugAction.detectChanges, checkAndUpdateView, null, [view]);
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function debugCheckNoChangesView(view) {
	    return callWithDebugContext(DebugAction.checkNoChanges, checkNoChangesView, null, [view]);
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function debugDestroyView(view) {
	    return callWithDebugContext(DebugAction.destroy, destroyView, null, [view]);
	}
	var DebugAction = {};
	DebugAction.create = 0;
	DebugAction.detectChanges = 1;
	DebugAction.checkNoChanges = 2;
	DebugAction.destroy = 3;
	DebugAction.handleEvent = 4;
	DebugAction[DebugAction.create] = "create";
	DebugAction[DebugAction.detectChanges] = "detectChanges";
	DebugAction[DebugAction.checkNoChanges] = "checkNoChanges";
	DebugAction[DebugAction.destroy] = "destroy";
	DebugAction[DebugAction.handleEvent] = "handleEvent";
	var _currentAction;
	var _currentView;
	var _currentNodeIndex;
	/**
	 * @param {?} view
	 * @param {?} nodeIndex
	 * @return {?}
	 */
	function debugSetCurrentNode(view, nodeIndex) {
	    _currentView = view;
	    _currentNodeIndex = nodeIndex;
	}
	/**
	 * @param {?} view
	 * @param {?} nodeIndex
	 * @param {?} eventName
	 * @param {?} event
	 * @return {?}
	 */
	function debugHandleEvent(view, nodeIndex, eventName, event) {
	    debugSetCurrentNode(view, nodeIndex);
	    return callWithDebugContext(DebugAction.handleEvent, view.def.handleEvent, null, [view, nodeIndex, eventName, event]);
	}
	/**
	 * @param {?} view
	 * @param {?} checkType
	 * @return {?}
	 */
	function debugUpdateDirectives(view, checkType) {
	    if (view.state & 128 /* Destroyed */) {
	        throw viewDestroyedError(DebugAction[_currentAction]);
	    }
	    debugSetCurrentNode(view, nextDirectiveWithBinding(view, 0));
	    return view.def.updateDirectives(debugCheckDirectivesFn, view);
	    /**
	     * @param {?} view
	     * @param {?} nodeIndex
	     * @param {?} argStyle
	     * @param {...?} values
	     * @return {?}
	     */
	    function debugCheckDirectivesFn(view, nodeIndex, argStyle) {
	        var values = [];
	        for (var _i = 3; _i < arguments.length; _i++) {
	            values[_i - 3] = arguments[_i];
	        }
	        var /** @type {?} */ nodeDef = view.def.nodes[nodeIndex];
	        if (checkType === 0 /* CheckAndUpdate */) {
	            debugCheckAndUpdateNode(view, nodeDef, argStyle, values);
	        }
	        else {
	            debugCheckNoChangesNode(view, nodeDef, argStyle, values);
	        }
	        if (nodeDef.flags & 16384 /* TypeDirective */) {
	            debugSetCurrentNode(view, nextDirectiveWithBinding(view, nodeIndex));
	        }
	        return (nodeDef.flags & 224 /* CatPureExpression */) ?
	            asPureExpressionData(view, nodeDef.index).value :
	            undefined;
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} checkType
	 * @return {?}
	 */
	function debugUpdateRenderer(view, checkType) {
	    if (view.state & 128 /* Destroyed */) {
	        throw viewDestroyedError(DebugAction[_currentAction]);
	    }
	    debugSetCurrentNode(view, nextRenderNodeWithBinding(view, 0));
	    return view.def.updateRenderer(debugCheckRenderNodeFn, view);
	    /**
	     * @param {?} view
	     * @param {?} nodeIndex
	     * @param {?} argStyle
	     * @param {...?} values
	     * @return {?}
	     */
	    function debugCheckRenderNodeFn(view, nodeIndex, argStyle) {
	        var values = [];
	        for (var _i = 3; _i < arguments.length; _i++) {
	            values[_i - 3] = arguments[_i];
	        }
	        var /** @type {?} */ nodeDef = view.def.nodes[nodeIndex];
	        if (checkType === 0 /* CheckAndUpdate */) {
	            debugCheckAndUpdateNode(view, nodeDef, argStyle, values);
	        }
	        else {
	            debugCheckNoChangesNode(view, nodeDef, argStyle, values);
	        }
	        if (nodeDef.flags & 3 /* CatRenderNode */) {
	            debugSetCurrentNode(view, nextRenderNodeWithBinding(view, nodeIndex));
	        }
	        return (nodeDef.flags & 224 /* CatPureExpression */) ?
	            asPureExpressionData(view, nodeDef.index).value :
	            undefined;
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} nodeDef
	 * @param {?} argStyle
	 * @param {?} givenValues
	 * @return {?}
	 */
	function debugCheckAndUpdateNode(view, nodeDef, argStyle, givenValues) {
	    var /** @type {?} */ changed = ((checkAndUpdateNode)).apply(void 0, [view, nodeDef, argStyle].concat(givenValues));
	    if (changed) {
	        var /** @type {?} */ values = argStyle === 1 /* Dynamic */ ? givenValues[0] : givenValues;
	        if (nodeDef.flags & 16384 /* TypeDirective */) {
	            var /** @type {?} */ bindingValues = {};
	            for (var /** @type {?} */ i = 0; i < nodeDef.bindings.length; i++) {
	                var /** @type {?} */ binding = nodeDef.bindings[i];
	                var /** @type {?} */ value = values[i];
	                if (binding.flags & 8 /* TypeProperty */) {
	                    bindingValues[normalizeDebugBindingName(/** @type {?} */ ((binding.nonMinifiedName)))] =
	                        normalizeDebugBindingValue(value);
	                }
	            }
	            var /** @type {?} */ elDef = ((nodeDef.parent));
	            var /** @type {?} */ el = asElementData(view, elDef.index).renderElement;
	            if (!((elDef.element)).name) {
	                // a comment.
	                view.renderer.setValue(el, "bindings=" + JSON.stringify(bindingValues, null, 2));
	            }
	            else {
	                // a regular element.
	                for (var /** @type {?} */ attr in bindingValues) {
	                    var /** @type {?} */ value = bindingValues[attr];
	                    if (value != null) {
	                        view.renderer.setAttribute(el, attr, value);
	                    }
	                    else {
	                        view.renderer.removeAttribute(el, attr);
	                    }
	                }
	            }
	        }
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} nodeDef
	 * @param {?} argStyle
	 * @param {?} values
	 * @return {?}
	 */
	function debugCheckNoChangesNode(view, nodeDef, argStyle, values) {
	    ((checkNoChangesNode)).apply(void 0, [view, nodeDef, argStyle].concat(values));
	}
	/**
	 * @param {?} name
	 * @return {?}
	 */
	function normalizeDebugBindingName(name) {
	    // Attribute names with `$` (eg `x-y$`) are valid per spec, but unsupported by some browsers
	    name = camelCaseToDashCase(name.replace(/[$@]/g, '_'));
	    return "ng-reflect-" + name;
	}
	var CAMEL_CASE_REGEXP = /([A-Z])/g;
	/**
	 * @param {?} input
	 * @return {?}
	 */
	function camelCaseToDashCase(input) {
	    return input.replace(CAMEL_CASE_REGEXP, function () {
	        var m = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            m[_i] = arguments[_i];
	        }
	        return '-' + m[1].toLowerCase();
	    });
	}
	/**
	 * @param {?} value
	 * @return {?}
	 */
	function normalizeDebugBindingValue(value) {
	    try {
	        // Limit the size of the value as otherwise the DOM just gets polluted.
	        return value != null ? value.toString().slice(0, 30) : value;
	    }
	    catch (e) {
	        return '[ERROR] Exception while trying to serialize the value';
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} nodeIndex
	 * @return {?}
	 */
	function nextDirectiveWithBinding(view, nodeIndex) {
	    for (var /** @type {?} */ i = nodeIndex; i < view.def.nodes.length; i++) {
	        var /** @type {?} */ nodeDef = view.def.nodes[i];
	        if (nodeDef.flags & 16384 /* TypeDirective */ && nodeDef.bindings && nodeDef.bindings.length) {
	            return i;
	        }
	    }
	    return null;
	}
	/**
	 * @param {?} view
	 * @param {?} nodeIndex
	 * @return {?}
	 */
	function nextRenderNodeWithBinding(view, nodeIndex) {
	    for (var /** @type {?} */ i = nodeIndex; i < view.def.nodes.length; i++) {
	        var /** @type {?} */ nodeDef = view.def.nodes[i];
	        if ((nodeDef.flags & 3 /* CatRenderNode */) && nodeDef.bindings && nodeDef.bindings.length) {
	            return i;
	        }
	    }
	    return null;
	}
	var DebugContext_ = (function () {
	    /**
	     * @param {?} view
	     * @param {?} nodeIndex
	     */
	    function DebugContext_(view, nodeIndex) {
	        this.view = view;
	        this.nodeIndex = nodeIndex;
	        if (nodeIndex == null) {
	            this.nodeIndex = nodeIndex = 0;
	        }
	        this.nodeDef = view.def.nodes[nodeIndex];
	        var elDef = this.nodeDef;
	        var elView = view;
	        while (elDef && (elDef.flags & 1 /* TypeElement */) === 0) {
	            elDef = elDef.parent;
	        }
	        if (!elDef) {
	            while (!elDef && elView) {
	                elDef = viewParentEl(elView);
	                elView = elView.parent;
	            }
	        }
	        this.elDef = elDef;
	        this.elView = elView;
	    }
	    Object.defineProperty(DebugContext_.prototype, "elOrCompView", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            // Has to be done lazily as we use the DebugContext also during creation of elements...
	            return asElementData(this.elView, this.elDef.index).componentView || this.view;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugContext_.prototype, "injector", {
	        /**
	         * @return {?}
	         */
	        get: function () { return createInjector(this.elView, this.elDef); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugContext_.prototype, "component", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.elOrCompView.component; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugContext_.prototype, "context", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.elOrCompView.context; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugContext_.prototype, "providerTokens", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            var /** @type {?} */ tokens = [];
	            if (this.elDef) {
	                for (var /** @type {?} */ i = this.elDef.index + 1; i <= this.elDef.index + this.elDef.childCount; i++) {
	                    var /** @type {?} */ childDef = this.elView.def.nodes[i];
	                    if (childDef.flags & 20224 /* CatProvider */) {
	                        tokens.push(/** @type {?} */ ((childDef.provider)).token);
	                    }
	                    i += childDef.childCount;
	                }
	            }
	            return tokens;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugContext_.prototype, "references", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            var /** @type {?} */ references = {};
	            if (this.elDef) {
	                collectReferences(this.elView, this.elDef, references);
	                for (var /** @type {?} */ i = this.elDef.index + 1; i <= this.elDef.index + this.elDef.childCount; i++) {
	                    var /** @type {?} */ childDef = this.elView.def.nodes[i];
	                    if (childDef.flags & 20224 /* CatProvider */) {
	                        collectReferences(this.elView, childDef, references);
	                    }
	                    i += childDef.childCount;
	                }
	            }
	            return references;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugContext_.prototype, "componentRenderElement", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            var /** @type {?} */ elData = findHostElement(this.elOrCompView);
	            return elData ? elData.renderElement : undefined;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugContext_.prototype, "renderNode", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            return this.nodeDef.flags & 2 /* TypeText */ ? renderNode(this.view, this.nodeDef) :
	                renderNode(this.elView, this.elDef);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @param {?} console
	     * @param {...?} values
	     * @return {?}
	     */
	    DebugContext_.prototype.logError = function (console) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var /** @type {?} */ logViewDef;
	        var /** @type {?} */ logNodeIndex;
	        if (this.nodeDef.flags & 2 /* TypeText */) {
	            logViewDef = this.view.def;
	            logNodeIndex = this.nodeDef.index;
	        }
	        else {
	            logViewDef = this.elView.def;
	            logNodeIndex = this.elDef.index;
	        }
	        // Note: we only generate a log function for text and element nodes
	        // to make the generated code as small as possible.
	        var /** @type {?} */ renderNodeIndex = getRenderNodeIndex(logViewDef, logNodeIndex);
	        var /** @type {?} */ currRenderNodeIndex = -1;
	        var /** @type {?} */ nodeLogger = function () {
	            currRenderNodeIndex++;
	            if (currRenderNodeIndex === renderNodeIndex) {
	                return (_a = console.error).bind.apply(_a, [console].concat(values));
	            }
	            else {
	                return NOOP;
	            }
	            var _a;
	        }; /** @type {?} */
	        ((logViewDef.factory))(nodeLogger);
	        if (currRenderNodeIndex < renderNodeIndex) {
	            console.error('Illegal state: the ViewDefinitionFactory did not call the logger!');
	            console.error.apply(console, values);
	        }
	    };
	    return DebugContext_;
	}());
	/**
	 * @param {?} viewDef
	 * @param {?} nodeIndex
	 * @return {?}
	 */
	function getRenderNodeIndex(viewDef$$1, nodeIndex) {
	    var /** @type {?} */ renderNodeIndex = -1;
	    for (var /** @type {?} */ i = 0; i <= nodeIndex; i++) {
	        var /** @type {?} */ nodeDef = viewDef$$1.nodes[i];
	        if (nodeDef.flags & 3 /* CatRenderNode */) {
	            renderNodeIndex++;
	        }
	    }
	    return renderNodeIndex;
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function findHostElement(view) {
	    while (view && !isComponentView(view)) {
	        view = ((view.parent));
	    }
	    if (view.parent) {
	        return asElementData(view.parent, /** @type {?} */ ((viewParentEl(view))).index);
	    }
	    return null;
	}
	/**
	 * @param {?} view
	 * @param {?} nodeDef
	 * @param {?} references
	 * @return {?}
	 */
	function collectReferences(view, nodeDef, references) {
	    for (var /** @type {?} */ refName in nodeDef.references) {
	        references[refName] = getQueryValue(view, nodeDef, nodeDef.references[refName]);
	    }
	}
	/**
	 * @param {?} action
	 * @param {?} fn
	 * @param {?} self
	 * @param {?} args
	 * @return {?}
	 */
	function callWithDebugContext(action, fn, self, args) {
	    var /** @type {?} */ oldAction = _currentAction;
	    var /** @type {?} */ oldView = _currentView;
	    var /** @type {?} */ oldNodeIndex = _currentNodeIndex;
	    try {
	        _currentAction = action;
	        var /** @type {?} */ result = fn.apply(self, args);
	        _currentView = oldView;
	        _currentNodeIndex = oldNodeIndex;
	        _currentAction = oldAction;
	        return result;
	    }
	    catch (e) {
	        if (isViewDebugError(e) || !_currentView) {
	            throw e;
	        }
	        throw viewWrappedDebugError(e, /** @type {?} */ ((getCurrentDebugContext())));
	    }
	}
	/**
	 * @return {?}
	 */
	function getCurrentDebugContext() {
	    return _currentView ? new DebugContext_(_currentView, _currentNodeIndex) : null;
	}
	var DebugRendererFactory2 = (function () {
	    /**
	     * @param {?} delegate
	     */
	    function DebugRendererFactory2(delegate) {
	        this.delegate = delegate;
	    }
	    /**
	     * @param {?} element
	     * @param {?} renderData
	     * @return {?}
	     */
	    DebugRendererFactory2.prototype.createRenderer = function (element, renderData) {
	        return new DebugRenderer2(this.delegate.createRenderer(element, renderData));
	    };
	    /**
	     * @return {?}
	     */
	    DebugRendererFactory2.prototype.begin = function () {
	        if (this.delegate.begin) {
	            this.delegate.begin();
	        }
	    };
	    /**
	     * @return {?}
	     */
	    DebugRendererFactory2.prototype.end = function () {
	        if (this.delegate.end) {
	            this.delegate.end();
	        }
	    };
	    /**
	     * @return {?}
	     */
	    DebugRendererFactory2.prototype.whenRenderingDone = function () {
	        if (this.delegate.whenRenderingDone) {
	            return this.delegate.whenRenderingDone();
	        }
	        return Promise.resolve(null);
	    };
	    return DebugRendererFactory2;
	}());
	var DebugRenderer2 = (function () {
	    /**
	     * @param {?} delegate
	     */
	    function DebugRenderer2(delegate) {
	        this.delegate = delegate;
	    }
	    Object.defineProperty(DebugRenderer2.prototype, "data", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.delegate.data; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    DebugRenderer2.prototype.destroyNode = function (node) {
	        removeDebugNodeFromIndex(/** @type {?} */ ((getDebugNode(node))));
	        if (this.delegate.destroyNode) {
	            this.delegate.destroyNode(node);
	        }
	    };
	    /**
	     * @return {?}
	     */
	    DebugRenderer2.prototype.destroy = function () { this.delegate.destroy(); };
	    /**
	     * @param {?} name
	     * @param {?=} namespace
	     * @return {?}
	     */
	    DebugRenderer2.prototype.createElement = function (name, namespace) {
	        var /** @type {?} */ el = this.delegate.createElement(name, namespace);
	        var /** @type {?} */ debugCtx = getCurrentDebugContext();
	        if (debugCtx) {
	            var /** @type {?} */ debugEl = new DebugElement(el, null, debugCtx);
	            debugEl.name = name;
	            indexDebugNode(debugEl);
	        }
	        return el;
	    };
	    /**
	     * @param {?} value
	     * @return {?}
	     */
	    DebugRenderer2.prototype.createComment = function (value) {
	        var /** @type {?} */ comment = this.delegate.createComment(value);
	        var /** @type {?} */ debugCtx = getCurrentDebugContext();
	        if (debugCtx) {
	            indexDebugNode(new DebugNode(comment, null, debugCtx));
	        }
	        return comment;
	    };
	    /**
	     * @param {?} value
	     * @return {?}
	     */
	    DebugRenderer2.prototype.createText = function (value) {
	        var /** @type {?} */ text = this.delegate.createText(value);
	        var /** @type {?} */ debugCtx = getCurrentDebugContext();
	        if (debugCtx) {
	            indexDebugNode(new DebugNode(text, null, debugCtx));
	        }
	        return text;
	    };
	    /**
	     * @param {?} parent
	     * @param {?} newChild
	     * @return {?}
	     */
	    DebugRenderer2.prototype.appendChild = function (parent, newChild) {
	        var /** @type {?} */ debugEl = getDebugNode(parent);
	        var /** @type {?} */ debugChildEl = getDebugNode(newChild);
	        if (debugEl && debugChildEl && debugEl instanceof DebugElement) {
	            debugEl.addChild(debugChildEl);
	        }
	        this.delegate.appendChild(parent, newChild);
	    };
	    /**
	     * @param {?} parent
	     * @param {?} newChild
	     * @param {?} refChild
	     * @return {?}
	     */
	    DebugRenderer2.prototype.insertBefore = function (parent, newChild, refChild) {
	        var /** @type {?} */ debugEl = getDebugNode(parent);
	        var /** @type {?} */ debugChildEl = getDebugNode(newChild);
	        var /** @type {?} */ debugRefEl = ((getDebugNode(refChild)));
	        if (debugEl && debugChildEl && debugEl instanceof DebugElement) {
	            debugEl.insertBefore(debugRefEl, debugChildEl);
	        }
	        this.delegate.insertBefore(parent, newChild, refChild);
	    };
	    /**
	     * @param {?} parent
	     * @param {?} oldChild
	     * @return {?}
	     */
	    DebugRenderer2.prototype.removeChild = function (parent, oldChild) {
	        var /** @type {?} */ debugEl = getDebugNode(parent);
	        var /** @type {?} */ debugChildEl = getDebugNode(oldChild);
	        if (debugEl && debugChildEl && debugEl instanceof DebugElement) {
	            debugEl.removeChild(debugChildEl);
	        }
	        this.delegate.removeChild(parent, oldChild);
	    };
	    /**
	     * @param {?} selectorOrNode
	     * @return {?}
	     */
	    DebugRenderer2.prototype.selectRootElement = function (selectorOrNode) {
	        var /** @type {?} */ el = this.delegate.selectRootElement(selectorOrNode);
	        var /** @type {?} */ debugCtx = getCurrentDebugContext();
	        if (debugCtx) {
	            indexDebugNode(new DebugElement(el, null, debugCtx));
	        }
	        return el;
	    };
	    /**
	     * @param {?} el
	     * @param {?} name
	     * @param {?} value
	     * @param {?=} namespace
	     * @return {?}
	     */
	    DebugRenderer2.prototype.setAttribute = function (el, name, value, namespace) {
	        var /** @type {?} */ debugEl = getDebugNode(el);
	        if (debugEl && debugEl instanceof DebugElement) {
	            var /** @type {?} */ fullName = namespace ? namespace + ':' + name : name;
	            debugEl.attributes[fullName] = value;
	        }
	        this.delegate.setAttribute(el, name, value, namespace);
	    };
	    /**
	     * @param {?} el
	     * @param {?} name
	     * @param {?=} namespace
	     * @return {?}
	     */
	    DebugRenderer2.prototype.removeAttribute = function (el, name, namespace) {
	        var /** @type {?} */ debugEl = getDebugNode(el);
	        if (debugEl && debugEl instanceof DebugElement) {
	            var /** @type {?} */ fullName = namespace ? namespace + ':' + name : name;
	            debugEl.attributes[fullName] = null;
	        }
	        this.delegate.removeAttribute(el, name, namespace);
	    };
	    /**
	     * @param {?} el
	     * @param {?} name
	     * @return {?}
	     */
	    DebugRenderer2.prototype.addClass = function (el, name) {
	        var /** @type {?} */ debugEl = getDebugNode(el);
	        if (debugEl && debugEl instanceof DebugElement) {
	            debugEl.classes[name] = true;
	        }
	        this.delegate.addClass(el, name);
	    };
	    /**
	     * @param {?} el
	     * @param {?} name
	     * @return {?}
	     */
	    DebugRenderer2.prototype.removeClass = function (el, name) {
	        var /** @type {?} */ debugEl = getDebugNode(el);
	        if (debugEl && debugEl instanceof DebugElement) {
	            debugEl.classes[name] = false;
	        }
	        this.delegate.removeClass(el, name);
	    };
	    /**
	     * @param {?} el
	     * @param {?} style
	     * @param {?} value
	     * @param {?} flags
	     * @return {?}
	     */
	    DebugRenderer2.prototype.setStyle = function (el, style, value, flags) {
	        var /** @type {?} */ debugEl = getDebugNode(el);
	        if (debugEl && debugEl instanceof DebugElement) {
	            debugEl.styles[style] = value;
	        }
	        this.delegate.setStyle(el, style, value, flags);
	    };
	    /**
	     * @param {?} el
	     * @param {?} style
	     * @param {?} flags
	     * @return {?}
	     */
	    DebugRenderer2.prototype.removeStyle = function (el, style, flags) {
	        var /** @type {?} */ debugEl = getDebugNode(el);
	        if (debugEl && debugEl instanceof DebugElement) {
	            debugEl.styles[style] = null;
	        }
	        this.delegate.removeStyle(el, style, flags);
	    };
	    /**
	     * @param {?} el
	     * @param {?} name
	     * @param {?} value
	     * @return {?}
	     */
	    DebugRenderer2.prototype.setProperty = function (el, name, value) {
	        var /** @type {?} */ debugEl = getDebugNode(el);
	        if (debugEl && debugEl instanceof DebugElement) {
	            debugEl.properties[name] = value;
	        }
	        this.delegate.setProperty(el, name, value);
	    };
	    /**
	     * @param {?} target
	     * @param {?} eventName
	     * @param {?} callback
	     * @return {?}
	     */
	    DebugRenderer2.prototype.listen = function (target, eventName, callback) {
	        if (typeof target !== 'string') {
	            var /** @type {?} */ debugEl = getDebugNode(target);
	            if (debugEl) {
	                debugEl.listeners.push(new EventListener(eventName, callback));
	            }
	        }
	        return this.delegate.listen(target, eventName, callback);
	    };
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    DebugRenderer2.prototype.parentNode = function (node) { return this.delegate.parentNode(node); };
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    DebugRenderer2.prototype.nextSibling = function (node) { return this.delegate.nextSibling(node); };
	    /**
	     * @param {?} node
	     * @param {?} value
	     * @return {?}
	     */
	    DebugRenderer2.prototype.setValue = function (node, value) { return this.delegate.setValue(node, value); };
	    return DebugRenderer2;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} override
	 * @return {?}
	 */
	function overrideProvider(override) {
	    initServicesIfNeeded();
	    return Services.overrideProvider(override);
	}
	/**
	 * @return {?}
	 */
	function clearProviderOverrides() {
	    initServicesIfNeeded();
	    return Services.clearProviderOverrides();
	}
	/**
	 * @param {?} ngModuleType
	 * @param {?} bootstrapComponents
	 * @param {?} defFactory
	 * @return {?}
	 */
	function createNgModuleFactory(ngModuleType, bootstrapComponents, defFactory) {
	    return new NgModuleFactory_(ngModuleType, bootstrapComponents, defFactory);
	}
	var NgModuleFactory_ = (function (_super) {
	    __extends(NgModuleFactory_, _super);
	    /**
	     * @param {?} moduleType
	     * @param {?} _bootstrapComponents
	     * @param {?} _ngModuleDefFactory
	     */
	    function NgModuleFactory_(moduleType, _bootstrapComponents, _ngModuleDefFactory) {
	        var _this = 
	        // Attention: this ctor is called as top level function.
	        // Putting any logic in here will destroy closure tree shaking!
	        _super.call(this) || this;
	        _this.moduleType = moduleType;
	        _this._bootstrapComponents = _bootstrapComponents;
	        _this._ngModuleDefFactory = _ngModuleDefFactory;
	        return _this;
	    }
	    /**
	     * @param {?} parentInjector
	     * @return {?}
	     */
	    NgModuleFactory_.prototype.create = function (parentInjector) {
	        initServicesIfNeeded();
	        var /** @type {?} */ def = resolveDefinition(this._ngModuleDefFactory);
	        return Services.createNgModuleRef(this.moduleType, parentInjector || Injector.NULL, this._bootstrapComponents, def);
	    };
	    return NgModuleFactory_;
	}(NgModuleFactory));
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@experimental Animation support is experimental.
	 */
	/**
	 * `trigger` is an animation-specific function that is designed to be used inside of Angular's
	 * animation DSL language. If this information is new, please navigate to the
	 * {\@link Component#animations component animations metadata page} to gain a better
	 * understanding of how animations in Angular are used.
	 *
	 * `trigger` Creates an animation trigger which will a list of {\@link state state} and
	 * {\@link transition transition} entries that will be evaluated when the expression
	 * bound to the trigger changes.
	 *
	 * Triggers are registered within the component annotation data under the
	 * {\@link Component#animations animations section}. An animation trigger can be placed on an element
	 * within a template by referencing the name of the trigger followed by the expression value that
	 * the
	 * trigger is bound to (in the form of `[\@triggerName]="expression"`.
	 *
	 * ### Usage
	 *
	 * `trigger` will create an animation trigger reference based on the provided `name` value. The
	 * provided `animation` value is expected to be an array consisting of {\@link state state} and
	 * {\@link transition transition} declarations.
	 *
	 * ```typescript
	 * \@Component({
	 *   selector: 'my-component',
	 *   templateUrl: 'my-component-tpl.html',
	 *   animations: [
	 *     trigger("myAnimationTrigger", [
	 *       state(...),
	 *       state(...),
	 *       transition(...),
	 *       transition(...)
	 *     ])
	 *   ]
	 * })
	 * class MyComponent {
	 *   myStatusExp = "something";
	 * }
	 * ```
	 *
	 * The template associated with this component will make use of the `myAnimationTrigger` animation
	 * trigger by binding to an element within its template code.
	 *
	 * ```html
	 * <!-- somewhere inside of my-component-tpl.html -->
	 * <div [\@myAnimationTrigger]="myStatusExp">...</div>
	 * ```
	 *
	 * ## Disable Child Animations
	 * A special animation control binding called `\@.disabled` can be placed on an element which will
	 * then disable animations for any inner animation triggers situated within the element.
	 *
	 * When true, the `\@.disabled` binding will prevent inner animations from rendering. The example
	 * below shows how to use this feature:
	 *
	 * ```ts
	 * \@Component({
	 *   selector: 'my-component',
	 *   template: `
	 *     <div [\@.disabled]="isDisabled">
	 *       <div [\@childAnimation]="exp"></div>
	 *     </div>
	 *   `,
	 *   animations: [
	 *     trigger("childAnimation", [
	 *       // ...
	 *     ])
	 *   ]
	 * })
	 * class MyComponent {
	 *   isDisabled = true;
	 *   exp = '...';
	 * }
	 * ```
	 *
	 * The `\@childAnimation` trigger will not animate because `\@.disabled` prevents it from happening
	 * (when true).
	 *
	 * Note that `\@.disbled` will only disable inner animations (any animations running on the same
	 * element will not be disabled).
	 *
	 * ### Disabling Animations Application-wide
	 * When an area of the template is set to have animations disabled, **all** inner components will
	 * also have their animations disabled as well. This means that all animations for an angular
	 * application can be disabled by placing a host binding set on `\@.disabled` on the topmost Angular
	 * component.
	 *
	 * ```ts
	 * import {Component, HostBinding} from '\@angular/core';
	 *
	 * \@Component({
	 *   selector: 'app-component',
	 *   templateUrl: 'app.component.html',
	 * })
	 * class AppComponent {
	 *   \@HostBinding('\@.disabled')
	 *   public animationsDisabled = true;
	 * }
	 * ```
	 *
	 * ### What about animations that us `query()` and `animateChild()`?
	 * Despite inner animations being disabled, a parent animation can {\@link query query} for inner
	 * elements located in disabled areas of the template and still animate them as it sees fit. This is
	 * also the case for when a sub animation is queried by a parent and then later animated using {\@link
	 * animateChild animateChild}.
	 *
	 * \@experimental Animation support is experimental.
	 * @param {?} name
	 * @param {?} definitions
	 * @return {?}
	 */
	function trigger$1(name, definitions) {
	    return { type: 7 /* Trigger */, name: name, definitions: definitions, options: {} };
	}
	/**
	 * `animate` is an animation-specific function that is designed to be used inside of Angular's
	 * animation DSL language. If this information is new, please navigate to the {\@link
	 * Component#animations component animations metadata page} to gain a better understanding of
	 * how animations in Angular are used.
	 *
	 * `animate` specifies an animation step that will apply the provided `styles` data for a given
	 * amount of time based on the provided `timing` expression value. Calls to `animate` are expected
	 * to be used within {\@link sequence an animation sequence}, {\@link group group}, or {\@link
	 * transition transition}.
	 *
	 * ### Usage
	 *
	 * The `animate` function accepts two input parameters: `timing` and `styles`:
	 *
	 * - `timing` is a string based value that can be a combination of a duration with optional delay
	 * and easing values. The format for the expression breaks down to `duration delay easing`
	 * (therefore a value such as `1s 100ms ease-out` will be parse itself into `duration=1000,
	 * delay=100, easing=ease-out`. If a numeric value is provided then that will be used as the
	 * `duration` value in millisecond form.
	 * - `styles` is the style input data which can either be a call to {\@link style style} or {\@link
	 * keyframes keyframes}. If left empty then the styles from the destination state will be collected
	 * and used (this is useful when describing an animation step that will complete an animation by
	 * {\@link transition#the-final-animate-call animating to the final state}).
	 *
	 * ```typescript
	 * // various functions for specifying timing data
	 * animate(500, style(...))
	 * animate("1s", style(...))
	 * animate("100ms 0.5s", style(...))
	 * animate("5s ease", style(...))
	 * animate("5s 10ms cubic-bezier(.17,.67,.88,.1)", style(...))
	 *
	 * // either style() of keyframes() can be used
	 * animate(500, style({ background: "red" }))
	 * animate(500, keyframes([
	 *   style({ background: "blue" })),
	 *   style({ background: "red" }))
	 * ])
	 * ```
	 *
	 * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * \@experimental Animation support is experimental.
	 * @param {?} timings
	 * @param {?=} styles
	 * @return {?}
	 */
	function animate$1(timings, styles) {
	    if (styles === void 0) { styles = null; }
	    return { type: 4 /* Animate */, styles: styles, timings: timings };
	}
	/**
	 * `group` is an animation-specific function that is designed to be used inside of Angular's
	 * animation DSL language. If this information is new, please navigate to the {\@link
	 * Component#animations component animations metadata page} to gain a better understanding of
	 * how animations in Angular are used.
	 *
	 * `group` specifies a list of animation steps that are all run in parallel. Grouped animations are
	 * useful when a series of styles must be animated/closed off at different starting/ending times.
	 *
	 * The `group` function can either be used within a {\@link sequence sequence} or a {\@link transition
	 * transition} and it will only continue to the next instruction once all of the inner animation
	 * steps have completed.
	 *
	 * ### Usage
	 *
	 * The `steps` data that is passed into the `group` animation function can either consist of {\@link
	 * style style} or {\@link animate animate} function calls. Each call to `style()` or `animate()`
	 * within a group will be executed instantly (use {\@link keyframes keyframes} or a {\@link
	 * animate#usage animate() with a delay value} to offset styles to be applied at a later time).
	 *
	 * ```typescript
	 * group([
	 *   animate("1s", { background: "black" }))
	 *   animate("2s", { color: "white" }))
	 * ])
	 * ```
	 *
	 * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * \@experimental Animation support is experimental.
	 * @param {?} steps
	 * @param {?=} options
	 * @return {?}
	 */
	function group$1(steps, options) {
	    if (options === void 0) { options = null; }
	    return { type: 3 /* Group */, steps: steps, options: options };
	}
	/**
	 * `sequence` is an animation-specific function that is designed to be used inside of Angular's
	 * animation DSL language. If this information is new, please navigate to the {\@link
	 * Component#animations component animations metadata page} to gain a better understanding of
	 * how animations in Angular are used.
	 *
	 * `sequence` Specifies a list of animation steps that are run one by one. (`sequence` is used by
	 * default when an array is passed as animation data into {\@link transition transition}.)
	 *
	 * The `sequence` function can either be used within a {\@link group group} or a {\@link transition
	 * transition} and it will only continue to the next instruction once each of the inner animation
	 * steps have completed.
	 *
	 * To perform animation styling in parallel with other animation steps then have a look at the
	 * {\@link group group} animation function.
	 *
	 * ### Usage
	 *
	 * The `steps` data that is passed into the `sequence` animation function can either consist of
	 * {\@link style style} or {\@link animate animate} function calls. A call to `style()` will apply the
	 * provided styling data immediately while a call to `animate()` will apply its styling data over a
	 * given time depending on its timing data.
	 *
	 * ```typescript
	 * sequence([
	 *   style({ opacity: 0 })),
	 *   animate("1s", { opacity: 1 }))
	 * ])
	 * ```
	 *
	 * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * \@experimental Animation support is experimental.
	 * @param {?} steps
	 * @param {?=} options
	 * @return {?}
	 */
	function sequence$1(steps, options) {
	    if (options === void 0) { options = null; }
	    return { type: 2 /* Sequence */, steps: steps, options: options };
	}
	/**
	 * `style` is an animation-specific function that is designed to be used inside of Angular's
	 * animation DSL language. If this information is new, please navigate to the {\@link
	 * Component#animations component animations metadata page} to gain a better understanding of
	 * how animations in Angular are used.
	 *
	 * `style` declares a key/value object containing CSS properties/styles that can then be used for
	 * {\@link state animation states}, within an {\@link sequence animation sequence}, or as styling data
	 * for both {\@link animate animate} and {\@link keyframes keyframes}.
	 *
	 * ### Usage
	 *
	 * `style` takes in a key/value string map as data and expects one or more CSS property/value pairs
	 * to be defined.
	 *
	 * ```typescript
	 * // string values are used for css properties
	 * style({ background: "red", color: "blue" })
	 *
	 * // numerical (pixel) values are also supported
	 * style({ width: 100, height: 0 })
	 * ```
	 *
	 * #### Auto-styles (using `*`)
	 *
	 * When an asterix (`*`) character is used as a value then it will be detected from the element
	 * being animated and applied as animation data when the animation starts.
	 *
	 * This feature proves useful for a state depending on layout and/or environment factors; in such
	 * cases the styles are calculated just before the animation starts.
	 *
	 * ```typescript
	 * // the steps below will animate from 0 to the
	 * // actual height of the element
	 * style({ height: 0 }),
	 * animate("1s", style({ height: "*" }))
	 * ```
	 *
	 * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * \@experimental Animation support is experimental.
	 * @param {?} tokens
	 * @return {?}
	 */
	function style$1(tokens) {
	    return { type: 6 /* Style */, styles: tokens, offset: null };
	}
	/**
	 * `state` is an animation-specific function that is designed to be used inside of Angular's
	 * animation DSL language. If this information is new, please navigate to the {\@link
	 * Component#animations component animations metadata page} to gain a better understanding of
	 * how animations in Angular are used.
	 *
	 * `state` declares an animation state within the given trigger. When a state is active within a
	 * component then its associated styles will persist on the element that the trigger is attached to
	 * (even when the animation ends).
	 *
	 * To animate between states, have a look at the animation {\@link transition transition} DSL
	 * function. To register states to an animation trigger please have a look at the {\@link trigger
	 * trigger} function.
	 *
	 * #### The `void` state
	 *
	 * The `void` state value is a reserved word that angular uses to determine when the element is not
	 * apart of the application anymore (e.g. when an `ngIf` evaluates to false then the state of the
	 * associated element is void).
	 *
	 * #### The `*` (default) state
	 *
	 * The `*` state (when styled) is a fallback state that will be used if the state that is being
	 * animated is not declared within the trigger.
	 *
	 * ### Usage
	 *
	 * `state` will declare an animation state with its associated styles
	 * within the given trigger.
	 *
	 * - `stateNameExpr` can be one or more state names separated by commas.
	 * - `styles` refers to the {\@link style styling data} that will be persisted on the element once
	 * the state has been reached.
	 *
	 * ```typescript
	 * // "void" is a reserved name for a state and is used to represent
	 * // the state in which an element is detached from from the application.
	 * state("void", style({ height: 0 }))
	 *
	 * // user-defined states
	 * state("closed", style({ height: 0 }))
	 * state("open, visible", style({ height: "*" }))
	 * ```
	 *
	 * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * \@experimental Animation support is experimental.
	 * @param {?} name
	 * @param {?} styles
	 * @return {?}
	 */
	function state$1(name, styles) {
	    return { type: 0 /* State */, name: name, styles: styles };
	}
	/**
	 * `keyframes` is an animation-specific function that is designed to be used inside of Angular's
	 * animation DSL language. If this information is new, please navigate to the {\@link
	 * Component#animations component animations metadata page} to gain a better understanding of
	 * how animations in Angular are used.
	 *
	 * `keyframes` specifies a collection of {\@link style style} entries each optionally characterized
	 * by an `offset` value.
	 *
	 * ### Usage
	 *
	 * The `keyframes` animation function is designed to be used alongside the {\@link animate animate}
	 * animation function. Instead of applying animations from where they are currently to their
	 * destination, keyframes can describe how each style entry is applied and at what point within the
	 * animation arc (much like CSS Keyframe Animations do).
	 *
	 * For each `style()` entry an `offset` value can be set. Doing so allows to specifiy at what
	 * percentage of the animate time the styles will be applied.
	 *
	 * ```typescript
	 * // the provided offset values describe when each backgroundColor value is applied.
	 * animate("5s", keyframes([
	 *   style({ backgroundColor: "red", offset: 0 }),
	 *   style({ backgroundColor: "blue", offset: 0.2 }),
	 *   style({ backgroundColor: "orange", offset: 0.3 }),
	 *   style({ backgroundColor: "black", offset: 1 })
	 * ]))
	 * ```
	 *
	 * Alternatively, if there are no `offset` values used within the style entries then the offsets
	 * will be calculated automatically.
	 *
	 * ```typescript
	 * animate("5s", keyframes([
	 *   style({ backgroundColor: "red" }) // offset = 0
	 *   style({ backgroundColor: "blue" }) // offset = 0.33
	 *   style({ backgroundColor: "orange" }) // offset = 0.66
	 *   style({ backgroundColor: "black" }) // offset = 1
	 * ]))
	 * ```
	 *
	 * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * \@experimental Animation support is experimental.
	 * @param {?} steps
	 * @return {?}
	 */
	function keyframes$1(steps) {
	    return { type: 5 /* Keyframes */, steps: steps };
	}
	/**
	 * `transition` is an animation-specific function that is designed to be used inside of Angular's
	 * animation DSL language. If this information is new, please navigate to the {\@link
	 * Component#animations component animations metadata page} to gain a better understanding of
	 * how animations in Angular are used.
	 *
	 * `transition` declares the {\@link sequence sequence of animation steps} that will be run when the
	 * provided `stateChangeExpr` value is satisfied. The `stateChangeExpr` consists of a `state1 =>
	 * state2` which consists of two known states (use an asterix (`*`) to refer to a dynamic starting
	 * and/or ending state).
	 *
	 * A function can also be provided as the `stateChangeExpr` argument for a transition and this
	 * function will be executed each time a state change occurs. If the value returned within the
	 * function is true then the associated animation will be run.
	 *
	 * Animation transitions are placed within an {\@link trigger animation trigger}. For an transition
	 * to animate to a state value and persist its styles then one or more {\@link state animation
	 * states} is expected to be defined.
	 *
	 * ### Usage
	 *
	 * An animation transition is kicked off the `stateChangeExpr` predicate evaluates to true based on
	 * what the previous state is and what the current state has become. In other words, if a transition
	 * is defined that matches the old/current state criteria then the associated animation will be
	 * triggered.
	 *
	 * ```typescript
	 * // all transition/state changes are defined within an animation trigger
	 * trigger("myAnimationTrigger", [
	 *   // if a state is defined then its styles will be persisted when the
	 *   // animation has fully completed itself
	 *   state("on", style({ background: "green" })),
	 *   state("off", style({ background: "grey" })),
	 *
	 *   // a transition animation that will be kicked off when the state value
	 *   // bound to "myAnimationTrigger" changes from "on" to "off"
	 *   transition("on => off", animate(500)),
	 *
	 *   // it is also possible to do run the same animation for both directions
	 *   transition("on <=> off", animate(500)),
	 *
	 *   // or to define multiple states pairs separated by commas
	 *   transition("on => off, off => void", animate(500)),
	 *
	 *   // this is a catch-all state change for when an element is inserted into
	 *   // the page and the destination state is unknown
	 *   transition("void => *", [
	 *     style({ opacity: 0 }),
	 *     animate(500)
	 *   ]),
	 *
	 *   // this will capture a state change between any states
	 *   transition("* => *", animate("1s 0s")),
	 *
	 *   // you can also go full out and include a function
	 *   transition((fromState, toState) => {
	 *     // when `true` then it will allow the animation below to be invoked
	 *     return fromState == "off" && toState == "on";
	 *   }, animate("1s 0s"))
	 * ])
	 * ```
	 *
	 * The template associated with this component will make use of the `myAnimationTrigger` animation
	 * trigger by binding to an element within its template code.
	 *
	 * ```html
	 * <!-- somewhere inside of my-component-tpl.html -->
	 * <div [\@myAnimationTrigger]="myStatusExp">...</div>
	 * ```
	 *
	 * #### The final `animate` call
	 *
	 * If the final step within the transition steps is a call to `animate()` that **only** uses a
	 * timing value with **no style data** then it will be automatically used as the final animation arc
	 * for the element to animate itself to the final state. This involves an automatic mix of
	 * adding/removing CSS styles so that the element will be in the exact state it should be for the
	 * applied state to be presented correctly.
	 *
	 * ```
	 * // start off by hiding the element, but make sure that it animates properly to whatever state
	 * // is currently active for "myAnimationTrigger"
	 * transition("void => *", [
	 *   style({ opacity: 0 }),
	 *   animate(500)
	 * ])
	 * ```
	 *
	 * ### Transition Aliases (`:enter` and `:leave`)
	 *
	 * Given that enter (insertion) and leave (removal) animations are so common, the `transition`
	 * function accepts both `:enter` and `:leave` values which are aliases for the `void => *` and `*
	 * => void` state changes.
	 *
	 * ```
	 * transition(":enter", [
	 *   style({ opacity: 0 }),
	 *   animate(500, style({ opacity: 1 }))
	 * ])
	 * transition(":leave", [
	 *   animate(500, style({ opacity: 0 }))
	 * ])
	 * ```
	 *
	 * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * \@experimental Animation support is experimental.
	 * @param {?} stateChangeExpr
	 * @param {?} steps
	 * @param {?=} options
	 * @return {?}
	 */
	function transition$1(stateChangeExpr, steps, options) {
	    if (options === void 0) { options = null; }
	    return { type: 1 /* Transition */, expr: stateChangeExpr, animation: steps, options: options };
	}
	/**
	 * `animation` is an animation-specific function that is designed to be used inside of Angular's
	 * animation DSL language.
	 *
	 * `var myAnimation = animation(...)` is designed to produce a reusable animation that can be later
	 * invoked in another animation or sequence. Reusable animations are designed to make use of
	 * animation parameters and the produced animation can be used via the `useAnimation` method.
	 *
	 * ```
	 * var fadeAnimation = animation([
	 *   style({ opacity: '{{ start }}' }),
	 *   animate('{{ time }}',
	 *     style({ opacity: '{{ end }}'))
	 * ], { params: { time: '1000ms', start: 0, end: 1 }});
	 * ```
	 *
	 * If parameters are attached to an animation then they act as **default parameter values**. When an
	 * animation is invoked via `useAnimation` then parameter values are allowed to be passed in
	 * directly. If any of the passed in parameter values are missing then the default values will be
	 * used.
	 *
	 * ```
	 * useAnimation(fadeAnimation, {
	 *   params: {
	 *     time: '2s',
	 *     start: 1,
	 *     end: 0
	 *   }
	 * })
	 * ```
	 *
	 * If one or more parameter values are missing before animated then an error will be thrown.
	 *
	 * \@experimental Animation support is experimental.
	 * @param {?} steps
	 * @param {?=} options
	 * @return {?}
	 */
	/**
	 * `animateChild` is an animation-specific function that is designed to be used inside of Angular's
	 * animation DSL language. It works by allowing a queried element to execute its own
	 * animation within the animation sequence.
	 *
	 * Each time an animation is triggered in angular, the parent animation
	 * will always get priority and any child animations will be blocked. In order
	 * for a child animation to run, the parent animation must query each of the elements
	 * containing child animations and then allow the animations to run using `animateChild`.
	 *
	 * The example HTML code below shows both parent and child elements that have animation
	 * triggers that will execute at the same time.
	 *
	 * ```html
	 * <!-- parent-child.component.html -->
	 * <button (click)="exp =! exp">Toggle</button>
	 * <hr>
	 *
	 * <div [\@parentAnimation]="exp">
	 *   <header>Hello</header>
	 *   <div [\@childAnimation]="exp">
	 *       one
	 *   </div>
	 *   <div [\@childAnimation]="exp">
	 *       two
	 *   </div>
	 *   <div [\@childAnimation]="exp">
	 *       three
	 *   </div>
	 * </div>
	 * ```
	 *
	 * Now when the `exp` value changes to true, only the `parentAnimation` animation will animate
	 * because it has priority. However, using `query` and `animateChild` each of the inner animations
	 * can also fire:
	 *
	 * ```ts
	 * // parent-child.component.ts
	 * import {trigger, transition, animate, style, query, animateChild} from '\@angular/animations';
	 * \@Component({
	 *   selector: 'parent-child-component',
	 *   animations: [
	 *     trigger('parentAnimation', [
	 *       transition('false => true', [
	 *         query('header', [
	 *           style({ opacity: 0 }),
	 *           animate(500, style({ opacity: 1 }))
	 *         ]),
	 *         query('\@childAnimation', [
	 *           animateChild()
	 *         ])
	 *       ])
	 *     ]),
	 *     trigger('childAnimation', [
	 *       transition('false => true', [
	 *         style({ opacity: 0 }),
	 *         animate(500, style({ opacity: 1 }))
	 *       ])
	 *     ])
	 *   ]
	 * })
	 * class ParentChildCmp {
	 *   exp: boolean = false;
	 * }
	 * ```
	 *
	 * In the animation code above, when the `parentAnimation` transition kicks off it first queries to
	 * find the header element and fades it in. It then finds each of the sub elements that contain the
	 * `\@childAnimation` trigger and then allows for their animations to fire.
	 *
	 * This example can be further extended by using stagger:
	 *
	 * ```ts
	 * query('\@childAnimation', stagger(100, [
	 *   animateChild()
	 * ]))
	 * ```
	 *
	 * Now each of the sub animations start off with respect to the `100ms` staggering step.
	 *
	 * ## The first frame of child animations
	 * When sub animations are executed using `animateChild` the animation engine will always apply the
	 * first frame of every sub animation immediately at the start of the animation sequence. This way
	 * the parent animation does not need to set any initial styling data on the sub elements before the
	 * sub animations kick off.
	 *
	 * In the example above the first frame of the `childAnimation`'s `false => true` transition
	 * consists of a style of `opacity: 0`. This is applied immediately when the `parentAnimation`
	 * animation transition sequence starts. Only then when the `\@childAnimation` is queried and called
	 * with `animateChild` will it then animate to its destination of `opacity: 1`.
	 *
	 * Note that this feature designed to be used alongside {\@link query query()} and it will only work
	 * with animations that are assigned using the Angular animation DSL (this means that CSS keyframes
	 * and transitions are not handled by this API).
	 *
	 * \@experimental Animation support is experimental.
	 * @param {?=} options
	 * @return {?}
	 */
	/**
	 * `useAnimation` is an animation-specific function that is designed to be used inside of Angular's
	 * animation DSL language. It is used to kick off a reusable animation that is created using {\@link
	 * animation animation()}.
	 *
	 * \@experimental Animation support is experimental.
	 * @param {?} animation
	 * @param {?=} options
	 * @return {?}
	 */
	/**
	 * `query` is an animation-specific function that is designed to be used inside of Angular's
	 * animation DSL language.
	 *
	 * query() is used to find one or more inner elements within the current element that is
	 * being animated within the sequence. The provided animation steps are applied
	 * to the queried element (by default, an array is provided, then this will be
	 * treated as an animation sequence).
	 *
	 * ### Usage
	 *
	 * query() is designed to collect mutiple elements and works internally by using
	 * `element.querySelectorAll`. An additional options object can be provided which
	 * can be used to limit the total amount of items to be collected.
	 *
	 * ```js
	 * query('div', [
	 *   animate(...),
	 *   animate(...)
	 * ], { limit: 1 })
	 * ```
	 *
	 * query(), by default, will throw an error when zero items are found. If a query
	 * has the `optional` flag set to true then this error will be ignored.
	 *
	 * ```js
	 * query('.some-element-that-may-not-be-there', [
	 *   animate(...),
	 *   animate(...)
	 * ], { optional: true })
	 * ```
	 *
	 * ### Special Selector Values
	 *
	 * The selector value within a query can collect elements that contain angular-specific
	 * characteristics
	 * using special pseudo-selectors tokens.
	 *
	 * These include:
	 *
	 *  - Querying for newly inserted/removed elements using `query(":enter")`/`query(":leave")`
	 *  - Querying all currently animating elements using `query(":animating")`
	 *  - Querying elements that contain an animation trigger using `query("\@triggerName")`
	 *  - Querying all elements that contain an animation triggers using `query("\@*")`
	 *  - Including the current element into the animation sequence using `query(":self")`
	 *
	 *
	 *  Each of these pseudo-selector tokens can be merged together into a combined query selector
	 * string:
	 *
	 *  ```
	 *  query(':self, .record:enter, .record:leave, \@subTrigger', [...])
	 *  ```
	 *
	 * ### Demo
	 *
	 * ```
	 * \@Component({
	 *   selector: 'inner',
	 *   template: `
	 *     <div [\@queryAnimation]="exp">
	 *       <h1>Title</h1>
	 *       <div class="content">
	 *         Blah blah blah
	 *       </div>
	 *     </div>
	 *   `,
	 *   animations: [
	 *    trigger('queryAnimation', [
	 *      transition('* => goAnimate', [
	 *        // hide the inner elements
	 *        query('h1', style({ opacity: 0 })),
	 *        query('.content', style({ opacity: 0 })),
	 *
	 *        // animate the inner elements in, one by one
	 *        query('h1', animate(1000, style({ opacity: 1 })),
	 *        query('.content', animate(1000, style({ opacity: 1 })),
	 *      ])
	 *    ])
	 *  ]
	 * })
	 * class Cmp {
	 *   exp = '';
	 *
	 *   goAnimate() {
	 *     this.exp = 'goAnimate';
	 *   }
	 * }
	 * ```
	 *
	 * \@experimental Animation support is experimental.
	 * @param {?} selector
	 * @param {?} animation
	 * @param {?=} options
	 * @return {?}
	 */
	/**
	 * `stagger` is an animation-specific function that is designed to be used inside of Angular's
	 * animation DSL language. It is designed to be used inside of an animation {\@link query query()}
	 * and works by issuing a timing gap between after each queried item is animated.
	 *
	 * ### Usage
	 *
	 * In the example below there is a container element that wraps a list of items stamped out
	 * by an ngFor. The container element contains an animation trigger that will later be set
	 * to query for each of the inner items.
	 *
	 * ```html
	 * <!-- list.component.html -->
	 * <button (click)="toggle()">Show / Hide Items</button>
	 * <hr />
	 * <div [\@listAnimation]="items.length">
	 *   <div *ngFor="let item of items">
	 *     {{ item }}
	 *   </div>
	 * </div>
	 * ```
	 *
	 * The component code for this looks as such:
	 *
	 * ```ts
	 * import {trigger, transition, style, animate, query, stagger} from '\@angular/animations';
	 * \@Component({
	 *   templateUrl: 'list.component.html',
	 *   animations: [
	 *     trigger('listAnimation', [
	 *        //...
	 *     ])
	 *   ]
	 * })
	 * class ListComponent {
	 *   items = [];
	 *
	 *   showItems() {
	 *     this.items = [0,1,2,3,4];
	 *   }
	 *
	 *   hideItems() {
	 *     this.items = [];
	 *   }
	 *
	 *   toggle() {
	 *     this.items.length ? this.hideItems() : this.showItems();
	 *   }
	 * }
	 * ```
	 *
	 * And now for the animation trigger code:
	 *
	 * ```ts
	 * trigger('listAnimation', [
	 *   transition('* => *', [ // each time the binding value changes
	 *     query(':leave', [
	 *       stagger(100, [
	 *         animate('0.5s', style({ opacity: 0 }))
	 *       ])
	 *     ]),
	 *     query(':enter', [
	 *       style({ opacity: 0 }),
	 *       stagger(100, [
	 *         animate('0.5s', style({ opacity: 1 }))
	 *       ])
	 *     ])
	 *   ])
	 * ])
	 * ```
	 *
	 * Now each time the items are added/removed then either the opacity
	 * fade-in animation will run or each removed item will be faded out.
	 * When either of these animations occur then a stagger effect will be
	 * applied after each item's animation is started.
	 *
	 * \@experimental Animation support is experimental.
	 * @param {?} timings
	 * @param {?} animation
	 * @return {?}
	 */
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @deprecated This symbol has moved. Please Import from \@angular/animations instead!
	 */
	var AUTO_STYLE$$1 = '*';
	/**
	 * @deprecated This symbol has moved. Please Import from \@angular/animations instead!
	 * @param {?} name
	 * @param {?} definitions
	 * @return {?}
	 */
	function trigger$$1(name, definitions) {
	    return trigger$1(name, definitions);
	}
	/**
	 * @deprecated This symbol has moved. Please Import from \@angular/animations instead!
	 * @param {?} timings
	 * @param {?=} styles
	 * @return {?}
	 */
	function animate$$1(timings, styles) {
	    return animate$1(timings, styles);
	}
	/**
	 * @deprecated This symbol has moved. Please Import from \@angular/animations instead!
	 * @param {?} steps
	 * @return {?}
	 */
	function group$$1(steps) {
	    return group$1(steps);
	}
	/**
	 * @deprecated This symbol has moved. Please Import from \@angular/animations instead!
	 * @param {?} steps
	 * @return {?}
	 */
	function sequence$$1(steps) {
	    return sequence$1(steps);
	}
	/**
	 * @deprecated This symbol has moved. Please Import from \@angular/animations instead!
	 * @param {?} tokens
	 * @return {?}
	 */
	function style$$1(tokens) {
	    return style$1(tokens);
	}
	/**
	 * @deprecated This symbol has moved. Please Import from \@angular/animations instead!
	 * @param {?} name
	 * @param {?} styles
	 * @return {?}
	 */
	function state$$1(name, styles) {
	    return state$1(name, styles);
	}
	/**
	 * @deprecated This symbol has moved. Please Import from \@angular/animations instead!
	 * @param {?} steps
	 * @return {?}
	 */
	function keyframes$$1(steps) {
	    return keyframes$1(steps);
	}
	/**
	 * @deprecated This symbol has moved. Please Import from \@angular/animations instead!
	 * @param {?} stateChangeExpr
	 * @param {?} steps
	 * @return {?}
	 */
	function transition$$1(stateChangeExpr, steps) {
	    return transition$1(stateChangeExpr, steps);
	}
	
	exports.Class = Class;
	exports.createPlatform = createPlatform;
	exports.assertPlatform = assertPlatform;
	exports.destroyPlatform = destroyPlatform;
	exports.getPlatform = getPlatform;
	exports.PlatformRef = PlatformRef;
	exports.ApplicationRef = ApplicationRef;
	exports.enableProdMode = enableProdMode;
	exports.isDevMode = isDevMode;
	exports.createPlatformFactory = createPlatformFactory;
	exports.NgProbeToken = NgProbeToken;
	exports.APP_ID = APP_ID;
	exports.PACKAGE_ROOT_URL = PACKAGE_ROOT_URL;
	exports.PLATFORM_INITIALIZER = PLATFORM_INITIALIZER;
	exports.PLATFORM_ID = PLATFORM_ID;
	exports.APP_BOOTSTRAP_LISTENER = APP_BOOTSTRAP_LISTENER;
	exports.APP_INITIALIZER = APP_INITIALIZER;
	exports.ApplicationInitStatus = ApplicationInitStatus;
	exports.DebugElement = DebugElement;
	exports.DebugNode = DebugNode;
	exports.asNativeElements = asNativeElements;
	exports.getDebugNode = getDebugNode;
	exports.Testability = Testability;
	exports.TestabilityRegistry = TestabilityRegistry;
	exports.setTestabilityGetter = setTestabilityGetter;
	exports.TRANSLATIONS = TRANSLATIONS;
	exports.TRANSLATIONS_FORMAT = TRANSLATIONS_FORMAT;
	exports.LOCALE_ID = LOCALE_ID;
	exports.MissingTranslationStrategy = MissingTranslationStrategy;
	exports.ApplicationModule = ApplicationModule;
	exports.wtfCreateScope = wtfCreateScope;
	exports.wtfLeave = wtfLeave;
	exports.wtfStartTimeRange = wtfStartTimeRange;
	exports.wtfEndTimeRange = wtfEndTimeRange;
	exports.Type = Type;
	exports.EventEmitter = EventEmitter;
	exports.ErrorHandler = ErrorHandler;
	exports.Sanitizer = Sanitizer;
	exports.SecurityContext = SecurityContext;
	exports.ANALYZE_FOR_ENTRY_COMPONENTS = ANALYZE_FOR_ENTRY_COMPONENTS;
	exports.Attribute = Attribute;
	exports.ContentChild = ContentChild;
	exports.ContentChildren = ContentChildren;
	exports.Query = Query;
	exports.ViewChild = ViewChild;
	exports.ViewChildren = ViewChildren;
	exports.Component = Component;
	exports.Directive = Directive;
	exports.HostBinding = HostBinding;
	exports.HostListener = HostListener;
	exports.Input = Input;
	exports.Output = Output;
	exports.Pipe = Pipe;
	exports.CUSTOM_ELEMENTS_SCHEMA = CUSTOM_ELEMENTS_SCHEMA;
	exports.NO_ERRORS_SCHEMA = NO_ERRORS_SCHEMA;
	exports.NgModule = NgModule;
	exports.ViewEncapsulation = ViewEncapsulation;
	exports.Version = Version;
	exports.VERSION = VERSION;
	exports.forwardRef = forwardRef;
	exports.resolveForwardRef = resolveForwardRef;
	exports.Injector = Injector;
	exports.ReflectiveInjector = ReflectiveInjector;
	exports.ResolvedReflectiveFactory = ResolvedReflectiveFactory;
	exports.ReflectiveKey = ReflectiveKey;
	exports.InjectionToken = InjectionToken;
	exports.OpaqueToken = OpaqueToken;
	exports.Inject = Inject;
	exports.Optional = Optional;
	exports.Injectable = Injectable;
	exports.Self = Self;
	exports.SkipSelf = SkipSelf;
	exports.Host = Host;
	exports.NgZone = NgZone;
	exports.RenderComponentType = RenderComponentType;
	exports.Renderer = Renderer;
	exports.Renderer2 = Renderer2;
	exports.RendererFactory2 = RendererFactory2;
	exports.RendererStyleFlags2 = RendererStyleFlags2;
	exports.RootRenderer = RootRenderer;
	exports.COMPILER_OPTIONS = COMPILER_OPTIONS;
	exports.Compiler = Compiler;
	exports.CompilerFactory = CompilerFactory;
	exports.ModuleWithComponentFactories = ModuleWithComponentFactories;
	exports.ComponentFactory = ComponentFactory;
	exports.ComponentRef = ComponentRef;
	exports.ComponentFactoryResolver = ComponentFactoryResolver;
	exports.ElementRef = ElementRef;
	exports.NgModuleFactory = NgModuleFactory;
	exports.NgModuleRef = NgModuleRef;
	exports.NgModuleFactoryLoader = NgModuleFactoryLoader;
	exports.getModuleFactory = getModuleFactory;
	exports.QueryList = QueryList;
	exports.SystemJsNgModuleLoader = SystemJsNgModuleLoader;
	exports.SystemJsNgModuleLoaderConfig = SystemJsNgModuleLoaderConfig;
	exports.TemplateRef = TemplateRef;
	exports.ViewContainerRef = ViewContainerRef;
	exports.EmbeddedViewRef = EmbeddedViewRef;
	exports.ViewRef = ViewRef;
	exports.ChangeDetectionStrategy = ChangeDetectionStrategy;
	exports.ChangeDetectorRef = ChangeDetectorRef;
	exports.DefaultIterableDiffer = DefaultIterableDiffer;
	exports.IterableDiffers = IterableDiffers;
	exports.KeyValueDiffers = KeyValueDiffers;
	exports.SimpleChange = SimpleChange;
	exports.WrappedValue = WrappedValue;
	exports.platformCore = platformCore;
	exports.ɵALLOW_MULTIPLE_PLATFORMS = ALLOW_MULTIPLE_PLATFORMS;
	exports.ɵAPP_ID_RANDOM_PROVIDER = APP_ID_RANDOM_PROVIDER;
	exports.ɵValueUnwrapper = ValueUnwrapper;
	exports.ɵdevModeEqual = devModeEqual;
	exports.ɵisListLikeIterable = isListLikeIterable;
	exports.ɵChangeDetectorStatus = ChangeDetectorStatus;
	exports.ɵisDefaultChangeDetectionStrategy = isDefaultChangeDetectionStrategy;
	exports.ɵConsole = Console;
	exports.ɵERROR_COMPONENT_TYPE = ERROR_COMPONENT_TYPE;
	exports.ɵComponentFactory = ComponentFactory;
	exports.ɵCodegenComponentFactoryResolver = CodegenComponentFactoryResolver;
	exports.ɵViewMetadata = ViewMetadata;
	exports.ɵReflectionCapabilities = ReflectionCapabilities;
	exports.ɵRenderDebugInfo = RenderDebugInfo;
	exports.ɵglobal = _global;
	exports.ɵlooseIdentical = looseIdentical;
	exports.ɵstringify = stringify;
	exports.ɵmakeDecorator = makeDecorator;
	exports.ɵisObservable = isObservable;
	exports.ɵisPromise = isPromise;
	exports.ɵclearProviderOverrides = clearProviderOverrides;
	exports.ɵoverrideProvider = overrideProvider;
	exports.ɵNOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR;
	exports.ɵregisterModuleFactory = registerModuleFactory;
	exports.ɵEMPTY_ARRAY = EMPTY_ARRAY;
	exports.ɵEMPTY_MAP = EMPTY_MAP;
	exports.ɵand = anchorDef;
	exports.ɵccf = createComponentFactory;
	exports.ɵcmf = createNgModuleFactory;
	exports.ɵcrt = createRendererType2;
	exports.ɵdid = directiveDef;
	exports.ɵeld = elementDef;
	exports.ɵelementEventFullName = elementEventFullName;
	exports.ɵgetComponentViewDefinitionFactory = getComponentViewDefinitionFactory;
	exports.ɵinlineInterpolate = inlineInterpolate;
	exports.ɵinterpolate = interpolate;
	exports.ɵmod = moduleDef;
	exports.ɵmpd = moduleProvideDef;
	exports.ɵncd = ngContentDef;
	exports.ɵnov = nodeValue;
	exports.ɵpid = pipeDef;
	exports.ɵprd = providerDef;
	exports.ɵpad = pureArrayDef;
	exports.ɵpod = pureObjectDef;
	exports.ɵppd = purePipeDef;
	exports.ɵqud = queryDef;
	exports.ɵted = textDef;
	exports.ɵunv = unwrapValue;
	exports.ɵvid = viewDef;
	exports.AUTO_STYLE = AUTO_STYLE$$1;
	exports.trigger = trigger$$1;
	exports.animate = animate$$1;
	exports.group = group$$1;
	exports.sequence = sequence$$1;
	exports.style = style$$1;
	exports.state = state$$1;
	exports.keyframes = keyframes$$1;
	exports.transition = transition$$1;
	exports.ɵx = animate$1;
	exports.ɵy = group$1;
	exports.ɵbc = keyframes$1;
	exports.ɵz = sequence$1;
	exports.ɵbb = state$1;
	exports.ɵba = style$1;
	exports.ɵbd = transition$1;
	exports.ɵw = trigger$1;
	exports.ɵk = _iterableDiffersFactory;
	exports.ɵl = _keyValueDiffersFactory;
	exports.ɵm = _localeFactory;
	exports.ɵe = ApplicationRef_;
	exports.ɵf = _appIdRandomProviderFactory;
	exports.ɵg = defaultIterableDiffers;
	exports.ɵh = defaultKeyValueDiffers;
	exports.ɵi = DefaultIterableDifferFactory;
	exports.ɵj = DefaultKeyValueDifferFactory;
	exports.ɵb = ReflectiveInjector_;
	exports.ɵc = ReflectiveDependency;
	exports.ɵd = resolveReflectiveProviders;
	exports.ɵn = wtfEnabled;
	exports.ɵp = createScope$1;
	exports.ɵo = detectWTF;
	exports.ɵs = endTimeRange;
	exports.ɵq = leave;
	exports.ɵr = startTimeRange;
	exports.ɵa = makeParamDecorator;
	exports.ɵt = _def;
	exports.ɵu = DebugContext;
	
	Object.defineProperty(exports, '__esModule', { value: true });
	
	})));
	//# sourceMappingURL=core.umd.js.map
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _NextTickScheduler = __webpack_require__(176);
	
	var _NextTickScheduler2 = _interopRequireDefault(_NextTickScheduler);
	
	exports['default'] = new _NextTickScheduler2['default']();
	module.exports = exports['default'];

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _Observable2 = __webpack_require__(4);
	
	var _Observable3 = _interopRequireDefault(_Observable2);
	
	var _ScalarObservable = __webpack_require__(30);
	
	var _ScalarObservable2 = _interopRequireDefault(_ScalarObservable);
	
	var _EmptyObservable = __webpack_require__(22);
	
	var _EmptyObservable2 = _interopRequireDefault(_EmptyObservable);
	
	var ArrayObservable = (function (_Observable) {
	    _inherits(ArrayObservable, _Observable);
	
	    function ArrayObservable(array, scheduler) {
	        _classCallCheck(this, ArrayObservable);
	
	        _Observable.call(this);
	        this.array = array;
	        this.scheduler = scheduler;
	        if (!scheduler && array.length === 1) {
	            this._isScalar = true;
	            this.value = array[0];
	        }
	    }
	
	    ArrayObservable.create = function create(array, scheduler) {
	        return new ArrayObservable(array, scheduler);
	    };
	
	    ArrayObservable.of = function of() {
	        for (var _len = arguments.length, array = Array(_len), _key = 0; _key < _len; _key++) {
	            array[_key] = arguments[_key];
	        }
	
	        var scheduler = array[array.length - 1];
	        if (scheduler && typeof scheduler.schedule === 'function') {
	            array.pop();
	        } else {
	            scheduler = void 0;
	        }
	        var len = array.length;
	        if (len > 1) {
	            return new ArrayObservable(array, scheduler);
	        } else if (len === 1) {
	            return new _ScalarObservable2['default'](array[0], scheduler);
	        } else {
	            return new _EmptyObservable2['default'](scheduler);
	        }
	    };
	
	    ArrayObservable.dispatch = function dispatch(state) {
	        var array = state.array;
	        var index = state.index;
	        var count = state.count;
	        var subscriber = state.subscriber;
	
	        if (index >= count) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(array[index]);
	        if (subscriber.isUnsubscribed) {
	            return;
	        }
	        state.index = index + 1;
	        this.schedule(state);
	    };
	
	    ArrayObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var index = 0;
	        var array = this.array;
	        var count = array.length;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            subscriber.add(scheduler.schedule(ArrayObservable.dispatch, 0, {
	                array: array, index: index, count: count, subscriber: subscriber
	            }));
	        } else {
	            for (var i = 0; i < count && !subscriber.isUnsubscribed; i++) {
	                subscriber.next(array[i]);
	            }
	            subscriber.complete();
	        }
	    };
	
	    return ArrayObservable;
	})(_Observable3['default']);
	
	exports['default'] = ArrayObservable;
	module.exports = exports['default'];

/***/ }),
/* 15 */
/***/ (function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = bindCallback;
	
	function bindCallback(func, thisArg, argCount) {
	    if (typeof thisArg === 'undefined') {
	        return func;
	    }
	    switch (argCount) {
	        case 0:
	            return function () {
	                return func.call(thisArg);
	            };
	        case 1:
	            return function (arg) {
	                return func.call(thisArg, arg);
	            };
	        case 2:
	            return function (value, index) {
	                return func.call(thisArg, value, index);
	            };
	        case 3:
	            return function (value, index, collection) {
	                return func.call(thisArg, value, index, collection);
	            };
	    }
	    return function () {
	        return func.apply(thisArg, arguments);
	    };
	}
	
	;
	module.exports = exports['default'];

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module, global) {'use strict';
	
	exports.__esModule = true;
	var objectTypes = {
	    'boolean': false,
	    'function': true,
	    'object': true,
	    'number': false,
	    'string': false,
	    'undefined': false
	};
	var root = objectTypes[typeof self] && self || objectTypes[typeof window] && window;
	exports.root = root;
	var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
	var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
	var freeGlobal = objectTypes[typeof global] && global;
	if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
	    exports.root = root = freeGlobal;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(222)(module), (function() { return this; }())))

/***/ }),
/* 17 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	// CommonJS / Node have global context exposed as "global" variable.
	// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake
	// the global "global" var for now.
	var __window = typeof window !== 'undefined' && window;
	var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&
	    self instanceof WorkerGlobalScope && self;
	var __global = typeof global !== 'undefined' && global;
	var _root = __window || __global || __self;
	exports.root = _root;
	// Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.
	// This is needed when used with angular/tsickle which inserts a goog.module statement.
	// Wrap in IIFE
	(function () {
	    if (!_root) {
	        throw new Error('RxJS could not find any global context (window, self, global)');
	    }
	})();
	//# sourceMappingURL=root.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Observable = __webpack_require__(4);
	
	var _Observable2 = _interopRequireDefault(_Observable);
	
	var Notification = (function () {
	    function Notification(kind, value, exception) {
	        _classCallCheck(this, Notification);
	
	        this.kind = kind;
	        this.value = value;
	        this.exception = exception;
	        this.hasValue = kind === 'N';
	    }
	
	    Notification.prototype.observe = function observe(observer) {
	        switch (this.kind) {
	            case 'N':
	                return observer.next(this.value);
	            case 'E':
	                return observer.error(this.exception);
	            case 'C':
	                return observer.complete();
	        }
	    };
	
	    Notification.prototype['do'] = function _do(next, error, complete) {
	        var kind = this.kind;
	        switch (kind) {
	            case 'N':
	                return next(this.value);
	            case 'E':
	                return error(this.exception);
	            case 'C':
	                return complete();
	        }
	    };
	
	    Notification.prototype.accept = function accept(nextOrObserver, error, complete) {
	        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
	            return this.observe(nextOrObserver);
	        } else {
	            return this['do'](nextOrObserver, error, complete);
	        }
	    };
	
	    Notification.prototype.toObservable = function toObservable() {
	        var kind = this.kind;
	        var value = this.value;
	        switch (kind) {
	            case 'N':
	                return _Observable2['default'].of(value);
	            case 'E':
	                return _Observable2['default']['throw'](value);
	            case 'C':
	                return _Observable2['default'].empty();
	        }
	    };
	
	    Notification.createNext = function createNext(value) {
	        if (typeof value !== 'undefined') {
	            return new Notification('N', value);
	        }
	        return this.undefinedValueNotification;
	    };
	
	    Notification.createError = function createError(err) {
	        return new Notification('E', undefined, err);
	    };
	
	    Notification.createComplete = function createComplete() {
	        return this.completeNotification;
	    };
	
	    return Notification;
	})();
	
	exports['default'] = Notification;
	
	Notification.completeNotification = new Notification('C');
	Notification.undefinedValueNotification = new Notification('N', undefined);
	module.exports = exports['default'];

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(6);
	var Subscriber_1 = __webpack_require__(8);
	var Subscription_1 = __webpack_require__(27);
	var ObjectUnsubscribedError_1 = __webpack_require__(72);
	var SubjectSubscription_1 = __webpack_require__(195);
	var rxSubscriber_1 = __webpack_require__(40);
	/**
	 * @class SubjectSubscriber<T>
	 */
	var SubjectSubscriber = (function (_super) {
	    __extends(SubjectSubscriber, _super);
	    function SubjectSubscriber(destination) {
	        _super.call(this, destination);
	        this.destination = destination;
	    }
	    return SubjectSubscriber;
	}(Subscriber_1.Subscriber));
	exports.SubjectSubscriber = SubjectSubscriber;
	/**
	 * @class Subject<T>
	 */
	var Subject = (function (_super) {
	    __extends(Subject, _super);
	    function Subject() {
	        _super.call(this);
	        this.observers = [];
	        this.closed = false;
	        this.isStopped = false;
	        this.hasError = false;
	        this.thrownError = null;
	    }
	    Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {
	        return new SubjectSubscriber(this);
	    };
	    Subject.prototype.lift = function (operator) {
	        var subject = new AnonymousSubject(this, this);
	        subject.operator = operator;
	        return subject;
	    };
	    Subject.prototype.next = function (value) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        if (!this.isStopped) {
	            var observers = this.observers;
	            var len = observers.length;
	            var copy = observers.slice();
	            for (var i = 0; i < len; i++) {
	                copy[i].next(value);
	            }
	        }
	    };
	    Subject.prototype.error = function (err) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        this.hasError = true;
	        this.thrownError = err;
	        this.isStopped = true;
	        var observers = this.observers;
	        var len = observers.length;
	        var copy = observers.slice();
	        for (var i = 0; i < len; i++) {
	            copy[i].error(err);
	        }
	        this.observers.length = 0;
	    };
	    Subject.prototype.complete = function () {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        this.isStopped = true;
	        var observers = this.observers;
	        var len = observers.length;
	        var copy = observers.slice();
	        for (var i = 0; i < len; i++) {
	            copy[i].complete();
	        }
	        this.observers.length = 0;
	    };
	    Subject.prototype.unsubscribe = function () {
	        this.isStopped = true;
	        this.closed = true;
	        this.observers = null;
	    };
	    Subject.prototype._trySubscribe = function (subscriber) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        else {
	            return _super.prototype._trySubscribe.call(this, subscriber);
	        }
	    };
	    Subject.prototype._subscribe = function (subscriber) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        else if (this.hasError) {
	            subscriber.error(this.thrownError);
	            return Subscription_1.Subscription.EMPTY;
	        }
	        else if (this.isStopped) {
	            subscriber.complete();
	            return Subscription_1.Subscription.EMPTY;
	        }
	        else {
	            this.observers.push(subscriber);
	            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
	        }
	    };
	    Subject.prototype.asObservable = function () {
	        var observable = new Observable_1.Observable();
	        observable.source = this;
	        return observable;
	    };
	    Subject.create = function (destination, source) {
	        return new AnonymousSubject(destination, source);
	    };
	    return Subject;
	}(Observable_1.Observable));
	exports.Subject = Subject;
	/**
	 * @class AnonymousSubject<T>
	 */
	var AnonymousSubject = (function (_super) {
	    __extends(AnonymousSubject, _super);
	    function AnonymousSubject(destination, source) {
	        _super.call(this);
	        this.destination = destination;
	        this.source = source;
	    }
	    AnonymousSubject.prototype.next = function (value) {
	        var destination = this.destination;
	        if (destination && destination.next) {
	            destination.next(value);
	        }
	    };
	    AnonymousSubject.prototype.error = function (err) {
	        var destination = this.destination;
	        if (destination && destination.error) {
	            this.destination.error(err);
	        }
	    };
	    AnonymousSubject.prototype.complete = function () {
	        var destination = this.destination;
	        if (destination && destination.complete) {
	            this.destination.complete();
	        }
	    };
	    AnonymousSubject.prototype._subscribe = function (subscriber) {
	        var source = this.source;
	        if (source) {
	            return this.source.subscribe(subscriber);
	        }
	        else {
	            return Subscription_1.Subscription.EMPTY;
	        }
	    };
	    return AnonymousSubject;
	}(Subject));
	exports.AnonymousSubject = AnonymousSubject;
	//# sourceMappingURL=Subject.js.map

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @license Angular v4.3.3
	 * (c) 2010-2017 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	(function (global, factory) {
		 true ? factory(exports, __webpack_require__(12)) :
		typeof define === 'function' && define.amd ? define(['exports', '@angular/core'], factory) :
		(factory((global.ng = global.ng || {}, global.ng.common = global.ng.common || {}),global.ng.core));
	}(this, (function (exports,_angular_core) { 'use strict';
	
	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0
	
	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.
	
	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
	/* global Reflect, Promise */
	
	var extendStatics = Object.setPrototypeOf ||
	    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	
	function __extends(d, b) {
	    extendStatics(d, b);
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}
	
	/**
	 * @license Angular v4.3.3
	 * (c) 2010-2017 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * This class should not be used directly by an application developer. Instead, use
	 * {\@link Location}.
	 *
	 * `PlatformLocation` encapsulates all calls to DOM apis, which allows the Router to be platform
	 * agnostic.
	 * This means that we can have different implementation of `PlatformLocation` for the different
	 * platforms that angular supports. For example, `\@angular/platform-browser` provides an
	 * implementation specific to the browser environment, while `\@angular/platform-webworker` provides
	 * one suitable for use with web workers.
	 *
	 * The `PlatformLocation` class is used directly by all implementations of {\@link LocationStrategy}
	 * when they need to interact with the DOM apis like pushState, popState, etc...
	 *
	 * {\@link LocationStrategy} in turn is used by the {\@link Location} service which is used directly
	 * by the {\@link Router} in order to navigate between routes. Since all interactions between {\@link
	 * Router} /
	 * {\@link Location} / {\@link LocationStrategy} and DOM apis flow through the `PlatformLocation`
	 * class they are all platform independent.
	 *
	 * \@stable
	 * @abstract
	 */
	var PlatformLocation = (function () {
	    function PlatformLocation() {
	    }
	    /**
	     * @abstract
	     * @return {?}
	     */
	    PlatformLocation.prototype.getBaseHrefFromDOM = function () { };
	    /**
	     * @abstract
	     * @param {?} fn
	     * @return {?}
	     */
	    PlatformLocation.prototype.onPopState = function (fn) { };
	    /**
	     * @abstract
	     * @param {?} fn
	     * @return {?}
	     */
	    PlatformLocation.prototype.onHashChange = function (fn) { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    PlatformLocation.prototype.pathname = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    PlatformLocation.prototype.search = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    PlatformLocation.prototype.hash = function () { };
	    /**
	     * @abstract
	     * @param {?} state
	     * @param {?} title
	     * @param {?} url
	     * @return {?}
	     */
	    PlatformLocation.prototype.replaceState = function (state, title, url) { };
	    /**
	     * @abstract
	     * @param {?} state
	     * @param {?} title
	     * @param {?} url
	     * @return {?}
	     */
	    PlatformLocation.prototype.pushState = function (state, title, url) { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    PlatformLocation.prototype.forward = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    PlatformLocation.prototype.back = function () { };
	    return PlatformLocation;
	}());
	/**
	 * \@whatItDoes indicates when a location is initialized
	 * \@experimental
	 */
	var LOCATION_INITIALIZED = new _angular_core.InjectionToken('Location Initialized');
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * `LocationStrategy` is responsible for representing and reading route state
	 * from the browser's URL. Angular provides two strategies:
	 * {\@link HashLocationStrategy} and {\@link PathLocationStrategy}.
	 *
	 * This is used under the hood of the {\@link Location} service.
	 *
	 * Applications should use the {\@link Router} or {\@link Location} services to
	 * interact with application route state.
	 *
	 * For instance, {\@link HashLocationStrategy} produces URLs like
	 * `http://example.com#/foo`, and {\@link PathLocationStrategy} produces
	 * `http://example.com/foo` as an equivalent URL.
	 *
	 * See these two classes for more.
	 *
	 * \@stable
	 * @abstract
	 */
	var LocationStrategy = (function () {
	    function LocationStrategy() {
	    }
	    /**
	     * @abstract
	     * @param {?=} includeHash
	     * @return {?}
	     */
	    LocationStrategy.prototype.path = function (includeHash) { };
	    /**
	     * @abstract
	     * @param {?} internal
	     * @return {?}
	     */
	    LocationStrategy.prototype.prepareExternalUrl = function (internal) { };
	    /**
	     * @abstract
	     * @param {?} state
	     * @param {?} title
	     * @param {?} url
	     * @param {?} queryParams
	     * @return {?}
	     */
	    LocationStrategy.prototype.pushState = function (state, title, url, queryParams) { };
	    /**
	     * @abstract
	     * @param {?} state
	     * @param {?} title
	     * @param {?} url
	     * @param {?} queryParams
	     * @return {?}
	     */
	    LocationStrategy.prototype.replaceState = function (state, title, url, queryParams) { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    LocationStrategy.prototype.forward = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    LocationStrategy.prototype.back = function () { };
	    /**
	     * @abstract
	     * @param {?} fn
	     * @return {?}
	     */
	    LocationStrategy.prototype.onPopState = function (fn) { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    LocationStrategy.prototype.getBaseHref = function () { };
	    return LocationStrategy;
	}());
	/**
	 * The `APP_BASE_HREF` token represents the base href to be used with the
	 * {\@link PathLocationStrategy}.
	 *
	 * If you're using {\@link PathLocationStrategy}, you must provide a provider to a string
	 * representing the URL prefix that should be preserved when generating and recognizing
	 * URLs.
	 *
	 * ### Example
	 *
	 * ```typescript
	 * import {Component, NgModule} from '\@angular/core';
	 * import {APP_BASE_HREF} from '\@angular/common';
	 *
	 * \@NgModule({
	 *   providers: [{provide: APP_BASE_HREF, useValue: '/my/app'}]
	 * })
	 * class AppModule {}
	 * ```
	 *
	 * \@stable
	 */
	var APP_BASE_HREF = new _angular_core.InjectionToken('appBaseHref');
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@whatItDoes `Location` is a service that applications can use to interact with a browser's URL.
	 * \@description
	 * Depending on which {\@link LocationStrategy} is used, `Location` will either persist
	 * to the URL's path or the URL's hash segment.
	 *
	 * Note: it's better to use {\@link Router#navigate} service to trigger route changes. Use
	 * `Location` only if you need to interact with or create normalized URLs outside of
	 * routing.
	 *
	 * `Location` is responsible for normalizing the URL against the application's base href.
	 * A normalized URL is absolute from the URL host, includes the application's base href, and has no
	 * trailing slash:
	 * - `/my/app/user/123` is normalized
	 * - `my/app/user/123` **is not** normalized
	 * - `/my/app/user/123/` **is not** normalized
	 *
	 * ### Example
	 * {\@example common/location/ts/path_location_component.ts region='LocationComponent'}
	 * \@stable
	 */
	var Location = (function () {
	    /**
	     * @param {?} platformStrategy
	     */
	    function Location(platformStrategy) {
	        var _this = this;
	        /**
	         * \@internal
	         */
	        this._subject = new _angular_core.EventEmitter();
	        this._platformStrategy = platformStrategy;
	        var browserBaseHref = this._platformStrategy.getBaseHref();
	        this._baseHref = Location.stripTrailingSlash(_stripIndexHtml(browserBaseHref));
	        this._platformStrategy.onPopState(function (ev) {
	            _this._subject.emit({
	                'url': _this.path(true),
	                'pop': true,
	                'type': ev.type,
	            });
	        });
	    }
	    /**
	     * @param {?=} includeHash
	     * @return {?}
	     */
	    Location.prototype.path = function (includeHash) {
	        if (includeHash === void 0) { includeHash = false; }
	        return this.normalize(this._platformStrategy.path(includeHash));
	    };
	    /**
	     * Normalizes the given path and compares to the current normalized path.
	     * @param {?} path
	     * @param {?=} query
	     * @return {?}
	     */
	    Location.prototype.isCurrentPathEqualTo = function (path, query) {
	        if (query === void 0) { query = ''; }
	        return this.path() == this.normalize(path + Location.normalizeQueryParams(query));
	    };
	    /**
	     * Given a string representing a URL, returns the normalized URL path without leading or
	     * trailing slashes.
	     * @param {?} url
	     * @return {?}
	     */
	    Location.prototype.normalize = function (url) {
	        return Location.stripTrailingSlash(_stripBaseHref(this._baseHref, _stripIndexHtml(url)));
	    };
	    /**
	     * Given a string representing a URL, returns the platform-specific external URL path.
	     * If the given URL doesn't begin with a leading slash (`'/'`), this method adds one
	     * before normalizing. This method will also add a hash if `HashLocationStrategy` is
	     * used, or the `APP_BASE_HREF` if the `PathLocationStrategy` is in use.
	     * @param {?} url
	     * @return {?}
	     */
	    Location.prototype.prepareExternalUrl = function (url) {
	        if (url && url[0] !== '/') {
	            url = '/' + url;
	        }
	        return this._platformStrategy.prepareExternalUrl(url);
	    };
	    /**
	     * Changes the browsers URL to the normalized version of the given URL, and pushes a
	     * new item onto the platform's history.
	     * @param {?} path
	     * @param {?=} query
	     * @return {?}
	     */
	    Location.prototype.go = function (path, query) {
	        if (query === void 0) { query = ''; }
	        this._platformStrategy.pushState(null, '', path, query);
	    };
	    /**
	     * Changes the browsers URL to the normalized version of the given URL, and replaces
	     * the top item on the platform's history stack.
	     * @param {?} path
	     * @param {?=} query
	     * @return {?}
	     */
	    Location.prototype.replaceState = function (path, query) {
	        if (query === void 0) { query = ''; }
	        this._platformStrategy.replaceState(null, '', path, query);
	    };
	    /**
	     * Navigates forward in the platform's history.
	     * @return {?}
	     */
	    Location.prototype.forward = function () { this._platformStrategy.forward(); };
	    /**
	     * Navigates back in the platform's history.
	     * @return {?}
	     */
	    Location.prototype.back = function () { this._platformStrategy.back(); };
	    /**
	     * Subscribe to the platform's `popState` events.
	     * @param {?} onNext
	     * @param {?=} onThrow
	     * @param {?=} onReturn
	     * @return {?}
	     */
	    Location.prototype.subscribe = function (onNext, onThrow, onReturn) {
	        return this._subject.subscribe({ next: onNext, error: onThrow, complete: onReturn });
	    };
	    /**
	     * Given a string of url parameters, prepend with '?' if needed, otherwise return parameters as
	     * is.
	     * @param {?} params
	     * @return {?}
	     */
	    Location.normalizeQueryParams = function (params) {
	        return params && params[0] !== '?' ? '?' + params : params;
	    };
	    /**
	     * Given 2 parts of a url, join them with a slash if needed.
	     * @param {?} start
	     * @param {?} end
	     * @return {?}
	     */
	    Location.joinWithSlash = function (start, end) {
	        if (start.length == 0) {
	            return end;
	        }
	        if (end.length == 0) {
	            return start;
	        }
	        var /** @type {?} */ slashes = 0;
	        if (start.endsWith('/')) {
	            slashes++;
	        }
	        if (end.startsWith('/')) {
	            slashes++;
	        }
	        if (slashes == 2) {
	            return start + end.substring(1);
	        }
	        if (slashes == 1) {
	            return start + end;
	        }
	        return start + '/' + end;
	    };
	    /**
	     * If url has a trailing slash, remove it, otherwise return url as is. This
	     * method looks for the first occurence of either #, ?, or the end of the
	     * line as `/` characters after any of these should not be replaced.
	     * @param {?} url
	     * @return {?}
	     */
	    Location.stripTrailingSlash = function (url) {
	        var /** @type {?} */ match = url.match(/#|\?|$/);
	        var /** @type {?} */ pathEndIdx = match && match.index || url.length;
	        var /** @type {?} */ droppedSlashIdx = pathEndIdx - (url[pathEndIdx - 1] === '/' ? 1 : 0);
	        return url.slice(0, droppedSlashIdx) + url.slice(pathEndIdx);
	    };
	    return Location;
	}());
	Location.decorators = [
	    { type: _angular_core.Injectable },
	];
	/**
	 * @nocollapse
	 */
	Location.ctorParameters = function () { return [
	    { type: LocationStrategy, },
	]; };
	/**
	 * @param {?} baseHref
	 * @param {?} url
	 * @return {?}
	 */
	function _stripBaseHref(baseHref, url) {
	    return baseHref && url.startsWith(baseHref) ? url.substring(baseHref.length) : url;
	}
	/**
	 * @param {?} url
	 * @return {?}
	 */
	function _stripIndexHtml(url) {
	    return url.replace(/\/index.html$/, '');
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@whatItDoes Use URL hash for storing application location data.
	 * \@description
	 * `HashLocationStrategy` is a {\@link LocationStrategy} used to configure the
	 * {\@link Location} service to represent its state in the
	 * [hash fragment](https://en.wikipedia.org/wiki/Uniform_Resource_Locator#Syntax)
	 * of the browser's URL.
	 *
	 * For instance, if you call `location.go('/foo')`, the browser's URL will become
	 * `example.com#/foo`.
	 *
	 * ### Example
	 *
	 * {\@example common/location/ts/hash_location_component.ts region='LocationComponent'}
	 *
	 * \@stable
	 */
	var HashLocationStrategy = (function (_super) {
	    __extends(HashLocationStrategy, _super);
	    /**
	     * @param {?} _platformLocation
	     * @param {?=} _baseHref
	     */
	    function HashLocationStrategy(_platformLocation, _baseHref) {
	        var _this = _super.call(this) || this;
	        _this._platformLocation = _platformLocation;
	        _this._baseHref = '';
	        if (_baseHref != null) {
	            _this._baseHref = _baseHref;
	        }
	        return _this;
	    }
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    HashLocationStrategy.prototype.onPopState = function (fn) {
	        this._platformLocation.onPopState(fn);
	        this._platformLocation.onHashChange(fn);
	    };
	    /**
	     * @return {?}
	     */
	    HashLocationStrategy.prototype.getBaseHref = function () { return this._baseHref; };
	    /**
	     * @param {?=} includeHash
	     * @return {?}
	     */
	    HashLocationStrategy.prototype.path = function (includeHash) {
	        if (includeHash === void 0) { includeHash = false; }
	        // the hash value is always prefixed with a `#`
	        // and if it is empty then it will stay empty
	        var /** @type {?} */ path = this._platformLocation.hash;
	        if (path == null)
	            path = '#';
	        return path.length > 0 ? path.substring(1) : path;
	    };
	    /**
	     * @param {?} internal
	     * @return {?}
	     */
	    HashLocationStrategy.prototype.prepareExternalUrl = function (internal) {
	        var /** @type {?} */ url = Location.joinWithSlash(this._baseHref, internal);
	        return url.length > 0 ? ('#' + url) : url;
	    };
	    /**
	     * @param {?} state
	     * @param {?} title
	     * @param {?} path
	     * @param {?} queryParams
	     * @return {?}
	     */
	    HashLocationStrategy.prototype.pushState = function (state, title, path, queryParams) {
	        var /** @type {?} */ url = this.prepareExternalUrl(path + Location.normalizeQueryParams(queryParams));
	        if (url.length == 0) {
	            url = this._platformLocation.pathname;
	        }
	        this._platformLocation.pushState(state, title, url);
	    };
	    /**
	     * @param {?} state
	     * @param {?} title
	     * @param {?} path
	     * @param {?} queryParams
	     * @return {?}
	     */
	    HashLocationStrategy.prototype.replaceState = function (state, title, path, queryParams) {
	        var /** @type {?} */ url = this.prepareExternalUrl(path + Location.normalizeQueryParams(queryParams));
	        if (url.length == 0) {
	            url = this._platformLocation.pathname;
	        }
	        this._platformLocation.replaceState(state, title, url);
	    };
	    /**
	     * @return {?}
	     */
	    HashLocationStrategy.prototype.forward = function () { this._platformLocation.forward(); };
	    /**
	     * @return {?}
	     */
	    HashLocationStrategy.prototype.back = function () { this._platformLocation.back(); };
	    return HashLocationStrategy;
	}(LocationStrategy));
	HashLocationStrategy.decorators = [
	    { type: _angular_core.Injectable },
	];
	/**
	 * @nocollapse
	 */
	HashLocationStrategy.ctorParameters = function () { return [
	    { type: PlatformLocation, },
	    { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [APP_BASE_HREF,] },] },
	]; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@whatItDoes Use URL for storing application location data.
	 * \@description
	 * `PathLocationStrategy` is a {\@link LocationStrategy} used to configure the
	 * {\@link Location} service to represent its state in the
	 * [path](https://en.wikipedia.org/wiki/Uniform_Resource_Locator#Syntax) of the
	 * browser's URL.
	 *
	 * If you're using `PathLocationStrategy`, you must provide a {\@link APP_BASE_HREF}
	 * or add a base element to the document. This URL prefix that will be preserved
	 * when generating and recognizing URLs.
	 *
	 * For instance, if you provide an `APP_BASE_HREF` of `'/my/app'` and call
	 * `location.go('/foo')`, the browser's URL will become
	 * `example.com/my/app/foo`.
	 *
	 * Similarly, if you add `<base href='/my/app'/>` to the document and call
	 * `location.go('/foo')`, the browser's URL will become
	 * `example.com/my/app/foo`.
	 *
	 * ### Example
	 *
	 * {\@example common/location/ts/path_location_component.ts region='LocationComponent'}
	 *
	 * \@stable
	 */
	var PathLocationStrategy = (function (_super) {
	    __extends(PathLocationStrategy, _super);
	    /**
	     * @param {?} _platformLocation
	     * @param {?=} href
	     */
	    function PathLocationStrategy(_platformLocation, href) {
	        var _this = _super.call(this) || this;
	        _this._platformLocation = _platformLocation;
	        if (href == null) {
	            href = _this._platformLocation.getBaseHrefFromDOM();
	        }
	        if (href == null) {
	            throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");
	        }
	        _this._baseHref = href;
	        return _this;
	    }
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    PathLocationStrategy.prototype.onPopState = function (fn) {
	        this._platformLocation.onPopState(fn);
	        this._platformLocation.onHashChange(fn);
	    };
	    /**
	     * @return {?}
	     */
	    PathLocationStrategy.prototype.getBaseHref = function () { return this._baseHref; };
	    /**
	     * @param {?} internal
	     * @return {?}
	     */
	    PathLocationStrategy.prototype.prepareExternalUrl = function (internal) {
	        return Location.joinWithSlash(this._baseHref, internal);
	    };
	    /**
	     * @param {?=} includeHash
	     * @return {?}
	     */
	    PathLocationStrategy.prototype.path = function (includeHash) {
	        if (includeHash === void 0) { includeHash = false; }
	        var /** @type {?} */ pathname = this._platformLocation.pathname +
	            Location.normalizeQueryParams(this._platformLocation.search);
	        var /** @type {?} */ hash = this._platformLocation.hash;
	        return hash && includeHash ? "" + pathname + hash : pathname;
	    };
	    /**
	     * @param {?} state
	     * @param {?} title
	     * @param {?} url
	     * @param {?} queryParams
	     * @return {?}
	     */
	    PathLocationStrategy.prototype.pushState = function (state, title, url, queryParams) {
	        var /** @type {?} */ externalUrl = this.prepareExternalUrl(url + Location.normalizeQueryParams(queryParams));
	        this._platformLocation.pushState(state, title, externalUrl);
	    };
	    /**
	     * @param {?} state
	     * @param {?} title
	     * @param {?} url
	     * @param {?} queryParams
	     * @return {?}
	     */
	    PathLocationStrategy.prototype.replaceState = function (state, title, url, queryParams) {
	        var /** @type {?} */ externalUrl = this.prepareExternalUrl(url + Location.normalizeQueryParams(queryParams));
	        this._platformLocation.replaceState(state, title, externalUrl);
	    };
	    /**
	     * @return {?}
	     */
	    PathLocationStrategy.prototype.forward = function () { this._platformLocation.forward(); };
	    /**
	     * @return {?}
	     */
	    PathLocationStrategy.prototype.back = function () { this._platformLocation.back(); };
	    return PathLocationStrategy;
	}(LocationStrategy));
	PathLocationStrategy.decorators = [
	    { type: _angular_core.Injectable },
	];
	/**
	 * @nocollapse
	 */
	PathLocationStrategy.ctorParameters = function () { return [
	    { type: PlatformLocation, },
	    { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [APP_BASE_HREF,] },] },
	]; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@experimental
	 * @abstract
	 */
	var NgLocalization = (function () {
	    function NgLocalization() {
	    }
	    /**
	     * @abstract
	     * @param {?} value
	     * @return {?}
	     */
	    NgLocalization.prototype.getPluralCategory = function (value) { };
	    return NgLocalization;
	}());
	/**
	 * Returns the plural category for a given value.
	 * - "=value" when the case exists,
	 * - the plural category otherwise
	 *
	 * \@internal
	 * @param {?} value
	 * @param {?} cases
	 * @param {?} ngLocalization
	 * @return {?}
	 */
	function getPluralCategory(value, cases, ngLocalization) {
	    var /** @type {?} */ key = "=" + value;
	    if (cases.indexOf(key) > -1) {
	        return key;
	    }
	    key = ngLocalization.getPluralCategory(value);
	    if (cases.indexOf(key) > -1) {
	        return key;
	    }
	    if (cases.indexOf('other') > -1) {
	        return 'other';
	    }
	    throw new Error("No plural message found for value \"" + value + "\"");
	}
	/**
	 * Returns the plural case based on the locale
	 *
	 * \@experimental
	 */
	var NgLocaleLocalization = (function (_super) {
	    __extends(NgLocaleLocalization, _super);
	    /**
	     * @param {?} locale
	     */
	    function NgLocaleLocalization(locale) {
	        var _this = _super.call(this) || this;
	        _this.locale = locale;
	        return _this;
	    }
	    /**
	     * @param {?} value
	     * @return {?}
	     */
	    NgLocaleLocalization.prototype.getPluralCategory = function (value) {
	        var /** @type {?} */ plural = getPluralCase(this.locale, value);
	        switch (plural) {
	            case Plural.Zero:
	                return 'zero';
	            case Plural.One:
	                return 'one';
	            case Plural.Two:
	                return 'two';
	            case Plural.Few:
	                return 'few';
	            case Plural.Many:
	                return 'many';
	            default:
	                return 'other';
	        }
	    };
	    return NgLocaleLocalization;
	}(NgLocalization));
	NgLocaleLocalization.decorators = [
	    { type: _angular_core.Injectable },
	];
	/**
	 * @nocollapse
	 */
	NgLocaleLocalization.ctorParameters = function () { return [
	    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
	]; };
	var Plural = {};
	Plural.Zero = 0;
	Plural.One = 1;
	Plural.Two = 2;
	Plural.Few = 3;
	Plural.Many = 4;
	Plural.Other = 5;
	Plural[Plural.Zero] = "Zero";
	Plural[Plural.One] = "One";
	Plural[Plural.Two] = "Two";
	Plural[Plural.Few] = "Few";
	Plural[Plural.Many] = "Many";
	Plural[Plural.Other] = "Other";
	/**
	 * Returns the plural case based on the locale
	 *
	 * \@experimental
	 * @param {?} locale
	 * @param {?} nLike
	 * @return {?}
	 */
	function getPluralCase(locale, nLike) {
	    // TODO(vicb): lazy compute
	    if (typeof nLike === 'string') {
	        nLike = parseInt(/** @type {?} */ (nLike), 10);
	    }
	    var /** @type {?} */ n = (nLike);
	    var /** @type {?} */ nDecimal = n.toString().replace(/^[^.]*\.?/, '');
	    var /** @type {?} */ i = Math.floor(Math.abs(n));
	    var /** @type {?} */ v = nDecimal.length;
	    var /** @type {?} */ f = parseInt(nDecimal, 10);
	    var /** @type {?} */ t = parseInt(n.toString().replace(/^[^.]*\.?|0+$/g, ''), 10) || 0;
	    var /** @type {?} */ lang = locale.split('-')[0].toLowerCase();
	    switch (lang) {
	        case 'af':
	        case 'asa':
	        case 'az':
	        case 'bem':
	        case 'bez':
	        case 'bg':
	        case 'brx':
	        case 'ce':
	        case 'cgg':
	        case 'chr':
	        case 'ckb':
	        case 'ee':
	        case 'el':
	        case 'eo':
	        case 'es':
	        case 'eu':
	        case 'fo':
	        case 'fur':
	        case 'gsw':
	        case 'ha':
	        case 'haw':
	        case 'hu':
	        case 'jgo':
	        case 'jmc':
	        case 'ka':
	        case 'kk':
	        case 'kkj':
	        case 'kl':
	        case 'ks':
	        case 'ksb':
	        case 'ky':
	        case 'lb':
	        case 'lg':
	        case 'mas':
	        case 'mgo':
	        case 'ml':
	        case 'mn':
	        case 'nb':
	        case 'nd':
	        case 'ne':
	        case 'nn':
	        case 'nnh':
	        case 'nyn':
	        case 'om':
	        case 'or':
	        case 'os':
	        case 'ps':
	        case 'rm':
	        case 'rof':
	        case 'rwk':
	        case 'saq':
	        case 'seh':
	        case 'sn':
	        case 'so':
	        case 'sq':
	        case 'ta':
	        case 'te':
	        case 'teo':
	        case 'tk':
	        case 'tr':
	        case 'ug':
	        case 'uz':
	        case 'vo':
	        case 'vun':
	        case 'wae':
	        case 'xog':
	            if (n === 1)
	                return Plural.One;
	            return Plural.Other;
	        case 'ak':
	        case 'ln':
	        case 'mg':
	        case 'pa':
	        case 'ti':
	            if (n === Math.floor(n) && n >= 0 && n <= 1)
	                return Plural.One;
	            return Plural.Other;
	        case 'am':
	        case 'as':
	        case 'bn':
	        case 'fa':
	        case 'gu':
	        case 'hi':
	        case 'kn':
	        case 'mr':
	        case 'zu':
	            if (i === 0 || n === 1)
	                return Plural.One;
	            return Plural.Other;
	        case 'ar':
	            if (n === 0)
	                return Plural.Zero;
	            if (n === 1)
	                return Plural.One;
	            if (n === 2)
	                return Plural.Two;
	            if (n % 100 === Math.floor(n % 100) && n % 100 >= 3 && n % 100 <= 10)
	                return Plural.Few;
	            if (n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 99)
	                return Plural.Many;
	            return Plural.Other;
	        case 'ast':
	        case 'ca':
	        case 'de':
	        case 'en':
	        case 'et':
	        case 'fi':
	        case 'fy':
	        case 'gl':
	        case 'it':
	        case 'nl':
	        case 'sv':
	        case 'sw':
	        case 'ur':
	        case 'yi':
	            if (i === 1 && v === 0)
	                return Plural.One;
	            return Plural.Other;
	        case 'be':
	            if (n % 10 === 1 && !(n % 100 === 11))
	                return Plural.One;
	            if (n % 10 === Math.floor(n % 10) && n % 10 >= 2 && n % 10 <= 4 &&
	                !(n % 100 >= 12 && n % 100 <= 14))
	                return Plural.Few;
	            if (n % 10 === 0 || n % 10 === Math.floor(n % 10) && n % 10 >= 5 && n % 10 <= 9 ||
	                n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 14)
	                return Plural.Many;
	            return Plural.Other;
	        case 'br':
	            if (n % 10 === 1 && !(n % 100 === 11 || n % 100 === 71 || n % 100 === 91))
	                return Plural.One;
	            if (n % 10 === 2 && !(n % 100 === 12 || n % 100 === 72 || n % 100 === 92))
	                return Plural.Two;
	            if (n % 10 === Math.floor(n % 10) && (n % 10 >= 3 && n % 10 <= 4 || n % 10 === 9) &&
	                !(n % 100 >= 10 && n % 100 <= 19 || n % 100 >= 70 && n % 100 <= 79 ||
	                    n % 100 >= 90 && n % 100 <= 99))
	                return Plural.Few;
	            if (!(n === 0) && n % 1e6 === 0)
	                return Plural.Many;
	            return Plural.Other;
	        case 'bs':
	        case 'hr':
	        case 'sr':
	            if (v === 0 && i % 10 === 1 && !(i % 100 === 11) || f % 10 === 1 && !(f % 100 === 11))
	                return Plural.One;
	            if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 &&
	                !(i % 100 >= 12 && i % 100 <= 14) ||
	                f % 10 === Math.floor(f % 10) && f % 10 >= 2 && f % 10 <= 4 &&
	                    !(f % 100 >= 12 && f % 100 <= 14))
	                return Plural.Few;
	            return Plural.Other;
	        case 'cs':
	        case 'sk':
	            if (i === 1 && v === 0)
	                return Plural.One;
	            if (i === Math.floor(i) && i >= 2 && i <= 4 && v === 0)
	                return Plural.Few;
	            if (!(v === 0))
	                return Plural.Many;
	            return Plural.Other;
	        case 'cy':
	            if (n === 0)
	                return Plural.Zero;
	            if (n === 1)
	                return Plural.One;
	            if (n === 2)
	                return Plural.Two;
	            if (n === 3)
	                return Plural.Few;
	            if (n === 6)
	                return Plural.Many;
	            return Plural.Other;
	        case 'da':
	            if (n === 1 || !(t === 0) && (i === 0 || i === 1))
	                return Plural.One;
	            return Plural.Other;
	        case 'dsb':
	        case 'hsb':
	            if (v === 0 && i % 100 === 1 || f % 100 === 1)
	                return Plural.One;
	            if (v === 0 && i % 100 === 2 || f % 100 === 2)
	                return Plural.Two;
	            if (v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 3 && i % 100 <= 4 ||
	                f % 100 === Math.floor(f % 100) && f % 100 >= 3 && f % 100 <= 4)
	                return Plural.Few;
	            return Plural.Other;
	        case 'ff':
	        case 'fr':
	        case 'hy':
	        case 'kab':
	            if (i === 0 || i === 1)
	                return Plural.One;
	            return Plural.Other;
	        case 'fil':
	            if (v === 0 && (i === 1 || i === 2 || i === 3) ||
	                v === 0 && !(i % 10 === 4 || i % 10 === 6 || i % 10 === 9) ||
	                !(v === 0) && !(f % 10 === 4 || f % 10 === 6 || f % 10 === 9))
	                return Plural.One;
	            return Plural.Other;
	        case 'ga':
	            if (n === 1)
	                return Plural.One;
	            if (n === 2)
	                return Plural.Two;
	            if (n === Math.floor(n) && n >= 3 && n <= 6)
	                return Plural.Few;
	            if (n === Math.floor(n) && n >= 7 && n <= 10)
	                return Plural.Many;
	            return Plural.Other;
	        case 'gd':
	            if (n === 1 || n === 11)
	                return Plural.One;
	            if (n === 2 || n === 12)
	                return Plural.Two;
	            if (n === Math.floor(n) && (n >= 3 && n <= 10 || n >= 13 && n <= 19))
	                return Plural.Few;
	            return Plural.Other;
	        case 'gv':
	            if (v === 0 && i % 10 === 1)
	                return Plural.One;
	            if (v === 0 && i % 10 === 2)
	                return Plural.Two;
	            if (v === 0 &&
	                (i % 100 === 0 || i % 100 === 20 || i % 100 === 40 || i % 100 === 60 || i % 100 === 80))
	                return Plural.Few;
	            if (!(v === 0))
	                return Plural.Many;
	            return Plural.Other;
	        case 'he':
	            if (i === 1 && v === 0)
	                return Plural.One;
	            if (i === 2 && v === 0)
	                return Plural.Two;
	            if (v === 0 && !(n >= 0 && n <= 10) && n % 10 === 0)
	                return Plural.Many;
	            return Plural.Other;
	        case 'is':
	            if (t === 0 && i % 10 === 1 && !(i % 100 === 11) || !(t === 0))
	                return Plural.One;
	            return Plural.Other;
	        case 'ksh':
	            if (n === 0)
	                return Plural.Zero;
	            if (n === 1)
	                return Plural.One;
	            return Plural.Other;
	        case 'kw':
	        case 'naq':
	        case 'se':
	        case 'smn':
	            if (n === 1)
	                return Plural.One;
	            if (n === 2)
	                return Plural.Two;
	            return Plural.Other;
	        case 'lag':
	            if (n === 0)
	                return Plural.Zero;
	            if ((i === 0 || i === 1) && !(n === 0))
	                return Plural.One;
	            return Plural.Other;
	        case 'lt':
	            if (n % 10 === 1 && !(n % 100 >= 11 && n % 100 <= 19))
	                return Plural.One;
	            if (n % 10 === Math.floor(n % 10) && n % 10 >= 2 && n % 10 <= 9 &&
	                !(n % 100 >= 11 && n % 100 <= 19))
	                return Plural.Few;
	            if (!(f === 0))
	                return Plural.Many;
	            return Plural.Other;
	        case 'lv':
	        case 'prg':
	            if (n % 10 === 0 || n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 19 ||
	                v === 2 && f % 100 === Math.floor(f % 100) && f % 100 >= 11 && f % 100 <= 19)
	                return Plural.Zero;
	            if (n % 10 === 1 && !(n % 100 === 11) || v === 2 && f % 10 === 1 && !(f % 100 === 11) ||
	                !(v === 2) && f % 10 === 1)
	                return Plural.One;
	            return Plural.Other;
	        case 'mk':
	            if (v === 0 && i % 10 === 1 || f % 10 === 1)
	                return Plural.One;
	            return Plural.Other;
	        case 'mt':
	            if (n === 1)
	                return Plural.One;
	            if (n === 0 || n % 100 === Math.floor(n % 100) && n % 100 >= 2 && n % 100 <= 10)
	                return Plural.Few;
	            if (n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 19)
	                return Plural.Many;
	            return Plural.Other;
	        case 'pl':
	            if (i === 1 && v === 0)
	                return Plural.One;
	            if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 &&
	                !(i % 100 >= 12 && i % 100 <= 14))
	                return Plural.Few;
	            if (v === 0 && !(i === 1) && i % 10 === Math.floor(i % 10) && i % 10 >= 0 && i % 10 <= 1 ||
	                v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 5 && i % 10 <= 9 ||
	                v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 12 && i % 100 <= 14)
	                return Plural.Many;
	            return Plural.Other;
	        case 'pt':
	            if (n === Math.floor(n) && n >= 0 && n <= 2 && !(n === 2))
	                return Plural.One;
	            return Plural.Other;
	        case 'ro':
	            if (i === 1 && v === 0)
	                return Plural.One;
	            if (!(v === 0) || n === 0 ||
	                !(n === 1) && n % 100 === Math.floor(n % 100) && n % 100 >= 1 && n % 100 <= 19)
	                return Plural.Few;
	            return Plural.Other;
	        case 'ru':
	        case 'uk':
	            if (v === 0 && i % 10 === 1 && !(i % 100 === 11))
	                return Plural.One;
	            if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 &&
	                !(i % 100 >= 12 && i % 100 <= 14))
	                return Plural.Few;
	            if (v === 0 && i % 10 === 0 ||
	                v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 5 && i % 10 <= 9 ||
	                v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 11 && i % 100 <= 14)
	                return Plural.Many;
	            return Plural.Other;
	        case 'shi':
	            if (i === 0 || n === 1)
	                return Plural.One;
	            if (n === Math.floor(n) && n >= 2 && n <= 10)
	                return Plural.Few;
	            return Plural.Other;
	        case 'si':
	            if (n === 0 || n === 1 || i === 0 && f === 1)
	                return Plural.One;
	            return Plural.Other;
	        case 'sl':
	            if (v === 0 && i % 100 === 1)
	                return Plural.One;
	            if (v === 0 && i % 100 === 2)
	                return Plural.Two;
	            if (v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 3 && i % 100 <= 4 || !(v === 0))
	                return Plural.Few;
	            return Plural.Other;
	        case 'tzm':
	            if (n === Math.floor(n) && n >= 0 && n <= 1 || n === Math.floor(n) && n >= 11 && n <= 99)
	                return Plural.One;
	            return Plural.Other;
	        // When there is no specification, the default is always "other"
	        // Spec: http://cldr.unicode.org/index/cldr-spec/plural-rules
	        // > other (required—general plural form — also used if the language only has a single form)
	        default:
	            return Plural.Other;
	    }
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 * @param {?} cookieStr
	 * @param {?} name
	 * @return {?}
	 */
	function parseCookieValue(cookieStr, name) {
	    name = encodeURIComponent(name);
	    for (var _i = 0, _a = cookieStr.split(';'); _i < _a.length; _i++) {
	        var cookie = _a[_i];
	        var /** @type {?} */ eqIndex = cookie.indexOf('=');
	        var _b = eqIndex == -1 ? [cookie, ''] : [cookie.slice(0, eqIndex), cookie.slice(eqIndex + 1)], cookieName = _b[0], cookieValue = _b[1];
	        if (cookieName.trim() === name) {
	            return decodeURIComponent(cookieValue);
	        }
	    }
	    return null;
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@ngModule CommonModule
	 *
	 * \@whatItDoes Adds and removes CSS classes on an HTML element.
	 *
	 * \@howToUse
	 * ```
	 *     <some-element [ngClass]="'first second'">...</some-element>
	 *
	 *     <some-element [ngClass]="['first', 'second']">...</some-element>
	 *
	 *     <some-element [ngClass]="{'first': true, 'second': true, 'third': false}">...</some-element>
	 *
	 *     <some-element [ngClass]="stringExp|arrayExp|objExp">...</some-element>
	 *
	 *     <some-element [ngClass]="{'class1 class2 class3' : true}">...</some-element>
	 * ```
	 *
	 * \@description
	 *
	 * The CSS classes are updated as follows, depending on the type of the expression evaluation:
	 * - `string` - the CSS classes listed in the string (space delimited) are added,
	 * - `Array` - the CSS classes declared as Array elements are added,
	 * - `Object` - keys are CSS classes that get added when the expression given in the value
	 *              evaluates to a truthy value, otherwise they are removed.
	 *
	 * \@stable
	 */
	var NgClass = (function () {
	    /**
	     * @param {?} _iterableDiffers
	     * @param {?} _keyValueDiffers
	     * @param {?} _ngEl
	     * @param {?} _renderer
	     */
	    function NgClass(_iterableDiffers, _keyValueDiffers, _ngEl, _renderer) {
	        this._iterableDiffers = _iterableDiffers;
	        this._keyValueDiffers = _keyValueDiffers;
	        this._ngEl = _ngEl;
	        this._renderer = _renderer;
	        this._initialClasses = [];
	    }
	    Object.defineProperty(NgClass.prototype, "klass", {
	        /**
	         * @param {?} v
	         * @return {?}
	         */
	        set: function (v) {
	            this._applyInitialClasses(true);
	            this._initialClasses = typeof v === 'string' ? v.split(/\s+/) : [];
	            this._applyInitialClasses(false);
	            this._applyClasses(this._rawClass, false);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgClass.prototype, "ngClass", {
	        /**
	         * @param {?} v
	         * @return {?}
	         */
	        set: function (v) {
	            this._cleanupClasses(this._rawClass);
	            this._iterableDiffer = null;
	            this._keyValueDiffer = null;
	            this._rawClass = typeof v === 'string' ? v.split(/\s+/) : v;
	            if (this._rawClass) {
	                if (_angular_core.ɵisListLikeIterable(this._rawClass)) {
	                    this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create();
	                }
	                else {
	                    this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create();
	                }
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @return {?}
	     */
	    NgClass.prototype.ngDoCheck = function () {
	        if (this._iterableDiffer) {
	            var /** @type {?} */ iterableChanges = this._iterableDiffer.diff(/** @type {?} */ (this._rawClass));
	            if (iterableChanges) {
	                this._applyIterableChanges(iterableChanges);
	            }
	        }
	        else if (this._keyValueDiffer) {
	            var /** @type {?} */ keyValueChanges = this._keyValueDiffer.diff(/** @type {?} */ (this._rawClass));
	            if (keyValueChanges) {
	                this._applyKeyValueChanges(keyValueChanges);
	            }
	        }
	    };
	    /**
	     * @param {?} rawClassVal
	     * @return {?}
	     */
	    NgClass.prototype._cleanupClasses = function (rawClassVal) {
	        this._applyClasses(rawClassVal, true);
	        this._applyInitialClasses(false);
	    };
	    /**
	     * @param {?} changes
	     * @return {?}
	     */
	    NgClass.prototype._applyKeyValueChanges = function (changes) {
	        var _this = this;
	        changes.forEachAddedItem(function (record) { return _this._toggleClass(record.key, record.currentValue); });
	        changes.forEachChangedItem(function (record) { return _this._toggleClass(record.key, record.currentValue); });
	        changes.forEachRemovedItem(function (record) {
	            if (record.previousValue) {
	                _this._toggleClass(record.key, false);
	            }
	        });
	    };
	    /**
	     * @param {?} changes
	     * @return {?}
	     */
	    NgClass.prototype._applyIterableChanges = function (changes) {
	        var _this = this;
	        changes.forEachAddedItem(function (record) {
	            if (typeof record.item === 'string') {
	                _this._toggleClass(record.item, true);
	            }
	            else {
	                throw new Error("NgClass can only toggle CSS classes expressed as strings, got " + _angular_core.ɵstringify(record.item));
	            }
	        });
	        changes.forEachRemovedItem(function (record) { return _this._toggleClass(record.item, false); });
	    };
	    /**
	     * @param {?} isCleanup
	     * @return {?}
	     */
	    NgClass.prototype._applyInitialClasses = function (isCleanup) {
	        var _this = this;
	        this._initialClasses.forEach(function (klass) { return _this._toggleClass(klass, !isCleanup); });
	    };
	    /**
	     * @param {?} rawClassVal
	     * @param {?} isCleanup
	     * @return {?}
	     */
	    NgClass.prototype._applyClasses = function (rawClassVal, isCleanup) {
	        var _this = this;
	        if (rawClassVal) {
	            if (Array.isArray(rawClassVal) || rawClassVal instanceof Set) {
	                ((rawClassVal)).forEach(function (klass) { return _this._toggleClass(klass, !isCleanup); });
	            }
	            else {
	                Object.keys(rawClassVal).forEach(function (klass) {
	                    if (rawClassVal[klass] != null)
	                        _this._toggleClass(klass, !isCleanup);
	                });
	            }
	        }
	    };
	    /**
	     * @param {?} klass
	     * @param {?} enabled
	     * @return {?}
	     */
	    NgClass.prototype._toggleClass = function (klass, enabled) {
	        var _this = this;
	        klass = klass.trim();
	        if (klass) {
	            klass.split(/\s+/g).forEach(function (klass) { _this._renderer.setElementClass(_this._ngEl.nativeElement, klass, !!enabled); });
	        }
	    };
	    return NgClass;
	}());
	NgClass.decorators = [
	    { type: _angular_core.Directive, args: [{ selector: '[ngClass]' },] },
	];
	/**
	 * @nocollapse
	 */
	NgClass.ctorParameters = function () { return [
	    { type: _angular_core.IterableDiffers, },
	    { type: _angular_core.KeyValueDiffers, },
	    { type: _angular_core.ElementRef, },
	    { type: _angular_core.Renderer, },
	]; };
	NgClass.propDecorators = {
	    'klass': [{ type: _angular_core.Input, args: ['class',] },],
	    'ngClass': [{ type: _angular_core.Input },],
	};
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Instantiates a single {\@link Component} type and inserts its Host View into current View.
	 * `NgComponentOutlet` provides a declarative approach for dynamic component creation.
	 *
	 * `NgComponentOutlet` requires a component type, if a falsy value is set the view will clear and
	 * any existing component will get destroyed.
	 *
	 * ### Fine tune control
	 *
	 * You can control the component creation process by using the following optional attributes:
	 *
	 * * `ngComponentOutletInjector`: Optional custom {\@link Injector} that will be used as parent for
	 * the Component. Defaults to the injector of the current view container.
	 *
	 * * `ngComponentOutletContent`: Optional list of projectable nodes to insert into the content
	 * section of the component, if exists.
	 *
	 * * `ngComponentOutletNgModuleFactory`: Optional module factory to allow dynamically loading other
	 * module, then load a component from that module.
	 *
	 * ### Syntax
	 *
	 * Simple
	 * ```
	 * <ng-container *ngComponentOutlet="componentTypeExpression"></ng-container>
	 * ```
	 *
	 * Customized injector/content
	 * ```
	 * <ng-container *ngComponentOutlet="componentTypeExpression;
	 *                                   injector: injectorExpression;
	 *                                   content: contentNodesExpression;">
	 * </ng-container>
	 * ```
	 *
	 * Customized ngModuleFactory
	 * ```
	 * <ng-container *ngComponentOutlet="componentTypeExpression;
	 *                                   ngModuleFactory: moduleFactory;">
	 * </ng-container>
	 * ```
	 * ## Example
	 *
	 * {\@example common/ngComponentOutlet/ts/module.ts region='SimpleExample'}
	 *
	 * A more complete example with additional options:
	 *
	 * {\@example common/ngComponentOutlet/ts/module.ts region='CompleteExample'}
	 * A more complete example with ngModuleFactory:
	 *
	 * {\@example common/ngComponentOutlet/ts/module.ts region='NgModuleFactoryExample'}
	 *
	 * \@experimental
	 */
	var NgComponentOutlet = (function () {
	    /**
	     * @param {?} _viewContainerRef
	     */
	    function NgComponentOutlet(_viewContainerRef) {
	        this._viewContainerRef = _viewContainerRef;
	        this._componentRef = null;
	        this._moduleRef = null;
	    }
	    /**
	     * @param {?} changes
	     * @return {?}
	     */
	    NgComponentOutlet.prototype.ngOnChanges = function (changes) {
	        this._viewContainerRef.clear();
	        this._componentRef = null;
	        if (this.ngComponentOutlet) {
	            var /** @type {?} */ elInjector = this.ngComponentOutletInjector || this._viewContainerRef.parentInjector;
	            if (changes['ngComponentOutletNgModuleFactory']) {
	                if (this._moduleRef)
	                    this._moduleRef.destroy();
	                if (this.ngComponentOutletNgModuleFactory) {
	                    var /** @type {?} */ parentModule = elInjector.get(_angular_core.NgModuleRef);
	                    this._moduleRef = this.ngComponentOutletNgModuleFactory.create(parentModule.injector);
	                }
	                else {
	                    this._moduleRef = null;
	                }
	            }
	            var /** @type {?} */ componentFactoryResolver = this._moduleRef ? this._moduleRef.componentFactoryResolver :
	                elInjector.get(_angular_core.ComponentFactoryResolver);
	            var /** @type {?} */ componentFactory = componentFactoryResolver.resolveComponentFactory(this.ngComponentOutlet);
	            this._componentRef = this._viewContainerRef.createComponent(componentFactory, this._viewContainerRef.length, elInjector, this.ngComponentOutletContent);
	        }
	    };
	    /**
	     * @return {?}
	     */
	    NgComponentOutlet.prototype.ngOnDestroy = function () {
	        if (this._moduleRef)
	            this._moduleRef.destroy();
	    };
	    return NgComponentOutlet;
	}());
	NgComponentOutlet.decorators = [
	    { type: _angular_core.Directive, args: [{ selector: '[ngComponentOutlet]' },] },
	];
	/**
	 * @nocollapse
	 */
	NgComponentOutlet.ctorParameters = function () { return [
	    { type: _angular_core.ViewContainerRef, },
	]; };
	NgComponentOutlet.propDecorators = {
	    'ngComponentOutlet': [{ type: _angular_core.Input },],
	    'ngComponentOutletInjector': [{ type: _angular_core.Input },],
	    'ngComponentOutletContent': [{ type: _angular_core.Input },],
	    'ngComponentOutletNgModuleFactory': [{ type: _angular_core.Input },],
	};
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@stable
	 */
	var NgForOfContext = (function () {
	    /**
	     * @param {?} $implicit
	     * @param {?} ngForOf
	     * @param {?} index
	     * @param {?} count
	     */
	    function NgForOfContext($implicit, ngForOf, index, count) {
	        this.$implicit = $implicit;
	        this.ngForOf = ngForOf;
	        this.index = index;
	        this.count = count;
	    }
	    Object.defineProperty(NgForOfContext.prototype, "first", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.index === 0; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgForOfContext.prototype, "last", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.index === this.count - 1; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgForOfContext.prototype, "even", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.index % 2 === 0; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgForOfContext.prototype, "odd", {
	        /**
	         * @return {?}
	         */
	        get: function () { return !this.even; },
	        enumerable: true,
	        configurable: true
	    });
	    return NgForOfContext;
	}());
	/**
	 * The `NgForOf` directive instantiates a template once per item from an iterable. The context
	 * for each instantiated template inherits from the outer context with the given loop variable
	 * set to the current item from the iterable.
	 *
	 * ### Local Variables
	 *
	 * `NgForOf` provides several exported values that can be aliased to local variables:
	 *
	 * - `$implicit: T`: The value of the individual items in the iterable (`ngForOf`).
	 * - `ngForOf: NgIterable<T>`: The value of the iterable expression. Useful when the expression is
	 * more complex then a property access, for example when using the async pipe (`userStreams |
	 * async`).
	 * - `index: number`: The index of the current item in the iterable.
	 * - `first: boolean`: True when the item is the first item in the iterable.
	 * - `last: boolean`: True when the item is the last item in the iterable.
	 * - `even: boolean`: True when the item has an even index in the iterable.
	 * - `odd: boolean`: True when the item has an odd index in the iterable.
	 *
	 * ```
	 * <li *ngFor="let user of userObservable | async as users; index as i; first as isFirst">
	 *    {{i}}/{{users.length}}. {{user}} <span *ngIf="isFirst">default</span>
	 * </li>
	 * ```
	 *
	 * ### Change Propagation
	 *
	 * When the contents of the iterator changes, `NgForOf` makes the corresponding changes to the DOM:
	 *
	 * * When an item is added, a new instance of the template is added to the DOM.
	 * * When an item is removed, its template instance is removed from the DOM.
	 * * When items are reordered, their respective templates are reordered in the DOM.
	 * * Otherwise, the DOM element for that item will remain the same.
	 *
	 * Angular uses object identity to track insertions and deletions within the iterator and reproduce
	 * those changes in the DOM. This has important implications for animations and any stateful
	 * controls (such as `<input>` elements which accept user input) that are present. Inserted rows can
	 * be animated in, deleted rows can be animated out, and unchanged rows retain any unsaved state
	 * such as user input.
	 *
	 * It is possible for the identities of elements in the iterator to change while the data does not.
	 * This can happen, for example, if the iterator produced from an RPC to the server, and that
	 * RPC is re-run. Even if the data hasn't changed, the second response will produce objects with
	 * different identities, and Angular will tear down the entire DOM and rebuild it (as if all old
	 * elements were deleted and all new elements inserted). This is an expensive operation and should
	 * be avoided if possible.
	 *
	 * To customize the default tracking algorithm, `NgForOf` supports `trackBy` option.
	 * `trackBy` takes a function which has two arguments: `index` and `item`.
	 * If `trackBy` is given, Angular tracks changes by the return value of the function.
	 *
	 * ### Syntax
	 *
	 * - `<li *ngFor="let item of items; index as i; trackBy: trackByFn">...</li>`
	 * - `<li template="ngFor let item of items; index as i; trackBy: trackByFn">...</li>`
	 *
	 * With `<ng-template>` element:
	 *
	 * ```
	 * <ng-template ngFor let-item [ngForOf]="items" let-i="index" [ngForTrackBy]="trackByFn">
	 *   <li>...</li>
	 * </ng-template>
	 * ```
	 *
	 * ### Example
	 *
	 * See a [live demo](http://plnkr.co/edit/KVuXxDp0qinGDyo307QW?p=preview) for a more detailed
	 * example.
	 *
	 * \@stable
	 */
	var NgForOf = (function () {
	    /**
	     * @param {?} _viewContainer
	     * @param {?} _template
	     * @param {?} _differs
	     */
	    function NgForOf(_viewContainer, _template, _differs) {
	        this._viewContainer = _viewContainer;
	        this._template = _template;
	        this._differs = _differs;
	        this._differ = null;
	    }
	    Object.defineProperty(NgForOf.prototype, "ngForTrackBy", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._trackByFn; },
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        set: function (fn) {
	            if (_angular_core.isDevMode() && fn != null && typeof fn !== 'function') {
	                // TODO(vicb): use a log service once there is a public one available
	                if ((console) && (console.warn)) {
	                    console.warn("trackBy must be a function, but received " + JSON.stringify(fn) + ". " +
	                        "See https://angular.io/docs/ts/latest/api/common/index/NgFor-directive.html#!#change-propagation for more information.");
	                }
	            }
	            this._trackByFn = fn;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgForOf.prototype, "ngForTemplate", {
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        set: function (value) {
	            // TODO(TS2.1): make TemplateRef<Partial<NgForRowOf<T>>> once we move to TS v2.1
	            // The current type is too restrictive; a template that just uses index, for example,
	            // should be acceptable.
	            if (value) {
	                this._template = value;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @param {?} changes
	     * @return {?}
	     */
	    NgForOf.prototype.ngOnChanges = function (changes) {
	        if ('ngForOf' in changes) {
	            // React on ngForOf changes only once all inputs have been initialized
	            var /** @type {?} */ value = changes['ngForOf'].currentValue;
	            if (!this._differ && value) {
	                try {
	                    this._differ = this._differs.find(value).create(this.ngForTrackBy);
	                }
	                catch (e) {
	                    throw new Error("Cannot find a differ supporting object '" + value + "' of type '" + getTypeNameForDebugging(value) + "'. NgFor only supports binding to Iterables such as Arrays.");
	                }
	            }
	        }
	    };
	    /**
	     * @return {?}
	     */
	    NgForOf.prototype.ngDoCheck = function () {
	        if (this._differ) {
	            var /** @type {?} */ changes = this._differ.diff(this.ngForOf);
	            if (changes)
	                this._applyChanges(changes);
	        }
	    };
	    /**
	     * @param {?} changes
	     * @return {?}
	     */
	    NgForOf.prototype._applyChanges = function (changes) {
	        var _this = this;
	        var /** @type {?} */ insertTuples = [];
	        changes.forEachOperation(function (item, adjustedPreviousIndex, currentIndex) {
	            if (item.previousIndex == null) {
	                var /** @type {?} */ view = _this._viewContainer.createEmbeddedView(_this._template, new NgForOfContext(/** @type {?} */ ((null)), _this.ngForOf, -1, -1), currentIndex);
	                var /** @type {?} */ tuple = new RecordViewTuple(item, view);
	                insertTuples.push(tuple);
	            }
	            else if (currentIndex == null) {
	                _this._viewContainer.remove(adjustedPreviousIndex);
	            }
	            else {
	                var /** @type {?} */ view = ((_this._viewContainer.get(adjustedPreviousIndex)));
	                _this._viewContainer.move(view, currentIndex);
	                var /** @type {?} */ tuple = new RecordViewTuple(item, /** @type {?} */ (view));
	                insertTuples.push(tuple);
	            }
	        });
	        for (var /** @type {?} */ i = 0; i < insertTuples.length; i++) {
	            this._perViewChange(insertTuples[i].view, insertTuples[i].record);
	        }
	        for (var /** @type {?} */ i = 0, /** @type {?} */ ilen = this._viewContainer.length; i < ilen; i++) {
	            var /** @type {?} */ viewRef = (this._viewContainer.get(i));
	            viewRef.context.index = i;
	            viewRef.context.count = ilen;
	        }
	        changes.forEachIdentityChange(function (record) {
	            var /** @type {?} */ viewRef = (_this._viewContainer.get(record.currentIndex));
	            viewRef.context.$implicit = record.item;
	        });
	    };
	    /**
	     * @param {?} view
	     * @param {?} record
	     * @return {?}
	     */
	    NgForOf.prototype._perViewChange = function (view, record) {
	        view.context.$implicit = record.item;
	    };
	    return NgForOf;
	}());
	NgForOf.decorators = [
	    { type: _angular_core.Directive, args: [{ selector: '[ngFor][ngForOf]' },] },
	];
	/**
	 * @nocollapse
	 */
	NgForOf.ctorParameters = function () { return [
	    { type: _angular_core.ViewContainerRef, },
	    { type: _angular_core.TemplateRef, },
	    { type: _angular_core.IterableDiffers, },
	]; };
	NgForOf.propDecorators = {
	    'ngForOf': [{ type: _angular_core.Input },],
	    'ngForTrackBy': [{ type: _angular_core.Input },],
	    'ngForTemplate': [{ type: _angular_core.Input },],
	};
	var RecordViewTuple = (function () {
	    /**
	     * @param {?} record
	     * @param {?} view
	     */
	    function RecordViewTuple(record, view) {
	        this.record = record;
	        this.view = view;
	    }
	    return RecordViewTuple;
	}());
	/**
	 * @deprecated from v4.0.0 - Use NgForOf instead.
	 */
	var NgFor = NgForOf;
	/**
	 * @param {?} type
	 * @return {?}
	 */
	function getTypeNameForDebugging(type) {
	    return type['name'] || typeof type;
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Conditionally includes a template based on the value of an `expression`.
	 *
	 * `ngIf` evaluates the `expression` and then renders the `then` or `else` template in its place
	 * when expression is truthy or falsy respectively. Typically the:
	 *  - `then` template is the inline template of `ngIf` unless bound to a different value.
	 *  - `else` template is blank unless it is bound.
	 *
	 * ## Most common usage
	 *
	 * The most common usage of the `ngIf` directive is to conditionally show the inline template as
	 * seen in this example:
	 * {\@example common/ngIf/ts/module.ts region='NgIfSimple'}
	 *
	 * ## Showing an alternative template using `else`
	 *
	 * If it is necessary to display a template when the `expression` is falsy use the `else` template
	 * binding as shown. Note that the `else` binding points to a `<ng-template>` labeled `#elseBlock`.
	 * The template can be defined anywhere in the component view but is typically placed right after
	 * `ngIf` for readability.
	 *
	 * {\@example common/ngIf/ts/module.ts region='NgIfElse'}
	 *
	 * ## Using non-inlined `then` template
	 *
	 * Usually the `then` template is the inlined template of the `ngIf`, but it can be changed using
	 * a binding (just like `else`). Because `then` and `else` are bindings, the template references can
	 * change at runtime as shown in this example.
	 *
	 * {\@example common/ngIf/ts/module.ts region='NgIfThenElse'}
	 *
	 * ## Storing conditional result in a variable
	 *
	 * A common pattern is that we need to show a set of properties from the same object. If the
	 * object is undefined, then we have to use the safe-traversal-operator `?.` to guard against
	 * dereferencing a `null` value. This is especially the case when waiting on async data such as
	 * when using the `async` pipe as shown in following example:
	 *
	 * ```
	 * Hello {{ (userStream|async)?.last }}, {{ (userStream|async)?.first }}!
	 * ```
	 *
	 * There are several inefficiencies in the above example:
	 *  - We create multiple subscriptions on `userStream`. One for each `async` pipe, or two in the
	 *    example above.
	 *  - We cannot display an alternative screen while waiting for the data to arrive asynchronously.
	 *  - We have to use the safe-traversal-operator `?.` to access properties, which is cumbersome.
	 *  - We have to place the `async` pipe in parenthesis.
	 *
	 * A better way to do this is to use `ngIf` and store the result of the condition in a local
	 * variable as shown in the the example below:
	 *
	 * {\@example common/ngIf/ts/module.ts region='NgIfAs'}
	 *
	 * Notice that:
	 *  - We use only one `async` pipe and hence only one subscription gets created.
	 *  - `ngIf` stores the result of the `userStream|async` in the local variable `user`.
	 *  - The local `user` can then be bound repeatedly in a more efficient way.
	 *  - No need to use the safe-traversal-operator `?.` to access properties as `ngIf` will only
	 *    display the data if `userStream` returns a value.
	 *  - We can display an alternative template while waiting for the data.
	 *
	 * ### Syntax
	 *
	 * Simple form:
	 * - `<div *ngIf="condition">...</div>`
	 * - `<div template="ngIf condition">...</div>`
	 * - `<ng-template [ngIf]="condition"><div>...</div></ng-template>`
	 *
	 * Form with an else block:
	 * ```
	 * <div *ngIf="condition; else elseBlock">...</div>
	 * <ng-template #elseBlock>...</ng-template>
	 * ```
	 *
	 * Form with a `then` and `else` block:
	 * ```
	 * <div *ngIf="condition; then thenBlock else elseBlock"></div>
	 * <ng-template #thenBlock>...</ng-template>
	 * <ng-template #elseBlock>...</ng-template>
	 * ```
	 *
	 * Form with storing the value locally:
	 * ```
	 * <div *ngIf="condition as value; else elseBlock">{{value}}</div>
	 * <ng-template #elseBlock>...</ng-template>
	 * ```
	 *
	 * \@stable
	 */
	var NgIf = (function () {
	    /**
	     * @param {?} _viewContainer
	     * @param {?} templateRef
	     */
	    function NgIf(_viewContainer, templateRef) {
	        this._viewContainer = _viewContainer;
	        this._context = new NgIfContext();
	        this._thenTemplateRef = null;
	        this._elseTemplateRef = null;
	        this._thenViewRef = null;
	        this._elseViewRef = null;
	        this._thenTemplateRef = templateRef;
	    }
	    Object.defineProperty(NgIf.prototype, "ngIf", {
	        /**
	         * @param {?} condition
	         * @return {?}
	         */
	        set: function (condition) {
	            this._context.$implicit = this._context.ngIf = condition;
	            this._updateView();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgIf.prototype, "ngIfThen", {
	        /**
	         * @param {?} templateRef
	         * @return {?}
	         */
	        set: function (templateRef) {
	            this._thenTemplateRef = templateRef;
	            this._thenViewRef = null; // clear previous view if any.
	            this._updateView();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgIf.prototype, "ngIfElse", {
	        /**
	         * @param {?} templateRef
	         * @return {?}
	         */
	        set: function (templateRef) {
	            this._elseTemplateRef = templateRef;
	            this._elseViewRef = null; // clear previous view if any.
	            this._updateView();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @return {?}
	     */
	    NgIf.prototype._updateView = function () {
	        if (this._context.$implicit) {
	            if (!this._thenViewRef) {
	                this._viewContainer.clear();
	                this._elseViewRef = null;
	                if (this._thenTemplateRef) {
	                    this._thenViewRef =
	                        this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context);
	                }
	            }
	        }
	        else {
	            if (!this._elseViewRef) {
	                this._viewContainer.clear();
	                this._thenViewRef = null;
	                if (this._elseTemplateRef) {
	                    this._elseViewRef =
	                        this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context);
	                }
	            }
	        }
	    };
	    return NgIf;
	}());
	NgIf.decorators = [
	    { type: _angular_core.Directive, args: [{ selector: '[ngIf]' },] },
	];
	/**
	 * @nocollapse
	 */
	NgIf.ctorParameters = function () { return [
	    { type: _angular_core.ViewContainerRef, },
	    { type: _angular_core.TemplateRef, },
	]; };
	NgIf.propDecorators = {
	    'ngIf': [{ type: _angular_core.Input },],
	    'ngIfThen': [{ type: _angular_core.Input },],
	    'ngIfElse': [{ type: _angular_core.Input },],
	};
	/**
	 * \@stable
	 */
	var NgIfContext = (function () {
	    function NgIfContext() {
	        this.$implicit = null;
	        this.ngIf = null;
	    }
	    return NgIfContext;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var SwitchView = (function () {
	    /**
	     * @param {?} _viewContainerRef
	     * @param {?} _templateRef
	     */
	    function SwitchView(_viewContainerRef, _templateRef) {
	        this._viewContainerRef = _viewContainerRef;
	        this._templateRef = _templateRef;
	        this._created = false;
	    }
	    /**
	     * @return {?}
	     */
	    SwitchView.prototype.create = function () {
	        this._created = true;
	        this._viewContainerRef.createEmbeddedView(this._templateRef);
	    };
	    /**
	     * @return {?}
	     */
	    SwitchView.prototype.destroy = function () {
	        this._created = false;
	        this._viewContainerRef.clear();
	    };
	    /**
	     * @param {?} created
	     * @return {?}
	     */
	    SwitchView.prototype.enforceState = function (created) {
	        if (created && !this._created) {
	            this.create();
	        }
	        else if (!created && this._created) {
	            this.destroy();
	        }
	    };
	    return SwitchView;
	}());
	/**
	 * \@ngModule CommonModule
	 *
	 * \@whatItDoes Adds / removes DOM sub-trees when the nest match expressions matches the switch
	 *             expression.
	 *
	 * \@howToUse
	 * ```
	 *     <container-element [ngSwitch]="switch_expression">
	 *       <some-element *ngSwitchCase="match_expression_1">...</some-element>
	 *       <some-element *ngSwitchCase="match_expression_2">...</some-element>
	 *       <some-other-element *ngSwitchCase="match_expression_3">...</some-other-element>
	 *       <ng-container *ngSwitchCase="match_expression_3">
	 *         <!-- use a ng-container to group multiple root nodes -->
	 *         <inner-element></inner-element>
	 *         <inner-other-element></inner-other-element>
	 *       </ng-container>
	 *       <some-element *ngSwitchDefault>...</some-element>
	 *     </container-element>
	 * ```
	 * \@description
	 *
	 * `NgSwitch` stamps out nested views when their match expression value matches the value of the
	 * switch expression.
	 *
	 * In other words:
	 * - you define a container element (where you place the directive with a switch expression on the
	 * `[ngSwitch]="..."` attribute)
	 * - you define inner views inside the `NgSwitch` and place a `*ngSwitchCase` attribute on the view
	 * root elements.
	 *
	 * Elements within `NgSwitch` but outside of a `NgSwitchCase` or `NgSwitchDefault` directives will
	 * be preserved at the location.
	 *
	 * The `ngSwitchCase` directive informs the parent `NgSwitch` of which view to display when the
	 * expression is evaluated.
	 * When no matching expression is found on a `ngSwitchCase` view, the `ngSwitchDefault` view is
	 * stamped out.
	 *
	 * \@stable
	 */
	var NgSwitch = (function () {
	    function NgSwitch() {
	        this._defaultUsed = false;
	        this._caseCount = 0;
	        this._lastCaseCheckIndex = 0;
	        this._lastCasesMatched = false;
	    }
	    Object.defineProperty(NgSwitch.prototype, "ngSwitch", {
	        /**
	         * @param {?} newValue
	         * @return {?}
	         */
	        set: function (newValue) {
	            this._ngSwitch = newValue;
	            if (this._caseCount === 0) {
	                this._updateDefaultCases(true);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * \@internal
	     * @return {?}
	     */
	    NgSwitch.prototype._addCase = function () { return this._caseCount++; };
	    /**
	     * \@internal
	     * @param {?} view
	     * @return {?}
	     */
	    NgSwitch.prototype._addDefault = function (view) {
	        if (!this._defaultViews) {
	            this._defaultViews = [];
	        }
	        this._defaultViews.push(view);
	    };
	    /**
	     * \@internal
	     * @param {?} value
	     * @return {?}
	     */
	    NgSwitch.prototype._matchCase = function (value) {
	        var /** @type {?} */ matched = value == this._ngSwitch;
	        this._lastCasesMatched = this._lastCasesMatched || matched;
	        this._lastCaseCheckIndex++;
	        if (this._lastCaseCheckIndex === this._caseCount) {
	            this._updateDefaultCases(!this._lastCasesMatched);
	            this._lastCaseCheckIndex = 0;
	            this._lastCasesMatched = false;
	        }
	        return matched;
	    };
	    /**
	     * @param {?} useDefault
	     * @return {?}
	     */
	    NgSwitch.prototype._updateDefaultCases = function (useDefault) {
	        if (this._defaultViews && useDefault !== this._defaultUsed) {
	            this._defaultUsed = useDefault;
	            for (var /** @type {?} */ i = 0; i < this._defaultViews.length; i++) {
	                var /** @type {?} */ defaultView = this._defaultViews[i];
	                defaultView.enforceState(useDefault);
	            }
	        }
	    };
	    return NgSwitch;
	}());
	NgSwitch.decorators = [
	    { type: _angular_core.Directive, args: [{ selector: '[ngSwitch]' },] },
	];
	/**
	 * @nocollapse
	 */
	NgSwitch.ctorParameters = function () { return []; };
	NgSwitch.propDecorators = {
	    'ngSwitch': [{ type: _angular_core.Input },],
	};
	/**
	 * \@ngModule CommonModule
	 *
	 * \@whatItDoes Creates a view that will be added/removed from the parent {\@link NgSwitch} when the
	 *             given expression evaluate to respectively the same/different value as the switch
	 *             expression.
	 *
	 * \@howToUse
	 * ```
	 * <container-element [ngSwitch]="switch_expression">
	 *   <some-element *ngSwitchCase="match_expression_1">...</some-element>
	 * </container-element>
	 * ```
	 * \@description
	 *
	 * Insert the sub-tree when the expression evaluates to the same value as the enclosing switch
	 * expression.
	 *
	 * If multiple match expressions match the switch expression value, all of them are displayed.
	 *
	 * See {\@link NgSwitch} for more details and example.
	 *
	 * \@stable
	 */
	var NgSwitchCase = (function () {
	    /**
	     * @param {?} viewContainer
	     * @param {?} templateRef
	     * @param {?} ngSwitch
	     */
	    function NgSwitchCase(viewContainer, templateRef, ngSwitch) {
	        this.ngSwitch = ngSwitch;
	        ngSwitch._addCase();
	        this._view = new SwitchView(viewContainer, templateRef);
	    }
	    /**
	     * @return {?}
	     */
	    NgSwitchCase.prototype.ngDoCheck = function () { this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase)); };
	    return NgSwitchCase;
	}());
	NgSwitchCase.decorators = [
	    { type: _angular_core.Directive, args: [{ selector: '[ngSwitchCase]' },] },
	];
	/**
	 * @nocollapse
	 */
	NgSwitchCase.ctorParameters = function () { return [
	    { type: _angular_core.ViewContainerRef, },
	    { type: _angular_core.TemplateRef, },
	    { type: NgSwitch, decorators: [{ type: _angular_core.Host },] },
	]; };
	NgSwitchCase.propDecorators = {
	    'ngSwitchCase': [{ type: _angular_core.Input },],
	};
	/**
	 * \@ngModule CommonModule
	 * \@whatItDoes Creates a view that is added to the parent {\@link NgSwitch} when no case expressions
	 * match the
	 *             switch expression.
	 *
	 * \@howToUse
	 * ```
	 * <container-element [ngSwitch]="switch_expression">
	 *   <some-element *ngSwitchCase="match_expression_1">...</some-element>
	 *   <some-other-element *ngSwitchDefault>...</some-other-element>
	 * </container-element>
	 * ```
	 *
	 * \@description
	 *
	 * Insert the sub-tree when no case expressions evaluate to the same value as the enclosing switch
	 * expression.
	 *
	 * See {\@link NgSwitch} for more details and example.
	 *
	 * \@stable
	 */
	var NgSwitchDefault = (function () {
	    /**
	     * @param {?} viewContainer
	     * @param {?} templateRef
	     * @param {?} ngSwitch
	     */
	    function NgSwitchDefault(viewContainer, templateRef, ngSwitch) {
	        ngSwitch._addDefault(new SwitchView(viewContainer, templateRef));
	    }
	    return NgSwitchDefault;
	}());
	NgSwitchDefault.decorators = [
	    { type: _angular_core.Directive, args: [{ selector: '[ngSwitchDefault]' },] },
	];
	/**
	 * @nocollapse
	 */
	NgSwitchDefault.ctorParameters = function () { return [
	    { type: _angular_core.ViewContainerRef, },
	    { type: _angular_core.TemplateRef, },
	    { type: NgSwitch, decorators: [{ type: _angular_core.Host },] },
	]; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@ngModule CommonModule
	 *
	 * \@whatItDoes Adds / removes DOM sub-trees based on a numeric value. Tailored for pluralization.
	 *
	 * \@howToUse
	 * ```
	 * <some-element [ngPlural]="value">
	 *   <ng-template ngPluralCase="=0">there is nothing</ng-template>
	 *   <ng-template ngPluralCase="=1">there is one</ng-template>
	 *   <ng-template ngPluralCase="few">there are a few</ng-template>
	 * </some-element>
	 * ```
	 *
	 * \@description
	 *
	 * Displays DOM sub-trees that match the switch expression value, or failing that, DOM sub-trees
	 * that match the switch expression's pluralization category.
	 *
	 * To use this directive you must provide a container element that sets the `[ngPlural]` attribute
	 * to a switch expression. Inner elements with a `[ngPluralCase]` will display based on their
	 * expression:
	 * - if `[ngPluralCase]` is set to a value starting with `=`, it will only display if the value
	 *   matches the switch expression exactly,
	 * - otherwise, the view will be treated as a "category match", and will only display if exact
	 *   value matches aren't found and the value maps to its category for the defined locale.
	 *
	 * See http://cldr.unicode.org/index/cldr-spec/plural-rules
	 *
	 * \@experimental
	 */
	var NgPlural = (function () {
	    /**
	     * @param {?} _localization
	     */
	    function NgPlural(_localization) {
	        this._localization = _localization;
	        this._caseViews = {};
	    }
	    Object.defineProperty(NgPlural.prototype, "ngPlural", {
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        set: function (value) {
	            this._switchValue = value;
	            this._updateView();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @param {?} value
	     * @param {?} switchView
	     * @return {?}
	     */
	    NgPlural.prototype.addCase = function (value, switchView) { this._caseViews[value] = switchView; };
	    /**
	     * @return {?}
	     */
	    NgPlural.prototype._updateView = function () {
	        this._clearViews();
	        var /** @type {?} */ cases = Object.keys(this._caseViews);
	        var /** @type {?} */ key = getPluralCategory(this._switchValue, cases, this._localization);
	        this._activateView(this._caseViews[key]);
	    };
	    /**
	     * @return {?}
	     */
	    NgPlural.prototype._clearViews = function () {
	        if (this._activeView)
	            this._activeView.destroy();
	    };
	    /**
	     * @param {?} view
	     * @return {?}
	     */
	    NgPlural.prototype._activateView = function (view) {
	        if (view) {
	            this._activeView = view;
	            this._activeView.create();
	        }
	    };
	    return NgPlural;
	}());
	NgPlural.decorators = [
	    { type: _angular_core.Directive, args: [{ selector: '[ngPlural]' },] },
	];
	/**
	 * @nocollapse
	 */
	NgPlural.ctorParameters = function () { return [
	    { type: NgLocalization, },
	]; };
	NgPlural.propDecorators = {
	    'ngPlural': [{ type: _angular_core.Input },],
	};
	/**
	 * \@ngModule CommonModule
	 *
	 * \@whatItDoes Creates a view that will be added/removed from the parent {\@link NgPlural} when the
	 *             given expression matches the plural expression according to CLDR rules.
	 *
	 * \@howToUse
	 * ```
	 * <some-element [ngPlural]="value">
	 *   <ng-template ngPluralCase="=0">...</ng-template>
	 *   <ng-template ngPluralCase="other">...</ng-template>
	 * </some-element>
	 * ```
	 *
	 * See {\@link NgPlural} for more details and example.
	 *
	 * \@experimental
	 */
	var NgPluralCase = (function () {
	    /**
	     * @param {?} value
	     * @param {?} template
	     * @param {?} viewContainer
	     * @param {?} ngPlural
	     */
	    function NgPluralCase(value, template, viewContainer, ngPlural) {
	        this.value = value;
	        var isANumber = !isNaN(Number(value));
	        ngPlural.addCase(isANumber ? "=" + value : value, new SwitchView(viewContainer, template));
	    }
	    return NgPluralCase;
	}());
	NgPluralCase.decorators = [
	    { type: _angular_core.Directive, args: [{ selector: '[ngPluralCase]' },] },
	];
	/**
	 * @nocollapse
	 */
	NgPluralCase.ctorParameters = function () { return [
	    { type: undefined, decorators: [{ type: _angular_core.Attribute, args: ['ngPluralCase',] },] },
	    { type: _angular_core.TemplateRef, },
	    { type: _angular_core.ViewContainerRef, },
	    { type: NgPlural, decorators: [{ type: _angular_core.Host },] },
	]; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@ngModule CommonModule
	 *
	 * \@whatItDoes Update an HTML element styles.
	 *
	 * \@howToUse
	 * ```
	 * <some-element [ngStyle]="{'font-style': styleExp}">...</some-element>
	 *
	 * <some-element [ngStyle]="{'max-width.px': widthExp}">...</some-element>
	 *
	 * <some-element [ngStyle]="objExp">...</some-element>
	 * ```
	 *
	 * \@description
	 *
	 * The styles are updated according to the value of the expression evaluation:
	 * - keys are style names with an optional `.<unit>` suffix (ie 'top.px', 'font-style.em'),
	 * - values are the values assigned to those properties (expressed in the given unit).
	 *
	 * \@stable
	 */
	var NgStyle = (function () {
	    /**
	     * @param {?} _differs
	     * @param {?} _ngEl
	     * @param {?} _renderer
	     */
	    function NgStyle(_differs, _ngEl, _renderer) {
	        this._differs = _differs;
	        this._ngEl = _ngEl;
	        this._renderer = _renderer;
	    }
	    Object.defineProperty(NgStyle.prototype, "ngStyle", {
	        /**
	         * @param {?} v
	         * @return {?}
	         */
	        set: function (v) {
	            this._ngStyle = v;
	            if (!this._differ && v) {
	                this._differ = this._differs.find(v).create();
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @return {?}
	     */
	    NgStyle.prototype.ngDoCheck = function () {
	        if (this._differ) {
	            var /** @type {?} */ changes = this._differ.diff(this._ngStyle);
	            if (changes) {
	                this._applyChanges(changes);
	            }
	        }
	    };
	    /**
	     * @param {?} changes
	     * @return {?}
	     */
	    NgStyle.prototype._applyChanges = function (changes) {
	        var _this = this;
	        changes.forEachRemovedItem(function (record) { return _this._setStyle(record.key, null); });
	        changes.forEachAddedItem(function (record) { return _this._setStyle(record.key, record.currentValue); });
	        changes.forEachChangedItem(function (record) { return _this._setStyle(record.key, record.currentValue); });
	    };
	    /**
	     * @param {?} nameAndUnit
	     * @param {?} value
	     * @return {?}
	     */
	    NgStyle.prototype._setStyle = function (nameAndUnit, value) {
	        var _a = nameAndUnit.split('.'), name = _a[0], unit = _a[1];
	        value = value != null && unit ? "" + value + unit : value;
	        this._renderer.setElementStyle(this._ngEl.nativeElement, name, /** @type {?} */ (value));
	    };
	    return NgStyle;
	}());
	NgStyle.decorators = [
	    { type: _angular_core.Directive, args: [{ selector: '[ngStyle]' },] },
	];
	/**
	 * @nocollapse
	 */
	NgStyle.ctorParameters = function () { return [
	    { type: _angular_core.KeyValueDiffers, },
	    { type: _angular_core.ElementRef, },
	    { type: _angular_core.Renderer, },
	]; };
	NgStyle.propDecorators = {
	    'ngStyle': [{ type: _angular_core.Input },],
	};
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@ngModule CommonModule
	 *
	 * \@whatItDoes Inserts an embedded view from a prepared `TemplateRef`
	 *
	 * \@howToUse
	 * ```
	 * <ng-container *ngTemplateOutlet="templateRefExp; context: contextExp"></ng-container>
	 * ```
	 *
	 * \@description
	 *
	 * You can attach a context object to the `EmbeddedViewRef` by setting `[ngTemplateOutletContext]`.
	 * `[ngTemplateOutletContext]` should be an object, the object's keys will be available for binding
	 * by the local template `let` declarations.
	 *
	 * Note: using the key `$implicit` in the context object will set it's value as default.
	 *
	 * ## Example
	 *
	 * {\@example common/ngTemplateOutlet/ts/module.ts region='NgTemplateOutlet'}
	 *
	 * \@experimental
	 */
	var NgTemplateOutlet = (function () {
	    /**
	     * @param {?} _viewContainerRef
	     */
	    function NgTemplateOutlet(_viewContainerRef) {
	        this._viewContainerRef = _viewContainerRef;
	    }
	    Object.defineProperty(NgTemplateOutlet.prototype, "ngOutletContext", {
	        /**
	         * @deprecated v4.0.0 - Renamed to ngTemplateOutletContext.
	         * @param {?} context
	         * @return {?}
	         */
	        set: function (context) { this.ngTemplateOutletContext = context; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @param {?} changes
	     * @return {?}
	     */
	    NgTemplateOutlet.prototype.ngOnChanges = function (changes) {
	        if (this._viewRef) {
	            this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._viewRef));
	        }
	        if (this.ngTemplateOutlet) {
	            this._viewRef = this._viewContainerRef.createEmbeddedView(this.ngTemplateOutlet, this.ngTemplateOutletContext);
	        }
	    };
	    return NgTemplateOutlet;
	}());
	NgTemplateOutlet.decorators = [
	    { type: _angular_core.Directive, args: [{ selector: '[ngTemplateOutlet]' },] },
	];
	/**
	 * @nocollapse
	 */
	NgTemplateOutlet.ctorParameters = function () { return [
	    { type: _angular_core.ViewContainerRef, },
	]; };
	NgTemplateOutlet.propDecorators = {
	    'ngTemplateOutletContext': [{ type: _angular_core.Input },],
	    'ngTemplateOutlet': [{ type: _angular_core.Input },],
	    'ngOutletContext': [{ type: _angular_core.Input },],
	};
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * A collection of Angular directives that are likely to be used in each and every Angular
	 * application.
	 */
	var COMMON_DIRECTIVES = [
	    NgClass,
	    NgComponentOutlet,
	    NgForOf,
	    NgIf,
	    NgTemplateOutlet,
	    NgStyle,
	    NgSwitch,
	    NgSwitchCase,
	    NgSwitchDefault,
	    NgPlural,
	    NgPluralCase,
	];
	/**
	 * A collection of deprecated directives that are no longer part of the core module.
	 */
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} type
	 * @param {?} value
	 * @return {?}
	 */
	function invalidPipeArgumentError(type, value) {
	    return Error("InvalidPipeArgument: '" + value + "' for pipe '" + _angular_core.ɵstringify(type) + "'");
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var ObservableStrategy = (function () {
	    function ObservableStrategy() {
	    }
	    /**
	     * @param {?} async
	     * @param {?} updateLatestValue
	     * @return {?}
	     */
	    ObservableStrategy.prototype.createSubscription = function (async, updateLatestValue) {
	        return async.subscribe({ next: updateLatestValue, error: function (e) { throw e; } });
	    };
	    /**
	     * @param {?} subscription
	     * @return {?}
	     */
	    ObservableStrategy.prototype.dispose = function (subscription) { subscription.unsubscribe(); };
	    /**
	     * @param {?} subscription
	     * @return {?}
	     */
	    ObservableStrategy.prototype.onDestroy = function (subscription) { subscription.unsubscribe(); };
	    return ObservableStrategy;
	}());
	var PromiseStrategy = (function () {
	    function PromiseStrategy() {
	    }
	    /**
	     * @param {?} async
	     * @param {?} updateLatestValue
	     * @return {?}
	     */
	    PromiseStrategy.prototype.createSubscription = function (async, updateLatestValue) {
	        return async.then(updateLatestValue, function (e) { throw e; });
	    };
	    /**
	     * @param {?} subscription
	     * @return {?}
	     */
	    PromiseStrategy.prototype.dispose = function (subscription) { };
	    /**
	     * @param {?} subscription
	     * @return {?}
	     */
	    PromiseStrategy.prototype.onDestroy = function (subscription) { };
	    return PromiseStrategy;
	}());
	var _promiseStrategy = new PromiseStrategy();
	var _observableStrategy = new ObservableStrategy();
	/**
	 * \@ngModule CommonModule
	 * \@whatItDoes Unwraps a value from an asynchronous primitive.
	 * \@howToUse `observable_or_promise_expression | async`
	 * \@description
	 * The `async` pipe subscribes to an `Observable` or `Promise` and returns the latest value it has
	 * emitted. When a new value is emitted, the `async` pipe marks the component to be checked for
	 * changes. When the component gets destroyed, the `async` pipe unsubscribes automatically to avoid
	 * potential memory leaks.
	 *
	 *
	 * ## Examples
	 *
	 * This example binds a `Promise` to the view. Clicking the `Resolve` button resolves the
	 * promise.
	 *
	 * {\@example common/pipes/ts/async_pipe.ts region='AsyncPipePromise'}
	 *
	 * It's also possible to use `async` with Observables. The example below binds the `time` Observable
	 * to the view. The Observable continuously updates the view with the current time.
	 *
	 * {\@example common/pipes/ts/async_pipe.ts region='AsyncPipeObservable'}
	 *
	 * \@stable
	 */
	var AsyncPipe = (function () {
	    /**
	     * @param {?} _ref
	     */
	    function AsyncPipe(_ref) {
	        this._ref = _ref;
	        this._latestValue = null;
	        this._latestReturnedValue = null;
	        this._subscription = null;
	        this._obj = null;
	        this._strategy = ((null));
	    }
	    /**
	     * @return {?}
	     */
	    AsyncPipe.prototype.ngOnDestroy = function () {
	        if (this._subscription) {
	            this._dispose();
	        }
	    };
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    AsyncPipe.prototype.transform = function (obj) {
	        if (!this._obj) {
	            if (obj) {
	                this._subscribe(obj);
	            }
	            this._latestReturnedValue = this._latestValue;
	            return this._latestValue;
	        }
	        if (obj !== this._obj) {
	            this._dispose();
	            return this.transform(/** @type {?} */ (obj));
	        }
	        if (this._latestValue === this._latestReturnedValue) {
	            return this._latestReturnedValue;
	        }
	        this._latestReturnedValue = this._latestValue;
	        return _angular_core.WrappedValue.wrap(this._latestValue);
	    };
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    AsyncPipe.prototype._subscribe = function (obj) {
	        var _this = this;
	        this._obj = obj;
	        this._strategy = this._selectStrategy(obj);
	        this._subscription = this._strategy.createSubscription(obj, function (value) { return _this._updateLatestValue(obj, value); });
	    };
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    AsyncPipe.prototype._selectStrategy = function (obj) {
	        if (_angular_core.ɵisPromise(obj)) {
	            return _promiseStrategy;
	        }
	        if (_angular_core.ɵisObservable(obj)) {
	            return _observableStrategy;
	        }
	        throw invalidPipeArgumentError(AsyncPipe, obj);
	    };
	    /**
	     * @return {?}
	     */
	    AsyncPipe.prototype._dispose = function () {
	        this._strategy.dispose(/** @type {?} */ ((this._subscription)));
	        this._latestValue = null;
	        this._latestReturnedValue = null;
	        this._subscription = null;
	        this._obj = null;
	    };
	    /**
	     * @param {?} async
	     * @param {?} value
	     * @return {?}
	     */
	    AsyncPipe.prototype._updateLatestValue = function (async, value) {
	        if (async === this._obj) {
	            this._latestValue = value;
	            this._ref.markForCheck();
	        }
	    };
	    return AsyncPipe;
	}());
	AsyncPipe.decorators = [
	    { type: _angular_core.Pipe, args: [{ name: 'async', pure: false },] },
	];
	/**
	 * @nocollapse
	 */
	AsyncPipe.ctorParameters = function () { return [
	    { type: _angular_core.ChangeDetectorRef, },
	]; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Transforms text to lowercase.
	 *
	 * {\@example  common/pipes/ts/lowerupper_pipe.ts region='LowerUpperPipe' }
	 *
	 * \@stable
	 */
	var LowerCasePipe = (function () {
	    function LowerCasePipe() {
	    }
	    /**
	     * @param {?} value
	     * @return {?}
	     */
	    LowerCasePipe.prototype.transform = function (value) {
	        if (!value)
	            return value;
	        if (typeof value !== 'string') {
	            throw invalidPipeArgumentError(LowerCasePipe, value);
	        }
	        return value.toLowerCase();
	    };
	    return LowerCasePipe;
	}());
	LowerCasePipe.decorators = [
	    { type: _angular_core.Pipe, args: [{ name: 'lowercase' },] },
	];
	/**
	 * @nocollapse
	 */
	LowerCasePipe.ctorParameters = function () { return []; };
	/**
	 * Helper method to transform a single word to titlecase.
	 *
	 * \@stable
	 * @param {?} word
	 * @return {?}
	 */
	function titleCaseWord(word) {
	    if (!word)
	        return word;
	    return word[0].toUpperCase() + word.substr(1).toLowerCase();
	}
	/**
	 * Transforms text to titlecase.
	 *
	 * \@stable
	 */
	var TitleCasePipe = (function () {
	    function TitleCasePipe() {
	    }
	    /**
	     * @param {?} value
	     * @return {?}
	     */
	    TitleCasePipe.prototype.transform = function (value) {
	        if (!value)
	            return value;
	        if (typeof value !== 'string') {
	            throw invalidPipeArgumentError(TitleCasePipe, value);
	        }
	        return value.split(/\b/g).map(function (word) { return titleCaseWord(word); }).join('');
	    };
	    return TitleCasePipe;
	}());
	TitleCasePipe.decorators = [
	    { type: _angular_core.Pipe, args: [{ name: 'titlecase' },] },
	];
	/**
	 * @nocollapse
	 */
	TitleCasePipe.ctorParameters = function () { return []; };
	/**
	 * Transforms text to uppercase.
	 *
	 * \@stable
	 */
	var UpperCasePipe = (function () {
	    function UpperCasePipe() {
	    }
	    /**
	     * @param {?} value
	     * @return {?}
	     */
	    UpperCasePipe.prototype.transform = function (value) {
	        if (!value)
	            return value;
	        if (typeof value !== 'string') {
	            throw invalidPipeArgumentError(UpperCasePipe, value);
	        }
	        return value.toUpperCase();
	    };
	    return UpperCasePipe;
	}());
	UpperCasePipe.decorators = [
	    { type: _angular_core.Pipe, args: [{ name: 'uppercase' },] },
	];
	/**
	 * @nocollapse
	 */
	UpperCasePipe.ctorParameters = function () { return []; };
	var NumberFormatStyle = {};
	NumberFormatStyle.Decimal = 0;
	NumberFormatStyle.Percent = 1;
	NumberFormatStyle.Currency = 2;
	NumberFormatStyle[NumberFormatStyle.Decimal] = "Decimal";
	NumberFormatStyle[NumberFormatStyle.Percent] = "Percent";
	NumberFormatStyle[NumberFormatStyle.Currency] = "Currency";
	var NumberFormatter = (function () {
	    function NumberFormatter() {
	    }
	    /**
	     * @param {?} num
	     * @param {?} locale
	     * @param {?} style
	     * @param {?=} opts
	     * @return {?}
	     */
	    NumberFormatter.format = function (num, locale, style, opts) {
	        if (opts === void 0) { opts = {}; }
	        var minimumIntegerDigits = opts.minimumIntegerDigits, minimumFractionDigits = opts.minimumFractionDigits, maximumFractionDigits = opts.maximumFractionDigits, currency = opts.currency, _a = opts.currencyAsSymbol, currencyAsSymbol = _a === void 0 ? false : _a;
	        var /** @type {?} */ options = {
	            minimumIntegerDigits: minimumIntegerDigits,
	            minimumFractionDigits: minimumFractionDigits,
	            maximumFractionDigits: maximumFractionDigits,
	            style: NumberFormatStyle[style].toLowerCase()
	        };
	        if (style == NumberFormatStyle.Currency) {
	            options.currency = typeof currency == 'string' ? currency : undefined;
	            options.currencyDisplay = currencyAsSymbol ? 'symbol' : 'code';
	        }
	        return new Intl.NumberFormat(locale, options).format(num);
	    };
	    return NumberFormatter;
	}());
	var DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsazZEwGjJ']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|J+|j+|m+|s+|a|z|Z|G+|w+))(.*)/;
	var PATTERN_ALIASES = {
	    // Keys are quoted so they do not get renamed during closure compilation.
	    'yMMMdjms': datePartGetterFactory(combine([
	        digitCondition('year', 1),
	        nameCondition('month', 3),
	        digitCondition('day', 1),
	        digitCondition('hour', 1),
	        digitCondition('minute', 1),
	        digitCondition('second', 1),
	    ])),
	    'yMdjm': datePartGetterFactory(combine([
	        digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1),
	        digitCondition('hour', 1), digitCondition('minute', 1)
	    ])),
	    'yMMMMEEEEd': datePartGetterFactory(combine([
	        digitCondition('year', 1), nameCondition('month', 4), nameCondition('weekday', 4),
	        digitCondition('day', 1)
	    ])),
	    'yMMMMd': datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 4), digitCondition('day', 1)])),
	    'yMMMd': datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 3), digitCondition('day', 1)])),
	    'yMd': datePartGetterFactory(combine([digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1)])),
	    'jms': datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('second', 1), digitCondition('minute', 1)])),
	    'jm': datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('minute', 1)]))
	};
	var DATE_FORMATS = {
	    // Keys are quoted so they do not get renamed.
	    'yyyy': datePartGetterFactory(digitCondition('year', 4)),
	    'yy': datePartGetterFactory(digitCondition('year', 2)),
	    'y': datePartGetterFactory(digitCondition('year', 1)),
	    'MMMM': datePartGetterFactory(nameCondition('month', 4)),
	    'MMM': datePartGetterFactory(nameCondition('month', 3)),
	    'MM': datePartGetterFactory(digitCondition('month', 2)),
	    'M': datePartGetterFactory(digitCondition('month', 1)),
	    'LLLL': datePartGetterFactory(nameCondition('month', 4)),
	    'L': datePartGetterFactory(nameCondition('month', 1)),
	    'dd': datePartGetterFactory(digitCondition('day', 2)),
	    'd': datePartGetterFactory(digitCondition('day', 1)),
	    'HH': digitModifier(hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), false)))),
	    'H': hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), false))),
	    'hh': digitModifier(hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), true)))),
	    'h': hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),
	    'jj': datePartGetterFactory(digitCondition('hour', 2)),
	    'j': datePartGetterFactory(digitCondition('hour', 1)),
	    'mm': digitModifier(datePartGetterFactory(digitCondition('minute', 2))),
	    'm': datePartGetterFactory(digitCondition('minute', 1)),
	    'ss': digitModifier(datePartGetterFactory(digitCondition('second', 2))),
	    's': datePartGetterFactory(digitCondition('second', 1)),
	    // while ISO 8601 requires fractions to be prefixed with `.` or `,`
	    // we can be just safely rely on using `sss` since we currently don't support single or two digit
	    // fractions
	    'sss': datePartGetterFactory(digitCondition('second', 3)),
	    'EEEE': datePartGetterFactory(nameCondition('weekday', 4)),
	    'EEE': datePartGetterFactory(nameCondition('weekday', 3)),
	    'EE': datePartGetterFactory(nameCondition('weekday', 2)),
	    'E': datePartGetterFactory(nameCondition('weekday', 1)),
	    'a': hourClockExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),
	    'Z': timeZoneGetter('short'),
	    'z': timeZoneGetter('long'),
	    'ww': datePartGetterFactory({}),
	    // first Thursday of the year. not support ?
	    'w': datePartGetterFactory({}),
	    // of the year not support ?
	    'G': datePartGetterFactory(nameCondition('era', 1)),
	    'GG': datePartGetterFactory(nameCondition('era', 2)),
	    'GGG': datePartGetterFactory(nameCondition('era', 3)),
	    'GGGG': datePartGetterFactory(nameCondition('era', 4))
	};
	/**
	 * @param {?} inner
	 * @return {?}
	 */
	function digitModifier(inner) {
	    return function (date, locale) {
	        var /** @type {?} */ result = inner(date, locale);
	        return result.length == 1 ? '0' + result : result;
	    };
	}
	/**
	 * @param {?} inner
	 * @return {?}
	 */
	function hourClockExtractor(inner) {
	    return function (date, locale) { return inner(date, locale).split(' ')[1]; };
	}
	/**
	 * @param {?} inner
	 * @return {?}
	 */
	function hourExtractor(inner) {
	    return function (date, locale) { return inner(date, locale).split(' ')[0]; };
	}
	/**
	 * @param {?} date
	 * @param {?} locale
	 * @param {?} options
	 * @return {?}
	 */
	function intlDateFormat(date, locale, options) {
	    return new Intl.DateTimeFormat(locale, options).format(date).replace(/[\u200e\u200f]/g, '');
	}
	/**
	 * @param {?} timezone
	 * @return {?}
	 */
	function timeZoneGetter(timezone) {
	    // To workaround `Intl` API restriction for single timezone let format with 24 hours
	    var /** @type {?} */ options = { hour: '2-digit', hour12: false, timeZoneName: timezone };
	    return function (date, locale) {
	        var /** @type {?} */ result = intlDateFormat(date, locale, options);
	        // Then extract first 3 letters that related to hours
	        return result ? result.substring(3) : '';
	    };
	}
	/**
	 * @param {?} options
	 * @param {?} value
	 * @return {?}
	 */
	function hour12Modify(options, value) {
	    options.hour12 = value;
	    return options;
	}
	/**
	 * @param {?} prop
	 * @param {?} len
	 * @return {?}
	 */
	function digitCondition(prop, len) {
	    var /** @type {?} */ result = {};
	    result[prop] = len === 2 ? '2-digit' : 'numeric';
	    return result;
	}
	/**
	 * @param {?} prop
	 * @param {?} len
	 * @return {?}
	 */
	function nameCondition(prop, len) {
	    var /** @type {?} */ result = {};
	    if (len < 4) {
	        result[prop] = len > 1 ? 'short' : 'narrow';
	    }
	    else {
	        result[prop] = 'long';
	    }
	    return result;
	}
	/**
	 * @param {?} options
	 * @return {?}
	 */
	function combine(options) {
	    return options.reduce(function (merged, opt) { return (Object.assign({}, merged, opt)); }, {});
	}
	/**
	 * @param {?} ret
	 * @return {?}
	 */
	function datePartGetterFactory(ret) {
	    return function (date, locale) { return intlDateFormat(date, locale, ret); };
	}
	var DATE_FORMATTER_CACHE = new Map();
	/**
	 * @param {?} format
	 * @param {?} date
	 * @param {?} locale
	 * @return {?}
	 */
	function dateFormatter(format, date, locale) {
	    var /** @type {?} */ fn = PATTERN_ALIASES[format];
	    if (fn)
	        return fn(date, locale);
	    var /** @type {?} */ cacheKey = format;
	    var /** @type {?} */ parts = DATE_FORMATTER_CACHE.get(cacheKey);
	    if (!parts) {
	        parts = [];
	        var /** @type {?} */ match = void 0;
	        DATE_FORMATS_SPLIT.exec(format);
	        var /** @type {?} */ _format = format;
	        while (_format) {
	            match = DATE_FORMATS_SPLIT.exec(_format);
	            if (match) {
	                parts = parts.concat(match.slice(1));
	                _format = ((parts.pop()));
	            }
	            else {
	                parts.push(_format);
	                _format = null;
	            }
	        }
	        DATE_FORMATTER_CACHE.set(cacheKey, parts);
	    }
	    return parts.reduce(function (text, part) {
	        var /** @type {?} */ fn = DATE_FORMATS[part];
	        return text + (fn ? fn(date, locale) : partToTime(part));
	    }, '');
	}
	/**
	 * @param {?} part
	 * @return {?}
	 */
	function partToTime(part) {
	    return part === '\'\'' ? '\'' : part.replace(/(^'|'$)/g, '').replace(/''/g, '\'');
	}
	var DateFormatter = (function () {
	    function DateFormatter() {
	    }
	    /**
	     * @param {?} date
	     * @param {?} locale
	     * @param {?} pattern
	     * @return {?}
	     */
	    DateFormatter.format = function (date, locale, pattern) {
	        return dateFormatter(pattern, date, locale);
	    };
	    return DateFormatter;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var _NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(-(\d+))?)?$/;
	/**
	 * @param {?} pipe
	 * @param {?} locale
	 * @param {?} value
	 * @param {?} style
	 * @param {?=} digits
	 * @param {?=} currency
	 * @param {?=} currencyAsSymbol
	 * @return {?}
	 */
	function formatNumber(pipe, locale, value, style, digits, currency, currencyAsSymbol) {
	    if (currency === void 0) { currency = null; }
	    if (currencyAsSymbol === void 0) { currencyAsSymbol = false; }
	    if (value == null)
	        return null;
	    // Convert strings to numbers
	    value = typeof value === 'string' && isNumeric(value) ? +value : value;
	    if (typeof value !== 'number') {
	        throw invalidPipeArgumentError(pipe, value);
	    }
	    var /** @type {?} */ minInt = undefined;
	    var /** @type {?} */ minFraction = undefined;
	    var /** @type {?} */ maxFraction = undefined;
	    if (style !== NumberFormatStyle.Currency) {
	        // rely on Intl default for currency
	        minInt = 1;
	        minFraction = 0;
	        maxFraction = 3;
	    }
	    if (digits) {
	        var /** @type {?} */ parts = digits.match(_NUMBER_FORMAT_REGEXP);
	        if (parts === null) {
	            throw new Error(digits + " is not a valid digit info for number pipes");
	        }
	        if (parts[1] != null) {
	            minInt = parseIntAutoRadix(parts[1]);
	        }
	        if (parts[3] != null) {
	            minFraction = parseIntAutoRadix(parts[3]);
	        }
	        if (parts[5] != null) {
	            maxFraction = parseIntAutoRadix(parts[5]);
	        }
	    }
	    return NumberFormatter.format(/** @type {?} */ (value), locale, style, {
	        minimumIntegerDigits: minInt,
	        minimumFractionDigits: minFraction,
	        maximumFractionDigits: maxFraction,
	        currency: currency,
	        currencyAsSymbol: currencyAsSymbol,
	    });
	}
	/**
	 * \@ngModule CommonModule
	 * \@whatItDoes Formats a number according to locale rules.
	 * \@howToUse `number_expression | number[:digitInfo]`
	 *
	 * Formats a number as text. Group sizing and separator and other locale-specific
	 * configurations are based on the active locale.
	 *
	 * where `expression` is a number:
	 *  - `digitInfo` is a `string` which has a following format: <br>
	 *     <code>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</code>
	 *   - `minIntegerDigits` is the minimum number of integer digits to use. Defaults to `1`.
	 *   - `minFractionDigits` is the minimum number of digits after fraction. Defaults to `0`.
	 *   - `maxFractionDigits` is the maximum number of digits after fraction. Defaults to `3`.
	 *
	 * For more information on the acceptable range for each of these numbers and other
	 * details see your native internationalization library.
	 *
	 * WARNING: this pipe uses the Internationalization API which is not yet available in all browsers
	 * and may require a polyfill. See [Browser Support](guide/browser-support) for details.
	 *
	 * ### Example
	 *
	 * {\@example common/pipes/ts/number_pipe.ts region='NumberPipe'}
	 *
	 * \@stable
	 */
	var DecimalPipe = (function () {
	    /**
	     * @param {?} _locale
	     */
	    function DecimalPipe(_locale) {
	        this._locale = _locale;
	    }
	    /**
	     * @param {?} value
	     * @param {?=} digits
	     * @return {?}
	     */
	    DecimalPipe.prototype.transform = function (value, digits) {
	        return formatNumber(DecimalPipe, this._locale, value, NumberFormatStyle.Decimal, digits);
	    };
	    return DecimalPipe;
	}());
	DecimalPipe.decorators = [
	    { type: _angular_core.Pipe, args: [{ name: 'number' },] },
	];
	/**
	 * @nocollapse
	 */
	DecimalPipe.ctorParameters = function () { return [
	    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
	]; };
	/**
	 * \@ngModule CommonModule
	 * \@whatItDoes Formats a number as a percentage according to locale rules.
	 * \@howToUse `number_expression | percent[:digitInfo]`
	 *
	 * \@description
	 *
	 * Formats a number as percentage.
	 *
	 * - `digitInfo` See {\@link DecimalPipe} for detailed description.
	 *
	 * WARNING: this pipe uses the Internationalization API which is not yet available in all browsers
	 * and may require a polyfill. See [Browser Support](guide/browser-support) for details.
	 *
	 * ### Example
	 *
	 * {\@example common/pipes/ts/number_pipe.ts region='PercentPipe'}
	 *
	 * \@stable
	 */
	var PercentPipe = (function () {
	    /**
	     * @param {?} _locale
	     */
	    function PercentPipe(_locale) {
	        this._locale = _locale;
	    }
	    /**
	     * @param {?} value
	     * @param {?=} digits
	     * @return {?}
	     */
	    PercentPipe.prototype.transform = function (value, digits) {
	        return formatNumber(PercentPipe, this._locale, value, NumberFormatStyle.Percent, digits);
	    };
	    return PercentPipe;
	}());
	PercentPipe.decorators = [
	    { type: _angular_core.Pipe, args: [{ name: 'percent' },] },
	];
	/**
	 * @nocollapse
	 */
	PercentPipe.ctorParameters = function () { return [
	    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
	]; };
	/**
	 * \@ngModule CommonModule
	 * \@whatItDoes Formats a number as currency using locale rules.
	 * \@howToUse `number_expression | currency[:currencyCode[:symbolDisplay[:digitInfo]]]`
	 * \@description
	 *
	 * Use `currency` to format a number as currency.
	 *
	 * - `currencyCode` is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, such
	 *    as `USD` for the US dollar and `EUR` for the euro.
	 * - `symbolDisplay` is a boolean indicating whether to use the currency symbol or code.
	 *   - `true`: use symbol (e.g. `$`).
	 *   - `false`(default): use code (e.g. `USD`).
	 * - `digitInfo` See {\@link DecimalPipe} for detailed description.
	 *
	 * WARNING: this pipe uses the Internationalization API which is not yet available in all browsers
	 * and may require a polyfill. See [Browser Support](guide/browser-support) for details.
	 *
	 * ### Example
	 *
	 * {\@example common/pipes/ts/number_pipe.ts region='CurrencyPipe'}
	 *
	 * \@stable
	 */
	var CurrencyPipe = (function () {
	    /**
	     * @param {?} _locale
	     */
	    function CurrencyPipe(_locale) {
	        this._locale = _locale;
	    }
	    /**
	     * @param {?} value
	     * @param {?=} currencyCode
	     * @param {?=} symbolDisplay
	     * @param {?=} digits
	     * @return {?}
	     */
	    CurrencyPipe.prototype.transform = function (value, currencyCode, symbolDisplay, digits) {
	        if (currencyCode === void 0) { currencyCode = 'USD'; }
	        if (symbolDisplay === void 0) { symbolDisplay = false; }
	        return formatNumber(CurrencyPipe, this._locale, value, NumberFormatStyle.Currency, digits, currencyCode, symbolDisplay);
	    };
	    return CurrencyPipe;
	}());
	CurrencyPipe.decorators = [
	    { type: _angular_core.Pipe, args: [{ name: 'currency' },] },
	];
	/**
	 * @nocollapse
	 */
	CurrencyPipe.ctorParameters = function () { return [
	    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
	]; };
	/**
	 * @param {?} text
	 * @return {?}
	 */
	function parseIntAutoRadix(text) {
	    var /** @type {?} */ result = parseInt(text);
	    if (isNaN(result)) {
	        throw new Error('Invalid integer literal when parsing ' + text);
	    }
	    return result;
	}
	/**
	 * @param {?} value
	 * @return {?}
	 */
	function isNumeric(value) {
	    return !isNaN(value - parseFloat(value));
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var ISO8601_DATE_REGEX = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
	/**
	 * \@ngModule CommonModule
	 * \@whatItDoes Formats a date according to locale rules.
	 * \@howToUse `date_expression | date[:format]`
	 * \@description
	 *
	 * Where:
	 * - `expression` is a date object or a number (milliseconds since UTC epoch) or an ISO string
	 * (https://www.w3.org/TR/NOTE-datetime).
	 * - `format` indicates which date/time components to include. The format can be predefined as
	 *   shown below or custom as shown in the table.
	 *   - `'medium'`: equivalent to `'yMMMdjms'` (e.g. `Sep 3, 2010, 12:05:08 PM` for `en-US`)
	 *   - `'short'`: equivalent to `'yMdjm'` (e.g. `9/3/2010, 12:05 PM` for `en-US`)
	 *   - `'fullDate'`: equivalent to `'yMMMMEEEEd'` (e.g. `Friday, September 3, 2010` for `en-US`)
	 *   - `'longDate'`: equivalent to `'yMMMMd'` (e.g. `September 3, 2010` for `en-US`)
	 *   - `'mediumDate'`: equivalent to `'yMMMd'` (e.g. `Sep 3, 2010` for `en-US`)
	 *   - `'shortDate'`: equivalent to `'yMd'` (e.g. `9/3/2010` for `en-US`)
	 *   - `'mediumTime'`: equivalent to `'jms'` (e.g. `12:05:08 PM` for `en-US`)
	 *   - `'shortTime'`: equivalent to `'jm'` (e.g. `12:05 PM` for `en-US`)
	 *
	 *
	 *  | Component | Symbol | Narrow | Short Form   | Long Form         | Numeric   | 2-digit   |
	 *  |-----------|:------:|--------|--------------|-------------------|-----------|-----------|
	 *  | era       |   G    | G (A)  | GGG (AD)     | GGGG (Anno Domini)| -         | -         |
	 *  | year      |   y    | -      | -            | -                 | y (2015)  | yy (15)   |
	 *  | month     |   M    | L (S)  | MMM (Sep)    | MMMM (September)  | M (9)     | MM (09)   |
	 *  | day       |   d    | -      | -            | -                 | d (3)     | dd (03)   |
	 *  | weekday   |   E    | E (S)  | EEE (Sun)    | EEEE (Sunday)     | -         | -         |
	 *  | hour      |   j    | -      | -            | -                 | j (13)    | jj (13)   |
	 *  | hour12    |   h    | -      | -            | -                 | h (1 PM)  | hh (01 PM)|
	 *  | hour24    |   H    | -      | -            | -                 | H (13)    | HH (13)   |
	 *  | minute    |   m    | -      | -            | -                 | m (5)     | mm (05)   |
	 *  | second    |   s    | -      | -            | -                 | s (9)     | ss (09)   |
	 *  | timezone  |   z    | -      | -            | z (Pacific Standard Time)| -  | -         |
	 *  | timezone  |   Z    | -      | Z (GMT-8:00) | -                 | -         | -         |
	 *  | timezone  |   a    | -      | a (PM)       | -                 | -         | -         |
	 *
	 * In javascript, only the components specified will be respected (not the ordering,
	 * punctuations, ...) and details of the formatting will be dependent on the locale.
	 *
	 * Timezone of the formatted text will be the local system timezone of the end-user's machine.
	 *
	 * When the expression is a ISO string without time (e.g. 2016-09-19) the time zone offset is not
	 * applied and the formatted text will have the same day, month and year of the expression.
	 *
	 * WARNINGS:
	 * - this pipe is marked as pure hence it will not be re-evaluated when the input is mutated.
	 *   Instead users should treat the date as an immutable object and change the reference when the
	 *   pipe needs to re-run (this is to avoid reformatting the date on every change detection run
	 *   which would be an expensive operation).
	 * - this pipe uses the Internationalization API. Therefore it is only reliable in Chrome and Opera
	 *   browsers.
	 *
	 * ### Examples
	 *
	 * Assuming `dateObj` is (year: 2015, month: 6, day: 15, hour: 21, minute: 43, second: 11)
	 * in the _local_ time and locale is 'en-US':
	 *
	 * ```
	 *     {{ dateObj | date }}               // output is 'Jun 15, 2015'
	 *     {{ dateObj | date:'medium' }}      // output is 'Jun 15, 2015, 9:43:11 PM'
	 *     {{ dateObj | date:'shortTime' }}   // output is '9:43 PM'
	 *     {{ dateObj | date:'mmss' }}        // output is '43:11'
	 * ```
	 *
	 * {\@example common/pipes/ts/date_pipe.ts region='DatePipe'}
	 *
	 * \@stable
	 */
	var DatePipe = (function () {
	    /**
	     * @param {?} _locale
	     */
	    function DatePipe(_locale) {
	        this._locale = _locale;
	    }
	    /**
	     * @param {?} value
	     * @param {?=} pattern
	     * @return {?}
	     */
	    DatePipe.prototype.transform = function (value, pattern) {
	        if (pattern === void 0) { pattern = 'mediumDate'; }
	        var /** @type {?} */ date;
	        if (isBlank(value) || value !== value)
	            return null;
	        if (typeof value === 'string') {
	            value = value.trim();
	        }
	        if (isDate(value)) {
	            date = value;
	        }
	        else if (isNumeric(value)) {
	            date = new Date(parseFloat(value));
	        }
	        else if (typeof value === 'string' && /^(\d{4}-\d{1,2}-\d{1,2})$/.test(value)) {
	            /**
	             * For ISO Strings without time the day, month and year must be extracted from the ISO String
	             * before Date creation to avoid time offset and errors in the new Date.
	             * If we only replace '-' with ',' in the ISO String ("2015,01,01"), and try to create a new
	             * date, some browsers (e.g. IE 9) will throw an invalid Date error
	             * If we leave the '-' ("2015-01-01") and try to create a new Date("2015-01-01") the timeoffset
	             * is applied
	             * Note: ISO months are 0 for January, 1 for February, ...
	             */
	            var _a = value.split('-').map(function (val) { return parseInt(val, 10); }), y = _a[0], m = _a[1], d = _a[2];
	            date = new Date(y, m - 1, d);
	        }
	        else {
	            date = new Date(value);
	        }
	        if (!isDate(date)) {
	            var /** @type {?} */ match = void 0;
	            if ((typeof value === 'string') && (match = value.match(ISO8601_DATE_REGEX))) {
	                date = isoStringToDate(match);
	            }
	            else {
	                throw invalidPipeArgumentError(DatePipe, value);
	            }
	        }
	        return DateFormatter.format(date, this._locale, DatePipe._ALIASES[pattern] || pattern);
	    };
	    return DatePipe;
	}());
	/**
	 * \@internal
	 */
	DatePipe._ALIASES = {
	    'medium': 'yMMMdjms',
	    'short': 'yMdjm',
	    'fullDate': 'yMMMMEEEEd',
	    'longDate': 'yMMMMd',
	    'mediumDate': 'yMMMd',
	    'shortDate': 'yMd',
	    'mediumTime': 'jms',
	    'shortTime': 'jm'
	};
	DatePipe.decorators = [
	    { type: _angular_core.Pipe, args: [{ name: 'date', pure: true },] },
	];
	/**
	 * @nocollapse
	 */
	DatePipe.ctorParameters = function () { return [
	    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
	]; };
	/**
	 * @param {?} obj
	 * @return {?}
	 */
	function isBlank(obj) {
	    return obj == null || obj === '';
	}
	/**
	 * @param {?} obj
	 * @return {?}
	 */
	function isDate(obj) {
	    return obj instanceof Date && !isNaN(obj.valueOf());
	}
	/**
	 * @param {?} match
	 * @return {?}
	 */
	function isoStringToDate(match) {
	    var /** @type {?} */ date = new Date(0);
	    var /** @type {?} */ tzHour = 0;
	    var /** @type {?} */ tzMin = 0;
	    var /** @type {?} */ dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear;
	    var /** @type {?} */ timeSetter = match[8] ? date.setUTCHours : date.setHours;
	    if (match[9]) {
	        tzHour = toInt(match[9] + match[10]);
	        tzMin = toInt(match[9] + match[11]);
	    }
	    dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
	    var /** @type {?} */ h = toInt(match[4] || '0') - tzHour;
	    var /** @type {?} */ m = toInt(match[5] || '0') - tzMin;
	    var /** @type {?} */ s = toInt(match[6] || '0');
	    var /** @type {?} */ ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
	    timeSetter.call(date, h, m, s, ms);
	    return date;
	}
	/**
	 * @param {?} str
	 * @return {?}
	 */
	function toInt(str) {
	    return parseInt(str, 10);
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var _INTERPOLATION_REGEXP = /#/g;
	/**
	 * \@ngModule CommonModule
	 * \@whatItDoes Maps a value to a string that pluralizes the value according to locale rules.
	 * \@howToUse `expression | i18nPlural:mapping`
	 * \@description
	 *
	 *  Where:
	 *  - `expression` is a number.
	 *  - `mapping` is an object that mimics the ICU format, see
	 *    http://userguide.icu-project.org/formatparse/messages
	 *
	 *  ## Example
	 *
	 * {\@example common/pipes/ts/i18n_pipe.ts region='I18nPluralPipeComponent'}
	 *
	 * \@experimental
	 */
	var I18nPluralPipe = (function () {
	    /**
	     * @param {?} _localization
	     */
	    function I18nPluralPipe(_localization) {
	        this._localization = _localization;
	    }
	    /**
	     * @param {?} value
	     * @param {?} pluralMap
	     * @return {?}
	     */
	    I18nPluralPipe.prototype.transform = function (value, pluralMap) {
	        if (value == null)
	            return '';
	        if (typeof pluralMap !== 'object' || pluralMap === null) {
	            throw invalidPipeArgumentError(I18nPluralPipe, pluralMap);
	        }
	        var /** @type {?} */ key = getPluralCategory(value, Object.keys(pluralMap), this._localization);
	        return pluralMap[key].replace(_INTERPOLATION_REGEXP, value.toString());
	    };
	    return I18nPluralPipe;
	}());
	I18nPluralPipe.decorators = [
	    { type: _angular_core.Pipe, args: [{ name: 'i18nPlural', pure: true },] },
	];
	/**
	 * @nocollapse
	 */
	I18nPluralPipe.ctorParameters = function () { return [
	    { type: NgLocalization, },
	]; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@ngModule CommonModule
	 * \@whatItDoes Generic selector that displays the string that matches the current value.
	 * \@howToUse `expression | i18nSelect:mapping`
	 * \@description
	 *
	 *  Where `mapping` is an object that indicates the text that should be displayed
	 *  for different values of the provided `expression`.
	 *  If none of the keys of the mapping match the value of the `expression`, then the content
	 *  of the `other` key is returned when present, otherwise an empty string is returned.
	 *
	 *  ## Example
	 *
	 * {\@example common/pipes/ts/i18n_pipe.ts region='I18nSelectPipeComponent'}
	 *
	 *  \@experimental
	 */
	var I18nSelectPipe = (function () {
	    function I18nSelectPipe() {
	    }
	    /**
	     * @param {?} value
	     * @param {?} mapping
	     * @return {?}
	     */
	    I18nSelectPipe.prototype.transform = function (value, mapping) {
	        if (value == null)
	            return '';
	        if (typeof mapping !== 'object' || typeof value !== 'string') {
	            throw invalidPipeArgumentError(I18nSelectPipe, mapping);
	        }
	        if (mapping.hasOwnProperty(value)) {
	            return mapping[value];
	        }
	        if (mapping.hasOwnProperty('other')) {
	            return mapping['other'];
	        }
	        return '';
	    };
	    return I18nSelectPipe;
	}());
	I18nSelectPipe.decorators = [
	    { type: _angular_core.Pipe, args: [{ name: 'i18nSelect', pure: true },] },
	];
	/**
	 * @nocollapse
	 */
	I18nSelectPipe.ctorParameters = function () { return []; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@ngModule CommonModule
	 * \@whatItDoes Converts value into JSON string.
	 * \@howToUse `expression | json`
	 * \@description
	 *
	 * Converts value into string using `JSON.stringify`. Useful for debugging.
	 *
	 * ### Example
	 * {\@example common/pipes/ts/json_pipe.ts region='JsonPipe'}
	 *
	 * \@stable
	 */
	var JsonPipe = (function () {
	    function JsonPipe() {
	    }
	    /**
	     * @param {?} value
	     * @return {?}
	     */
	    JsonPipe.prototype.transform = function (value) { return JSON.stringify(value, null, 2); };
	    return JsonPipe;
	}());
	JsonPipe.decorators = [
	    { type: _angular_core.Pipe, args: [{ name: 'json', pure: false },] },
	];
	/**
	 * @nocollapse
	 */
	JsonPipe.ctorParameters = function () { return []; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@ngModule CommonModule
	 * \@whatItDoes Creates a new List or String containing a subset (slice) of the elements.
	 * \@howToUse `array_or_string_expression | slice:start[:end]`
	 * \@description
	 *
	 * Where the input expression is a `List` or `String`, and:
	 * - `start`: The starting index of the subset to return.
	 *   - **a positive integer**: return the item at `start` index and all items after
	 *     in the list or string expression.
	 *   - **a negative integer**: return the item at `start` index from the end and all items after
	 *     in the list or string expression.
	 *   - **if positive and greater than the size of the expression**: return an empty list or string.
	 *   - **if negative and greater than the size of the expression**: return entire list or string.
	 * - `end`: The ending index of the subset to return.
	 *   - **omitted**: return all items until the end.
	 *   - **if positive**: return all items before `end` index of the list or string.
	 *   - **if negative**: return all items before `end` index from the end of the list or string.
	 *
	 * All behavior is based on the expected behavior of the JavaScript API `Array.prototype.slice()`
	 * and `String.prototype.slice()`.
	 *
	 * When operating on a [List], the returned list is always a copy even when all
	 * the elements are being returned.
	 *
	 * When operating on a blank value, the pipe returns the blank value.
	 *
	 * ## List Example
	 *
	 * This `ngFor` example:
	 *
	 * {\@example common/pipes/ts/slice_pipe.ts region='SlicePipe_list'}
	 *
	 * produces the following:
	 *
	 *     <li>b</li>
	 *     <li>c</li>
	 *
	 * ## String Examples
	 *
	 * {\@example common/pipes/ts/slice_pipe.ts region='SlicePipe_string'}
	 *
	 * \@stable
	 */
	var SlicePipe = (function () {
	    function SlicePipe() {
	    }
	    /**
	     * @param {?} value
	     * @param {?} start
	     * @param {?=} end
	     * @return {?}
	     */
	    SlicePipe.prototype.transform = function (value, start, end) {
	        if (value == null)
	            return value;
	        if (!this.supports(value)) {
	            throw invalidPipeArgumentError(SlicePipe, value);
	        }
	        return value.slice(start, end);
	    };
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    SlicePipe.prototype.supports = function (obj) { return typeof obj === 'string' || Array.isArray(obj); };
	    return SlicePipe;
	}());
	SlicePipe.decorators = [
	    { type: _angular_core.Pipe, args: [{ name: 'slice', pure: false },] },
	];
	/**
	 * @nocollapse
	 */
	SlicePipe.ctorParameters = function () { return []; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @module
	 * @description
	 * This module provides a set of common Pipes.
	 */
	/**
	 * A collection of Angular pipes that are likely to be used in each and every application.
	 */
	var COMMON_PIPES = [
	    AsyncPipe,
	    UpperCasePipe,
	    LowerCasePipe,
	    JsonPipe,
	    SlicePipe,
	    DecimalPipe,
	    PercentPipe,
	    TitleCasePipe,
	    CurrencyPipe,
	    DatePipe,
	    I18nPluralPipe,
	    I18nSelectPipe,
	];
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * The module that includes all the basic Angular directives like {\@link NgIf}, {\@link NgForOf}, ...
	 *
	 * \@stable
	 */
	var CommonModule = (function () {
	    function CommonModule() {
	    }
	    return CommonModule;
	}());
	CommonModule.decorators = [
	    { type: _angular_core.NgModule, args: [{
	                declarations: [COMMON_DIRECTIVES, COMMON_PIPES],
	                exports: [COMMON_DIRECTIVES, COMMON_PIPES],
	                providers: [
	                    { provide: NgLocalization, useClass: NgLocaleLocalization },
	                ],
	            },] },
	];
	/**
	 * @nocollapse
	 */
	CommonModule.ctorParameters = function () { return []; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * A DI Token representing the main rendering context. In a browser this is the DOM Document.
	 *
	 * Note: Document might not be available in the Application Context when Application and Rendering
	 * Contexts are not the same (e.g. when running the application into a Web Worker).
	 *
	 * \@stable
	 */
	var DOCUMENT = new _angular_core.InjectionToken('DocumentToken');
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var PLATFORM_BROWSER_ID = 'browser';
	var PLATFORM_SERVER_ID = 'server';
	var PLATFORM_WORKER_APP_ID = 'browserWorkerApp';
	var PLATFORM_WORKER_UI_ID = 'browserWorkerUi';
	/**
	 * Returns whether a platform id represents a browser platform.
	 * \@experimental
	 * @param {?} platformId
	 * @return {?}
	 */
	function isPlatformBrowser(platformId) {
	    return platformId === PLATFORM_BROWSER_ID;
	}
	/**
	 * Returns whether a platform id represents a server platform.
	 * \@experimental
	 * @param {?} platformId
	 * @return {?}
	 */
	function isPlatformServer(platformId) {
	    return platformId === PLATFORM_SERVER_ID;
	}
	/**
	 * Returns whether a platform id represents a web worker app platform.
	 * \@experimental
	 * @param {?} platformId
	 * @return {?}
	 */
	function isPlatformWorkerApp(platformId) {
	    return platformId === PLATFORM_WORKER_APP_ID;
	}
	/**
	 * Returns whether a platform id represents a web worker UI platform.
	 * \@experimental
	 * @param {?} platformId
	 * @return {?}
	 */
	function isPlatformWorkerUi(platformId) {
	    return platformId === PLATFORM_WORKER_UI_ID;
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @module
	 * @description
	 * Entry point for all public APIs of the common package.
	 */
	/**
	 * \@stable
	 */
	var VERSION = new _angular_core.Version('4.3.3');
	
	exports.NgLocaleLocalization = NgLocaleLocalization;
	exports.NgLocalization = NgLocalization;
	exports.ɵparseCookieValue = parseCookieValue;
	exports.CommonModule = CommonModule;
	exports.NgClass = NgClass;
	exports.NgFor = NgFor;
	exports.NgForOf = NgForOf;
	exports.NgForOfContext = NgForOfContext;
	exports.NgIf = NgIf;
	exports.NgIfContext = NgIfContext;
	exports.NgPlural = NgPlural;
	exports.NgPluralCase = NgPluralCase;
	exports.NgStyle = NgStyle;
	exports.NgSwitch = NgSwitch;
	exports.NgSwitchCase = NgSwitchCase;
	exports.NgSwitchDefault = NgSwitchDefault;
	exports.NgTemplateOutlet = NgTemplateOutlet;
	exports.NgComponentOutlet = NgComponentOutlet;
	exports.DOCUMENT = DOCUMENT;
	exports.AsyncPipe = AsyncPipe;
	exports.DatePipe = DatePipe;
	exports.I18nPluralPipe = I18nPluralPipe;
	exports.I18nSelectPipe = I18nSelectPipe;
	exports.JsonPipe = JsonPipe;
	exports.LowerCasePipe = LowerCasePipe;
	exports.CurrencyPipe = CurrencyPipe;
	exports.DecimalPipe = DecimalPipe;
	exports.PercentPipe = PercentPipe;
	exports.SlicePipe = SlicePipe;
	exports.UpperCasePipe = UpperCasePipe;
	exports.TitleCasePipe = TitleCasePipe;
	exports.ɵPLATFORM_BROWSER_ID = PLATFORM_BROWSER_ID;
	exports.ɵPLATFORM_SERVER_ID = PLATFORM_SERVER_ID;
	exports.ɵPLATFORM_WORKER_APP_ID = PLATFORM_WORKER_APP_ID;
	exports.ɵPLATFORM_WORKER_UI_ID = PLATFORM_WORKER_UI_ID;
	exports.isPlatformBrowser = isPlatformBrowser;
	exports.isPlatformServer = isPlatformServer;
	exports.isPlatformWorkerApp = isPlatformWorkerApp;
	exports.isPlatformWorkerUi = isPlatformWorkerUi;
	exports.VERSION = VERSION;
	exports.PlatformLocation = PlatformLocation;
	exports.LOCATION_INITIALIZED = LOCATION_INITIALIZED;
	exports.LocationStrategy = LocationStrategy;
	exports.APP_BASE_HREF = APP_BASE_HREF;
	exports.HashLocationStrategy = HashLocationStrategy;
	exports.PathLocationStrategy = PathLocationStrategy;
	exports.Location = Location;
	exports.ɵa = COMMON_DIRECTIVES;
	exports.ɵb = COMMON_PIPES;
	
	Object.defineProperty(exports, '__esModule', { value: true });
	
	})));
	//# sourceMappingURL=common.umd.js.map


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @license Angular v4.3.3
	 * (c) 2010-2017 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	(function (global, factory) {
		 true ? factory(exports, __webpack_require__(20), __webpack_require__(12)) :
		typeof define === 'function' && define.amd ? define(['exports', '@angular/common', '@angular/core'], factory) :
		(factory((global.ng = global.ng || {}, global.ng.platformBrowser = global.ng.platformBrowser || {}),global.ng.common,global.ng.core));
	}(this, (function (exports,_angular_common,_angular_core) { 'use strict';
	
	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0
	
	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.
	
	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
	/* global Reflect, Promise */
	
	var extendStatics = Object.setPrototypeOf ||
	    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	
	function __extends(d, b) {
	    extendStatics(d, b);
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}
	
	/**
	 * @license Angular v4.3.3
	 * (c) 2010-2017 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var _DOM = ((null));
	/**
	 * @return {?}
	 */
	function getDOM() {
	    return _DOM;
	}
	/**
	 * @param {?} adapter
	 * @return {?}
	 */
	/**
	 * @param {?} adapter
	 * @return {?}
	 */
	function setRootDomAdapter(adapter) {
	    if (!_DOM) {
	        _DOM = adapter;
	    }
	}
	/**
	 * Provides DOM operations in an environment-agnostic way.
	 *
	 * \@security Tread carefully! Interacting with the DOM directly is dangerous and
	 * can introduce XSS risks.
	 * @abstract
	 */
	var DomAdapter = (function () {
	    function DomAdapter() {
	        this.resourceLoaderType = ((null));
	    }
	    /**
	     * @abstract
	     * @param {?} element
	     * @param {?} name
	     * @return {?}
	     */
	    DomAdapter.prototype.hasProperty = function (element, name) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @param {?} name
	     * @param {?} value
	     * @return {?}
	     */
	    DomAdapter.prototype.setProperty = function (el, name, value) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @param {?} name
	     * @return {?}
	     */
	    DomAdapter.prototype.getProperty = function (el, name) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @param {?} methodName
	     * @param {?} args
	     * @return {?}
	     */
	    DomAdapter.prototype.invoke = function (el, methodName, args) { };
	    /**
	     * @abstract
	     * @param {?} error
	     * @return {?}
	     */
	    DomAdapter.prototype.logError = function (error) { };
	    /**
	     * @abstract
	     * @param {?} error
	     * @return {?}
	     */
	    DomAdapter.prototype.log = function (error) { };
	    /**
	     * @abstract
	     * @param {?} error
	     * @return {?}
	     */
	    DomAdapter.prototype.logGroup = function (error) { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DomAdapter.prototype.logGroupEnd = function () { };
	    Object.defineProperty(DomAdapter.prototype, "attrToPropMap", {
	        /**
	         * Maps attribute names to their corresponding property names for cases
	         * where attribute name doesn't match property name.
	         * @return {?}
	         */
	        get: function () { return this._attrToPropMap; },
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        set: function (value) { this._attrToPropMap = value; },
	        enumerable: true,
	        configurable: true
	    });
	    
	    
	    /**
	     * @abstract
	     * @param {?} nodeA
	     * @param {?} nodeB
	     * @return {?}
	     */
	    DomAdapter.prototype.contains = function (nodeA, nodeB) { };
	    /**
	     * @abstract
	     * @param {?} templateHtml
	     * @return {?}
	     */
	    DomAdapter.prototype.parse = function (templateHtml) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @param {?} selector
	     * @return {?}
	     */
	    DomAdapter.prototype.querySelector = function (el, selector) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @param {?} selector
	     * @return {?}
	     */
	    DomAdapter.prototype.querySelectorAll = function (el, selector) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @param {?} evt
	     * @param {?} listener
	     * @return {?}
	     */
	    DomAdapter.prototype.on = function (el, evt, listener) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @param {?} evt
	     * @param {?} listener
	     * @return {?}
	     */
	    DomAdapter.prototype.onAndCancel = function (el, evt, listener) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @param {?} evt
	     * @return {?}
	     */
	    DomAdapter.prototype.dispatchEvent = function (el, evt) { };
	    /**
	     * @abstract
	     * @param {?} eventType
	     * @return {?}
	     */
	    DomAdapter.prototype.createMouseEvent = function (eventType) { };
	    /**
	     * @abstract
	     * @param {?} eventType
	     * @return {?}
	     */
	    DomAdapter.prototype.createEvent = function (eventType) { };
	    /**
	     * @abstract
	     * @param {?} evt
	     * @return {?}
	     */
	    DomAdapter.prototype.preventDefault = function (evt) { };
	    /**
	     * @abstract
	     * @param {?} evt
	     * @return {?}
	     */
	    DomAdapter.prototype.isPrevented = function (evt) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @return {?}
	     */
	    DomAdapter.prototype.getInnerHTML = function (el) { };
	    /**
	     * Returns content if el is a <template> element, null otherwise.
	     * @abstract
	     * @param {?} el
	     * @return {?}
	     */
	    DomAdapter.prototype.getTemplateContent = function (el) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @return {?}
	     */
	    DomAdapter.prototype.getOuterHTML = function (el) { };
	    /**
	     * @abstract
	     * @param {?} node
	     * @return {?}
	     */
	    DomAdapter.prototype.nodeName = function (node) { };
	    /**
	     * @abstract
	     * @param {?} node
	     * @return {?}
	     */
	    DomAdapter.prototype.nodeValue = function (node) { };
	    /**
	     * @abstract
	     * @param {?} node
	     * @return {?}
	     */
	    DomAdapter.prototype.type = function (node) { };
	    /**
	     * @abstract
	     * @param {?} node
	     * @return {?}
	     */
	    DomAdapter.prototype.content = function (node) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @return {?}
	     */
	    DomAdapter.prototype.firstChild = function (el) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @return {?}
	     */
	    DomAdapter.prototype.nextSibling = function (el) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @return {?}
	     */
	    DomAdapter.prototype.parentElement = function (el) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @return {?}
	     */
	    DomAdapter.prototype.childNodes = function (el) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @return {?}
	     */
	    DomAdapter.prototype.childNodesAsList = function (el) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @return {?}
	     */
	    DomAdapter.prototype.clearNodes = function (el) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @param {?} node
	     * @return {?}
	     */
	    DomAdapter.prototype.appendChild = function (el, node) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @param {?} node
	     * @return {?}
	     */
	    DomAdapter.prototype.removeChild = function (el, node) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @param {?} newNode
	     * @param {?} oldNode
	     * @return {?}
	     */
	    DomAdapter.prototype.replaceChild = function (el, newNode, oldNode) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @return {?}
	     */
	    DomAdapter.prototype.remove = function (el) { };
	    /**
	     * @abstract
	     * @param {?} parent
	     * @param {?} ref
	     * @param {?} node
	     * @return {?}
	     */
	    DomAdapter.prototype.insertBefore = function (parent, ref, node) { };
	    /**
	     * @abstract
	     * @param {?} parent
	     * @param {?} ref
	     * @param {?} nodes
	     * @return {?}
	     */
	    DomAdapter.prototype.insertAllBefore = function (parent, ref, nodes) { };
	    /**
	     * @abstract
	     * @param {?} parent
	     * @param {?} el
	     * @param {?} node
	     * @return {?}
	     */
	    DomAdapter.prototype.insertAfter = function (parent, el, node) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @param {?} value
	     * @return {?}
	     */
	    DomAdapter.prototype.setInnerHTML = function (el, value) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @return {?}
	     */
	    DomAdapter.prototype.getText = function (el) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @param {?} value
	     * @return {?}
	     */
	    DomAdapter.prototype.setText = function (el, value) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @return {?}
	     */
	    DomAdapter.prototype.getValue = function (el) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @param {?} value
	     * @return {?}
	     */
	    DomAdapter.prototype.setValue = function (el, value) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @return {?}
	     */
	    DomAdapter.prototype.getChecked = function (el) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @param {?} value
	     * @return {?}
	     */
	    DomAdapter.prototype.setChecked = function (el, value) { };
	    /**
	     * @abstract
	     * @param {?} text
	     * @return {?}
	     */
	    DomAdapter.prototype.createComment = function (text) { };
	    /**
	     * @abstract
	     * @param {?} html
	     * @return {?}
	     */
	    DomAdapter.prototype.createTemplate = function (html) { };
	    /**
	     * @abstract
	     * @param {?} tagName
	     * @param {?=} doc
	     * @return {?}
	     */
	    DomAdapter.prototype.createElement = function (tagName, doc) { };
	    /**
	     * @abstract
	     * @param {?} ns
	     * @param {?} tagName
	     * @param {?=} doc
	     * @return {?}
	     */
	    DomAdapter.prototype.createElementNS = function (ns, tagName, doc) { };
	    /**
	     * @abstract
	     * @param {?} text
	     * @param {?=} doc
	     * @return {?}
	     */
	    DomAdapter.prototype.createTextNode = function (text, doc) { };
	    /**
	     * @abstract
	     * @param {?} attrName
	     * @param {?} attrValue
	     * @param {?=} doc
	     * @return {?}
	     */
	    DomAdapter.prototype.createScriptTag = function (attrName, attrValue, doc) { };
	    /**
	     * @abstract
	     * @param {?} css
	     * @param {?=} doc
	     * @return {?}
	     */
	    DomAdapter.prototype.createStyleElement = function (css, doc) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @return {?}
	     */
	    DomAdapter.prototype.createShadowRoot = function (el) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @return {?}
	     */
	    DomAdapter.prototype.getShadowRoot = function (el) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @return {?}
	     */
	    DomAdapter.prototype.getHost = function (el) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @return {?}
	     */
	    DomAdapter.prototype.getDistributedNodes = function (el) { };
	    /**
	     * @abstract
	     * @param {?} node
	     * @return {?}
	     */
	    DomAdapter.prototype.clone /*<T extends Node>*/ = function (node) { };
	    /**
	     * @abstract
	     * @param {?} element
	     * @param {?} name
	     * @return {?}
	     */
	    DomAdapter.prototype.getElementsByClassName = function (element, name) { };
	    /**
	     * @abstract
	     * @param {?} element
	     * @param {?} name
	     * @return {?}
	     */
	    DomAdapter.prototype.getElementsByTagName = function (element, name) { };
	    /**
	     * @abstract
	     * @param {?} element
	     * @return {?}
	     */
	    DomAdapter.prototype.classList = function (element) { };
	    /**
	     * @abstract
	     * @param {?} element
	     * @param {?} className
	     * @return {?}
	     */
	    DomAdapter.prototype.addClass = function (element, className) { };
	    /**
	     * @abstract
	     * @param {?} element
	     * @param {?} className
	     * @return {?}
	     */
	    DomAdapter.prototype.removeClass = function (element, className) { };
	    /**
	     * @abstract
	     * @param {?} element
	     * @param {?} className
	     * @return {?}
	     */
	    DomAdapter.prototype.hasClass = function (element, className) { };
	    /**
	     * @abstract
	     * @param {?} element
	     * @param {?} styleName
	     * @param {?} styleValue
	     * @return {?}
	     */
	    DomAdapter.prototype.setStyle = function (element, styleName, styleValue) { };
	    /**
	     * @abstract
	     * @param {?} element
	     * @param {?} styleName
	     * @return {?}
	     */
	    DomAdapter.prototype.removeStyle = function (element, styleName) { };
	    /**
	     * @abstract
	     * @param {?} element
	     * @param {?} styleName
	     * @return {?}
	     */
	    DomAdapter.prototype.getStyle = function (element, styleName) { };
	    /**
	     * @abstract
	     * @param {?} element
	     * @param {?} styleName
	     * @param {?=} styleValue
	     * @return {?}
	     */
	    DomAdapter.prototype.hasStyle = function (element, styleName, styleValue) { };
	    /**
	     * @abstract
	     * @param {?} element
	     * @return {?}
	     */
	    DomAdapter.prototype.tagName = function (element) { };
	    /**
	     * @abstract
	     * @param {?} element
	     * @return {?}
	     */
	    DomAdapter.prototype.attributeMap = function (element) { };
	    /**
	     * @abstract
	     * @param {?} element
	     * @param {?} attribute
	     * @return {?}
	     */
	    DomAdapter.prototype.hasAttribute = function (element, attribute) { };
	    /**
	     * @abstract
	     * @param {?} element
	     * @param {?} ns
	     * @param {?} attribute
	     * @return {?}
	     */
	    DomAdapter.prototype.hasAttributeNS = function (element, ns, attribute) { };
	    /**
	     * @abstract
	     * @param {?} element
	     * @param {?} attribute
	     * @return {?}
	     */
	    DomAdapter.prototype.getAttribute = function (element, attribute) { };
	    /**
	     * @abstract
	     * @param {?} element
	     * @param {?} ns
	     * @param {?} attribute
	     * @return {?}
	     */
	    DomAdapter.prototype.getAttributeNS = function (element, ns, attribute) { };
	    /**
	     * @abstract
	     * @param {?} element
	     * @param {?} name
	     * @param {?} value
	     * @return {?}
	     */
	    DomAdapter.prototype.setAttribute = function (element, name, value) { };
	    /**
	     * @abstract
	     * @param {?} element
	     * @param {?} ns
	     * @param {?} name
	     * @param {?} value
	     * @return {?}
	     */
	    DomAdapter.prototype.setAttributeNS = function (element, ns, name, value) { };
	    /**
	     * @abstract
	     * @param {?} element
	     * @param {?} attribute
	     * @return {?}
	     */
	    DomAdapter.prototype.removeAttribute = function (element, attribute) { };
	    /**
	     * @abstract
	     * @param {?} element
	     * @param {?} ns
	     * @param {?} attribute
	     * @return {?}
	     */
	    DomAdapter.prototype.removeAttributeNS = function (element, ns, attribute) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @return {?}
	     */
	    DomAdapter.prototype.templateAwareRoot = function (el) { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DomAdapter.prototype.createHtmlDocument = function () { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @return {?}
	     */
	    DomAdapter.prototype.getBoundingClientRect = function (el) { };
	    /**
	     * @abstract
	     * @param {?} doc
	     * @return {?}
	     */
	    DomAdapter.prototype.getTitle = function (doc) { };
	    /**
	     * @abstract
	     * @param {?} doc
	     * @param {?} newTitle
	     * @return {?}
	     */
	    DomAdapter.prototype.setTitle = function (doc, newTitle) { };
	    /**
	     * @abstract
	     * @param {?} n
	     * @param {?} selector
	     * @return {?}
	     */
	    DomAdapter.prototype.elementMatches = function (n, selector) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @return {?}
	     */
	    DomAdapter.prototype.isTemplateElement = function (el) { };
	    /**
	     * @abstract
	     * @param {?} node
	     * @return {?}
	     */
	    DomAdapter.prototype.isTextNode = function (node) { };
	    /**
	     * @abstract
	     * @param {?} node
	     * @return {?}
	     */
	    DomAdapter.prototype.isCommentNode = function (node) { };
	    /**
	     * @abstract
	     * @param {?} node
	     * @return {?}
	     */
	    DomAdapter.prototype.isElementNode = function (node) { };
	    /**
	     * @abstract
	     * @param {?} node
	     * @return {?}
	     */
	    DomAdapter.prototype.hasShadowRoot = function (node) { };
	    /**
	     * @abstract
	     * @param {?} node
	     * @return {?}
	     */
	    DomAdapter.prototype.isShadowRoot = function (node) { };
	    /**
	     * @abstract
	     * @param {?} node
	     * @return {?}
	     */
	    DomAdapter.prototype.importIntoDoc /*<T extends Node>*/ = function (node) { };
	    /**
	     * @abstract
	     * @param {?} node
	     * @return {?}
	     */
	    DomAdapter.prototype.adoptNode /*<T extends Node>*/ = function (node) { };
	    /**
	     * @abstract
	     * @param {?} element
	     * @return {?}
	     */
	    DomAdapter.prototype.getHref = function (element) { };
	    /**
	     * @abstract
	     * @param {?} event
	     * @return {?}
	     */
	    DomAdapter.prototype.getEventKey = function (event) { };
	    /**
	     * @abstract
	     * @param {?} element
	     * @param {?} baseUrl
	     * @param {?} href
	     * @return {?}
	     */
	    DomAdapter.prototype.resolveAndSetHref = function (element, baseUrl, href) { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DomAdapter.prototype.supportsDOMEvents = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DomAdapter.prototype.supportsNativeShadowDOM = function () { };
	    /**
	     * @abstract
	     * @param {?} doc
	     * @param {?} target
	     * @return {?}
	     */
	    DomAdapter.prototype.getGlobalEventTarget = function (doc, target) { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DomAdapter.prototype.getHistory = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DomAdapter.prototype.getLocation = function () { };
	    /**
	     * @abstract
	     * @param {?} doc
	     * @return {?}
	     */
	    DomAdapter.prototype.getBaseHref = function (doc) { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DomAdapter.prototype.resetBaseElement = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DomAdapter.prototype.getUserAgent = function () { };
	    /**
	     * @abstract
	     * @param {?} element
	     * @param {?} name
	     * @param {?} value
	     * @return {?}
	     */
	    DomAdapter.prototype.setData = function (element, name, value) { };
	    /**
	     * @abstract
	     * @param {?} element
	     * @return {?}
	     */
	    DomAdapter.prototype.getComputedStyle = function (element) { };
	    /**
	     * @abstract
	     * @param {?} element
	     * @param {?} name
	     * @return {?}
	     */
	    DomAdapter.prototype.getData = function (element, name) { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DomAdapter.prototype.supportsWebAnimation = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DomAdapter.prototype.performanceNow = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DomAdapter.prototype.getAnimationPrefix = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DomAdapter.prototype.getTransitionEnd = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DomAdapter.prototype.supportsAnimation = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DomAdapter.prototype.supportsCookies = function () { };
	    /**
	     * @abstract
	     * @param {?} name
	     * @return {?}
	     */
	    DomAdapter.prototype.getCookie = function (name) { };
	    /**
	     * @abstract
	     * @param {?} name
	     * @param {?} value
	     * @return {?}
	     */
	    DomAdapter.prototype.setCookie = function (name, value) { };
	    return DomAdapter;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Provides DOM operations in any browser environment.
	 *
	 * \@security Tread carefully! Interacting with the DOM directly is dangerous and
	 * can introduce XSS risks.
	 * @abstract
	 */
	var GenericBrowserDomAdapter = (function (_super) {
	    __extends(GenericBrowserDomAdapter, _super);
	    function GenericBrowserDomAdapter() {
	        var _this = _super.call(this) || this;
	        _this._animationPrefix = null;
	        _this._transitionEnd = null;
	        try {
	            var element_1 = _this.createElement('div', document);
	            if (_this.getStyle(element_1, 'animationName') != null) {
	                _this._animationPrefix = '';
	            }
	            else {
	                var domPrefixes = ['Webkit', 'Moz', 'O', 'ms'];
	                for (var i = 0; i < domPrefixes.length; i++) {
	                    if (_this.getStyle(element_1, domPrefixes[i] + 'AnimationName') != null) {
	                        _this._animationPrefix = '-' + domPrefixes[i].toLowerCase() + '-';
	                        break;
	                    }
	                }
	            }
	            var transEndEventNames_1 = {
	                WebkitTransition: 'webkitTransitionEnd',
	                MozTransition: 'transitionend',
	                OTransition: 'oTransitionEnd otransitionend',
	                transition: 'transitionend'
	            };
	            Object.keys(transEndEventNames_1).forEach(function (key) {
	                if (_this.getStyle(element_1, key) != null) {
	                    _this._transitionEnd = transEndEventNames_1[key];
	                }
	            });
	        }
	        catch (e) {
	            _this._animationPrefix = null;
	            _this._transitionEnd = null;
	        }
	        return _this;
	    }
	    /**
	     * @param {?} el
	     * @return {?}
	     */
	    GenericBrowserDomAdapter.prototype.getDistributedNodes = function (el) { return ((el)).getDistributedNodes(); };
	    /**
	     * @param {?} el
	     * @param {?} baseUrl
	     * @param {?} href
	     * @return {?}
	     */
	    GenericBrowserDomAdapter.prototype.resolveAndSetHref = function (el, baseUrl, href) {
	        el.href = href == null ? baseUrl : baseUrl + '/../' + href;
	    };
	    /**
	     * @return {?}
	     */
	    GenericBrowserDomAdapter.prototype.supportsDOMEvents = function () { return true; };
	    /**
	     * @return {?}
	     */
	    GenericBrowserDomAdapter.prototype.supportsNativeShadowDOM = function () {
	        return typeof ((document.body)).createShadowRoot === 'function';
	    };
	    /**
	     * @return {?}
	     */
	    GenericBrowserDomAdapter.prototype.getAnimationPrefix = function () { return this._animationPrefix ? this._animationPrefix : ''; };
	    /**
	     * @return {?}
	     */
	    GenericBrowserDomAdapter.prototype.getTransitionEnd = function () { return this._transitionEnd ? this._transitionEnd : ''; };
	    /**
	     * @return {?}
	     */
	    GenericBrowserDomAdapter.prototype.supportsAnimation = function () {
	        return this._animationPrefix != null && this._transitionEnd != null;
	    };
	    return GenericBrowserDomAdapter;
	}(DomAdapter));
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var _attrToPropMap = {
	    'class': 'className',
	    'innerHtml': 'innerHTML',
	    'readonly': 'readOnly',
	    'tabindex': 'tabIndex',
	};
	var DOM_KEY_LOCATION_NUMPAD = 3;
	// Map to convert some key or keyIdentifier values to what will be returned by getEventKey
	var _keyMap = {
	    // The following values are here for cross-browser compatibility and to match the W3C standard
	    // cf http://www.w3.org/TR/DOM-Level-3-Events-key/
	    '\b': 'Backspace',
	    '\t': 'Tab',
	    '\x7F': 'Delete',
	    '\x1B': 'Escape',
	    'Del': 'Delete',
	    'Esc': 'Escape',
	    'Left': 'ArrowLeft',
	    'Right': 'ArrowRight',
	    'Up': 'ArrowUp',
	    'Down': 'ArrowDown',
	    'Menu': 'ContextMenu',
	    'Scroll': 'ScrollLock',
	    'Win': 'OS'
	};
	// There is a bug in Chrome for numeric keypad keys:
	// https://code.google.com/p/chromium/issues/detail?id=155654
	// 1, 2, 3 ... are reported as A, B, C ...
	var _chromeNumKeyPadMap = {
	    'A': '1',
	    'B': '2',
	    'C': '3',
	    'D': '4',
	    'E': '5',
	    'F': '6',
	    'G': '7',
	    'H': '8',
	    'I': '9',
	    'J': '*',
	    'K': '+',
	    'M': '-',
	    'N': '.',
	    'O': '/',
	    '\x60': '0',
	    '\x90': 'NumLock'
	};
	var nodeContains;
	if (_angular_core.ɵglobal['Node']) {
	    nodeContains = _angular_core.ɵglobal['Node'].prototype.contains || function (node) {
	        return !!(this.compareDocumentPosition(node) & 16);
	    };
	}
	var BrowserDomAdapter = (function (_super) {
	    __extends(BrowserDomAdapter, _super);
	    function BrowserDomAdapter() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    /**
	     * @param {?} templateHtml
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.parse = function (templateHtml) { throw new Error('parse not implemented'); };
	    /**
	     * @return {?}
	     */
	    BrowserDomAdapter.makeCurrent = function () { setRootDomAdapter(new BrowserDomAdapter()); };
	    /**
	     * @param {?} element
	     * @param {?} name
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.hasProperty = function (element, name) { return name in element; };
	    /**
	     * @param {?} el
	     * @param {?} name
	     * @param {?} value
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.setProperty = function (el, name, value) { ((el))[name] = value; };
	    /**
	     * @param {?} el
	     * @param {?} name
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.getProperty = function (el, name) { return ((el))[name]; };
	    /**
	     * @param {?} el
	     * @param {?} methodName
	     * @param {?} args
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.invoke = function (el, methodName, args) { ((el))[methodName].apply(((el)), args); };
	    /**
	     * @param {?} error
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.logError = function (error) {
	        if (window.console) {
	            if (console.error) {
	                console.error(error);
	            }
	            else {
	                console.log(error);
	            }
	        }
	    };
	    /**
	     * @param {?} error
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.log = function (error) {
	        if (window.console) {
	            window.console.log && window.console.log(error);
	        }
	    };
	    /**
	     * @param {?} error
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.logGroup = function (error) {
	        if (window.console) {
	            window.console.group && window.console.group(error);
	        }
	    };
	    /**
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.logGroupEnd = function () {
	        if (window.console) {
	            window.console.groupEnd && window.console.groupEnd();
	        }
	    };
	    Object.defineProperty(BrowserDomAdapter.prototype, "attrToPropMap", {
	        /**
	         * @return {?}
	         */
	        get: function () { return _attrToPropMap; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @param {?} nodeA
	     * @param {?} nodeB
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.contains = function (nodeA, nodeB) { return nodeContains.call(nodeA, nodeB); };
	    /**
	     * @param {?} el
	     * @param {?} selector
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.querySelector = function (el, selector) { return el.querySelector(selector); };
	    /**
	     * @param {?} el
	     * @param {?} selector
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.querySelectorAll = function (el, selector) { return el.querySelectorAll(selector); };
	    /**
	     * @param {?} el
	     * @param {?} evt
	     * @param {?} listener
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.on = function (el, evt, listener) { el.addEventListener(evt, listener, false); };
	    /**
	     * @param {?} el
	     * @param {?} evt
	     * @param {?} listener
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.onAndCancel = function (el, evt, listener) {
	        el.addEventListener(evt, listener, false);
	        // Needed to follow Dart's subscription semantic, until fix of
	        // https://code.google.com/p/dart/issues/detail?id=17406
	        return function () { el.removeEventListener(evt, listener, false); };
	    };
	    /**
	     * @param {?} el
	     * @param {?} evt
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.dispatchEvent = function (el, evt) { el.dispatchEvent(evt); };
	    /**
	     * @param {?} eventType
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.createMouseEvent = function (eventType) {
	        var /** @type {?} */ evt = document.createEvent('MouseEvent');
	        evt.initEvent(eventType, true, true);
	        return evt;
	    };
	    /**
	     * @param {?} eventType
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.createEvent = function (eventType) {
	        var /** @type {?} */ evt = document.createEvent('Event');
	        evt.initEvent(eventType, true, true);
	        return evt;
	    };
	    /**
	     * @param {?} evt
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.preventDefault = function (evt) {
	        evt.preventDefault();
	        evt.returnValue = false;
	    };
	    /**
	     * @param {?} evt
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.isPrevented = function (evt) {
	        return evt.defaultPrevented || evt.returnValue != null && !evt.returnValue;
	    };
	    /**
	     * @param {?} el
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.getInnerHTML = function (el) { return el.innerHTML; };
	    /**
	     * @param {?} el
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.getTemplateContent = function (el) {
	        return 'content' in el && el instanceof HTMLTemplateElement ? el.content : null;
	    };
	    /**
	     * @param {?} el
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.getOuterHTML = function (el) { return el.outerHTML; };
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.nodeName = function (node) { return node.nodeName; };
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.nodeValue = function (node) { return node.nodeValue; };
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.type = function (node) { return node.type; };
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.content = function (node) {
	        if (this.hasProperty(node, 'content')) {
	            return ((node)).content;
	        }
	        else {
	            return node;
	        }
	    };
	    /**
	     * @param {?} el
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.firstChild = function (el) { return el.firstChild; };
	    /**
	     * @param {?} el
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.nextSibling = function (el) { return el.nextSibling; };
	    /**
	     * @param {?} el
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.parentElement = function (el) { return el.parentNode; };
	    /**
	     * @param {?} el
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.childNodes = function (el) { return el.childNodes; };
	    /**
	     * @param {?} el
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.childNodesAsList = function (el) {
	        var /** @type {?} */ childNodes = el.childNodes;
	        var /** @type {?} */ res = new Array(childNodes.length);
	        for (var /** @type {?} */ i = 0; i < childNodes.length; i++) {
	            res[i] = childNodes[i];
	        }
	        return res;
	    };
	    /**
	     * @param {?} el
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.clearNodes = function (el) {
	        while (el.firstChild) {
	            el.removeChild(el.firstChild);
	        }
	    };
	    /**
	     * @param {?} el
	     * @param {?} node
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.appendChild = function (el, node) { el.appendChild(node); };
	    /**
	     * @param {?} el
	     * @param {?} node
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.removeChild = function (el, node) { el.removeChild(node); };
	    /**
	     * @param {?} el
	     * @param {?} newChild
	     * @param {?} oldChild
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.replaceChild = function (el, newChild, oldChild) { el.replaceChild(newChild, oldChild); };
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.remove = function (node) {
	        if (node.parentNode) {
	            node.parentNode.removeChild(node);
	        }
	        return node;
	    };
	    /**
	     * @param {?} parent
	     * @param {?} ref
	     * @param {?} node
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.insertBefore = function (parent, ref, node) { parent.insertBefore(node, ref); };
	    /**
	     * @param {?} parent
	     * @param {?} ref
	     * @param {?} nodes
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.insertAllBefore = function (parent, ref, nodes) {
	        nodes.forEach(function (n) { return parent.insertBefore(n, ref); });
	    };
	    /**
	     * @param {?} parent
	     * @param {?} ref
	     * @param {?} node
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.insertAfter = function (parent, ref, node) { parent.insertBefore(node, ref.nextSibling); };
	    /**
	     * @param {?} el
	     * @param {?} value
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.setInnerHTML = function (el, value) { el.innerHTML = value; };
	    /**
	     * @param {?} el
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.getText = function (el) { return el.textContent; };
	    /**
	     * @param {?} el
	     * @param {?} value
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.setText = function (el, value) { el.textContent = value; };
	    /**
	     * @param {?} el
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.getValue = function (el) { return el.value; };
	    /**
	     * @param {?} el
	     * @param {?} value
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.setValue = function (el, value) { el.value = value; };
	    /**
	     * @param {?} el
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.getChecked = function (el) { return el.checked; };
	    /**
	     * @param {?} el
	     * @param {?} value
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.setChecked = function (el, value) { el.checked = value; };
	    /**
	     * @param {?} text
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.createComment = function (text) { return document.createComment(text); };
	    /**
	     * @param {?} html
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.createTemplate = function (html) {
	        var /** @type {?} */ t = document.createElement('template');
	        t.innerHTML = html;
	        return t;
	    };
	    /**
	     * @param {?} tagName
	     * @param {?=} doc
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.createElement = function (tagName, doc) {
	        if (doc === void 0) { doc = document; }
	        return doc.createElement(tagName);
	    };
	    /**
	     * @param {?} ns
	     * @param {?} tagName
	     * @param {?=} doc
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.createElementNS = function (ns, tagName, doc) {
	        if (doc === void 0) { doc = document; }
	        return doc.createElementNS(ns, tagName);
	    };
	    /**
	     * @param {?} text
	     * @param {?=} doc
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.createTextNode = function (text, doc) {
	        if (doc === void 0) { doc = document; }
	        return doc.createTextNode(text);
	    };
	    /**
	     * @param {?} attrName
	     * @param {?} attrValue
	     * @param {?=} doc
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.createScriptTag = function (attrName, attrValue, doc) {
	        if (doc === void 0) { doc = document; }
	        var /** @type {?} */ el = (doc.createElement('SCRIPT'));
	        el.setAttribute(attrName, attrValue);
	        return el;
	    };
	    /**
	     * @param {?} css
	     * @param {?=} doc
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.createStyleElement = function (css, doc) {
	        if (doc === void 0) { doc = document; }
	        var /** @type {?} */ style = (doc.createElement('style'));
	        this.appendChild(style, this.createTextNode(css));
	        return style;
	    };
	    /**
	     * @param {?} el
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.createShadowRoot = function (el) { return ((el)).createShadowRoot(); };
	    /**
	     * @param {?} el
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.getShadowRoot = function (el) { return ((el)).shadowRoot; };
	    /**
	     * @param {?} el
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.getHost = function (el) { return ((el)).host; };
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.clone = function (node) { return node.cloneNode(true); };
	    /**
	     * @param {?} element
	     * @param {?} name
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.getElementsByClassName = function (element, name) {
	        return element.getElementsByClassName(name);
	    };
	    /**
	     * @param {?} element
	     * @param {?} name
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.getElementsByTagName = function (element, name) {
	        return element.getElementsByTagName(name);
	    };
	    /**
	     * @param {?} element
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.classList = function (element) { return Array.prototype.slice.call(element.classList, 0); };
	    /**
	     * @param {?} element
	     * @param {?} className
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.addClass = function (element, className) { element.classList.add(className); };
	    /**
	     * @param {?} element
	     * @param {?} className
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.removeClass = function (element, className) { element.classList.remove(className); };
	    /**
	     * @param {?} element
	     * @param {?} className
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.hasClass = function (element, className) {
	        return element.classList.contains(className);
	    };
	    /**
	     * @param {?} element
	     * @param {?} styleName
	     * @param {?} styleValue
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.setStyle = function (element, styleName, styleValue) {
	        element.style[styleName] = styleValue;
	    };
	    /**
	     * @param {?} element
	     * @param {?} stylename
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.removeStyle = function (element, stylename) {
	        // IE requires '' instead of null
	        // see https://github.com/angular/angular/issues/7916
	        element.style[stylename] = '';
	    };
	    /**
	     * @param {?} element
	     * @param {?} stylename
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.getStyle = function (element, stylename) { return element.style[stylename]; };
	    /**
	     * @param {?} element
	     * @param {?} styleName
	     * @param {?=} styleValue
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.hasStyle = function (element, styleName, styleValue) {
	        var /** @type {?} */ value = this.getStyle(element, styleName) || '';
	        return styleValue ? value == styleValue : value.length > 0;
	    };
	    /**
	     * @param {?} element
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.tagName = function (element) { return element.tagName; };
	    /**
	     * @param {?} element
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.attributeMap = function (element) {
	        var /** @type {?} */ res = new Map();
	        var /** @type {?} */ elAttrs = element.attributes;
	        for (var /** @type {?} */ i = 0; i < elAttrs.length; i++) {
	            var /** @type {?} */ attrib = elAttrs[i];
	            res.set(attrib.name, attrib.value);
	        }
	        return res;
	    };
	    /**
	     * @param {?} element
	     * @param {?} attribute
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.hasAttribute = function (element, attribute) {
	        return element.hasAttribute(attribute);
	    };
	    /**
	     * @param {?} element
	     * @param {?} ns
	     * @param {?} attribute
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.hasAttributeNS = function (element, ns, attribute) {
	        return element.hasAttributeNS(ns, attribute);
	    };
	    /**
	     * @param {?} element
	     * @param {?} attribute
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.getAttribute = function (element, attribute) {
	        return element.getAttribute(attribute);
	    };
	    /**
	     * @param {?} element
	     * @param {?} ns
	     * @param {?} name
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.getAttributeNS = function (element, ns, name) {
	        return element.getAttributeNS(ns, name);
	    };
	    /**
	     * @param {?} element
	     * @param {?} name
	     * @param {?} value
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.setAttribute = function (element, name, value) { element.setAttribute(name, value); };
	    /**
	     * @param {?} element
	     * @param {?} ns
	     * @param {?} name
	     * @param {?} value
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.setAttributeNS = function (element, ns, name, value) {
	        element.setAttributeNS(ns, name, value);
	    };
	    /**
	     * @param {?} element
	     * @param {?} attribute
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.removeAttribute = function (element, attribute) { element.removeAttribute(attribute); };
	    /**
	     * @param {?} element
	     * @param {?} ns
	     * @param {?} name
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.removeAttributeNS = function (element, ns, name) {
	        element.removeAttributeNS(ns, name);
	    };
	    /**
	     * @param {?} el
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.templateAwareRoot = function (el) { return this.isTemplateElement(el) ? this.content(el) : el; };
	    /**
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.createHtmlDocument = function () {
	        return document.implementation.createHTMLDocument('fakeTitle');
	    };
	    /**
	     * @param {?} el
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.getBoundingClientRect = function (el) {
	        try {
	            return el.getBoundingClientRect();
	        }
	        catch (e) {
	            return { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 };
	        }
	    };
	    /**
	     * @param {?} doc
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.getTitle = function (doc) { return document.title; };
	    /**
	     * @param {?} doc
	     * @param {?} newTitle
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.setTitle = function (doc, newTitle) { document.title = newTitle || ''; };
	    /**
	     * @param {?} n
	     * @param {?} selector
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.elementMatches = function (n, selector) {
	        if (n instanceof HTMLElement) {
	            return n.matches && n.matches(selector) ||
	                n.msMatchesSelector && n.msMatchesSelector(selector) ||
	                n.webkitMatchesSelector && n.webkitMatchesSelector(selector);
	        }
	        return false;
	    };
	    /**
	     * @param {?} el
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.isTemplateElement = function (el) {
	        return el instanceof HTMLElement && el.nodeName == 'TEMPLATE';
	    };
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.isTextNode = function (node) { return node.nodeType === Node.TEXT_NODE; };
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.isCommentNode = function (node) { return node.nodeType === Node.COMMENT_NODE; };
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.isElementNode = function (node) { return node.nodeType === Node.ELEMENT_NODE; };
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.hasShadowRoot = function (node) {
	        return node.shadowRoot != null && node instanceof HTMLElement;
	    };
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.isShadowRoot = function (node) { return node instanceof DocumentFragment; };
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.importIntoDoc = function (node) { return document.importNode(this.templateAwareRoot(node), true); };
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.adoptNode = function (node) { return document.adoptNode(node); };
	    /**
	     * @param {?} el
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.getHref = function (el) { return ((el)).href; };
	    /**
	     * @param {?} event
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.getEventKey = function (event) {
	        var /** @type {?} */ key = event.key;
	        if (key == null) {
	            key = event.keyIdentifier;
	            // keyIdentifier is defined in the old draft of DOM Level 3 Events implemented by Chrome and
	            // Safari cf
	            // http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html#Events-KeyboardEvents-Interfaces
	            if (key == null) {
	                return 'Unidentified';
	            }
	            if (key.startsWith('U+')) {
	                key = String.fromCharCode(parseInt(key.substring(2), 16));
	                if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {
	                    // There is a bug in Chrome for numeric keypad keys:
	                    // https://code.google.com/p/chromium/issues/detail?id=155654
	                    // 1, 2, 3 ... are reported as A, B, C ...
	                    key = ((_chromeNumKeyPadMap))[key];
	                }
	            }
	        }
	        return _keyMap[key] || key;
	    };
	    /**
	     * @param {?} doc
	     * @param {?} target
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.getGlobalEventTarget = function (doc, target) {
	        if (target === 'window') {
	            return window;
	        }
	        if (target === 'document') {
	            return document;
	        }
	        if (target === 'body') {
	            return document.body;
	        }
	        return null;
	    };
	    /**
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.getHistory = function () { return window.history; };
	    /**
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.getLocation = function () { return window.location; };
	    /**
	     * @param {?} doc
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.getBaseHref = function (doc) {
	        var /** @type {?} */ href = getBaseElementHref();
	        return href == null ? null : relativePath(href);
	    };
	    /**
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.resetBaseElement = function () { baseElement = null; };
	    /**
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.getUserAgent = function () { return window.navigator.userAgent; };
	    /**
	     * @param {?} element
	     * @param {?} name
	     * @param {?} value
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.setData = function (element, name, value) {
	        this.setAttribute(element, 'data-' + name, value);
	    };
	    /**
	     * @param {?} element
	     * @param {?} name
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.getData = function (element, name) {
	        return this.getAttribute(element, 'data-' + name);
	    };
	    /**
	     * @param {?} element
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.getComputedStyle = function (element) { return getComputedStyle(element); };
	    /**
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.supportsWebAnimation = function () {
	        return typeof ((Element)).prototype['animate'] === 'function';
	    };
	    /**
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.performanceNow = function () {
	        // performance.now() is not available in all browsers, see
	        // http://caniuse.com/#search=performance.now
	        return window.performance && window.performance.now ? window.performance.now() :
	            new Date().getTime();
	    };
	    /**
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.supportsCookies = function () { return true; };
	    /**
	     * @param {?} name
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.getCookie = function (name) { return _angular_common.ɵparseCookieValue(document.cookie, name); };
	    /**
	     * @param {?} name
	     * @param {?} value
	     * @return {?}
	     */
	    BrowserDomAdapter.prototype.setCookie = function (name, value) {
	        // document.cookie is magical, assigning into it assigns/overrides one cookie value, but does
	        // not clear other cookies.
	        document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);
	    };
	    return BrowserDomAdapter;
	}(GenericBrowserDomAdapter));
	var baseElement = null;
	/**
	 * @return {?}
	 */
	function getBaseElementHref() {
	    if (!baseElement) {
	        baseElement = ((document.querySelector('base')));
	        if (!baseElement) {
	            return null;
	        }
	    }
	    return baseElement.getAttribute('href');
	}
	// based on urlUtils.js in AngularJS 1
	var urlParsingNode;
	/**
	 * @param {?} url
	 * @return {?}
	 */
	function relativePath(url) {
	    if (!urlParsingNode) {
	        urlParsingNode = document.createElement('a');
	    }
	    urlParsingNode.setAttribute('href', url);
	    return (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname :
	        '/' + urlParsingNode.pathname;
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * A DI Token representing the main rendering context. In a browser this is the DOM Document.
	 *
	 * Note: Document might not be available in the Application Context when Application and Rendering
	 * Contexts are not the same (e.g. when running the application into a Web Worker).
	 *
	 * @deprecated import from `\@angular/common` instead.
	 */
	var DOCUMENT$1 = _angular_common.DOCUMENT;
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 * @return {?}
	 */
	function supportsState() {
	    return !!window.history.pushState;
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * `PlatformLocation` encapsulates all of the direct calls to platform APIs.
	 * This class should not be used directly by an application developer. Instead, use
	 * {\@link Location}.
	 */
	var BrowserPlatformLocation = (function (_super) {
	    __extends(BrowserPlatformLocation, _super);
	    /**
	     * @param {?} _doc
	     */
	    function BrowserPlatformLocation(_doc) {
	        var _this = _super.call(this) || this;
	        _this._doc = _doc;
	        _this._init();
	        return _this;
	    }
	    /**
	     * \@internal
	     * @return {?}
	     */
	    BrowserPlatformLocation.prototype._init = function () {
	        this._location = getDOM().getLocation();
	        this._history = getDOM().getHistory();
	    };
	    Object.defineProperty(BrowserPlatformLocation.prototype, "location", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._location; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @return {?}
	     */
	    BrowserPlatformLocation.prototype.getBaseHrefFromDOM = function () { return ((getDOM().getBaseHref(this._doc))); };
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    BrowserPlatformLocation.prototype.onPopState = function (fn) {
	        getDOM().getGlobalEventTarget(this._doc, 'window').addEventListener('popstate', fn, false);
	    };
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    BrowserPlatformLocation.prototype.onHashChange = function (fn) {
	        getDOM().getGlobalEventTarget(this._doc, 'window').addEventListener('hashchange', fn, false);
	    };
	    Object.defineProperty(BrowserPlatformLocation.prototype, "pathname", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._location.pathname; },
	        /**
	         * @param {?} newPath
	         * @return {?}
	         */
	        set: function (newPath) { this._location.pathname = newPath; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BrowserPlatformLocation.prototype, "search", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._location.search; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BrowserPlatformLocation.prototype, "hash", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._location.hash; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @param {?} state
	     * @param {?} title
	     * @param {?} url
	     * @return {?}
	     */
	    BrowserPlatformLocation.prototype.pushState = function (state, title, url) {
	        if (supportsState()) {
	            this._history.pushState(state, title, url);
	        }
	        else {
	            this._location.hash = url;
	        }
	    };
	    /**
	     * @param {?} state
	     * @param {?} title
	     * @param {?} url
	     * @return {?}
	     */
	    BrowserPlatformLocation.prototype.replaceState = function (state, title, url) {
	        if (supportsState()) {
	            this._history.replaceState(state, title, url);
	        }
	        else {
	            this._location.hash = url;
	        }
	    };
	    /**
	     * @return {?}
	     */
	    BrowserPlatformLocation.prototype.forward = function () { this._history.forward(); };
	    /**
	     * @return {?}
	     */
	    BrowserPlatformLocation.prototype.back = function () { this._history.back(); };
	    return BrowserPlatformLocation;
	}(_angular_common.PlatformLocation));
	BrowserPlatformLocation.decorators = [
	    { type: _angular_core.Injectable },
	];
	/**
	 * @nocollapse
	 */
	BrowserPlatformLocation.ctorParameters = function () { return [
	    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [DOCUMENT$1,] },] },
	]; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * A service that can be used to get and add meta tags.
	 *
	 * \@experimental
	 */
	var Meta = (function () {
	    /**
	     * @param {?} _doc
	     */
	    function Meta(_doc) {
	        this._doc = _doc;
	        this._dom = getDOM();
	    }
	    /**
	     * @param {?} tag
	     * @param {?=} forceCreation
	     * @return {?}
	     */
	    Meta.prototype.addTag = function (tag, forceCreation) {
	        if (forceCreation === void 0) { forceCreation = false; }
	        if (!tag)
	            return null;
	        return this._getOrCreateElement(tag, forceCreation);
	    };
	    /**
	     * @param {?} tags
	     * @param {?=} forceCreation
	     * @return {?}
	     */
	    Meta.prototype.addTags = function (tags, forceCreation) {
	        var _this = this;
	        if (forceCreation === void 0) { forceCreation = false; }
	        if (!tags)
	            return [];
	        return tags.reduce(function (result, tag) {
	            if (tag) {
	                result.push(_this._getOrCreateElement(tag, forceCreation));
	            }
	            return result;
	        }, []);
	    };
	    /**
	     * @param {?} attrSelector
	     * @return {?}
	     */
	    Meta.prototype.getTag = function (attrSelector) {
	        if (!attrSelector)
	            return null;
	        return this._dom.querySelector(this._doc, "meta[" + attrSelector + "]");
	    };
	    /**
	     * @param {?} attrSelector
	     * @return {?}
	     */
	    Meta.prototype.getTags = function (attrSelector) {
	        if (!attrSelector)
	            return [];
	        var /** @type {?} */ list /*NodeList*/ = this._dom.querySelectorAll(this._doc, "meta[" + attrSelector + "]");
	        return list ? [].slice.call(list) : [];
	    };
	    /**
	     * @param {?} tag
	     * @param {?=} selector
	     * @return {?}
	     */
	    Meta.prototype.updateTag = function (tag, selector) {
	        if (!tag)
	            return null;
	        selector = selector || this._parseSelector(tag);
	        var /** @type {?} */ meta = ((this.getTag(selector)));
	        if (meta) {
	            return this._setMetaElementAttributes(tag, meta);
	        }
	        return this._getOrCreateElement(tag, true);
	    };
	    /**
	     * @param {?} attrSelector
	     * @return {?}
	     */
	    Meta.prototype.removeTag = function (attrSelector) { this.removeTagElement(/** @type {?} */ ((this.getTag(attrSelector)))); };
	    /**
	     * @param {?} meta
	     * @return {?}
	     */
	    Meta.prototype.removeTagElement = function (meta) {
	        if (meta) {
	            this._dom.remove(meta);
	        }
	    };
	    /**
	     * @param {?} meta
	     * @param {?=} forceCreation
	     * @return {?}
	     */
	    Meta.prototype._getOrCreateElement = function (meta, forceCreation) {
	        if (forceCreation === void 0) { forceCreation = false; }
	        if (!forceCreation) {
	            var /** @type {?} */ selector = this._parseSelector(meta);
	            var /** @type {?} */ elem = ((this.getTag(selector)));
	            // It's allowed to have multiple elements with the same name so it's not enough to
	            // just check that element with the same name already present on the page. We also need to
	            // check if element has tag attributes
	            if (elem && this._containsAttributes(meta, elem))
	                return elem;
	        }
	        var /** @type {?} */ element = (this._dom.createElement('meta'));
	        this._setMetaElementAttributes(meta, element);
	        var /** @type {?} */ head = this._dom.getElementsByTagName(this._doc, 'head')[0];
	        this._dom.appendChild(head, element);
	        return element;
	    };
	    /**
	     * @param {?} tag
	     * @param {?} el
	     * @return {?}
	     */
	    Meta.prototype._setMetaElementAttributes = function (tag, el) {
	        var _this = this;
	        Object.keys(tag).forEach(function (prop) { return _this._dom.setAttribute(el, prop, tag[prop]); });
	        return el;
	    };
	    /**
	     * @param {?} tag
	     * @return {?}
	     */
	    Meta.prototype._parseSelector = function (tag) {
	        var /** @type {?} */ attr = tag.name ? 'name' : 'property';
	        return attr + "=\"" + tag[attr] + "\"";
	    };
	    /**
	     * @param {?} tag
	     * @param {?} elem
	     * @return {?}
	     */
	    Meta.prototype._containsAttributes = function (tag, elem) {
	        var _this = this;
	        return Object.keys(tag).every(function (key) { return _this._dom.getAttribute(elem, key) === tag[key]; });
	    };
	    return Meta;
	}());
	Meta.decorators = [
	    { type: _angular_core.Injectable },
	];
	/**
	 * @nocollapse
	 */
	Meta.ctorParameters = function () { return [
	    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [DOCUMENT$1,] },] },
	]; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * An id that identifies a particular application being bootstrapped, that should
	 * match across the client/server boundary.
	 */
	var TRANSITION_ID = new _angular_core.InjectionToken('TRANSITION_ID');
	/**
	 * @param {?} transitionId
	 * @param {?} document
	 * @param {?} injector
	 * @return {?}
	 */
	function appInitializerFactory(transitionId, document, injector) {
	    return function () {
	        // Wait for all application initializers to be completed before removing the styles set by
	        // the server.
	        injector.get(_angular_core.ApplicationInitStatus).donePromise.then(function () {
	            var /** @type {?} */ dom = getDOM();
	            var /** @type {?} */ styles = Array.prototype.slice.apply(dom.querySelectorAll(document, "style[ng-transition]"));
	            styles.filter(function (el) { return dom.getAttribute(el, 'ng-transition') === transitionId; })
	                .forEach(function (el) { return dom.remove(el); });
	        });
	    };
	}
	var SERVER_TRANSITION_PROVIDERS = [
	    {
	        provide: _angular_core.APP_INITIALIZER,
	        useFactory: appInitializerFactory,
	        deps: [TRANSITION_ID, DOCUMENT$1, _angular_core.Injector],
	        multi: true
	    },
	];
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var BrowserGetTestability = (function () {
	    function BrowserGetTestability() {
	    }
	    /**
	     * @return {?}
	     */
	    BrowserGetTestability.init = function () { _angular_core.setTestabilityGetter(new BrowserGetTestability()); };
	    /**
	     * @param {?} registry
	     * @return {?}
	     */
	    BrowserGetTestability.prototype.addToWindow = function (registry) {
	        _angular_core.ɵglobal['getAngularTestability'] = function (elem, findInAncestors) {
	            if (findInAncestors === void 0) { findInAncestors = true; }
	            var /** @type {?} */ testability = registry.findTestabilityInTree(elem, findInAncestors);
	            if (testability == null) {
	                throw new Error('Could not find testability for element.');
	            }
	            return testability;
	        };
	        _angular_core.ɵglobal['getAllAngularTestabilities'] = function () { return registry.getAllTestabilities(); };
	        _angular_core.ɵglobal['getAllAngularRootElements'] = function () { return registry.getAllRootElements(); };
	        var /** @type {?} */ whenAllStable = function (callback /** TODO #9100 */) {
	            var /** @type {?} */ testabilities = _angular_core.ɵglobal['getAllAngularTestabilities']();
	            var /** @type {?} */ count = testabilities.length;
	            var /** @type {?} */ didWork = false;
	            var /** @type {?} */ decrement = function (didWork_ /** TODO #9100 */) {
	                didWork = didWork || didWork_;
	                count--;
	                if (count == 0) {
	                    callback(didWork);
	                }
	            };
	            testabilities.forEach(function (testability /** TODO #9100 */) {
	                testability.whenStable(decrement);
	            });
	        };
	        if (!_angular_core.ɵglobal['frameworkStabilizers']) {
	            _angular_core.ɵglobal['frameworkStabilizers'] = [];
	        }
	        _angular_core.ɵglobal['frameworkStabilizers'].push(whenAllStable);
	    };
	    /**
	     * @param {?} registry
	     * @param {?} elem
	     * @param {?} findInAncestors
	     * @return {?}
	     */
	    BrowserGetTestability.prototype.findTestabilityInTree = function (registry, elem, findInAncestors) {
	        if (elem == null) {
	            return null;
	        }
	        var /** @type {?} */ t = registry.getTestability(elem);
	        if (t != null) {
	            return t;
	        }
	        else if (!findInAncestors) {
	            return null;
	        }
	        if (getDOM().isShadowRoot(elem)) {
	            return this.findTestabilityInTree(registry, getDOM().getHost(elem), true);
	        }
	        return this.findTestabilityInTree(registry, getDOM().parentElement(elem), true);
	    };
	    return BrowserGetTestability;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * A service that can be used to get and set the title of a current HTML document.
	 *
	 * Since an Angular application can't be bootstrapped on the entire HTML document (`<html>` tag)
	 * it is not possible to bind to the `text` property of the `HTMLTitleElement` elements
	 * (representing the `<title>` tag). Instead, this service can be used to set and get the current
	 * title value.
	 *
	 * \@experimental
	 */
	var Title = (function () {
	    /**
	     * @param {?} _doc
	     */
	    function Title(_doc) {
	        this._doc = _doc;
	    }
	    /**
	     * Get the title of the current HTML document.
	     * @return {?}
	     */
	    Title.prototype.getTitle = function () { return getDOM().getTitle(this._doc); };
	    /**
	     * Set the title of the current HTML document.
	     * @param {?} newTitle
	     * @return {?}
	     */
	    Title.prototype.setTitle = function (newTitle) { getDOM().setTitle(this._doc, newTitle); };
	    return Title;
	}());
	Title.decorators = [
	    { type: _angular_core.Injectable },
	];
	/**
	 * @nocollapse
	 */
	Title.ctorParameters = function () { return [
	    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [DOCUMENT$1,] },] },
	]; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} input
	 * @return {?}
	 */
	/**
	 * @param {?} input
	 * @return {?}
	 */
	/**
	 * Exports the value under a given `name` in the global property `ng`. For example `ng.probe` if
	 * `name` is `'probe'`.
	 * @param {?} name Name under which it will be exported. Keep in mind this will be a property of the
	 * global `ng` object.
	 * @param {?} value The value to export.
	 * @return {?}
	 */
	function exportNgVar(name, value) {
	    if (!ng) {
	        _angular_core.ɵglobal['ng'] = ng = ((_angular_core.ɵglobal['ng'])) || {};
	    }
	    ng[name] = value;
	}
	var ng;
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var CORE_TOKENS = {
	    'ApplicationRef': _angular_core.ApplicationRef,
	    'NgZone': _angular_core.NgZone,
	};
	var INSPECT_GLOBAL_NAME = 'probe';
	var CORE_TOKENS_GLOBAL_NAME = 'coreTokens';
	/**
	 * Returns a {\@link DebugElement} for the given native DOM element, or
	 * null if the given native element does not have an Angular view associated
	 * with it.
	 * @param {?} element
	 * @return {?}
	 */
	function inspectNativeElement(element) {
	    return _angular_core.getDebugNode(element);
	}
	/**
	 * Deprecated. Use the one from '\@angular/core'.
	 * @deprecated
	 */
	var NgProbeToken$1 = (function () {
	    /**
	     * @param {?} name
	     * @param {?} token
	     */
	    function NgProbeToken$1(name, token) {
	        this.name = name;
	        this.token = token;
	    }
	    return NgProbeToken$1;
	}());
	/**
	 * @param {?} extraTokens
	 * @param {?} coreTokens
	 * @return {?}
	 */
	function _createNgProbe(extraTokens, coreTokens) {
	    var /** @type {?} */ tokens = (extraTokens || []).concat(coreTokens || []);
	    exportNgVar(INSPECT_GLOBAL_NAME, inspectNativeElement);
	    exportNgVar(CORE_TOKENS_GLOBAL_NAME, Object.assign({}, CORE_TOKENS, _ngProbeTokensToMap(tokens || [])));
	    return function () { return inspectNativeElement; };
	}
	/**
	 * @param {?} tokens
	 * @return {?}
	 */
	function _ngProbeTokensToMap(tokens) {
	    return tokens.reduce(function (prev, t) { return (prev[t.name] = t.token, prev); }, {});
	}
	/**
	 * Providers which support debugging Angular applications (e.g. via `ng.probe`).
	 */
	var ELEMENT_PROBE_PROVIDERS = [
	    {
	        provide: _angular_core.APP_INITIALIZER,
	        useFactory: _createNgProbe,
	        deps: [
	            [NgProbeToken$1, new _angular_core.Optional()],
	            [_angular_core.NgProbeToken, new _angular_core.Optional()],
	        ],
	        multi: true,
	    },
	];
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@stable
	 */
	var EVENT_MANAGER_PLUGINS = new _angular_core.InjectionToken('EventManagerPlugins');
	/**
	 * \@stable
	 */
	var EventManager = (function () {
	    /**
	     * @param {?} plugins
	     * @param {?} _zone
	     */
	    function EventManager(plugins, _zone) {
	        var _this = this;
	        this._zone = _zone;
	        this._eventNameToPlugin = new Map();
	        plugins.forEach(function (p) { return p.manager = _this; });
	        this._plugins = plugins.slice().reverse();
	    }
	    /**
	     * @param {?} element
	     * @param {?} eventName
	     * @param {?} handler
	     * @return {?}
	     */
	    EventManager.prototype.addEventListener = function (element, eventName, handler) {
	        var /** @type {?} */ plugin = this._findPluginFor(eventName);
	        return plugin.addEventListener(element, eventName, handler);
	    };
	    /**
	     * @param {?} target
	     * @param {?} eventName
	     * @param {?} handler
	     * @return {?}
	     */
	    EventManager.prototype.addGlobalEventListener = function (target, eventName, handler) {
	        var /** @type {?} */ plugin = this._findPluginFor(eventName);
	        return plugin.addGlobalEventListener(target, eventName, handler);
	    };
	    /**
	     * @return {?}
	     */
	    EventManager.prototype.getZone = function () { return this._zone; };
	    /**
	     * \@internal
	     * @param {?} eventName
	     * @return {?}
	     */
	    EventManager.prototype._findPluginFor = function (eventName) {
	        var /** @type {?} */ plugin = this._eventNameToPlugin.get(eventName);
	        if (plugin) {
	            return plugin;
	        }
	        var /** @type {?} */ plugins = this._plugins;
	        for (var /** @type {?} */ i = 0; i < plugins.length; i++) {
	            var /** @type {?} */ plugin_1 = plugins[i];
	            if (plugin_1.supports(eventName)) {
	                this._eventNameToPlugin.set(eventName, plugin_1);
	                return plugin_1;
	            }
	        }
	        throw new Error("No event manager plugin found for event " + eventName);
	    };
	    return EventManager;
	}());
	EventManager.decorators = [
	    { type: _angular_core.Injectable },
	];
	/**
	 * @nocollapse
	 */
	EventManager.ctorParameters = function () { return [
	    { type: Array, decorators: [{ type: _angular_core.Inject, args: [EVENT_MANAGER_PLUGINS,] },] },
	    { type: _angular_core.NgZone, },
	]; };
	/**
	 * @abstract
	 */
	var EventManagerPlugin = (function () {
	    /**
	     * @param {?} _doc
	     */
	    function EventManagerPlugin(_doc) {
	        this._doc = _doc;
	    }
	    /**
	     * @abstract
	     * @param {?} eventName
	     * @return {?}
	     */
	    EventManagerPlugin.prototype.supports = function (eventName) { };
	    /**
	     * @abstract
	     * @param {?} element
	     * @param {?} eventName
	     * @param {?} handler
	     * @return {?}
	     */
	    EventManagerPlugin.prototype.addEventListener = function (element, eventName, handler) { };
	    /**
	     * @param {?} element
	     * @param {?} eventName
	     * @param {?} handler
	     * @return {?}
	     */
	    EventManagerPlugin.prototype.addGlobalEventListener = function (element, eventName, handler) {
	        var /** @type {?} */ target = getDOM().getGlobalEventTarget(this._doc, element);
	        if (!target) {
	            throw new Error("Unsupported event target " + target + " for event " + eventName);
	        }
	        return this.addEventListener(target, eventName, handler);
	    };
	    
	    return EventManagerPlugin;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var SharedStylesHost = (function () {
	    function SharedStylesHost() {
	        /**
	         * \@internal
	         */
	        this._stylesSet = new Set();
	    }
	    /**
	     * @param {?} styles
	     * @return {?}
	     */
	    SharedStylesHost.prototype.addStyles = function (styles) {
	        var _this = this;
	        var /** @type {?} */ additions = new Set();
	        styles.forEach(function (style) {
	            if (!_this._stylesSet.has(style)) {
	                _this._stylesSet.add(style);
	                additions.add(style);
	            }
	        });
	        this.onStylesAdded(additions);
	    };
	    /**
	     * @param {?} additions
	     * @return {?}
	     */
	    SharedStylesHost.prototype.onStylesAdded = function (additions) { };
	    /**
	     * @return {?}
	     */
	    SharedStylesHost.prototype.getAllStyles = function () { return Array.from(this._stylesSet); };
	    return SharedStylesHost;
	}());
	SharedStylesHost.decorators = [
	    { type: _angular_core.Injectable },
	];
	/**
	 * @nocollapse
	 */
	SharedStylesHost.ctorParameters = function () { return []; };
	var DomSharedStylesHost = (function (_super) {
	    __extends(DomSharedStylesHost, _super);
	    /**
	     * @param {?} _doc
	     */
	    function DomSharedStylesHost(_doc) {
	        var _this = _super.call(this) || this;
	        _this._doc = _doc;
	        _this._hostNodes = new Set();
	        _this._styleNodes = new Set();
	        _this._hostNodes.add(_doc.head);
	        return _this;
	    }
	    /**
	     * @param {?} styles
	     * @param {?} host
	     * @return {?}
	     */
	    DomSharedStylesHost.prototype._addStylesToHost = function (styles, host) {
	        var _this = this;
	        styles.forEach(function (style) {
	            var /** @type {?} */ styleEl = _this._doc.createElement('style');
	            styleEl.textContent = style;
	            _this._styleNodes.add(host.appendChild(styleEl));
	        });
	    };
	    /**
	     * @param {?} hostNode
	     * @return {?}
	     */
	    DomSharedStylesHost.prototype.addHost = function (hostNode) {
	        this._addStylesToHost(this._stylesSet, hostNode);
	        this._hostNodes.add(hostNode);
	    };
	    /**
	     * @param {?} hostNode
	     * @return {?}
	     */
	    DomSharedStylesHost.prototype.removeHost = function (hostNode) { this._hostNodes.delete(hostNode); };
	    /**
	     * @param {?} additions
	     * @return {?}
	     */
	    DomSharedStylesHost.prototype.onStylesAdded = function (additions) {
	        var _this = this;
	        this._hostNodes.forEach(function (hostNode) { return _this._addStylesToHost(additions, hostNode); });
	    };
	    /**
	     * @return {?}
	     */
	    DomSharedStylesHost.prototype.ngOnDestroy = function () { this._styleNodes.forEach(function (styleNode) { return getDOM().remove(styleNode); }); };
	    return DomSharedStylesHost;
	}(SharedStylesHost));
	DomSharedStylesHost.decorators = [
	    { type: _angular_core.Injectable },
	];
	/**
	 * @nocollapse
	 */
	DomSharedStylesHost.ctorParameters = function () { return [
	    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [DOCUMENT$1,] },] },
	]; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var NAMESPACE_URIS = {
	    'svg': 'http://www.w3.org/2000/svg',
	    'xhtml': 'http://www.w3.org/1999/xhtml',
	    'xlink': 'http://www.w3.org/1999/xlink',
	    'xml': 'http://www.w3.org/XML/1998/namespace',
	    'xmlns': 'http://www.w3.org/2000/xmlns/',
	};
	var COMPONENT_REGEX = /%COMP%/g;
	var COMPONENT_VARIABLE = '%COMP%';
	var HOST_ATTR = "_nghost-" + COMPONENT_VARIABLE;
	var CONTENT_ATTR = "_ngcontent-" + COMPONENT_VARIABLE;
	/**
	 * @param {?} componentShortId
	 * @return {?}
	 */
	function shimContentAttribute(componentShortId) {
	    return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);
	}
	/**
	 * @param {?} componentShortId
	 * @return {?}
	 */
	function shimHostAttribute(componentShortId) {
	    return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);
	}
	/**
	 * @param {?} compId
	 * @param {?} styles
	 * @param {?} target
	 * @return {?}
	 */
	function flattenStyles(compId, styles, target) {
	    for (var /** @type {?} */ i = 0; i < styles.length; i++) {
	        var /** @type {?} */ style = styles[i];
	        if (Array.isArray(style)) {
	            flattenStyles(compId, style, target);
	        }
	        else {
	            style = style.replace(COMPONENT_REGEX, compId);
	            target.push(style);
	        }
	    }
	    return target;
	}
	/**
	 * @param {?} eventHandler
	 * @return {?}
	 */
	function decoratePreventDefault(eventHandler) {
	    return function (event) {
	        var /** @type {?} */ allowDefaultBehavior = eventHandler(event);
	        if (allowDefaultBehavior === false) {
	            // TODO(tbosch): move preventDefault into event plugins...
	            event.preventDefault();
	            event.returnValue = false;
	        }
	    };
	}
	var DomRendererFactory2 = (function () {
	    /**
	     * @param {?} eventManager
	     * @param {?} sharedStylesHost
	     */
	    function DomRendererFactory2(eventManager, sharedStylesHost) {
	        this.eventManager = eventManager;
	        this.sharedStylesHost = sharedStylesHost;
	        this.rendererByCompId = new Map();
	        this.defaultRenderer = new DefaultDomRenderer2(eventManager);
	    }
	    
	    /**
	     * @param {?} element
	     * @param {?} type
	     * @return {?}
	     */
	    DomRendererFactory2.prototype.createRenderer = function (element, type) {
	        if (!element || !type) {
	            return this.defaultRenderer;
	        }
	        switch (type.encapsulation) {
	            case _angular_core.ViewEncapsulation.Emulated: {
	                var /** @type {?} */ renderer = this.rendererByCompId.get(type.id);
	                if (!renderer) {
	                    renderer =
	                        new EmulatedEncapsulationDomRenderer2(this.eventManager, this.sharedStylesHost, type);
	                    this.rendererByCompId.set(type.id, renderer);
	                }
	                ((renderer)).applyToHost(element);
	                return renderer;
	            }
	            case _angular_core.ViewEncapsulation.Native:
	                return new ShadowDomRenderer(this.eventManager, this.sharedStylesHost, element, type);
	            default: {
	                if (!this.rendererByCompId.has(type.id)) {
	                    var /** @type {?} */ styles = flattenStyles(type.id, type.styles, []);
	                    this.sharedStylesHost.addStyles(styles);
	                    this.rendererByCompId.set(type.id, this.defaultRenderer);
	                }
	                return this.defaultRenderer;
	            }
	        }
	    };
	    /**
	     * @return {?}
	     */
	    DomRendererFactory2.prototype.begin = function () { };
	    /**
	     * @return {?}
	     */
	    DomRendererFactory2.prototype.end = function () { };
	    return DomRendererFactory2;
	}());
	DomRendererFactory2.decorators = [
	    { type: _angular_core.Injectable },
	];
	/**
	 * @nocollapse
	 */
	DomRendererFactory2.ctorParameters = function () { return [
	    { type: EventManager, },
	    { type: DomSharedStylesHost, },
	]; };
	var DefaultDomRenderer2 = (function () {
	    /**
	     * @param {?} eventManager
	     */
	    function DefaultDomRenderer2(eventManager) {
	        this.eventManager = eventManager;
	        this.data = Object.create(null);
	    }
	    /**
	     * @return {?}
	     */
	    DefaultDomRenderer2.prototype.destroy = function () { };
	    /**
	     * @param {?} name
	     * @param {?=} namespace
	     * @return {?}
	     */
	    DefaultDomRenderer2.prototype.createElement = function (name, namespace) {
	        if (namespace) {
	            return document.createElementNS(NAMESPACE_URIS[namespace], name);
	        }
	        return document.createElement(name);
	    };
	    /**
	     * @param {?} value
	     * @return {?}
	     */
	    DefaultDomRenderer2.prototype.createComment = function (value) { return document.createComment(value); };
	    /**
	     * @param {?} value
	     * @return {?}
	     */
	    DefaultDomRenderer2.prototype.createText = function (value) { return document.createTextNode(value); };
	    /**
	     * @param {?} parent
	     * @param {?} newChild
	     * @return {?}
	     */
	    DefaultDomRenderer2.prototype.appendChild = function (parent, newChild) { parent.appendChild(newChild); };
	    /**
	     * @param {?} parent
	     * @param {?} newChild
	     * @param {?} refChild
	     * @return {?}
	     */
	    DefaultDomRenderer2.prototype.insertBefore = function (parent, newChild, refChild) {
	        if (parent) {
	            parent.insertBefore(newChild, refChild);
	        }
	    };
	    /**
	     * @param {?} parent
	     * @param {?} oldChild
	     * @return {?}
	     */
	    DefaultDomRenderer2.prototype.removeChild = function (parent, oldChild) {
	        if (parent) {
	            parent.removeChild(oldChild);
	        }
	    };
	    /**
	     * @param {?} selectorOrNode
	     * @return {?}
	     */
	    DefaultDomRenderer2.prototype.selectRootElement = function (selectorOrNode) {
	        var /** @type {?} */ el = typeof selectorOrNode === 'string' ? document.querySelector(selectorOrNode) :
	            selectorOrNode;
	        if (!el) {
	            throw new Error("The selector \"" + selectorOrNode + "\" did not match any elements");
	        }
	        el.textContent = '';
	        return el;
	    };
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    DefaultDomRenderer2.prototype.parentNode = function (node) { return node.parentNode; };
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    DefaultDomRenderer2.prototype.nextSibling = function (node) { return node.nextSibling; };
	    /**
	     * @param {?} el
	     * @param {?} name
	     * @param {?} value
	     * @param {?=} namespace
	     * @return {?}
	     */
	    DefaultDomRenderer2.prototype.setAttribute = function (el, name, value, namespace) {
	        if (namespace) {
	            name = namespace + ":" + name;
	            var /** @type {?} */ namespaceUri = NAMESPACE_URIS[namespace];
	            if (namespaceUri) {
	                el.setAttributeNS(namespaceUri, name, value);
	            }
	            else {
	                el.setAttribute(name, value);
	            }
	        }
	        else {
	            el.setAttribute(name, value);
	        }
	    };
	    /**
	     * @param {?} el
	     * @param {?} name
	     * @param {?=} namespace
	     * @return {?}
	     */
	    DefaultDomRenderer2.prototype.removeAttribute = function (el, name, namespace) {
	        if (namespace) {
	            var /** @type {?} */ namespaceUri = NAMESPACE_URIS[namespace];
	            if (namespaceUri) {
	                el.removeAttributeNS(namespaceUri, name);
	            }
	            else {
	                el.removeAttribute(namespace + ":" + name);
	            }
	        }
	        else {
	            el.removeAttribute(name);
	        }
	    };
	    /**
	     * @param {?} el
	     * @param {?} name
	     * @return {?}
	     */
	    DefaultDomRenderer2.prototype.addClass = function (el, name) { el.classList.add(name); };
	    /**
	     * @param {?} el
	     * @param {?} name
	     * @return {?}
	     */
	    DefaultDomRenderer2.prototype.removeClass = function (el, name) { el.classList.remove(name); };
	    /**
	     * @param {?} el
	     * @param {?} style
	     * @param {?} value
	     * @param {?} flags
	     * @return {?}
	     */
	    DefaultDomRenderer2.prototype.setStyle = function (el, style, value, flags) {
	        if (flags & _angular_core.RendererStyleFlags2.DashCase) {
	            el.style.setProperty(style, value, !!(flags & _angular_core.RendererStyleFlags2.Important) ? 'important' : '');
	        }
	        else {
	            el.style[style] = value;
	        }
	    };
	    /**
	     * @param {?} el
	     * @param {?} style
	     * @param {?} flags
	     * @return {?}
	     */
	    DefaultDomRenderer2.prototype.removeStyle = function (el, style, flags) {
	        if (flags & _angular_core.RendererStyleFlags2.DashCase) {
	            el.style.removeProperty(style);
	        }
	        else {
	            // IE requires '' instead of null
	            // see https://github.com/angular/angular/issues/7916
	            el.style[style] = '';
	        }
	    };
	    /**
	     * @param {?} el
	     * @param {?} name
	     * @param {?} value
	     * @return {?}
	     */
	    DefaultDomRenderer2.prototype.setProperty = function (el, name, value) {
	        checkNoSyntheticProp(name, 'property');
	        el[name] = value;
	    };
	    /**
	     * @param {?} node
	     * @param {?} value
	     * @return {?}
	     */
	    DefaultDomRenderer2.prototype.setValue = function (node, value) { node.nodeValue = value; };
	    /**
	     * @param {?} target
	     * @param {?} event
	     * @param {?} callback
	     * @return {?}
	     */
	    DefaultDomRenderer2.prototype.listen = function (target, event, callback) {
	        checkNoSyntheticProp(event, 'listener');
	        if (typeof target === 'string') {
	            return (this.eventManager.addGlobalEventListener(target, event, decoratePreventDefault(callback)));
	        }
	        return ((this.eventManager.addEventListener(target, event, decoratePreventDefault(callback))));
	    };
	    return DefaultDomRenderer2;
	}());
	var AT_CHARCODE = '@'.charCodeAt(0);
	/**
	 * @param {?} name
	 * @param {?} nameKind
	 * @return {?}
	 */
	function checkNoSyntheticProp(name, nameKind) {
	    if (name.charCodeAt(0) === AT_CHARCODE) {
	        throw new Error("Found the synthetic " + nameKind + " " + name + ". Please include either \"BrowserAnimationsModule\" or \"NoopAnimationsModule\" in your application.");
	    }
	}
	var EmulatedEncapsulationDomRenderer2 = (function (_super) {
	    __extends(EmulatedEncapsulationDomRenderer2, _super);
	    /**
	     * @param {?} eventManager
	     * @param {?} sharedStylesHost
	     * @param {?} component
	     */
	    function EmulatedEncapsulationDomRenderer2(eventManager, sharedStylesHost, component) {
	        var _this = _super.call(this, eventManager) || this;
	        _this.component = component;
	        var styles = flattenStyles(component.id, component.styles, []);
	        sharedStylesHost.addStyles(styles);
	        _this.contentAttr = shimContentAttribute(component.id);
	        _this.hostAttr = shimHostAttribute(component.id);
	        return _this;
	    }
	    /**
	     * @param {?} element
	     * @return {?}
	     */
	    EmulatedEncapsulationDomRenderer2.prototype.applyToHost = function (element) { _super.prototype.setAttribute.call(this, element, this.hostAttr, ''); };
	    /**
	     * @param {?} parent
	     * @param {?} name
	     * @return {?}
	     */
	    EmulatedEncapsulationDomRenderer2.prototype.createElement = function (parent, name) {
	        var /** @type {?} */ el = _super.prototype.createElement.call(this, parent, name);
	        _super.prototype.setAttribute.call(this, el, this.contentAttr, '');
	        return el;
	    };
	    return EmulatedEncapsulationDomRenderer2;
	}(DefaultDomRenderer2));
	var ShadowDomRenderer = (function (_super) {
	    __extends(ShadowDomRenderer, _super);
	    /**
	     * @param {?} eventManager
	     * @param {?} sharedStylesHost
	     * @param {?} hostEl
	     * @param {?} component
	     */
	    function ShadowDomRenderer(eventManager, sharedStylesHost, hostEl, component) {
	        var _this = _super.call(this, eventManager) || this;
	        _this.sharedStylesHost = sharedStylesHost;
	        _this.hostEl = hostEl;
	        _this.component = component;
	        _this.shadowRoot = hostEl.createShadowRoot();
	        _this.sharedStylesHost.addHost(_this.shadowRoot);
	        var styles = flattenStyles(component.id, component.styles, []);
	        for (var i = 0; i < styles.length; i++) {
	            var styleEl = document.createElement('style');
	            styleEl.textContent = styles[i];
	            _this.shadowRoot.appendChild(styleEl);
	        }
	        return _this;
	    }
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    ShadowDomRenderer.prototype.nodeOrShadowRoot = function (node) { return node === this.hostEl ? this.shadowRoot : node; };
	    /**
	     * @return {?}
	     */
	    ShadowDomRenderer.prototype.destroy = function () { this.sharedStylesHost.removeHost(this.shadowRoot); };
	    /**
	     * @param {?} parent
	     * @param {?} newChild
	     * @return {?}
	     */
	    ShadowDomRenderer.prototype.appendChild = function (parent, newChild) {
	        return _super.prototype.appendChild.call(this, this.nodeOrShadowRoot(parent), newChild);
	    };
	    /**
	     * @param {?} parent
	     * @param {?} newChild
	     * @param {?} refChild
	     * @return {?}
	     */
	    ShadowDomRenderer.prototype.insertBefore = function (parent, newChild, refChild) {
	        return _super.prototype.insertBefore.call(this, this.nodeOrShadowRoot(parent), newChild, refChild);
	    };
	    /**
	     * @param {?} parent
	     * @param {?} oldChild
	     * @return {?}
	     */
	    ShadowDomRenderer.prototype.removeChild = function (parent, oldChild) {
	        return _super.prototype.removeChild.call(this, this.nodeOrShadowRoot(parent), oldChild);
	    };
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    ShadowDomRenderer.prototype.parentNode = function (node) {
	        return this.nodeOrShadowRoot(_super.prototype.parentNode.call(this, this.nodeOrShadowRoot(node)));
	    };
	    return ShadowDomRenderer;
	}(DefaultDomRenderer2));
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var DomEventsPlugin = (function (_super) {
	    __extends(DomEventsPlugin, _super);
	    /**
	     * @param {?} doc
	     */
	    function DomEventsPlugin(doc) {
	        return _super.call(this, doc) || this;
	    }
	    /**
	     * @param {?} eventName
	     * @return {?}
	     */
	    DomEventsPlugin.prototype.supports = function (eventName) { return true; };
	    /**
	     * @param {?} element
	     * @param {?} eventName
	     * @param {?} handler
	     * @return {?}
	     */
	    DomEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {
	        element.addEventListener(eventName, /** @type {?} */ (handler), false);
	        return function () { return element.removeEventListener(eventName, /** @type {?} */ (handler), false); };
	    };
	    return DomEventsPlugin;
	}(EventManagerPlugin));
	DomEventsPlugin.decorators = [
	    { type: _angular_core.Injectable },
	];
	/**
	 * @nocollapse
	 */
	DomEventsPlugin.ctorParameters = function () { return [
	    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [DOCUMENT$1,] },] },
	]; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var EVENT_NAMES = {
	    // pan
	    'pan': true,
	    'panstart': true,
	    'panmove': true,
	    'panend': true,
	    'pancancel': true,
	    'panleft': true,
	    'panright': true,
	    'panup': true,
	    'pandown': true,
	    // pinch
	    'pinch': true,
	    'pinchstart': true,
	    'pinchmove': true,
	    'pinchend': true,
	    'pinchcancel': true,
	    'pinchin': true,
	    'pinchout': true,
	    // press
	    'press': true,
	    'pressup': true,
	    // rotate
	    'rotate': true,
	    'rotatestart': true,
	    'rotatemove': true,
	    'rotateend': true,
	    'rotatecancel': true,
	    // swipe
	    'swipe': true,
	    'swipeleft': true,
	    'swiperight': true,
	    'swipeup': true,
	    'swipedown': true,
	    // tap
	    'tap': true,
	};
	/**
	 * A DI token that you can use to provide{\@link HammerGestureConfig} to Angular. Use it to configure
	 * Hammer gestures.
	 *
	 * \@experimental
	 */
	var HAMMER_GESTURE_CONFIG = new _angular_core.InjectionToken('HammerGestureConfig');
	/**
	 * \@experimental
	 */
	var HammerGestureConfig = (function () {
	    function HammerGestureConfig() {
	        this.events = [];
	        this.overrides = {};
	    }
	    /**
	     * @param {?} element
	     * @return {?}
	     */
	    HammerGestureConfig.prototype.buildHammer = function (element) {
	        var /** @type {?} */ mc = new Hammer(element);
	        mc.get('pinch').set({ enable: true });
	        mc.get('rotate').set({ enable: true });
	        for (var /** @type {?} */ eventName in this.overrides) {
	            mc.get(eventName).set(this.overrides[eventName]);
	        }
	        return mc;
	    };
	    return HammerGestureConfig;
	}());
	HammerGestureConfig.decorators = [
	    { type: _angular_core.Injectable },
	];
	/**
	 * @nocollapse
	 */
	HammerGestureConfig.ctorParameters = function () { return []; };
	var HammerGesturesPlugin = (function (_super) {
	    __extends(HammerGesturesPlugin, _super);
	    /**
	     * @param {?} doc
	     * @param {?} _config
	     */
	    function HammerGesturesPlugin(doc, _config) {
	        var _this = _super.call(this, doc) || this;
	        _this._config = _config;
	        return _this;
	    }
	    /**
	     * @param {?} eventName
	     * @return {?}
	     */
	    HammerGesturesPlugin.prototype.supports = function (eventName) {
	        if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {
	            return false;
	        }
	        if (!((window)).Hammer) {
	            throw new Error("Hammer.js is not loaded, can not bind " + eventName + " event");
	        }
	        return true;
	    };
	    /**
	     * @param {?} element
	     * @param {?} eventName
	     * @param {?} handler
	     * @return {?}
	     */
	    HammerGesturesPlugin.prototype.addEventListener = function (element, eventName, handler) {
	        var _this = this;
	        var /** @type {?} */ zone = this.manager.getZone();
	        eventName = eventName.toLowerCase();
	        return zone.runOutsideAngular(function () {
	            // Creating the manager bind events, must be done outside of angular
	            var /** @type {?} */ mc = _this._config.buildHammer(element);
	            var /** @type {?} */ callback = function (eventObj) {
	                zone.runGuarded(function () { handler(eventObj); });
	            };
	            mc.on(eventName, callback);
	            return function () { return mc.off(eventName, callback); };
	        });
	    };
	    /**
	     * @param {?} eventName
	     * @return {?}
	     */
	    HammerGesturesPlugin.prototype.isCustomEvent = function (eventName) { return this._config.events.indexOf(eventName) > -1; };
	    return HammerGesturesPlugin;
	}(EventManagerPlugin));
	HammerGesturesPlugin.decorators = [
	    { type: _angular_core.Injectable },
	];
	/**
	 * @nocollapse
	 */
	HammerGesturesPlugin.ctorParameters = function () { return [
	    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [DOCUMENT$1,] },] },
	    { type: HammerGestureConfig, decorators: [{ type: _angular_core.Inject, args: [HAMMER_GESTURE_CONFIG,] },] },
	]; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var MODIFIER_KEYS = ['alt', 'control', 'meta', 'shift'];
	var MODIFIER_KEY_GETTERS = {
	    'alt': function (event) { return event.altKey; },
	    'control': function (event) { return event.ctrlKey; },
	    'meta': function (event) { return event.metaKey; },
	    'shift': function (event) { return event.shiftKey; }
	};
	/**
	 * \@experimental
	 */
	var KeyEventsPlugin = (function (_super) {
	    __extends(KeyEventsPlugin, _super);
	    /**
	     * @param {?} doc
	     */
	    function KeyEventsPlugin(doc) {
	        return _super.call(this, doc) || this;
	    }
	    /**
	     * @param {?} eventName
	     * @return {?}
	     */
	    KeyEventsPlugin.prototype.supports = function (eventName) { return KeyEventsPlugin.parseEventName(eventName) != null; };
	    /**
	     * @param {?} element
	     * @param {?} eventName
	     * @param {?} handler
	     * @return {?}
	     */
	    KeyEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {
	        var /** @type {?} */ parsedEvent = ((KeyEventsPlugin.parseEventName(eventName)));
	        var /** @type {?} */ outsideHandler = KeyEventsPlugin.eventCallback(parsedEvent['fullKey'], handler, this.manager.getZone());
	        return this.manager.getZone().runOutsideAngular(function () {
	            return getDOM().onAndCancel(element, parsedEvent['domEventName'], outsideHandler);
	        });
	    };
	    /**
	     * @param {?} eventName
	     * @return {?}
	     */
	    KeyEventsPlugin.parseEventName = function (eventName) {
	        var /** @type {?} */ parts = eventName.toLowerCase().split('.');
	        var /** @type {?} */ domEventName = parts.shift();
	        if ((parts.length === 0) || !(domEventName === 'keydown' || domEventName === 'keyup')) {
	            return null;
	        }
	        var /** @type {?} */ key = KeyEventsPlugin._normalizeKey(/** @type {?} */ ((parts.pop())));
	        var /** @type {?} */ fullKey = '';
	        MODIFIER_KEYS.forEach(function (modifierName) {
	            var /** @type {?} */ index = parts.indexOf(modifierName);
	            if (index > -1) {
	                parts.splice(index, 1);
	                fullKey += modifierName + '.';
	            }
	        });
	        fullKey += key;
	        if (parts.length != 0 || key.length === 0) {
	            // returning null instead of throwing to let another plugin process the event
	            return null;
	        }
	        var /** @type {?} */ result = {};
	        result['domEventName'] = domEventName;
	        result['fullKey'] = fullKey;
	        return result;
	    };
	    /**
	     * @param {?} event
	     * @return {?}
	     */
	    KeyEventsPlugin.getEventFullKey = function (event) {
	        var /** @type {?} */ fullKey = '';
	        var /** @type {?} */ key = getDOM().getEventKey(event);
	        key = key.toLowerCase();
	        if (key === ' ') {
	            key = 'space'; // for readability
	        }
	        else if (key === '.') {
	            key = 'dot'; // because '.' is used as a separator in event names
	        }
	        MODIFIER_KEYS.forEach(function (modifierName) {
	            if (modifierName != key) {
	                var /** @type {?} */ modifierGetter = MODIFIER_KEY_GETTERS[modifierName];
	                if (modifierGetter(event)) {
	                    fullKey += modifierName + '.';
	                }
	            }
	        });
	        fullKey += key;
	        return fullKey;
	    };
	    /**
	     * @param {?} fullKey
	     * @param {?} handler
	     * @param {?} zone
	     * @return {?}
	     */
	    KeyEventsPlugin.eventCallback = function (fullKey, handler, zone) {
	        return function (event /** TODO #9100 */) {
	            if (KeyEventsPlugin.getEventFullKey(event) === fullKey) {
	                zone.runGuarded(function () { return handler(event); });
	            }
	        };
	    };
	    /**
	     * \@internal
	     * @param {?} keyName
	     * @return {?}
	     */
	    KeyEventsPlugin._normalizeKey = function (keyName) {
	        // TODO: switch to a Map if the mapping grows too much
	        switch (keyName) {
	            case 'esc':
	                return 'escape';
	            default:
	                return keyName;
	        }
	    };
	    return KeyEventsPlugin;
	}(EventManagerPlugin));
	KeyEventsPlugin.decorators = [
	    { type: _angular_core.Injectable },
	];
	/**
	 * @nocollapse
	 */
	KeyEventsPlugin.ctorParameters = function () { return [
	    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [DOCUMENT$1,] },] },
	]; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * A pattern that recognizes a commonly useful subset of URLs that are safe.
	 *
	 * This regular expression matches a subset of URLs that will not cause script
	 * execution if used in URL context within a HTML document. Specifically, this
	 * regular expression matches if (comment from here on and regex copied from
	 * Soy's EscapingConventions):
	 * (1) Either a protocol in a whitelist (http, https, mailto or ftp).
	 * (2) or no protocol.  A protocol must be followed by a colon. The below
	 *     allows that by allowing colons only after one of the characters [/?#].
	 *     A colon after a hash (#) must be in the fragment.
	 *     Otherwise, a colon after a (?) must be in a query.
	 *     Otherwise, a colon after a single solidus (/) must be in a path.
	 *     Otherwise, a colon after a double solidus (//) must be in the authority
	 *     (before port).
	 *
	 * The pattern disallows &, used in HTML entity declarations before
	 * one of the characters in [/?#]. This disallows HTML entities used in the
	 * protocol name, which should never happen, e.g. "h&#116;tp" for "http".
	 * It also disallows HTML entities in the first path part of a relative path,
	 * e.g. "foo&lt;bar/baz".  Our existing escaping functions should not produce
	 * that. More importantly, it disallows masking of a colon,
	 * e.g. "javascript&#58;...".
	 *
	 * This regular expression was taken from the Closure sanitization library.
	 */
	var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;
	/**
	 * A pattern that matches safe data URLs. Only matches image, video and audio types.
	 */
	var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;
	/**
	 * @param {?} url
	 * @return {?}
	 */
	function sanitizeUrl(url) {
	    url = String(url);
	    if (url.match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN))
	        return url;
	    if (_angular_core.isDevMode()) {
	        getDOM().log("WARNING: sanitizing unsafe URL value " + url + " (see http://g.co/ng/security#xss)");
	    }
	    return 'unsafe:' + url;
	}
	/**
	 * @param {?} srcset
	 * @return {?}
	 */
	function sanitizeSrcset(srcset) {
	    srcset = String(srcset);
	    return srcset.split(',').map(function (srcset) { return sanitizeUrl(srcset.trim()); }).join(', ');
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * A <body> element that can be safely used to parse untrusted HTML. Lazily initialized below.
	 */
	var inertElement = null;
	/**
	 * Lazily initialized to make sure the DOM adapter gets set before use.
	 */
	var DOM = null;
	/**
	 * Returns an HTML element that is guaranteed to not execute code when creating elements in it.
	 * @return {?}
	 */
	function getInertElement() {
	    if (inertElement)
	        return inertElement;
	    DOM = getDOM();
	    // Prefer using <template> element if supported.
	    var /** @type {?} */ templateEl = DOM.createElement('template');
	    if ('content' in templateEl)
	        return templateEl;
	    var /** @type {?} */ doc = DOM.createHtmlDocument();
	    inertElement = DOM.querySelector(doc, 'body');
	    if (inertElement == null) {
	        // usually there should be only one body element in the document, but IE doesn't have any, so we
	        // need to create one.
	        var /** @type {?} */ html = DOM.createElement('html', doc);
	        inertElement = DOM.createElement('body', doc);
	        DOM.appendChild(html, inertElement);
	        DOM.appendChild(doc, html);
	    }
	    return inertElement;
	}
	/**
	 * @param {?} tags
	 * @return {?}
	 */
	function tagSet(tags) {
	    var /** @type {?} */ res = {};
	    for (var _i = 0, _a = tags.split(','); _i < _a.length; _i++) {
	        var t = _a[_i];
	        res[t] = true;
	    }
	    return res;
	}
	/**
	 * @param {...?} sets
	 * @return {?}
	 */
	function merge() {
	    var sets = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        sets[_i] = arguments[_i];
	    }
	    var /** @type {?} */ res = {};
	    for (var _a = 0, sets_1 = sets; _a < sets_1.length; _a++) {
	        var s = sets_1[_a];
	        for (var /** @type {?} */ v in s) {
	            if (s.hasOwnProperty(v))
	                res[v] = true;
	        }
	    }
	    return res;
	}
	// Good source of info about elements and attributes
	// http://dev.w3.org/html5/spec/Overview.html#semantics
	// http://simon.html5.org/html-elements
	// Safe Void Elements - HTML5
	// http://dev.w3.org/html5/spec/Overview.html#void-elements
	var VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');
	// Elements that you can, intentionally, leave open (and which close themselves)
	// http://dev.w3.org/html5/spec/Overview.html#optional-tags
	var OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');
	var OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');
	var OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);
	// Safe Block Elements - HTML5
	var BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet('address,article,' +
	    'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' +
	    'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));
	// Inline Elements - HTML5
	var INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet('a,abbr,acronym,audio,b,' +
	    'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' +
	    'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));
	var VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);
	// Attributes that have href and hence need to be sanitized
	var URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');
	// Attributes that have special href set hence need to be sanitized
	var SRCSET_ATTRS = tagSet('srcset');
	var HTML_ATTRS = tagSet('abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' +
	    'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' +
	    'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' +
	    'scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,' +
	    'valign,value,vspace,width');
	// NB: This currently consciously doesn't support SVG. SVG sanitization has had several security
	// issues in the past, so it seems safer to leave it out if possible. If support for binding SVG via
	// innerHTML is required, SVG attributes should be added here.
	// NB: Sanitization does not allow <form> elements or other active elements (<button> etc). Those
	// can be sanitized, but they increase security surface area without a legitimate use case, so they
	// are left out here.
	var VALID_ATTRS = merge(URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS);
	/**
	 * SanitizingHtmlSerializer serializes a DOM fragment, stripping out any unsafe elements and unsafe
	 * attributes.
	 */
	var SanitizingHtmlSerializer = (function () {
	    function SanitizingHtmlSerializer() {
	        this.sanitizedSomething = false;
	        this.buf = [];
	    }
	    /**
	     * @param {?} el
	     * @return {?}
	     */
	    SanitizingHtmlSerializer.prototype.sanitizeChildren = function (el) {
	        // This cannot use a TreeWalker, as it has to run on Angular's various DOM adapters.
	        // However this code never accesses properties off of `document` before deleting its contents
	        // again, so it shouldn't be vulnerable to DOM clobbering.
	        var /** @type {?} */ current = ((el.firstChild));
	        while (current) {
	            if (DOM.isElementNode(current)) {
	                this.startElement(/** @type {?} */ (current));
	            }
	            else if (DOM.isTextNode(current)) {
	                this.chars(/** @type {?} */ ((DOM.nodeValue(current))));
	            }
	            else {
	                // Strip non-element, non-text nodes.
	                this.sanitizedSomething = true;
	            }
	            if (DOM.firstChild(current)) {
	                current = ((DOM.firstChild(current)));
	                continue;
	            }
	            while (current) {
	                // Leaving the element. Walk up and to the right, closing tags as we go.
	                if (DOM.isElementNode(current)) {
	                    this.endElement(/** @type {?} */ (current));
	                }
	                var /** @type {?} */ next = checkClobberedElement(current, /** @type {?} */ ((DOM.nextSibling(current))));
	                if (next) {
	                    current = next;
	                    break;
	                }
	                current = checkClobberedElement(current, /** @type {?} */ ((DOM.parentElement(current))));
	            }
	        }
	        return this.buf.join('');
	    };
	    /**
	     * @param {?} element
	     * @return {?}
	     */
	    SanitizingHtmlSerializer.prototype.startElement = function (element) {
	        var _this = this;
	        var /** @type {?} */ tagName = DOM.nodeName(element).toLowerCase();
	        if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {
	            this.sanitizedSomething = true;
	            return;
	        }
	        this.buf.push('<');
	        this.buf.push(tagName);
	        DOM.attributeMap(element).forEach(function (value, attrName) {
	            var /** @type {?} */ lower = attrName.toLowerCase();
	            if (!VALID_ATTRS.hasOwnProperty(lower)) {
	                _this.sanitizedSomething = true;
	                return;
	            }
	            // TODO(martinprobst): Special case image URIs for data:image/...
	            if (URI_ATTRS[lower])
	                value = sanitizeUrl(value);
	            if (SRCSET_ATTRS[lower])
	                value = sanitizeSrcset(value);
	            _this.buf.push(' ');
	            _this.buf.push(attrName);
	            _this.buf.push('="');
	            _this.buf.push(encodeEntities(value));
	            _this.buf.push('"');
	        });
	        this.buf.push('>');
	    };
	    /**
	     * @param {?} current
	     * @return {?}
	     */
	    SanitizingHtmlSerializer.prototype.endElement = function (current) {
	        var /** @type {?} */ tagName = DOM.nodeName(current).toLowerCase();
	        if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {
	            this.buf.push('</');
	            this.buf.push(tagName);
	            this.buf.push('>');
	        }
	    };
	    /**
	     * @param {?} chars
	     * @return {?}
	     */
	    SanitizingHtmlSerializer.prototype.chars = function (chars) { this.buf.push(encodeEntities(chars)); };
	    return SanitizingHtmlSerializer;
	}());
	/**
	 * @param {?} node
	 * @param {?} nextNode
	 * @return {?}
	 */
	function checkClobberedElement(node, nextNode) {
	    if (nextNode && DOM.contains(node, nextNode)) {
	        throw new Error("Failed to sanitize html because the element is clobbered: " + DOM.getOuterHTML(node));
	    }
	    return nextNode;
	}
	// Regular Expressions for parsing tags and attributes
	var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
	// ! to ~ is the ASCII range.
	var NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
	/**
	 * Escapes all potentially dangerous characters, so that the
	 * resulting string can be safely inserted into attribute or
	 * element text.
	 * @param {?} value
	 * @return {?}
	 */
	function encodeEntities(value) {
	    return value.replace(/&/g, '&amp;')
	        .replace(SURROGATE_PAIR_REGEXP, function (match) {
	        var /** @type {?} */ hi = match.charCodeAt(0);
	        var /** @type {?} */ low = match.charCodeAt(1);
	        return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
	    })
	        .replace(NON_ALPHANUMERIC_REGEXP, function (match) { return '&#' + match.charCodeAt(0) + ';'; })
	        .replace(/</g, '&lt;')
	        .replace(/>/g, '&gt;');
	}
	/**
	 * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1'
	 * attribute to declare ns1 namespace and prefixes the attribute with 'ns1' (e.g. 'ns1:xlink:foo').
	 *
	 * This is undesirable since we don't want to allow any of these custom attributes. This method
	 * strips them all.
	 * @param {?} el
	 * @return {?}
	 */
	function stripCustomNsAttrs(el) {
	    DOM.attributeMap(el).forEach(function (_, attrName) {
	        if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {
	            DOM.removeAttribute(el, attrName);
	        }
	    });
	    for (var _i = 0, _a = DOM.childNodesAsList(el); _i < _a.length; _i++) {
	        var n = _a[_i];
	        if (DOM.isElementNode(n))
	            stripCustomNsAttrs(/** @type {?} */ (n));
	    }
	}
	/**
	 * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to
	 * the DOM in a browser environment.
	 * @param {?} defaultDoc
	 * @param {?} unsafeHtmlInput
	 * @return {?}
	 */
	function sanitizeHtml(defaultDoc, unsafeHtmlInput) {
	    try {
	        var /** @type {?} */ containerEl = getInertElement();
	        // Make sure unsafeHtml is actually a string (TypeScript types are not enforced at runtime).
	        var /** @type {?} */ unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';
	        // mXSS protection. Repeatedly parse the document to make sure it stabilizes, so that a browser
	        // trying to auto-correct incorrect HTML cannot cause formerly inert HTML to become dangerous.
	        var /** @type {?} */ mXSSAttempts = 5;
	        var /** @type {?} */ parsedHtml = unsafeHtml;
	        do {
	            if (mXSSAttempts === 0) {
	                throw new Error('Failed to sanitize html because the input is unstable');
	            }
	            mXSSAttempts--;
	            unsafeHtml = parsedHtml;
	            DOM.setInnerHTML(containerEl, unsafeHtml);
	            if (defaultDoc.documentMode) {
	                // strip custom-namespaced attributes on IE<=11
	                stripCustomNsAttrs(containerEl);
	            }
	            parsedHtml = DOM.getInnerHTML(containerEl);
	        } while (unsafeHtml !== parsedHtml);
	        var /** @type {?} */ sanitizer = new SanitizingHtmlSerializer();
	        var /** @type {?} */ safeHtml = sanitizer.sanitizeChildren(DOM.getTemplateContent(containerEl) || containerEl);
	        // Clear out the body element.
	        var /** @type {?} */ parent = DOM.getTemplateContent(containerEl) || containerEl;
	        for (var _i = 0, _a = DOM.childNodesAsList(parent); _i < _a.length; _i++) {
	            var child = _a[_i];
	            DOM.removeChild(parent, child);
	        }
	        if (_angular_core.isDevMode() && sanitizer.sanitizedSomething) {
	            DOM.log('WARNING: sanitizing HTML stripped some content (see http://g.co/ng/security#xss).');
	        }
	        return safeHtml;
	    }
	    catch (e) {
	        // In case anything goes wrong, clear out inertElement to reset the entire DOM structure.
	        inertElement = null;
	        throw e;
	    }
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Regular expression for safe style values.
	 *
	 * Quotes (" and ') are allowed, but a check must be done elsewhere to ensure they're balanced.
	 *
	 * ',' allows multiple values to be assigned to the same property (e.g. background-attachment or
	 * font-family) and hence could allow multiple values to get injected, but that should pose no risk
	 * of XSS.
	 *
	 * The function expression checks only for XSS safety, not for CSS validity.
	 *
	 * This regular expression was taken from the Closure sanitization library, and augmented for
	 * transformation values.
	 */
	var VALUES = '[-,."\'%_!# a-zA-Z0-9]+';
	var TRANSFORMATION_FNS = '(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|3d)?';
	var COLOR_FNS = '(?:rgb|hsl)a?';
	var GRADIENTS = '(?:repeating-)?(?:linear|radial)-gradient';
	var CSS3_FNS = '(?:calc|attr)';
	var FN_ARGS = '\\([-0-9.%, #a-zA-Z]+\\)';
	var SAFE_STYLE_VALUE = new RegExp("^(" + VALUES + "|" +
	    ("(?:" + TRANSFORMATION_FNS + "|" + COLOR_FNS + "|" + GRADIENTS + "|" + CSS3_FNS + ")") +
	    (FN_ARGS + ")$"), 'g');
	/**
	 * Matches a `url(...)` value with an arbitrary argument as long as it does
	 * not contain parentheses.
	 *
	 * The URL value still needs to be sanitized separately.
	 *
	 * `url(...)` values are a very common use case, e.g. for `background-image`. With carefully crafted
	 * CSS style rules, it is possible to construct an information leak with `url` values in CSS, e.g.
	 * by observing whether scroll bars are displayed, or character ranges used by a font face
	 * definition.
	 *
	 * Angular only allows binding CSS values (as opposed to entire CSS rules), so it is unlikely that
	 * binding a URL value without further cooperation from the page will cause an information leak, and
	 * if so, it is just a leak, not a full blown XSS vulnerability.
	 *
	 * Given the common use case, low likelihood of attack vector, and low impact of an attack, this
	 * code is permissive and allows URLs that sanitize otherwise.
	 */
	var URL_RE = /^url\(([^)]+)\)$/;
	/**
	 * Checks that quotes (" and ') are properly balanced inside a string. Assumes
	 * that neither escape (\) nor any other character that could result in
	 * breaking out of a string parsing context are allowed;
	 * see http://www.w3.org/TR/css3-syntax/#string-token-diagram.
	 *
	 * This code was taken from the Closure sanitization library.
	 * @param {?} value
	 * @return {?}
	 */
	function hasBalancedQuotes(value) {
	    var /** @type {?} */ outsideSingle = true;
	    var /** @type {?} */ outsideDouble = true;
	    for (var /** @type {?} */ i = 0; i < value.length; i++) {
	        var /** @type {?} */ c = value.charAt(i);
	        if (c === '\'' && outsideDouble) {
	            outsideSingle = !outsideSingle;
	        }
	        else if (c === '"' && outsideSingle) {
	            outsideDouble = !outsideDouble;
	        }
	    }
	    return outsideSingle && outsideDouble;
	}
	/**
	 * Sanitizes the given untrusted CSS style property value (i.e. not an entire object, just a single
	 * value) and returns a value that is safe to use in a browser environment.
	 * @param {?} value
	 * @return {?}
	 */
	function sanitizeStyle(value) {
	    value = String(value).trim(); // Make sure it's actually a string.
	    if (!value)
	        return '';
	    // Single url(...) values are supported, but only for URLs that sanitize cleanly. See above for
	    // reasoning behind this.
	    var /** @type {?} */ urlMatch = value.match(URL_RE);
	    if ((urlMatch && sanitizeUrl(urlMatch[1]) === urlMatch[1]) ||
	        value.match(SAFE_STYLE_VALUE) && hasBalancedQuotes(value)) {
	        return value; // Safe style values.
	    }
	    if (_angular_core.isDevMode()) {
	        getDOM().log("WARNING: sanitizing unsafe style value " + value + " (see http://g.co/ng/security#xss).");
	    }
	    return 'unsafe';
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * DomSanitizer helps preventing Cross Site Scripting Security bugs (XSS) by sanitizing
	 * values to be safe to use in the different DOM contexts.
	 *
	 * For example, when binding a URL in an `<a [href]="someValue">` hyperlink, `someValue` will be
	 * sanitized so that an attacker cannot inject e.g. a `javascript:` URL that would execute code on
	 * the website.
	 *
	 * In specific situations, it might be necessary to disable sanitization, for example if the
	 * application genuinely needs to produce a `javascript:` style link with a dynamic value in it.
	 * Users can bypass security by constructing a value with one of the `bypassSecurityTrust...`
	 * methods, and then binding to that value from the template.
	 *
	 * These situations should be very rare, and extraordinary care must be taken to avoid creating a
	 * Cross Site Scripting (XSS) security bug!
	 *
	 * When using `bypassSecurityTrust...`, make sure to call the method as early as possible and as
	 * close as possible to the source of the value, to make it easy to verify no security bug is
	 * created by its use.
	 *
	 * It is not required (and not recommended) to bypass security if the value is safe, e.g. a URL that
	 * does not start with a suspicious protocol, or an HTML snippet that does not contain dangerous
	 * code. The sanitizer leaves safe values intact.
	 *
	 * \@security Calling any of the `bypassSecurityTrust...` APIs disables Angular's built-in
	 * sanitization for the value passed in. Carefully check and audit all values and code paths going
	 * into this call. Make sure any user data is appropriately escaped for this security context.
	 * For more detail, see the [Security Guide](http://g.co/ng/security).
	 *
	 * \@stable
	 * @abstract
	 */
	var DomSanitizer = (function () {
	    function DomSanitizer() {
	    }
	    /**
	     * Sanitizes a value for use in the given SecurityContext.
	     *
	     * If value is trusted for the context, this method will unwrap the contained safe value and use
	     * it directly. Otherwise, value will be sanitized to be safe in the given context, for example
	     * by replacing URLs that have an unsafe protocol part (such as `javascript:`). The implementation
	     * is responsible to make sure that the value can definitely be safely used in the given context.
	     * @abstract
	     * @param {?} context
	     * @param {?} value
	     * @return {?}
	     */
	    DomSanitizer.prototype.sanitize = function (context, value) { };
	    /**
	     * Bypass security and trust the given value to be safe HTML. Only use this when the bound HTML
	     * is unsafe (e.g. contains `<script>` tags) and the code should be executed. The sanitizer will
	     * leave safe HTML intact, so in most situations this method should not be used.
	     *
	     * **WARNING:** calling this method with untrusted user data exposes your application to XSS
	     * security risks!
	     * @abstract
	     * @param {?} value
	     * @return {?}
	     */
	    DomSanitizer.prototype.bypassSecurityTrustHtml = function (value) { };
	    /**
	     * Bypass security and trust the given value to be safe style value (CSS).
	     *
	     * **WARNING:** calling this method with untrusted user data exposes your application to XSS
	     * security risks!
	     * @abstract
	     * @param {?} value
	     * @return {?}
	     */
	    DomSanitizer.prototype.bypassSecurityTrustStyle = function (value) { };
	    /**
	     * Bypass security and trust the given value to be safe JavaScript.
	     *
	     * **WARNING:** calling this method with untrusted user data exposes your application to XSS
	     * security risks!
	     * @abstract
	     * @param {?} value
	     * @return {?}
	     */
	    DomSanitizer.prototype.bypassSecurityTrustScript = function (value) { };
	    /**
	     * Bypass security and trust the given value to be a safe style URL, i.e. a value that can be used
	     * in hyperlinks or `<img src>`.
	     *
	     * **WARNING:** calling this method with untrusted user data exposes your application to XSS
	     * security risks!
	     * @abstract
	     * @param {?} value
	     * @return {?}
	     */
	    DomSanitizer.prototype.bypassSecurityTrustUrl = function (value) { };
	    /**
	     * Bypass security and trust the given value to be a safe resource URL, i.e. a location that may
	     * be used to load executable code from, like `<script src>`, or `<iframe src>`.
	     *
	     * **WARNING:** calling this method with untrusted user data exposes your application to XSS
	     * security risks!
	     * @abstract
	     * @param {?} value
	     * @return {?}
	     */
	    DomSanitizer.prototype.bypassSecurityTrustResourceUrl = function (value) { };
	    return DomSanitizer;
	}());
	var DomSanitizerImpl = (function (_super) {
	    __extends(DomSanitizerImpl, _super);
	    /**
	     * @param {?} _doc
	     */
	    function DomSanitizerImpl(_doc) {
	        var _this = _super.call(this) || this;
	        _this._doc = _doc;
	        return _this;
	    }
	    /**
	     * @param {?} ctx
	     * @param {?} value
	     * @return {?}
	     */
	    DomSanitizerImpl.prototype.sanitize = function (ctx, value) {
	        if (value == null)
	            return null;
	        switch (ctx) {
	            case _angular_core.SecurityContext.NONE:
	                return (value);
	            case _angular_core.SecurityContext.HTML:
	                if (value instanceof SafeHtmlImpl)
	                    return value.changingThisBreaksApplicationSecurity;
	                this.checkNotSafeValue(value, 'HTML');
	                return sanitizeHtml(this._doc, String(value));
	            case _angular_core.SecurityContext.STYLE:
	                if (value instanceof SafeStyleImpl)
	                    return value.changingThisBreaksApplicationSecurity;
	                this.checkNotSafeValue(value, 'Style');
	                return sanitizeStyle(/** @type {?} */ (value));
	            case _angular_core.SecurityContext.SCRIPT:
	                if (value instanceof SafeScriptImpl)
	                    return value.changingThisBreaksApplicationSecurity;
	                this.checkNotSafeValue(value, 'Script');
	                throw new Error('unsafe value used in a script context');
	            case _angular_core.SecurityContext.URL:
	                if (value instanceof SafeResourceUrlImpl || value instanceof SafeUrlImpl) {
	                    // Allow resource URLs in URL contexts, they are strictly more trusted.
	                    return value.changingThisBreaksApplicationSecurity;
	                }
	                this.checkNotSafeValue(value, 'URL');
	                return sanitizeUrl(String(value));
	            case _angular_core.SecurityContext.RESOURCE_URL:
	                if (value instanceof SafeResourceUrlImpl) {
	                    return value.changingThisBreaksApplicationSecurity;
	                }
	                this.checkNotSafeValue(value, 'ResourceURL');
	                throw new Error('unsafe value used in a resource URL context (see http://g.co/ng/security#xss)');
	            default:
	                throw new Error("Unexpected SecurityContext " + ctx + " (see http://g.co/ng/security#xss)");
	        }
	    };
	    /**
	     * @param {?} value
	     * @param {?} expectedType
	     * @return {?}
	     */
	    DomSanitizerImpl.prototype.checkNotSafeValue = function (value, expectedType) {
	        if (value instanceof SafeValueImpl) {
	            throw new Error("Required a safe " + expectedType + ", got a " + value.getTypeName() + " " +
	                "(see http://g.co/ng/security#xss)");
	        }
	    };
	    /**
	     * @param {?} value
	     * @return {?}
	     */
	    DomSanitizerImpl.prototype.bypassSecurityTrustHtml = function (value) { return new SafeHtmlImpl(value); };
	    /**
	     * @param {?} value
	     * @return {?}
	     */
	    DomSanitizerImpl.prototype.bypassSecurityTrustStyle = function (value) { return new SafeStyleImpl(value); };
	    /**
	     * @param {?} value
	     * @return {?}
	     */
	    DomSanitizerImpl.prototype.bypassSecurityTrustScript = function (value) { return new SafeScriptImpl(value); };
	    /**
	     * @param {?} value
	     * @return {?}
	     */
	    DomSanitizerImpl.prototype.bypassSecurityTrustUrl = function (value) { return new SafeUrlImpl(value); };
	    /**
	     * @param {?} value
	     * @return {?}
	     */
	    DomSanitizerImpl.prototype.bypassSecurityTrustResourceUrl = function (value) {
	        return new SafeResourceUrlImpl(value);
	    };
	    return DomSanitizerImpl;
	}(DomSanitizer));
	DomSanitizerImpl.decorators = [
	    { type: _angular_core.Injectable },
	];
	/**
	 * @nocollapse
	 */
	DomSanitizerImpl.ctorParameters = function () { return [
	    { type: undefined, decorators: [{ type: _angular_core.Inject, args: [DOCUMENT$1,] },] },
	]; };
	/**
	 * @abstract
	 */
	var SafeValueImpl = (function () {
	    /**
	     * @param {?} changingThisBreaksApplicationSecurity
	     */
	    function SafeValueImpl(changingThisBreaksApplicationSecurity) {
	        this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
	        // empty
	    }
	    /**
	     * @abstract
	     * @return {?}
	     */
	    SafeValueImpl.prototype.getTypeName = function () { };
	    /**
	     * @return {?}
	     */
	    SafeValueImpl.prototype.toString = function () {
	        return "SafeValue must use [property]=binding: " + this.changingThisBreaksApplicationSecurity +
	            " (see http://g.co/ng/security#xss)";
	    };
	    return SafeValueImpl;
	}());
	var SafeHtmlImpl = (function (_super) {
	    __extends(SafeHtmlImpl, _super);
	    function SafeHtmlImpl() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    /**
	     * @return {?}
	     */
	    SafeHtmlImpl.prototype.getTypeName = function () { return 'HTML'; };
	    return SafeHtmlImpl;
	}(SafeValueImpl));
	var SafeStyleImpl = (function (_super) {
	    __extends(SafeStyleImpl, _super);
	    function SafeStyleImpl() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    /**
	     * @return {?}
	     */
	    SafeStyleImpl.prototype.getTypeName = function () { return 'Style'; };
	    return SafeStyleImpl;
	}(SafeValueImpl));
	var SafeScriptImpl = (function (_super) {
	    __extends(SafeScriptImpl, _super);
	    function SafeScriptImpl() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    /**
	     * @return {?}
	     */
	    SafeScriptImpl.prototype.getTypeName = function () { return 'Script'; };
	    return SafeScriptImpl;
	}(SafeValueImpl));
	var SafeUrlImpl = (function (_super) {
	    __extends(SafeUrlImpl, _super);
	    function SafeUrlImpl() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    /**
	     * @return {?}
	     */
	    SafeUrlImpl.prototype.getTypeName = function () { return 'URL'; };
	    return SafeUrlImpl;
	}(SafeValueImpl));
	var SafeResourceUrlImpl = (function (_super) {
	    __extends(SafeResourceUrlImpl, _super);
	    function SafeResourceUrlImpl() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    /**
	     * @return {?}
	     */
	    SafeResourceUrlImpl.prototype.getTypeName = function () { return 'ResourceURL'; };
	    return SafeResourceUrlImpl;
	}(SafeValueImpl));
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var INTERNAL_BROWSER_PLATFORM_PROVIDERS = [
	    { provide: _angular_core.PLATFORM_ID, useValue: _angular_common.ɵPLATFORM_BROWSER_ID },
	    { provide: _angular_core.PLATFORM_INITIALIZER, useValue: initDomAdapter, multi: true },
	    { provide: _angular_common.PlatformLocation, useClass: BrowserPlatformLocation },
	    { provide: DOCUMENT$1, useFactory: _document, deps: [] },
	];
	/**
	 * \@security Replacing built-in sanitization providers exposes the application to XSS risks.
	 * Attacker-controlled data introduced by an unsanitized provider could expose your
	 * application to XSS risks. For more detail, see the [Security Guide](http://g.co/ng/security).
	 * \@experimental
	 */
	var BROWSER_SANITIZATION_PROVIDERS = [
	    { provide: _angular_core.Sanitizer, useExisting: DomSanitizer },
	    { provide: DomSanitizer, useClass: DomSanitizerImpl },
	];
	/**
	 * \@stable
	 */
	var platformBrowser = _angular_core.createPlatformFactory(_angular_core.platformCore, 'browser', INTERNAL_BROWSER_PLATFORM_PROVIDERS);
	/**
	 * @return {?}
	 */
	function initDomAdapter() {
	    BrowserDomAdapter.makeCurrent();
	    BrowserGetTestability.init();
	}
	/**
	 * @return {?}
	 */
	function errorHandler() {
	    return new _angular_core.ErrorHandler();
	}
	/**
	 * @return {?}
	 */
	function _document() {
	    return document;
	}
	/**
	 * The ng module for the browser.
	 *
	 * \@stable
	 */
	var BrowserModule = (function () {
	    /**
	     * @param {?} parentModule
	     */
	    function BrowserModule(parentModule) {
	        if (parentModule) {
	            throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.");
	        }
	    }
	    /**
	     * Configures a browser-based application to transition from a server-rendered app, if
	     * one is present on the page. The specified parameters must include an application id,
	     * which must match between the client and server applications.
	     *
	     * \@experimental
	     * @param {?} params
	     * @return {?}
	     */
	    BrowserModule.withServerTransition = function (params) {
	        return {
	            ngModule: BrowserModule,
	            providers: [
	                { provide: _angular_core.APP_ID, useValue: params.appId },
	                { provide: TRANSITION_ID, useExisting: _angular_core.APP_ID },
	                SERVER_TRANSITION_PROVIDERS,
	            ],
	        };
	    };
	    return BrowserModule;
	}());
	BrowserModule.decorators = [
	    { type: _angular_core.NgModule, args: [{
	                providers: [
	                    BROWSER_SANITIZATION_PROVIDERS,
	                    { provide: _angular_core.ErrorHandler, useFactory: errorHandler, deps: [] },
	                    { provide: EVENT_MANAGER_PLUGINS, useClass: DomEventsPlugin, multi: true },
	                    { provide: EVENT_MANAGER_PLUGINS, useClass: KeyEventsPlugin, multi: true },
	                    { provide: EVENT_MANAGER_PLUGINS, useClass: HammerGesturesPlugin, multi: true },
	                    { provide: HAMMER_GESTURE_CONFIG, useClass: HammerGestureConfig },
	                    DomRendererFactory2,
	                    { provide: _angular_core.RendererFactory2, useExisting: DomRendererFactory2 },
	                    { provide: SharedStylesHost, useExisting: DomSharedStylesHost },
	                    DomSharedStylesHost,
	                    _angular_core.Testability,
	                    EventManager,
	                    ELEMENT_PROBE_PROVIDERS,
	                    Meta,
	                    Title,
	                ],
	                exports: [_angular_common.CommonModule, _angular_core.ApplicationModule]
	            },] },
	];
	/**
	 * @nocollapse
	 */
	BrowserModule.ctorParameters = function () { return [
	    { type: BrowserModule, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.SkipSelf },] },
	]; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var win = typeof window !== 'undefined' && window || {};
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var ChangeDetectionPerfRecord = (function () {
	    /**
	     * @param {?} msPerTick
	     * @param {?} numTicks
	     */
	    function ChangeDetectionPerfRecord(msPerTick, numTicks) {
	        this.msPerTick = msPerTick;
	        this.numTicks = numTicks;
	    }
	    return ChangeDetectionPerfRecord;
	}());
	/**
	 * Entry point for all Angular profiling-related debug tools. This object
	 * corresponds to the `ng.profiler` in the dev console.
	 */
	var AngularProfiler = (function () {
	    /**
	     * @param {?} ref
	     */
	    function AngularProfiler(ref) {
	        this.appRef = ref.injector.get(_angular_core.ApplicationRef);
	    }
	    /**
	     * Exercises change detection in a loop and then prints the average amount of
	     * time in milliseconds how long a single round of change detection takes for
	     * the current state of the UI. It runs a minimum of 5 rounds for a minimum
	     * of 500 milliseconds.
	     *
	     * Optionally, a user may pass a `config` parameter containing a map of
	     * options. Supported options are:
	     *
	     * `record` (boolean) - causes the profiler to record a CPU profile while
	     * it exercises the change detector. Example:
	     *
	     * ```
	     * ng.profiler.timeChangeDetection({record: true})
	     * ```
	     * @param {?} config
	     * @return {?}
	     */
	    AngularProfiler.prototype.timeChangeDetection = function (config) {
	        var /** @type {?} */ record = config && config['record'];
	        var /** @type {?} */ profileName = 'Change Detection';
	        // Profiler is not available in Android browsers, nor in IE 9 without dev tools opened
	        var /** @type {?} */ isProfilerAvailable = win.console.profile != null;
	        if (record && isProfilerAvailable) {
	            win.console.profile(profileName);
	        }
	        var /** @type {?} */ start = getDOM().performanceNow();
	        var /** @type {?} */ numTicks = 0;
	        while (numTicks < 5 || (getDOM().performanceNow() - start) < 500) {
	            this.appRef.tick();
	            numTicks++;
	        }
	        var /** @type {?} */ end = getDOM().performanceNow();
	        if (record && isProfilerAvailable) {
	            // need to cast to <any> because type checker thinks there's no argument
	            // while in fact there is:
	            //
	            // https://developer.mozilla.org/en-US/docs/Web/API/Console/profileEnd
	            ((win.console.profileEnd))(profileName);
	        }
	        var /** @type {?} */ msPerTick = (end - start) / numTicks;
	        win.console.log("ran " + numTicks + " change detection cycles");
	        win.console.log(msPerTick.toFixed(2) + " ms per check");
	        return new ChangeDetectionPerfRecord(msPerTick, numTicks);
	    };
	    return AngularProfiler;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var PROFILER_GLOBAL_NAME = 'profiler';
	/**
	 * Enabled Angular debug tools that are accessible via your browser's
	 * developer console.
	 *
	 * Usage:
	 *
	 * 1. Open developer console (e.g. in Chrome Ctrl + Shift + j)
	 * 1. Type `ng.` (usually the console will show auto-complete suggestion)
	 * 1. Try the change detection profiler `ng.profiler.timeChangeDetection()`
	 *    then hit Enter.
	 *
	 * \@experimental All debugging apis are currently experimental.
	 * @template T
	 * @param {?} ref
	 * @return {?}
	 */
	function enableDebugTools(ref) {
	    exportNgVar(PROFILER_GLOBAL_NAME, new AngularProfiler(ref));
	    return ref;
	}
	/**
	 * Disables Angular tools.
	 *
	 * \@experimental All debugging apis are currently experimental.
	 * @return {?}
	 */
	function disableDebugTools() {
	    exportNgVar(PROFILER_GLOBAL_NAME, null);
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Predicates for use with {\@link DebugElement}'s query functions.
	 *
	 * \@experimental All debugging apis are currently experimental.
	 */
	var By = (function () {
	    function By() {
	    }
	    /**
	     * Match all elements.
	     *
	     * ## Example
	     *
	     * {\@example platform-browser/dom/debug/ts/by/by.ts region='by_all'}
	     * @return {?}
	     */
	    By.all = function () { return function (debugElement) { return true; }; };
	    /**
	     * Match elements by the given CSS selector.
	     *
	     * ## Example
	     *
	     * {\@example platform-browser/dom/debug/ts/by/by.ts region='by_css'}
	     * @param {?} selector
	     * @return {?}
	     */
	    By.css = function (selector) {
	        return function (debugElement) {
	            return debugElement.nativeElement != null ?
	                getDOM().elementMatches(debugElement.nativeElement, selector) :
	                false;
	        };
	    };
	    /**
	     * Match elements that have the given directive present.
	     *
	     * ## Example
	     *
	     * {\@example platform-browser/dom/debug/ts/by/by.ts region='by_directive'}
	     * @param {?} type
	     * @return {?}
	     */
	    By.directive = function (type) {
	        return function (debugElement) { return ((debugElement.providerTokens)).indexOf(type) !== -1; };
	    };
	    return By;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @module
	 * @description
	 * Entry point for all public APIs of the common package.
	 */
	/**
	 * \@stable
	 */
	var VERSION = new _angular_core.Version('4.3.3');
	
	exports.BrowserModule = BrowserModule;
	exports.platformBrowser = platformBrowser;
	exports.Meta = Meta;
	exports.Title = Title;
	exports.disableDebugTools = disableDebugTools;
	exports.enableDebugTools = enableDebugTools;
	exports.By = By;
	exports.NgProbeToken = NgProbeToken$1;
	exports.DOCUMENT = DOCUMENT$1;
	exports.EVENT_MANAGER_PLUGINS = EVENT_MANAGER_PLUGINS;
	exports.EventManager = EventManager;
	exports.HAMMER_GESTURE_CONFIG = HAMMER_GESTURE_CONFIG;
	exports.HammerGestureConfig = HammerGestureConfig;
	exports.DomSanitizer = DomSanitizer;
	exports.VERSION = VERSION;
	exports.ɵBROWSER_SANITIZATION_PROVIDERS = BROWSER_SANITIZATION_PROVIDERS;
	exports.ɵINTERNAL_BROWSER_PLATFORM_PROVIDERS = INTERNAL_BROWSER_PLATFORM_PROVIDERS;
	exports.ɵinitDomAdapter = initDomAdapter;
	exports.ɵBrowserDomAdapter = BrowserDomAdapter;
	exports.ɵBrowserPlatformLocation = BrowserPlatformLocation;
	exports.ɵTRANSITION_ID = TRANSITION_ID;
	exports.ɵBrowserGetTestability = BrowserGetTestability;
	exports.ɵELEMENT_PROBE_PROVIDERS = ELEMENT_PROBE_PROVIDERS;
	exports.ɵDomAdapter = DomAdapter;
	exports.ɵgetDOM = getDOM;
	exports.ɵsetRootDomAdapter = setRootDomAdapter;
	exports.ɵDomRendererFactory2 = DomRendererFactory2;
	exports.ɵNAMESPACE_URIS = NAMESPACE_URIS;
	exports.ɵflattenStyles = flattenStyles;
	exports.ɵshimContentAttribute = shimContentAttribute;
	exports.ɵshimHostAttribute = shimHostAttribute;
	exports.ɵDomEventsPlugin = DomEventsPlugin;
	exports.ɵHammerGesturesPlugin = HammerGesturesPlugin;
	exports.ɵKeyEventsPlugin = KeyEventsPlugin;
	exports.ɵDomSharedStylesHost = DomSharedStylesHost;
	exports.ɵSharedStylesHost = SharedStylesHost;
	exports.ɵb = _document;
	exports.ɵa = errorHandler;
	exports.ɵh = GenericBrowserDomAdapter;
	exports.ɵg = SERVER_TRANSITION_PROVIDERS;
	exports.ɵf = appInitializerFactory;
	exports.ɵc = _createNgProbe;
	exports.ɵd = EventManagerPlugin;
	exports.ɵe = DomSanitizerImpl;
	
	Object.defineProperty(exports, '__esModule', { value: true });
	
	})));
	//# sourceMappingURL=platform-browser.umd.js.map


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _Observable2 = __webpack_require__(4);
	
	var _Observable3 = _interopRequireDefault(_Observable2);
	
	var EmptyObservable = (function (_Observable) {
	    _inherits(EmptyObservable, _Observable);
	
	    function EmptyObservable(scheduler) {
	        _classCallCheck(this, EmptyObservable);
	
	        _Observable.call(this);
	        this.scheduler = scheduler;
	    }
	
	    EmptyObservable.create = function create(scheduler) {
	        return new EmptyObservable(scheduler);
	    };
	
	    EmptyObservable.dispatch = function dispatch(_ref) {
	        var subscriber = _ref.subscriber;
	
	        subscriber.complete();
	    };
	
	    EmptyObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            subscriber.add(scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber }));
	        } else {
	            subscriber.complete();
	        }
	    };
	
	    return EmptyObservable;
	})(_Observable3['default']);
	
	exports['default'] = EmptyObservable;
	module.exports = exports['default'];

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = multicast;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _observablesConnectableObservable = __webpack_require__(43);
	
	var _observablesConnectableObservable2 = _interopRequireDefault(_observablesConnectableObservable);
	
	function multicast(subjectFactory) {
	    return new _observablesConnectableObservable2['default'](this, subjectFactory);
	}
	
	module.exports = exports['default'];

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _Subscription2 = __webpack_require__(5);
	
	var _Subscription3 = _interopRequireDefault(_Subscription2);
	
	var ImmediateAction = (function (_Subscription) {
	    _inherits(ImmediateAction, _Subscription);
	
	    function ImmediateAction(scheduler, work) {
	        _classCallCheck(this, ImmediateAction);
	
	        _Subscription.call(this);
	        this.scheduler = scheduler;
	        this.work = work;
	    }
	
	    ImmediateAction.prototype.schedule = function schedule(state) {
	        if (this.isUnsubscribed) {
	            return this;
	        }
	        this.state = state;
	        var scheduler = this.scheduler;
	        scheduler.actions.push(this);
	        scheduler.flush();
	        return this;
	    };
	
	    ImmediateAction.prototype.execute = function execute() {
	        if (this.isUnsubscribed) {
	            throw new Error('How did did we execute a canceled Action?');
	        }
	        this.work(this.state);
	    };
	
	    ImmediateAction.prototype.unsubscribe = function unsubscribe() {
	        var scheduler = this.scheduler;
	        var actions = scheduler.actions;
	        var index = actions.indexOf(this);
	        this.work = void 0;
	        this.state = void 0;
	        this.scheduler = void 0;
	        if (index !== -1) {
	            actions.splice(index, 1);
	        }
	        _Subscription.prototype.unsubscribe.call(this);
	    };
	
	    return ImmediateAction;
	})(_Subscription3['default']);
	
	exports['default'] = ImmediateAction;
	module.exports = exports['default'];

/***/ }),
/* 25 */
/***/ (function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var EmptyError = function EmptyError() {
	    _classCallCheck(this, EmptyError);
	
	    this.name = 'EmptyError';
	    this.message = 'no elements in sequence';
	};
	
	exports['default'] = EmptyError;
	module.exports = exports['default'];

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _root = __webpack_require__(16);
	
	if (!_root.root.Symbol) {
	    _root.root.Symbol = {};
	}
	if (!_root.root.Symbol.iterator) {
	    if (typeof _root.root.Symbol['for'] === 'function') {
	        _root.root.Symbol.iterator = _root.root.Symbol['for']('iterator');
	    } else if (_root.root.Set && typeof new _root.root.Set()['@@iterator'] === 'function') {
	        // Bug for mozilla version
	        _root.root.Symbol.iterator = '@@iterator';
	    } else {
	        _root.root.Symbol.iterator = '_es6shim_iterator_';
	    }
	}
	exports['default'] = _root.root.Symbol.iterator;
	
	// // Shim in iterator support
	// export var $iterator$ = (typeof Symbol === 'function' && Symbol.iterator) || '_es6shim_iterator_';
	// // Bug for mozilla version
	// if (root.Set && typeof new root.Set()['@@iterator'] === 'function') {
	//     $iterator$ = '@@iterator';
	// }
	module.exports = exports['default'];

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var isArray_1 = __webpack_require__(74);
	var isObject_1 = __webpack_require__(77);
	var isFunction_1 = __webpack_require__(76);
	var tryCatch_1 = __webpack_require__(219);
	var errorObject_1 = __webpack_require__(73);
	var UnsubscriptionError_1 = __webpack_require__(217);
	/**
	 * Represents a disposable resource, such as the execution of an Observable. A
	 * Subscription has one important method, `unsubscribe`, that takes no argument
	 * and just disposes the resource held by the subscription.
	 *
	 * Additionally, subscriptions may be grouped together through the `add()`
	 * method, which will attach a child Subscription to the current Subscription.
	 * When a Subscription is unsubscribed, all its children (and its grandchildren)
	 * will be unsubscribed as well.
	 *
	 * @class Subscription
	 */
	var Subscription = (function () {
	    /**
	     * @param {function(): void} [unsubscribe] A function describing how to
	     * perform the disposal of resources when the `unsubscribe` method is called.
	     */
	    function Subscription(unsubscribe) {
	        /**
	         * A flag to indicate whether this Subscription has already been unsubscribed.
	         * @type {boolean}
	         */
	        this.closed = false;
	        this._parent = null;
	        this._parents = null;
	        this._subscriptions = null;
	        if (unsubscribe) {
	            this._unsubscribe = unsubscribe;
	        }
	    }
	    /**
	     * Disposes the resources held by the subscription. May, for instance, cancel
	     * an ongoing Observable execution or cancel any other type of work that
	     * started when the Subscription was created.
	     * @return {void}
	     */
	    Subscription.prototype.unsubscribe = function () {
	        var hasErrors = false;
	        var errors;
	        if (this.closed) {
	            return;
	        }
	        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
	        this.closed = true;
	        this._parent = null;
	        this._parents = null;
	        // null out _subscriptions first so any child subscriptions that attempt
	        // to remove themselves from this subscription will noop
	        this._subscriptions = null;
	        var index = -1;
	        var len = _parents ? _parents.length : 0;
	        // if this._parent is null, then so is this._parents, and we
	        // don't have to remove ourselves from any parent subscriptions.
	        while (_parent) {
	            _parent.remove(this);
	            // if this._parents is null or index >= len,
	            // then _parent is set to null, and the loop exits
	            _parent = ++index < len && _parents[index] || null;
	        }
	        if (isFunction_1.isFunction(_unsubscribe)) {
	            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
	            if (trial === errorObject_1.errorObject) {
	                hasErrors = true;
	                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?
	                    flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
	            }
	        }
	        if (isArray_1.isArray(_subscriptions)) {
	            index = -1;
	            len = _subscriptions.length;
	            while (++index < len) {
	                var sub = _subscriptions[index];
	                if (isObject_1.isObject(sub)) {
	                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
	                    if (trial === errorObject_1.errorObject) {
	                        hasErrors = true;
	                        errors = errors || [];
	                        var err = errorObject_1.errorObject.e;
	                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
	                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
	                        }
	                        else {
	                            errors.push(err);
	                        }
	                    }
	                }
	            }
	        }
	        if (hasErrors) {
	            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
	        }
	    };
	    /**
	     * Adds a tear down to be called during the unsubscribe() of this
	     * Subscription.
	     *
	     * If the tear down being added is a subscription that is already
	     * unsubscribed, is the same reference `add` is being called on, or is
	     * `Subscription.EMPTY`, it will not be added.
	     *
	     * If this subscription is already in an `closed` state, the passed
	     * tear down logic will be executed immediately.
	     *
	     * @param {TeardownLogic} teardown The additional logic to execute on
	     * teardown.
	     * @return {Subscription} Returns the Subscription used or created to be
	     * added to the inner subscriptions list. This Subscription can be used with
	     * `remove()` to remove the passed teardown logic from the inner subscriptions
	     * list.
	     */
	    Subscription.prototype.add = function (teardown) {
	        if (!teardown || (teardown === Subscription.EMPTY)) {
	            return Subscription.EMPTY;
	        }
	        if (teardown === this) {
	            return this;
	        }
	        var subscription = teardown;
	        switch (typeof teardown) {
	            case 'function':
	                subscription = new Subscription(teardown);
	            case 'object':
	                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
	                    return subscription;
	                }
	                else if (this.closed) {
	                    subscription.unsubscribe();
	                    return subscription;
	                }
	                else if (typeof subscription._addParent !== 'function' /* quack quack */) {
	                    var tmp = subscription;
	                    subscription = new Subscription();
	                    subscription._subscriptions = [tmp];
	                }
	                break;
	            default:
	                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
	        }
	        var subscriptions = this._subscriptions || (this._subscriptions = []);
	        subscriptions.push(subscription);
	        subscription._addParent(this);
	        return subscription;
	    };
	    /**
	     * Removes a Subscription from the internal list of subscriptions that will
	     * unsubscribe during the unsubscribe process of this Subscription.
	     * @param {Subscription} subscription The subscription to remove.
	     * @return {void}
	     */
	    Subscription.prototype.remove = function (subscription) {
	        var subscriptions = this._subscriptions;
	        if (subscriptions) {
	            var subscriptionIndex = subscriptions.indexOf(subscription);
	            if (subscriptionIndex !== -1) {
	                subscriptions.splice(subscriptionIndex, 1);
	            }
	        }
	    };
	    Subscription.prototype._addParent = function (parent) {
	        var _a = this, _parent = _a._parent, _parents = _a._parents;
	        if (!_parent || _parent === parent) {
	            // If we don't have a parent, or the new parent is the same as the
	            // current parent, then set this._parent to the new parent.
	            this._parent = parent;
	        }
	        else if (!_parents) {
	            // If there's already one parent, but not multiple, allocate an Array to
	            // store the rest of the parent Subscriptions.
	            this._parents = [parent];
	        }
	        else if (_parents.indexOf(parent) === -1) {
	            // Only add the new parent to the _parents list if it's not already there.
	            _parents.push(parent);
	        }
	    };
	    Subscription.EMPTY = (function (empty) {
	        empty.closed = true;
	        return empty;
	    }(new Subscription()));
	    return Subscription;
	}());
	exports.Subscription = Subscription;
	function flattenUnsubscriptionErrors(errors) {
	    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);
	}
	//# sourceMappingURL=Subscription.js.map

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _Observable2 = __webpack_require__(4);
	
	var _Observable3 = _interopRequireDefault(_Observable2);
	
	var ErrorObservable = (function (_Observable) {
	    _inherits(ErrorObservable, _Observable);
	
	    function ErrorObservable(error, scheduler) {
	        _classCallCheck(this, ErrorObservable);
	
	        _Observable.call(this);
	        this.error = error;
	        this.scheduler = scheduler;
	    }
	
	    ErrorObservable.create = function create(error, scheduler) {
	        return new ErrorObservable(error, scheduler);
	    };
	
	    ErrorObservable.dispatch = function dispatch(_ref) {
	        var error = _ref.error;
	        var subscriber = _ref.subscriber;
	
	        subscriber.error(error);
	    };
	
	    ErrorObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var error = this.error;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            subscriber.add(scheduler.schedule(ErrorObservable.dispatch, 0, {
	                error: error, subscriber: subscriber
	            }));
	        } else {
	            subscriber.error(error);
	        }
	    };
	
	    return ErrorObservable;
	})(_Observable3['default']);
	
	exports['default'] = ErrorObservable;
	module.exports = exports['default'];

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _Observable2 = __webpack_require__(4);
	
	var _Observable3 = _interopRequireDefault(_Observable2);
	
	var _Subscription = __webpack_require__(5);
	
	var _Subscription2 = _interopRequireDefault(_Subscription);
	
	var _schedulersImmediate = __webpack_require__(10);
	
	var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);
	
	var PromiseObservable = (function (_Observable) {
	    _inherits(PromiseObservable, _Observable);
	
	    function PromiseObservable(promise, scheduler) {
	        _classCallCheck(this, PromiseObservable);
	
	        _Observable.call(this);
	        this.promise = promise;
	        this.scheduler = scheduler;
	        this._isScalar = false;
	    }
	
	    PromiseObservable.create = function create(promise) {
	        var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersImmediate2['default'] : arguments[1];
	
	        return new PromiseObservable(promise, scheduler);
	    };
	
	    PromiseObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var _this = this;
	
	        var scheduler = this.scheduler;
	        var promise = this.promise;
	        if (scheduler === _schedulersImmediate2['default']) {
	            if (this._isScalar) {
	                subscriber.next(this.value);
	                subscriber.complete();
	            } else {
	                promise.then(function (value) {
	                    _this._isScalar = true;
	                    _this.value = value;
	                    subscriber.next(value);
	                    subscriber.complete();
	                }, function (err) {
	                    return subscriber.error(err);
	                }).then(null, function (err) {
	                    // escape the promise trap, throw unhandled errors
	                    setTimeout(function () {
	                        throw err;
	                    });
	                });
	            }
	        } else {
	            var _ret = (function () {
	                var subscription = new _Subscription2['default']();
	                if (_this._isScalar) {
	                    var value = _this.value;
	                    subscription.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));
	                } else {
	                    promise.then(function (value) {
	                        _this._isScalar = true;
	                        _this.value = value;
	                        subscription.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));
	                    }, function (err) {
	                        return subscription.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));
	                    }).then(null, function (err) {
	                        // escape the promise trap, throw unhandled errors
	                        scheduler.schedule(function () {
	                            throw err;
	                        });
	                    });
	                }
	                return {
	                    v: subscription
	                };
	            })();
	
	            if (typeof _ret === 'object') return _ret.v;
	        }
	    };
	
	    return PromiseObservable;
	})(_Observable3['default']);
	
	exports['default'] = PromiseObservable;
	
	function dispatchNext(_ref) {
	    var value = _ref.value;
	    var subscriber = _ref.subscriber;
	
	    subscriber.next(value);
	    subscriber.complete();
	}
	function dispatchError(_ref2) {
	    var err = _ref2.err;
	    var subscriber = _ref2.subscriber;
	
	    subscriber.error(err);
	}
	module.exports = exports['default'];

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _Observable2 = __webpack_require__(4);
	
	var _Observable3 = _interopRequireDefault(_Observable2);
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	var _ErrorObservable = __webpack_require__(28);
	
	var _ErrorObservable2 = _interopRequireDefault(_ErrorObservable);
	
	var _EmptyObservable = __webpack_require__(22);
	
	var _EmptyObservable2 = _interopRequireDefault(_EmptyObservable);
	
	var ScalarObservable = (function (_Observable) {
	    _inherits(ScalarObservable, _Observable);
	
	    function ScalarObservable(value, scheduler) {
	        _classCallCheck(this, ScalarObservable);
	
	        _Observable.call(this);
	        this.value = value;
	        this.scheduler = scheduler;
	        this._isScalar = true;
	    }
	
	    // TypeScript is weird about class prototype member functions and instance properties touching on it's plate.
	
	    ScalarObservable.create = function create(value, scheduler) {
	        return new ScalarObservable(value, scheduler);
	    };
	
	    ScalarObservable.dispatch = function dispatch(state) {
	        var done = state.done;
	        var value = state.value;
	        var subscriber = state.subscriber;
	
	        if (done) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(value);
	        if (subscriber.isUnsubscribed) {
	            return;
	        }
	        state.done = true;
	        this.schedule(state);
	    };
	
	    ScalarObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var value = this.value;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            subscriber.add(scheduler.schedule(ScalarObservable.dispatch, 0, {
	                done: false, value: value, subscriber: subscriber
	            }));
	        } else {
	            subscriber.next(value);
	            if (!subscriber.isUnsubscribed) {
	                subscriber.complete();
	            }
	        }
	    };
	
	    return ScalarObservable;
	})(_Observable3['default']);
	
	exports['default'] = ScalarObservable;
	var proto = ScalarObservable.prototype;
	proto.map = function (project, thisArg) {
	    var result = _utilTryCatch2['default'](project).call(thisArg || this, this.value, 0);
	    if (result === _utilErrorObject.errorObject) {
	        return new _ErrorObservable2['default'](_utilErrorObject.errorObject.e);
	    } else {
	        return new ScalarObservable(project.call(thisArg || this, this.value, 0));
	    }
	};
	proto.filter = function (select, thisArg) {
	    var result = _utilTryCatch2['default'](select).call(thisArg || this, this.value, 0);
	    if (result === _utilErrorObject.errorObject) {
	        return new _ErrorObservable2['default'](_utilErrorObject.errorObject.e);
	    } else if (result) {
	        return this;
	    } else {
	        return new _EmptyObservable2['default']();
	    }
	};
	proto.reduce = function (project, acc) {
	    if (typeof acc === 'undefined') {
	        return this;
	    }
	    var result = _utilTryCatch2['default'](project)(acc, this.value);
	    if (result === _utilErrorObject.errorObject) {
	        return new _ErrorObservable2['default'](_utilErrorObject.errorObject.e);
	    } else {
	        return new ScalarObservable(result);
	    }
	};
	proto.scan = function (project, acc) {
	    return this.reduce(project, acc);
	};
	proto.count = function (predicate, thisArg) {
	    if (!predicate) {
	        return new ScalarObservable(1);
	    } else {
	        var result = _utilTryCatch2['default'](predicate).call(thisArg || this, this.value, 0, this);
	        if (result === _utilErrorObject.errorObject) {
	            return new _ErrorObservable2['default'](_utilErrorObject.errorObject.e);
	        } else {
	            return new ScalarObservable(result ? 1 : 0);
	        }
	    }
	};
	proto.skip = function (count) {
	    if (count > 0) {
	        return new _EmptyObservable2['default']();
	    }
	    return this;
	};
	proto.take = function (count) {
	    if (count > 0) {
	        return this;
	    }
	    return new _EmptyObservable2['default']();
	};
	module.exports = exports['default'];

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	var _OuterSubscriber2 = __webpack_require__(9);
	
	var _OuterSubscriber3 = _interopRequireDefault(_OuterSubscriber2);
	
	var _utilSubscribeToResult = __webpack_require__(11);
	
	var _utilSubscribeToResult2 = _interopRequireDefault(_utilSubscribeToResult);
	
	var CombineLatestOperator = (function () {
	    function CombineLatestOperator(project) {
	        _classCallCheck(this, CombineLatestOperator);
	
	        this.project = project;
	    }
	
	    CombineLatestOperator.prototype.call = function call(subscriber) {
	        return new CombineLatestSubscriber(subscriber, this.project);
	    };
	
	    return CombineLatestOperator;
	})();
	
	exports.CombineLatestOperator = CombineLatestOperator;
	
	var CombineLatestSubscriber = (function (_OuterSubscriber) {
	    _inherits(CombineLatestSubscriber, _OuterSubscriber);
	
	    function CombineLatestSubscriber(destination, project) {
	        _classCallCheck(this, CombineLatestSubscriber);
	
	        _OuterSubscriber.call(this, destination);
	        this.project = project;
	        this.active = 0;
	        this.values = [];
	        this.observables = [];
	        this.toRespond = [];
	    }
	
	    CombineLatestSubscriber.prototype._next = function _next(observable) {
	        var toRespond = this.toRespond;
	        toRespond.push(toRespond.length);
	        this.observables.push(observable);
	    };
	
	    CombineLatestSubscriber.prototype._complete = function _complete() {
	        var observables = this.observables;
	        var len = observables.length;
	        if (len === 0) {
	            this.destination.complete();
	        } else {
	            this.active = len;
	            for (var i = 0; i < len; i++) {
	                var observable = observables[i];
	                this.add(_utilSubscribeToResult2['default'](this, observable, observable, i));
	            }
	        }
	    };
	
	    CombineLatestSubscriber.prototype.notifyComplete = function notifyComplete(innerSubscriber) {
	        if ((this.active -= 1) === 0) {
	            this.destination.complete();
	        }
	    };
	
	    CombineLatestSubscriber.prototype.notifyNext = function notifyNext(observable, value, outerIndex, innerIndex) {
	        var values = this.values;
	        values[outerIndex] = value;
	        var toRespond = this.toRespond;
	        if (toRespond.length > 0) {
	            var found = toRespond.indexOf(outerIndex);
	            if (found !== -1) {
	                toRespond.splice(found, 1);
	            }
	        }
	        if (toRespond.length === 0) {
	            var project = this.project;
	            var destination = this.destination;
	            if (project) {
	                var result = _utilTryCatch2['default'](project).apply(this, values);
	                if (result === _utilErrorObject.errorObject) {
	                    destination.error(_utilErrorObject.errorObject.e);
	                } else {
	                    destination.next(result);
	                }
	            } else {
	                destination.next(values);
	            }
	        }
	    };
	
	    return CombineLatestSubscriber;
	})(_OuterSubscriber3['default']);
	
	exports.CombineLatestSubscriber = CombineLatestSubscriber;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _OuterSubscriber2 = __webpack_require__(9);
	
	var _OuterSubscriber3 = _interopRequireDefault(_OuterSubscriber2);
	
	var _utilSubscribeToResult = __webpack_require__(11);
	
	var _utilSubscribeToResult2 = _interopRequireDefault(_utilSubscribeToResult);
	
	var MergeAllOperator = (function () {
	    function MergeAllOperator(concurrent) {
	        _classCallCheck(this, MergeAllOperator);
	
	        this.concurrent = concurrent;
	    }
	
	    MergeAllOperator.prototype.call = function call(observer) {
	        return new MergeAllSubscriber(observer, this.concurrent);
	    };
	
	    return MergeAllOperator;
	})();
	
	exports.MergeAllOperator = MergeAllOperator;
	
	var MergeAllSubscriber = (function (_OuterSubscriber) {
	    _inherits(MergeAllSubscriber, _OuterSubscriber);
	
	    function MergeAllSubscriber(destination, concurrent) {
	        _classCallCheck(this, MergeAllSubscriber);
	
	        _OuterSubscriber.call(this, destination);
	        this.concurrent = concurrent;
	        this.hasCompleted = false;
	        this.buffer = [];
	        this.active = 0;
	    }
	
	    MergeAllSubscriber.prototype._next = function _next(observable) {
	        if (this.active < this.concurrent) {
	            if (observable._isScalar) {
	                this.destination.next(observable.value);
	            } else {
	                this.active++;
	                this.add(_utilSubscribeToResult2['default'](this, observable));
	            }
	        } else {
	            this.buffer.push(observable);
	        }
	    };
	
	    MergeAllSubscriber.prototype._complete = function _complete() {
	        this.hasCompleted = true;
	        if (this.active === 0 && this.buffer.length === 0) {
	            this.destination.complete();
	        }
	    };
	
	    MergeAllSubscriber.prototype.notifyComplete = function notifyComplete(innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer.length > 0) {
	            this._next(buffer.shift());
	        } else if (this.active === 0 && this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	
	    return MergeAllSubscriber;
	})(_OuterSubscriber3['default']);
	
	exports.MergeAllSubscriber = MergeAllSubscriber;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	var _OuterSubscriber2 = __webpack_require__(9);
	
	var _OuterSubscriber3 = _interopRequireDefault(_OuterSubscriber2);
	
	var _utilSubscribeToResult = __webpack_require__(11);
	
	var _utilSubscribeToResult2 = _interopRequireDefault(_utilSubscribeToResult);
	
	var MergeMapToOperator = (function () {
	    function MergeMapToOperator(ish, resultSelector) {
	        var concurrent = arguments.length <= 2 || arguments[2] === undefined ? Number.POSITIVE_INFINITY : arguments[2];
	
	        _classCallCheck(this, MergeMapToOperator);
	
	        this.ish = ish;
	        this.resultSelector = resultSelector;
	        this.concurrent = concurrent;
	    }
	
	    MergeMapToOperator.prototype.call = function call(observer) {
	        return new MergeMapToSubscriber(observer, this.ish, this.resultSelector, this.concurrent);
	    };
	
	    return MergeMapToOperator;
	})();
	
	exports.MergeMapToOperator = MergeMapToOperator;
	
	var MergeMapToSubscriber = (function (_OuterSubscriber) {
	    _inherits(MergeMapToSubscriber, _OuterSubscriber);
	
	    function MergeMapToSubscriber(destination, ish, resultSelector) {
	        var concurrent = arguments.length <= 3 || arguments[3] === undefined ? Number.POSITIVE_INFINITY : arguments[3];
	
	        _classCallCheck(this, MergeMapToSubscriber);
	
	        _OuterSubscriber.call(this, destination);
	        this.ish = ish;
	        this.resultSelector = resultSelector;
	        this.concurrent = concurrent;
	        this.hasCompleted = false;
	        this.buffer = [];
	        this.active = 0;
	        this.index = 0;
	    }
	
	    MergeMapToSubscriber.prototype._next = function _next(value) {
	        if (this.active < this.concurrent) {
	            var resultSelector = this.resultSelector;
	            var index = this.index++;
	            var ish = this.ish;
	            var destination = this.destination;
	            if (ish === _utilErrorObject.errorObject) {
	                destination.error(ish.e);
	            } else {
	                this.active--;
	                this._innerSub(ish, destination, resultSelector, value, index);
	            }
	        } else {
	            this.buffer.push(value);
	        }
	    };
	
	    MergeMapToSubscriber.prototype._innerSub = function _innerSub(ish, destination, resultSelector, value, index) {
	        this.add(_utilSubscribeToResult2['default'](this, ish, value, index));
	    };
	
	    MergeMapToSubscriber.prototype._complete = function _complete() {
	        this.hasCompleted = true;
	        if (this.active === 0 && this.buffer.length === 0) {
	            this.destination.complete();
	        }
	    };
	
	    MergeMapToSubscriber.prototype.notifyNext = function notifyNext(outerValue, innerValue, outerIndex, innerIndex) {
	        var resultSelector = this.resultSelector;
	        var destination = this.destination;
	
	        if (resultSelector) {
	            var result = _utilTryCatch2['default'](resultSelector)(outerValue, innerValue, outerIndex, innerIndex);
	            if (result === _utilErrorObject.errorObject) {
	                destination.error(_utilErrorObject.errorObject.e);
	            } else {
	                destination.next(result);
	            }
	        } else {
	            destination.next(innerValue);
	        }
	    };
	
	    MergeMapToSubscriber.prototype.notifyError = function notifyError(err) {
	        this.destination.error(err);
	    };
	
	    MergeMapToSubscriber.prototype.notifyComplete = function notifyComplete(innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer.length > 0) {
	            this._next(buffer.shift());
	        } else if (this.active === 0 && this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	
	    return MergeMapToSubscriber;
	})(_OuterSubscriber3['default']);
	
	exports.MergeMapToSubscriber = MergeMapToSubscriber;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _root = __webpack_require__(16);
	
	if (!_root.root.Symbol) {
	    _root.root.Symbol = {};
	}
	if (!_root.root.Symbol.observable) {
	    if (typeof _root.root.Symbol['for'] === 'function') {
	        _root.root.Symbol.observable = _root.root.Symbol['for']('observable');
	    } else {
	        _root.root.Symbol.observable = '@@observable';
	    }
	}
	exports['default'] = _root.root.Symbol.observable;
	module.exports = exports['default'];

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(8);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var OuterSubscriber = (function (_super) {
	    __extends(OuterSubscriber, _super);
	    function OuterSubscriber() {
	        _super.apply(this, arguments);
	    }
	    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.destination.next(innerValue);
	    };
	    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
	        this.destination.error(error);
	    };
	    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.destination.complete();
	    };
	    return OuterSubscriber;
	}(Subscriber_1.Subscriber));
	exports.OuterSubscriber = OuterSubscriber;
	//# sourceMappingURL=OuterSubscriber.js.map

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(6);
	var ScalarObservable_1 = __webpack_require__(70);
	var EmptyObservable_1 = __webpack_require__(68);
	var isScheduler_1 = __webpack_require__(79);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var ArrayObservable = (function (_super) {
	    __extends(ArrayObservable, _super);
	    function ArrayObservable(array, scheduler) {
	        _super.call(this);
	        this.array = array;
	        this.scheduler = scheduler;
	        if (!scheduler && array.length === 1) {
	            this._isScalar = true;
	            this.value = array[0];
	        }
	    }
	    ArrayObservable.create = function (array, scheduler) {
	        return new ArrayObservable(array, scheduler);
	    };
	    /**
	     * Creates an Observable that emits some values you specify as arguments,
	     * immediately one after the other, and then emits a complete notification.
	     *
	     * <span class="informal">Emits the arguments you provide, then completes.
	     * </span>
	     *
	     * <img src="./img/of.png" width="100%">
	     *
	     * This static operator is useful for creating a simple Observable that only
	     * emits the arguments given, and the complete notification thereafter. It can
	     * be used for composing with other Observables, such as with {@link concat}.
	     * By default, it uses a `null` IScheduler, which means the `next`
	     * notifications are sent synchronously, although with a different IScheduler
	     * it is possible to determine when those notifications will be delivered.
	     *
	     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>
	     * var numbers = Rx.Observable.of(10, 20, 30);
	     * var letters = Rx.Observable.of('a', 'b', 'c');
	     * var interval = Rx.Observable.interval(1000);
	     * var result = numbers.concat(letters).concat(interval);
	     * result.subscribe(x => console.log(x));
	     *
	     * @see {@link create}
	     * @see {@link empty}
	     * @see {@link never}
	     * @see {@link throw}
	     *
	     * @param {...T} values Arguments that represent `next` values to be emitted.
	     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
	     * the emissions of the `next` notifications.
	     * @return {Observable<T>} An Observable that emits each given input value.
	     * @static true
	     * @name of
	     * @owner Observable
	     */
	    ArrayObservable.of = function () {
	        var array = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            array[_i - 0] = arguments[_i];
	        }
	        var scheduler = array[array.length - 1];
	        if (isScheduler_1.isScheduler(scheduler)) {
	            array.pop();
	        }
	        else {
	            scheduler = null;
	        }
	        var len = array.length;
	        if (len > 1) {
	            return new ArrayObservable(array, scheduler);
	        }
	        else if (len === 1) {
	            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
	        }
	        else {
	            return new EmptyObservable_1.EmptyObservable(scheduler);
	        }
	    };
	    ArrayObservable.dispatch = function (state) {
	        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;
	        if (index >= count) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(array[index]);
	        if (subscriber.closed) {
	            return;
	        }
	        state.index = index + 1;
	        this.schedule(state);
	    };
	    ArrayObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var array = this.array;
	        var count = array.length;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(ArrayObservable.dispatch, 0, {
	                array: array, index: index, count: count, subscriber: subscriber
	            });
	        }
	        else {
	            for (var i = 0; i < count && !subscriber.closed; i++) {
	                subscriber.next(array[i]);
	            }
	            subscriber.complete();
	        }
	    };
	    return ArrayObservable;
	}(Observable_1.Observable));
	exports.ArrayObservable = ArrayObservable;
	//# sourceMappingURL=ArrayObservable.js.map

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(35);
	var subscribeToResult_1 = __webpack_require__(42);
	/**
	 * Converts a higher-order Observable into a first-order Observable which
	 * concurrently delivers all values that are emitted on the inner Observables.
	 *
	 * <span class="informal">Flattens an Observable-of-Observables.</span>
	 *
	 * <img src="./img/mergeAll.png" width="100%">
	 *
	 * `mergeAll` subscribes to an Observable that emits Observables, also known as
	 * a higher-order Observable. Each time it observes one of these emitted inner
	 * Observables, it subscribes to that and delivers all the values from the
	 * inner Observable on the output Observable. The output Observable only
	 * completes once all inner Observables have completed. Any error delivered by
	 * a inner Observable will be immediately emitted on the output Observable.
	 *
	 * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
	 * var firstOrder = higherOrder.mergeAll();
	 * firstOrder.subscribe(x => console.log(x));
	 *
	 * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
	 * var firstOrder = higherOrder.mergeAll(2);
	 * firstOrder.subscribe(x => console.log(x));
	 *
	 * @see {@link combineAll}
	 * @see {@link concatAll}
	 * @see {@link exhaust}
	 * @see {@link merge}
	 * @see {@link mergeMap}
	 * @see {@link mergeMapTo}
	 * @see {@link mergeScan}
	 * @see {@link switch}
	 * @see {@link zipAll}
	 *
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
	 * Observables being subscribed to concurrently.
	 * @return {Observable} An Observable that emits values coming from all the
	 * inner Observables emitted by the source Observable.
	 * @method mergeAll
	 * @owner Observable
	 */
	function mergeAll(concurrent) {
	    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	    return this.lift(new MergeAllOperator(concurrent));
	}
	exports.mergeAll = mergeAll;
	var MergeAllOperator = (function () {
	    function MergeAllOperator(concurrent) {
	        this.concurrent = concurrent;
	    }
	    MergeAllOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new MergeAllSubscriber(observer, this.concurrent));
	    };
	    return MergeAllOperator;
	}());
	exports.MergeAllOperator = MergeAllOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MergeAllSubscriber = (function (_super) {
	    __extends(MergeAllSubscriber, _super);
	    function MergeAllSubscriber(destination, concurrent) {
	        _super.call(this, destination);
	        this.concurrent = concurrent;
	        this.hasCompleted = false;
	        this.buffer = [];
	        this.active = 0;
	    }
	    MergeAllSubscriber.prototype._next = function (observable) {
	        if (this.active < this.concurrent) {
	            this.active++;
	            this.add(subscribeToResult_1.subscribeToResult(this, observable));
	        }
	        else {
	            this.buffer.push(observable);
	        }
	    };
	    MergeAllSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.active === 0 && this.buffer.length === 0) {
	            this.destination.complete();
	        }
	    };
	    MergeAllSubscriber.prototype.notifyComplete = function (innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer.length > 0) {
	            this._next(buffer.shift());
	        }
	        else if (this.active === 0 && this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	    return MergeAllSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	exports.MergeAllSubscriber = MergeAllSubscriber;
	//# sourceMappingURL=mergeAll.js.map

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(17);
	function symbolIteratorPonyfill(root) {
	    var Symbol = root.Symbol;
	    if (typeof Symbol === 'function') {
	        if (!Symbol.iterator) {
	            Symbol.iterator = Symbol('iterator polyfill');
	        }
	        return Symbol.iterator;
	    }
	    else {
	        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)
	        var Set_1 = root.Set;
	        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {
	            return '@@iterator';
	        }
	        var Map_1 = root.Map;
	        // required for compatability with es6-shim
	        if (Map_1) {
	            var keys = Object.getOwnPropertyNames(Map_1.prototype);
	            for (var i = 0; i < keys.length; ++i) {
	                var key = keys[i];
	                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.
	                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {
	                    return key;
	                }
	            }
	        }
	        return '@@iterator';
	    }
	}
	exports.symbolIteratorPonyfill = symbolIteratorPonyfill;
	exports.iterator = symbolIteratorPonyfill(root_1.root);
	/**
	 * @deprecated use iterator instead
	 */
	exports.$$iterator = exports.iterator;
	//# sourceMappingURL=iterator.js.map

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(17);
	function getSymbolObservable(context) {
	    var $$observable;
	    var Symbol = context.Symbol;
	    if (typeof Symbol === 'function') {
	        if (Symbol.observable) {
	            $$observable = Symbol.observable;
	        }
	        else {
	            $$observable = Symbol('observable');
	            Symbol.observable = $$observable;
	        }
	    }
	    else {
	        $$observable = '@@observable';
	    }
	    return $$observable;
	}
	exports.getSymbolObservable = getSymbolObservable;
	exports.observable = getSymbolObservable(root_1.root);
	/**
	 * @deprecated use observable instead
	 */
	exports.$$observable = exports.observable;
	//# sourceMappingURL=observable.js.map

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(17);
	var Symbol = root_1.root.Symbol;
	exports.rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
	    Symbol.for('rxSubscriber') : '@@rxSubscriber';
	/**
	 * @deprecated use rxSubscriber instead
	 */
	exports.$$rxSubscriber = exports.rxSubscriber;
	//# sourceMappingURL=rxSubscriber.js.map

/***/ }),
/* 41 */
/***/ (function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when an Observable or a sequence was queried but has no
	 * elements.
	 *
	 * @see {@link first}
	 * @see {@link last}
	 * @see {@link single}
	 *
	 * @class EmptyError
	 */
	var EmptyError = (function (_super) {
	    __extends(EmptyError, _super);
	    function EmptyError() {
	        var err = _super.call(this, 'no elements in sequence');
	        this.name = err.name = 'EmptyError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return EmptyError;
	}(Error));
	exports.EmptyError = EmptyError;
	//# sourceMappingURL=EmptyError.js.map

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(17);
	var isArrayLike_1 = __webpack_require__(75);
	var isPromise_1 = __webpack_require__(78);
	var isObject_1 = __webpack_require__(77);
	var Observable_1 = __webpack_require__(6);
	var iterator_1 = __webpack_require__(38);
	var InnerSubscriber_1 = __webpack_require__(193);
	var observable_1 = __webpack_require__(39);
	function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
	    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
	    if (destination.closed) {
	        return null;
	    }
	    if (result instanceof Observable_1.Observable) {
	        if (result._isScalar) {
	            destination.next(result.value);
	            destination.complete();
	            return null;
	        }
	        else {
	            return result.subscribe(destination);
	        }
	    }
	    else if (isArrayLike_1.isArrayLike(result)) {
	        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {
	            destination.next(result[i]);
	        }
	        if (!destination.closed) {
	            destination.complete();
	        }
	    }
	    else if (isPromise_1.isPromise(result)) {
	        result.then(function (value) {
	            if (!destination.closed) {
	                destination.next(value);
	                destination.complete();
	            }
	        }, function (err) { return destination.error(err); })
	            .then(null, function (err) {
	            // Escaping the Promise trap: globally throw unhandled errors
	            root_1.root.setTimeout(function () { throw err; });
	        });
	        return destination;
	    }
	    else if (result && typeof result[iterator_1.iterator] === 'function') {
	        var iterator = result[iterator_1.iterator]();
	        do {
	            var item = iterator.next();
	            if (item.done) {
	                destination.complete();
	                break;
	            }
	            destination.next(item.value);
	            if (destination.closed) {
	                break;
	            }
	        } while (true);
	    }
	    else if (result && typeof result[observable_1.observable] === 'function') {
	        var obs = result[observable_1.observable]();
	        if (typeof obs.subscribe !== 'function') {
	            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));
	        }
	        else {
	            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
	        }
	    }
	    else {
	        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
	        var msg = ("You provided " + value + " where a stream was expected.")
	            + ' You can provide an Observable, Promise, Array, or Iterable.';
	        destination.error(new TypeError(msg));
	    }
	    return null;
	}
	exports.subscribeToResult = subscribeToResult;
	//# sourceMappingURL=subscribeToResult.js.map

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _Observable3 = __webpack_require__(4);
	
	var _Observable4 = _interopRequireDefault(_Observable3);
	
	var _Subscription3 = __webpack_require__(5);
	
	var _Subscription4 = _interopRequireDefault(_Subscription3);
	
	var ConnectableObservable = (function (_Observable) {
	    _inherits(ConnectableObservable, _Observable);
	
	    function ConnectableObservable(source, subjectFactory) {
	        _classCallCheck(this, ConnectableObservable);
	
	        _Observable.call(this);
	        this.source = source;
	        this.subjectFactory = subjectFactory;
	    }
	
	    ConnectableObservable.prototype._subscribe = function _subscribe(subscriber) {
	        return this._getSubject().subscribe(subscriber);
	    };
	
	    ConnectableObservable.prototype._getSubject = function _getSubject() {
	        var subject = this.subject;
	        if (subject && !subject.isUnsubscribed) {
	            return subject;
	        }
	        return this.subject = this.subjectFactory();
	    };
	
	    ConnectableObservable.prototype.connect = function connect() {
	        var source = this.source;
	        var subscription = this.subscription;
	        if (subscription && !subscription.isUnsubscribed) {
	            return subscription;
	        }
	        subscription = source.subscribe(this._getSubject());
	        subscription.add(new ConnectableSubscription(this));
	        return this.subscription = subscription;
	    };
	
	    ConnectableObservable.prototype.refCount = function refCount() {
	        return new RefCountObservable(this);
	    };
	
	    return ConnectableObservable;
	})(_Observable4['default']);
	
	exports['default'] = ConnectableObservable;
	
	var ConnectableSubscription = (function (_Subscription) {
	    _inherits(ConnectableSubscription, _Subscription);
	
	    function ConnectableSubscription(connectable) {
	        _classCallCheck(this, ConnectableSubscription);
	
	        _Subscription.call(this);
	        this.connectable = connectable;
	    }
	
	    ConnectableSubscription.prototype._unsubscribe = function _unsubscribe() {
	        var connectable = this.connectable;
	        connectable.subject = void 0;
	        connectable.subscription = void 0;
	        this.connectable = void 0;
	    };
	
	    return ConnectableSubscription;
	})(_Subscription4['default']);
	
	var RefCountObservable = (function (_Observable2) {
	    _inherits(RefCountObservable, _Observable2);
	
	    function RefCountObservable(connectable) {
	        var refCount = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	
	        _classCallCheck(this, RefCountObservable);
	
	        _Observable2.call(this);
	        this.connectable = connectable;
	        this.refCount = refCount;
	    }
	
	    RefCountObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var connectable = this.connectable;
	        var subscription = connectable.subscribe(subscriber);
	        if (++this.refCount === 1) {
	            this.connection = connectable.connect();
	        }
	        subscription.add(new RefCountSubscription(this));
	        return subscription;
	    };
	
	    return RefCountObservable;
	})(_Observable4['default']);
	
	var RefCountSubscription = (function (_Subscription2) {
	    _inherits(RefCountSubscription, _Subscription2);
	
	    function RefCountSubscription(refCountObservable) {
	        _classCallCheck(this, RefCountSubscription);
	
	        _Subscription2.call(this);
	        this.refCountObservable = refCountObservable;
	    }
	
	    RefCountSubscription.prototype._unsubscribe = function _unsubscribe() {
	        var observable = this.refCountObservable;
	        if (--observable.refCount === 0) {
	            observable.connection.unsubscribe();
	            observable.connection = void 0;
	        }
	    };
	
	    return RefCountSubscription;
	})(_Subscription4['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = concat;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _Observable = __webpack_require__(4);
	
	var _Observable2 = _interopRequireDefault(_Observable);
	
	var _schedulersImmediate = __webpack_require__(10);
	
	var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);
	
	/**
	 * Joins multiple observables together by subscribing to them one at a time and merging their results
	 * into the returned observable. Will wait for each observable to complete before moving on to the next.
	 * @params {...Observable} the observables to concatenate
	 * @params {Scheduler} [scheduler] an optional scheduler to schedule each observable subscription on.
	 * @returns {Observable} All values of each passed observable merged into a single observable, in order, in serial fashion.
	 */
	
	function concat() {
	    var scheduler = _schedulersImmediate2['default'];
	
	    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
	        observables[_key] = arguments[_key];
	    }
	
	    var args = observables;
	    var len = args.length;
	    if (typeof args[observables.length - 1].schedule === 'function') {
	        scheduler = args.pop();
	        args.push(1, scheduler);
	    }
	    return _Observable2['default'].fromArray(observables).mergeAll(1);
	}
	
	module.exports = exports['default'];

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = distinctUntilChanged;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	var _utilBindCallback = __webpack_require__(15);
	
	var _utilBindCallback2 = _interopRequireDefault(_utilBindCallback);
	
	function distinctUntilChanged(compare, thisArg) {
	    return this.lift(new DistinctUntilChangedOperator(thisArg ? _utilBindCallback2['default'](compare, thisArg, 2) : compare));
	}
	
	var DistinctUntilChangedOperator = (function () {
	    function DistinctUntilChangedOperator(compare) {
	        _classCallCheck(this, DistinctUntilChangedOperator);
	
	        this.compare = compare;
	    }
	
	    DistinctUntilChangedOperator.prototype.call = function call(subscriber) {
	        return new DistinctUntilChangedSubscriber(subscriber, this.compare);
	    };
	
	    return DistinctUntilChangedOperator;
	})();
	
	var DistinctUntilChangedSubscriber = (function (_Subscriber) {
	    _inherits(DistinctUntilChangedSubscriber, _Subscriber);
	
	    function DistinctUntilChangedSubscriber(destination, compare) {
	        _classCallCheck(this, DistinctUntilChangedSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.hasValue = false;
	        if (typeof compare === 'function') {
	            this.compare = compare;
	        }
	    }
	
	    DistinctUntilChangedSubscriber.prototype.compare = function compare(x, y) {
	        return x === y;
	    };
	
	    DistinctUntilChangedSubscriber.prototype._next = function _next(x) {
	        var result = false;
	        if (this.hasValue) {
	            result = _utilTryCatch2['default'](this.compare)(this.value, x);
	            if (result === _utilErrorObject.errorObject) {
	                this.destination.error(_utilErrorObject.errorObject.e);
	                return;
	            }
	        } else {
	            this.hasValue = true;
	        }
	        if (Boolean(result) === false) {
	            this.value = x;
	            this.destination.next(x);
	        }
	    };
	
	    return DistinctUntilChangedSubscriber;
	})(_Subscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	var _utilBindCallback = __webpack_require__(15);
	
	var _utilBindCallback2 = _interopRequireDefault(_utilBindCallback);
	
	var FindValueOperator = (function () {
	    function FindValueOperator(predicate, source, yieldIndex, thisArg) {
	        _classCallCheck(this, FindValueOperator);
	
	        this.predicate = predicate;
	        this.source = source;
	        this.yieldIndex = yieldIndex;
	        this.thisArg = thisArg;
	    }
	
	    FindValueOperator.prototype.call = function call(observer) {
	        return new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg);
	    };
	
	    return FindValueOperator;
	})();
	
	exports.FindValueOperator = FindValueOperator;
	
	var FindValueSubscriber = (function (_Subscriber) {
	    _inherits(FindValueSubscriber, _Subscriber);
	
	    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
	        _classCallCheck(this, FindValueSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.source = source;
	        this.yieldIndex = yieldIndex;
	        this.thisArg = thisArg;
	        this.index = 0;
	        if (typeof predicate === 'function') {
	            this.predicate = _utilBindCallback2['default'](predicate, thisArg, 3);
	        }
	    }
	
	    FindValueSubscriber.prototype.notifyComplete = function notifyComplete(value) {
	        var destination = this.destination;
	        destination.next(value);
	        destination.complete();
	    };
	
	    FindValueSubscriber.prototype._next = function _next(value) {
	        var predicate = this.predicate;
	        if (predicate === undefined) {
	            this.destination.error(new TypeError('predicate must be a function'));
	        }
	        var index = this.index++;
	        var result = _utilTryCatch2['default'](predicate)(value, index, this.source);
	        if (result === _utilErrorObject.errorObject) {
	            this.destination.error(result.e);
	        } else if (result) {
	            this.notifyComplete(this.yieldIndex ? index : value);
	        }
	    };
	
	    FindValueSubscriber.prototype._complete = function _complete() {
	        this.notifyComplete(this.yieldIndex ? -1 : undefined);
	    };
	
	    return FindValueSubscriber;
	})(_Subscriber3['default']);
	
	exports.FindValueSubscriber = FindValueSubscriber;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = filter;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	var _utilBindCallback = __webpack_require__(15);
	
	var _utilBindCallback2 = _interopRequireDefault(_utilBindCallback);
	
	/**
	 * Similar to the well-known `Array.prototype.filter` method, this operator filters values down to a set
	 * allowed by a `select` function
	 *
	 * @param {Function} select a function that is used to select the resulting values
	 *  if it returns `true`, the value is emitted, if `false` the value is not passed to the resulting observable
	 * @param {any} [thisArg] an optional argument to determine the value of `this` in the `select` function
	 * @returns {Observable} an observable of values allowed by the select function
	 */
	
	function filter(select, thisArg) {
	    return this.lift(new FilterOperator(select, thisArg));
	}
	
	var FilterOperator = (function () {
	    function FilterOperator(select, thisArg) {
	        _classCallCheck(this, FilterOperator);
	
	        this.select = _utilBindCallback2['default'](select, thisArg, 2);
	    }
	
	    FilterOperator.prototype.call = function call(subscriber) {
	        return new FilterSubscriber(subscriber, this.select);
	    };
	
	    return FilterOperator;
	})();
	
	var FilterSubscriber = (function (_Subscriber) {
	    _inherits(FilterSubscriber, _Subscriber);
	
	    function FilterSubscriber(destination, select) {
	        _classCallCheck(this, FilterSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.count = 0;
	        this.select = select;
	    }
	
	    FilterSubscriber.prototype._next = function _next(x) {
	        var result = _utilTryCatch2['default'](this.select)(x, this.count++);
	        if (result === _utilErrorObject.errorObject) {
	            this.destination.error(_utilErrorObject.errorObject.e);
	        } else if (Boolean(result)) {
	            this.destination.next(x);
	        }
	    };
	
	    return FilterSubscriber;
	})(_Subscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = merge;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _observablesArrayObservable = __webpack_require__(14);
	
	var _observablesArrayObservable2 = _interopRequireDefault(_observablesArrayObservable);
	
	var _mergeAllSupport = __webpack_require__(32);
	
	var _schedulersImmediate = __webpack_require__(10);
	
	var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);
	
	function merge() {
	    var concurrent = Number.POSITIVE_INFINITY;
	    var scheduler = _schedulersImmediate2['default'];
	
	    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
	        observables[_key] = arguments[_key];
	    }
	
	    var last = observables[observables.length - 1];
	    if (typeof last.schedule === 'function') {
	        scheduler = observables.pop();
	        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
	            concurrent = observables.pop();
	        }
	    } else if (typeof last === 'number') {
	        concurrent = observables.pop();
	    }
	    if (observables.length === 1) {
	        return observables[0];
	    }
	    return new _observablesArrayObservable2['default'](observables, scheduler).lift(new _mergeAllSupport.MergeAllOperator(concurrent));
	}
	
	module.exports = exports['default'];

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	var _utilSubscribeToResult = __webpack_require__(11);
	
	var _utilSubscribeToResult2 = _interopRequireDefault(_utilSubscribeToResult);
	
	var _OuterSubscriber2 = __webpack_require__(9);
	
	var _OuterSubscriber3 = _interopRequireDefault(_OuterSubscriber2);
	
	var MergeMapOperator = (function () {
	    function MergeMapOperator(project, resultSelector) {
	        var concurrent = arguments.length <= 2 || arguments[2] === undefined ? Number.POSITIVE_INFINITY : arguments[2];
	
	        _classCallCheck(this, MergeMapOperator);
	
	        this.project = project;
	        this.resultSelector = resultSelector;
	        this.concurrent = concurrent;
	    }
	
	    MergeMapOperator.prototype.call = function call(observer) {
	        return new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent);
	    };
	
	    return MergeMapOperator;
	})();
	
	exports.MergeMapOperator = MergeMapOperator;
	
	var MergeMapSubscriber = (function (_OuterSubscriber) {
	    _inherits(MergeMapSubscriber, _OuterSubscriber);
	
	    function MergeMapSubscriber(destination, project, resultSelector) {
	        var concurrent = arguments.length <= 3 || arguments[3] === undefined ? Number.POSITIVE_INFINITY : arguments[3];
	
	        _classCallCheck(this, MergeMapSubscriber);
	
	        _OuterSubscriber.call(this, destination);
	        this.project = project;
	        this.resultSelector = resultSelector;
	        this.concurrent = concurrent;
	        this.hasCompleted = false;
	        this.buffer = [];
	        this.active = 0;
	        this.index = 0;
	    }
	
	    MergeMapSubscriber.prototype._next = function _next(value) {
	        if (this.active < this.concurrent) {
	            var resultSelector = this.resultSelector;
	            var index = this.index++;
	            var ish = _utilTryCatch2['default'](this.project)(value, index);
	            var destination = this.destination;
	            if (ish === _utilErrorObject.errorObject) {
	                destination.error(ish.e);
	            } else {
	                this.active++;
	                this._innerSub(ish, value, index);
	            }
	        } else {
	            this.buffer.push(value);
	        }
	    };
	
	    MergeMapSubscriber.prototype._innerSub = function _innerSub(ish, value, index) {
	        this.add(_utilSubscribeToResult2['default'](this, ish, value, index));
	    };
	
	    MergeMapSubscriber.prototype._complete = function _complete() {
	        this.hasCompleted = true;
	        if (this.active === 0 && this.buffer.length === 0) {
	            this.destination.complete();
	        }
	    };
	
	    MergeMapSubscriber.prototype.notifyNext = function notifyNext(outerValue, innerValue, outerIndex, innerIndex) {
	        var destination = this.destination;
	        var resultSelector = this.resultSelector;
	
	        if (resultSelector) {
	            var result = _utilTryCatch2['default'](resultSelector)(outerValue, innerValue, outerIndex, innerIndex);
	            if (result === _utilErrorObject.errorObject) {
	                destination.error(_utilErrorObject.errorObject.e);
	            } else {
	                destination.next(result);
	            }
	        } else {
	            destination.next(innerValue);
	        }
	    };
	
	    MergeMapSubscriber.prototype.notifyComplete = function notifyComplete(innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer.length > 0) {
	            this._next(buffer.shift());
	        } else if (this.active === 0 && this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	
	    return MergeMapSubscriber;
	})(_OuterSubscriber3['default']);
	
	exports.MergeMapSubscriber = MergeMapSubscriber;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	var _Notification = __webpack_require__(18);
	
	var _Notification2 = _interopRequireDefault(_Notification);
	
	var ObserveOnOperator = (function () {
	    function ObserveOnOperator(scheduler) {
	        var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	
	        _classCallCheck(this, ObserveOnOperator);
	
	        this.delay = delay;
	        this.scheduler = scheduler;
	    }
	
	    ObserveOnOperator.prototype.call = function call(subscriber) {
	        return new ObserveOnSubscriber(subscriber, this.scheduler, this.delay);
	    };
	
	    return ObserveOnOperator;
	})();
	
	exports.ObserveOnOperator = ObserveOnOperator;
	
	var ObserveOnSubscriber = (function (_Subscriber) {
	    _inherits(ObserveOnSubscriber, _Subscriber);
	
	    function ObserveOnSubscriber(destination, scheduler) {
	        var delay = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	
	        _classCallCheck(this, ObserveOnSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.delay = delay;
	        this.scheduler = scheduler;
	    }
	
	    ObserveOnSubscriber.dispatch = function dispatch(_ref) {
	        var notification = _ref.notification;
	        var destination = _ref.destination;
	
	        notification.observe(destination);
	    };
	
	    ObserveOnSubscriber.prototype._next = function _next(x) {
	        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(_Notification2['default'].createNext(x), this.destination)));
	    };
	
	    ObserveOnSubscriber.prototype._error = function _error(e) {
	        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(_Notification2['default'].createError(e), this.destination)));
	    };
	
	    ObserveOnSubscriber.prototype._complete = function _complete() {
	        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(_Notification2['default'].createComplete(), this.destination)));
	    };
	
	    return ObserveOnSubscriber;
	})(_Subscriber3['default']);
	
	exports.ObserveOnSubscriber = ObserveOnSubscriber;
	
	var ObserveOnMessage = function ObserveOnMessage(notification, destination) {
	    _classCallCheck(this, ObserveOnMessage);
	
	    this.notification = notification;
	    this.destination = destination;
	};

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = publish;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _Subject = __webpack_require__(7);
	
	var _Subject2 = _interopRequireDefault(_Subject);
	
	var _multicast = __webpack_require__(23);
	
	var _multicast2 = _interopRequireDefault(_multicast);
	
	function subjectFactory() {
	    return new _Subject2['default']();
	}
	
	function publish() {
	    return _multicast2['default'].call(this, subjectFactory);
	}
	
	module.exports = exports['default'];

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = publishReplay;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _subjectsReplaySubject = __webpack_require__(58);
	
	var _subjectsReplaySubject2 = _interopRequireDefault(_subjectsReplaySubject);
	
	var _multicast = __webpack_require__(23);
	
	var _multicast2 = _interopRequireDefault(_multicast);
	
	function publishReplay(bufferSize, windowTime, scheduler) {
	    if (bufferSize === undefined) bufferSize = Number.POSITIVE_INFINITY;
	    if (windowTime === undefined) windowTime = Number.POSITIVE_INFINITY;
	
	    return _multicast2['default'].call(this, function () {
	        return new _subjectsReplaySubject2['default'](bufferSize, windowTime, scheduler);
	    });
	}
	
	module.exports = exports['default'];

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = zip;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _observablesArrayObservable = __webpack_require__(14);
	
	var _observablesArrayObservable2 = _interopRequireDefault(_observablesArrayObservable);
	
	var _zipSupport = __webpack_require__(54);
	
	function zip() {
	    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
	        observables[_key] = arguments[_key];
	    }
	
	    var project = observables[observables.length - 1];
	    if (typeof project === 'function') {
	        observables.pop();
	    }
	    return new _observablesArrayObservable2['default'](observables).lift(new _zipSupport.ZipOperator(project));
	}
	
	module.exports = exports['default'];

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	var _OuterSubscriber2 = __webpack_require__(9);
	
	var _OuterSubscriber3 = _interopRequireDefault(_OuterSubscriber2);
	
	var _utilSubscribeToResult = __webpack_require__(11);
	
	var _utilSubscribeToResult2 = _interopRequireDefault(_utilSubscribeToResult);
	
	var _utilSymbol_iterator = __webpack_require__(26);
	
	var _utilSymbol_iterator2 = _interopRequireDefault(_utilSymbol_iterator);
	
	var isArray = Array.isArray;
	
	var ZipOperator = (function () {
	    function ZipOperator(project) {
	        _classCallCheck(this, ZipOperator);
	
	        this.project = project;
	    }
	
	    ZipOperator.prototype.call = function call(subscriber) {
	        return new ZipSubscriber(subscriber, this.project);
	    };
	
	    return ZipOperator;
	})();
	
	exports.ZipOperator = ZipOperator;
	
	var ZipSubscriber = (function (_Subscriber) {
	    _inherits(ZipSubscriber, _Subscriber);
	
	    function ZipSubscriber(destination, project) {
	        var values = arguments.length <= 2 || arguments[2] === undefined ? Object.create(null) : arguments[2];
	
	        _classCallCheck(this, ZipSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.index = 0;
	        this.iterators = [];
	        this.active = 0;
	        this.project = typeof project === 'function' ? project : null;
	        this.values = values;
	    }
	
	    ZipSubscriber.prototype._next = function _next(value) {
	        var iterators = this.iterators;
	        var index = this.index++;
	        if (isArray(value)) {
	            iterators.push(new StaticArrayIterator(value));
	        } else if (typeof value[_utilSymbol_iterator2['default']] === 'function') {
	            iterators.push(new StaticIterator(value[_utilSymbol_iterator2['default']]()));
	        } else {
	            iterators.push(new ZipBufferIterator(this.destination, this, value, index));
	        }
	    };
	
	    ZipSubscriber.prototype._complete = function _complete() {
	        var values = this.values;
	        var iterators = this.iterators;
	        var len = iterators.length;
	        this.active = len;
	        for (var i = 0; i < len; i++) {
	            var iterator = iterators[i];
	            if (iterator.stillUnsubscribed) {
	                iterator.subscribe(iterator, i);
	            } else {
	                this.active--; // not an observable
	            }
	        }
	    };
	
	    ZipSubscriber.prototype.notifyInactive = function notifyInactive() {
	        this.active--;
	        if (this.active === 0) {
	            this.destination.complete();
	        }
	    };
	
	    ZipSubscriber.prototype.checkIterators = function checkIterators() {
	        var iterators = this.iterators;
	        var len = iterators.length;
	        var destination = this.destination;
	        // abort if not all of them have values
	        for (var i = 0; i < len; i++) {
	            var iterator = iterators[i];
	            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
	                return;
	            }
	        }
	        var shouldComplete = false;
	        var args = [];
	        for (var i = 0; i < len; i++) {
	            var iterator = iterators[i];
	            var result = iterator.next();
	            // check to see if it's completed now that you've gotten
	            // the next value.
	            if (iterator.hasCompleted()) {
	                shouldComplete = true;
	            }
	            if (result.done) {
	                destination.complete();
	                return;
	            }
	            args.push(result.value);
	        }
	        var project = this.project;
	        if (project) {
	            var result = _utilTryCatch2['default'](project).apply(this, args);
	            if (result === _utilErrorObject.errorObject) {
	                destination.error(_utilErrorObject.errorObject.e);
	            } else {
	                destination.next(result);
	            }
	        } else {
	            destination.next(args);
	        }
	        if (shouldComplete) {
	            destination.complete();
	        }
	    };
	
	    return ZipSubscriber;
	})(_Subscriber3['default']);
	
	exports.ZipSubscriber = ZipSubscriber;
	
	var StaticIterator = (function () {
	    function StaticIterator(iterator) {
	        _classCallCheck(this, StaticIterator);
	
	        this.iterator = iterator;
	        this.nextResult = iterator.next();
	    }
	
	    StaticIterator.prototype.hasValue = function hasValue() {
	        return true;
	    };
	
	    StaticIterator.prototype.next = function next() {
	        var result = this.nextResult;
	        this.nextResult = this.iterator.next();
	        return result;
	    };
	
	    StaticIterator.prototype.hasCompleted = function hasCompleted() {
	        var nextResult = this.nextResult;
	        return nextResult && nextResult.done;
	    };
	
	    return StaticIterator;
	})();
	
	var StaticArrayIterator = (function () {
	    function StaticArrayIterator(array) {
	        _classCallCheck(this, StaticArrayIterator);
	
	        this.array = array;
	        this.index = 0;
	        this.length = 0;
	        this.length = array.length;
	    }
	
	    StaticArrayIterator.prototype[_utilSymbol_iterator2['default']] = function () {
	        return this;
	    };
	
	    StaticArrayIterator.prototype.next = function next(value) {
	        var i = this.index++;
	        var array = this.array;
	        return i < this.length ? { value: array[i], done: false } : { done: true };
	    };
	
	    StaticArrayIterator.prototype.hasValue = function hasValue() {
	        return this.array.length > this.index;
	    };
	
	    StaticArrayIterator.prototype.hasCompleted = function hasCompleted() {
	        return this.array.length === this.index;
	    };
	
	    return StaticArrayIterator;
	})();
	
	var ZipBufferIterator = (function (_OuterSubscriber) {
	    _inherits(ZipBufferIterator, _OuterSubscriber);
	
	    function ZipBufferIterator(destination, parent, observable, index) {
	        _classCallCheck(this, ZipBufferIterator);
	
	        _OuterSubscriber.call(this, destination);
	        this.parent = parent;
	        this.observable = observable;
	        this.index = index;
	        this.stillUnsubscribed = true;
	        this.buffer = [];
	        this.isComplete = false;
	    }
	
	    ZipBufferIterator.prototype[_utilSymbol_iterator2['default']] = function () {
	        return this;
	    };
	
	    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next
	    //    this is legit because `next()` will never be called by a subscription in this case.
	
	    ZipBufferIterator.prototype.next = function next() {
	        var buffer = this.buffer;
	        if (buffer.length === 0 && this.isComplete) {
	            return { done: true };
	        } else {
	            return { value: buffer.shift(), done: false };
	        }
	    };
	
	    ZipBufferIterator.prototype.hasValue = function hasValue() {
	        return this.buffer.length > 0;
	    };
	
	    ZipBufferIterator.prototype.hasCompleted = function hasCompleted() {
	        return this.buffer.length === 0 && this.isComplete;
	    };
	
	    ZipBufferIterator.prototype.notifyComplete = function notifyComplete() {
	        if (this.buffer.length > 0) {
	            this.isComplete = true;
	            this.parent.notifyInactive();
	        } else {
	            this.destination.complete();
	        }
	    };
	
	    ZipBufferIterator.prototype.notifyNext = function notifyNext(outerValue, innerValue, outerIndex, innerIndex) {
	        this.buffer.push(innerValue);
	        this.parent.checkIterators();
	    };
	
	    ZipBufferIterator.prototype.subscribe = function subscribe(value, index) {
	        this.add(_utilSubscribeToResult2['default'](this, this.observable, this, index));
	    };
	
	    return ZipBufferIterator;
	})(_OuterSubscriber3['default']);

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _ImmediateAction = __webpack_require__(24);
	
	var _ImmediateAction2 = _interopRequireDefault(_ImmediateAction);
	
	var _FutureAction = __webpack_require__(174);
	
	var _FutureAction2 = _interopRequireDefault(_FutureAction);
	
	var ImmediateScheduler = (function () {
	    function ImmediateScheduler() {
	        _classCallCheck(this, ImmediateScheduler);
	
	        this.actions = [];
	        this.active = false;
	        this.scheduled = false;
	    }
	
	    ImmediateScheduler.prototype.now = function now() {
	        return Date.now();
	    };
	
	    ImmediateScheduler.prototype.flush = function flush() {
	        if (this.active || this.scheduled) {
	            return;
	        }
	        this.active = true;
	        var actions = this.actions;
	        for (var action = undefined; action = actions.shift();) {
	            action.execute();
	        }
	        this.active = false;
	    };
	
	    ImmediateScheduler.prototype.schedule = function schedule(work, delay, state) {
	        if (delay === undefined) delay = 0;
	
	        return delay <= 0 ? this.scheduleNow(work, state) : this.scheduleLater(work, delay, state);
	    };
	
	    ImmediateScheduler.prototype.scheduleNow = function scheduleNow(work, state) {
	        return new _ImmediateAction2['default'](this, work).schedule(state);
	    };
	
	    ImmediateScheduler.prototype.scheduleLater = function scheduleLater(work, delay, state) {
	        return new _FutureAction2['default'](this, work).schedule(state, delay);
	    };
	
	    return ImmediateScheduler;
	})();
	
	exports['default'] = ImmediateScheduler;
	module.exports = exports['default'];

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscription2 = __webpack_require__(5);
	
	var _Subscription3 = _interopRequireDefault(_Subscription2);
	
	var VirtualTimeScheduler = (function () {
	    function VirtualTimeScheduler() {
	        _classCallCheck(this, VirtualTimeScheduler);
	
	        this.actions = [];
	        this.active = false;
	        this.scheduled = false;
	        this.index = 0;
	        this.sorted = false;
	        this.frame = 0;
	        this.maxFrames = 750;
	    }
	
	    VirtualTimeScheduler.prototype.now = function now() {
	        return this.frame;
	    };
	
	    VirtualTimeScheduler.prototype.flush = function flush() {
	        var actions = this.actions;
	        var maxFrames = this.maxFrames;
	        while (actions.length > 0) {
	            var action = actions.shift();
	            this.frame = action.delay;
	            if (this.frame <= maxFrames) {
	                action.execute();
	            } else {
	                break;
	            }
	        }
	        actions.length = 0;
	        this.frame = 0;
	    };
	
	    VirtualTimeScheduler.prototype.addAction = function addAction(action) {
	        var findDelay = action.delay;
	        var actions = this.actions;
	        var len = actions.length;
	        var vaction = action;
	        actions.push(action);
	        actions.sort(function (a, b) {
	            if (a.delay === b.delay) {
	                if (a.index === b.index) {
	                    return 0;
	                } else if (a.index > b.index) {
	                    return 1;
	                } else {
	                    return -1;
	                }
	            } else if (a.delay > b.delay) {
	                return 1;
	            } else {
	                return -1;
	            }
	        });
	    };
	
	    VirtualTimeScheduler.prototype.schedule = function schedule(work, delay, state) {
	        if (delay === undefined) delay = 0;
	
	        this.sorted = false;
	        return new VirtualAction(this, work, this.index++).schedule(state, delay);
	    };
	
	    return VirtualTimeScheduler;
	})();
	
	exports['default'] = VirtualTimeScheduler;
	
	VirtualTimeScheduler.frameTimeFactor = 10;
	
	var VirtualAction = (function (_Subscription) {
	    _inherits(VirtualAction, _Subscription);
	
	    function VirtualAction(scheduler, work, index) {
	        _classCallCheck(this, VirtualAction);
	
	        _Subscription.call(this);
	        this.scheduler = scheduler;
	        this.work = work;
	        this.index = index;
	        this.calls = 0;
	    }
	
	    VirtualAction.prototype.schedule = function schedule(state) {
	        var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	
	        if (this.isUnsubscribed) {
	            return this;
	        }
	        var scheduler = this.scheduler;
	        var action = undefined;
	        if (this.calls++ === 0) {
	            // the action is not being rescheduled.
	            action = this;
	        } else {
	            // the action is being rescheduled, and we can't mutate the one in the actions list
	            // in the scheduler, so we'll create a new one.
	            action = new VirtualAction(scheduler, this.work, scheduler.index += 1);
	            this.add(action);
	        }
	        action.state = state;
	        action.delay = scheduler.frame + delay;
	        scheduler.addAction(action);
	        return this;
	    };
	
	    VirtualAction.prototype.execute = function execute() {
	        if (this.isUnsubscribed) {
	            throw new Error('How did did we execute a canceled Action?');
	        }
	        this.work(this.state);
	    };
	
	    VirtualAction.prototype.unsubscribe = function unsubscribe() {
	        var actions = this.scheduler.actions;
	        var index = actions.indexOf(this);
	        this.work = void 0;
	        this.state = void 0;
	        this.scheduler = void 0;
	        if (index !== -1) {
	            actions.splice(index, 1);
	        }
	        _Subscription.prototype.unsubscribe.call(this);
	    };
	
	    return VirtualAction;
	})(_Subscription3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _Subject2 = __webpack_require__(7);
	
	var _Subject3 = _interopRequireDefault(_Subject2);
	
	var BehaviorSubject = (function (_Subject) {
	    _inherits(BehaviorSubject, _Subject);
	
	    function BehaviorSubject(value) {
	        _classCallCheck(this, BehaviorSubject);
	
	        _Subject.call(this);
	        this.value = value;
	    }
	
	    BehaviorSubject.prototype._subscribe = function _subscribe(subscriber) {
	        var subscription = _Subject.prototype._subscribe.call(this, subscriber);
	        if (!subscription) {
	            return;
	        } else if (!subscription.isUnsubscribed) {
	            subscriber.next(this.value);
	        }
	        return subscription;
	    };
	
	    BehaviorSubject.prototype._next = function _next(value) {
	        _Subject.prototype._next.call(this, this.value = value);
	    };
	
	    return BehaviorSubject;
	})(_Subject3['default']);
	
	exports['default'] = BehaviorSubject;
	module.exports = exports['default'];

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _Subject2 = __webpack_require__(7);
	
	var _Subject3 = _interopRequireDefault(_Subject2);
	
	var _schedulersImmediate = __webpack_require__(10);
	
	var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);
	
	var ReplaySubject = (function (_Subject) {
	    _inherits(ReplaySubject, _Subject);
	
	    function ReplaySubject(bufferSize, _windowTime, scheduler) {
	        if (bufferSize === undefined) bufferSize = Number.POSITIVE_INFINITY;
	        if (_windowTime === undefined) _windowTime = Number.POSITIVE_INFINITY;
	
	        _classCallCheck(this, ReplaySubject);
	
	        _Subject.call(this);
	        this.events = [];
	        this.bufferSize = bufferSize < 1 ? 1 : bufferSize;
	        this._windowTime = _windowTime < 1 ? 1 : _windowTime;
	        this.scheduler = scheduler;
	    }
	
	    ReplaySubject.prototype._next = function _next(value) {
	        var now = this._getNow();
	        this.events.push(new ReplayEvent(now, value));
	        _Subject.prototype._next.call(this, value);
	    };
	
	    ReplaySubject.prototype._subscribe = function _subscribe(subscriber) {
	        var events = this._getEvents(this._getNow());
	        var index = -1;
	        var len = events.length;
	        while (!subscriber.isUnsubscribed && ++index < len) {
	            subscriber.next(events[index].value);
	        }
	        return _Subject.prototype._subscribe.call(this, subscriber);
	    };
	
	    ReplaySubject.prototype._getNow = function _getNow() {
	        return (this.scheduler || _schedulersImmediate2['default']).now();
	    };
	
	    ReplaySubject.prototype._getEvents = function _getEvents(now) {
	        var bufferSize = this.bufferSize;
	        var _windowTime = this._windowTime;
	        var events = this.events;
	        var eventsCount = events.length;
	        var spliceCount = 0;
	        // Trim events that fall out of the time window.
	        // Start at the front of the list. Break early once
	        // we encounter an event that falls within the window.
	        while (spliceCount < eventsCount) {
	            if (now - events[spliceCount].time < _windowTime) {
	                break;
	            }
	            spliceCount += 1;
	        }
	        if (eventsCount > bufferSize) {
	            spliceCount = Math.max(spliceCount, eventsCount - bufferSize);
	        }
	        if (spliceCount > 0) {
	            events.splice(0, spliceCount);
	        }
	        return events;
	    };
	
	    return ReplaySubject;
	})(_Subject3['default']);
	
	exports['default'] = ReplaySubject;
	
	var ReplayEvent = function ReplayEvent(time, value) {
	    _classCallCheck(this, ReplayEvent);
	
	    this.time = time;
	    this.value = value;
	};
	
	module.exports = exports['default'];

/***/ }),
/* 59 */
/***/ (function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var SubscriptionLog = function SubscriptionLog(subscribedFrame) {
	    var unsubscribedFrame = arguments.length <= 1 || arguments[1] === undefined ? Number.POSITIVE_INFINITY : arguments[1];
	
	    _classCallCheck(this, SubscriptionLog);
	
	    this.subscribedFrame = subscribedFrame;
	    this.unsubscribedFrame = unsubscribedFrame;
	};
	
	exports["default"] = SubscriptionLog;
	module.exports = exports["default"];

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _SubscriptionLog = __webpack_require__(59);
	
	var _SubscriptionLog2 = _interopRequireDefault(_SubscriptionLog);
	
	var SubscriptionLoggable = (function () {
	    function SubscriptionLoggable() {
	        _classCallCheck(this, SubscriptionLoggable);
	
	        this.subscriptions = [];
	    }
	
	    SubscriptionLoggable.prototype.logSubscribedFrame = function logSubscribedFrame() {
	        this.subscriptions.push(new _SubscriptionLog2['default'](this.scheduler.now()));
	        return this.subscriptions.length - 1;
	    };
	
	    SubscriptionLoggable.prototype.logUnsubscribedFrame = function logUnsubscribedFrame(index) {
	        var subscriptionLogs = this.subscriptions;
	        var oldSubscriptionLog = subscriptionLogs[index];
	        subscriptionLogs[index] = new _SubscriptionLog2['default'](oldSubscriptionLog.subscribedFrame, this.scheduler.now());
	    };
	
	    return SubscriptionLoggable;
	})();
	
	exports['default'] = SubscriptionLoggable;
	module.exports = exports['default'];

/***/ }),
/* 61 */
/***/ (function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var ArgumentOutOfRangeError = function ArgumentOutOfRangeError() {
	    _classCallCheck(this, ArgumentOutOfRangeError);
	
	    this.name = 'ArgumentOutOfRangeError';
	    this.message = 'argument out of range';
	};
	
	exports['default'] = ArgumentOutOfRangeError;
	module.exports = exports['default'];

/***/ }),
/* 62 */
/***/ (function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = applyMixins;
	
	function applyMixins(derivedCtor, baseCtors) {
	    for (var i = 0, len = baseCtors.length; i < len; i++) {
	        var baseCtor = baseCtors[i];
	        var propertyKeys = Object.getOwnPropertyNames(baseCtor.prototype);
	        for (var j = 0, len2 = propertyKeys.length; j < len2; j++) {
	            var _name = propertyKeys[j];
	            derivedCtor.prototype[_name] = baseCtor.prototype[_name];
	        }
	    }
	}
	
	module.exports = exports["default"];

/***/ }),
/* 63 */
/***/ (function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = isDate;
	
	function isDate(value) {
	    return value instanceof Date && !isNaN(+value);
	}
	
	module.exports = exports["default"];

/***/ }),
/* 64 */
/***/ (function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = isNumeric;
	var is_array = Array.isArray;
	
	function isNumeric(val) {
	    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
	    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
	    // subtraction forces infinities to NaN
	    // adding 1 corrects loss of precision from parseFloat (#15100)
	    return !is_array(val) && val - parseFloat(val) + 1 >= 0;
	}
	
	;
	module.exports = exports["default"];

/***/ }),
/* 65 */
/***/ (function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = noop;
	
	function noop() {}
	
	module.exports = exports["default"];

/***/ }),
/* 66 */
/***/ (function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;
	
	process.listeners = function (name) { return [] }
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ }),
/* 67 */
/***/ (function(module, exports) {

	"use strict";
	exports.empty = {
	    closed: true,
	    next: function (value) { },
	    error: function (err) { throw err; },
	    complete: function () { }
	};
	//# sourceMappingURL=Observer.js.map

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(6);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var EmptyObservable = (function (_super) {
	    __extends(EmptyObservable, _super);
	    function EmptyObservable(scheduler) {
	        _super.call(this);
	        this.scheduler = scheduler;
	    }
	    /**
	     * Creates an Observable that emits no items to the Observer and immediately
	     * emits a complete notification.
	     *
	     * <span class="informal">Just emits 'complete', and nothing else.
	     * </span>
	     *
	     * <img src="./img/empty.png" width="100%">
	     *
	     * This static operator is useful for creating a simple Observable that only
	     * emits the complete notification. It can be used for composing with other
	     * Observables, such as in a {@link mergeMap}.
	     *
	     * @example <caption>Emit the number 7, then complete.</caption>
	     * var result = Rx.Observable.empty().startWith(7);
	     * result.subscribe(x => console.log(x));
	     *
	     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
	     * var interval = Rx.Observable.interval(1000);
	     * var result = interval.mergeMap(x =>
	     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
	     * );
	     * result.subscribe(x => console.log(x));
	     *
	     * // Results in the following to the console:
	     * // x is equal to the count on the interval eg(0,1,2,3,...)
	     * // x will occur every 1000ms
	     * // if x % 2 is equal to 1 print abc
	     * // if x % 2 is not equal to 1 nothing will be output
	     *
	     * @see {@link create}
	     * @see {@link never}
	     * @see {@link of}
	     * @see {@link throw}
	     *
	     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
	     * the emission of the complete notification.
	     * @return {Observable} An "empty" Observable: emits only the complete
	     * notification.
	     * @static true
	     * @name empty
	     * @owner Observable
	     */
	    EmptyObservable.create = function (scheduler) {
	        return new EmptyObservable(scheduler);
	    };
	    EmptyObservable.dispatch = function (arg) {
	        var subscriber = arg.subscriber;
	        subscriber.complete();
	    };
	    EmptyObservable.prototype._subscribe = function (subscriber) {
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });
	        }
	        else {
	            subscriber.complete();
	        }
	    };
	    return EmptyObservable;
	}(Observable_1.Observable));
	exports.EmptyObservable = EmptyObservable;
	//# sourceMappingURL=EmptyObservable.js.map

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var root_1 = __webpack_require__(17);
	var Observable_1 = __webpack_require__(6);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var PromiseObservable = (function (_super) {
	    __extends(PromiseObservable, _super);
	    function PromiseObservable(promise, scheduler) {
	        _super.call(this);
	        this.promise = promise;
	        this.scheduler = scheduler;
	    }
	    /**
	     * Converts a Promise to an Observable.
	     *
	     * <span class="informal">Returns an Observable that just emits the Promise's
	     * resolved value, then completes.</span>
	     *
	     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an
	     * Observable. If the Promise resolves with a value, the output Observable
	     * emits that resolved value as a `next`, and then completes. If the Promise
	     * is rejected, then the output Observable emits the corresponding Error.
	     *
	     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>
	     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));
	     * result.subscribe(x => console.log(x), e => console.error(e));
	     *
	     * @see {@link bindCallback}
	     * @see {@link from}
	     *
	     * @param {PromiseLike<T>} promise The promise to be converted.
	     * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling
	     * the delivery of the resolved value (or the rejection).
	     * @return {Observable<T>} An Observable which wraps the Promise.
	     * @static true
	     * @name fromPromise
	     * @owner Observable
	     */
	    PromiseObservable.create = function (promise, scheduler) {
	        return new PromiseObservable(promise, scheduler);
	    };
	    PromiseObservable.prototype._subscribe = function (subscriber) {
	        var _this = this;
	        var promise = this.promise;
	        var scheduler = this.scheduler;
	        if (scheduler == null) {
	            if (this._isScalar) {
	                if (!subscriber.closed) {
	                    subscriber.next(this.value);
	                    subscriber.complete();
	                }
	            }
	            else {
	                promise.then(function (value) {
	                    _this.value = value;
	                    _this._isScalar = true;
	                    if (!subscriber.closed) {
	                        subscriber.next(value);
	                        subscriber.complete();
	                    }
	                }, function (err) {
	                    if (!subscriber.closed) {
	                        subscriber.error(err);
	                    }
	                })
	                    .then(null, function (err) {
	                    // escape the promise trap, throw unhandled errors
	                    root_1.root.setTimeout(function () { throw err; });
	                });
	            }
	        }
	        else {
	            if (this._isScalar) {
	                if (!subscriber.closed) {
	                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });
	                }
	            }
	            else {
	                promise.then(function (value) {
	                    _this.value = value;
	                    _this._isScalar = true;
	                    if (!subscriber.closed) {
	                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));
	                    }
	                }, function (err) {
	                    if (!subscriber.closed) {
	                        subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));
	                    }
	                })
	                    .then(null, function (err) {
	                    // escape the promise trap, throw unhandled errors
	                    root_1.root.setTimeout(function () { throw err; });
	                });
	            }
	        }
	    };
	    return PromiseObservable;
	}(Observable_1.Observable));
	exports.PromiseObservable = PromiseObservable;
	function dispatchNext(arg) {
	    var value = arg.value, subscriber = arg.subscriber;
	    if (!subscriber.closed) {
	        subscriber.next(value);
	        subscriber.complete();
	    }
	}
	function dispatchError(arg) {
	    var err = arg.err, subscriber = arg.subscriber;
	    if (!subscriber.closed) {
	        subscriber.error(err);
	    }
	}
	//# sourceMappingURL=PromiseObservable.js.map

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(6);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var ScalarObservable = (function (_super) {
	    __extends(ScalarObservable, _super);
	    function ScalarObservable(value, scheduler) {
	        _super.call(this);
	        this.value = value;
	        this.scheduler = scheduler;
	        this._isScalar = true;
	        if (scheduler) {
	            this._isScalar = false;
	        }
	    }
	    ScalarObservable.create = function (value, scheduler) {
	        return new ScalarObservable(value, scheduler);
	    };
	    ScalarObservable.dispatch = function (state) {
	        var done = state.done, value = state.value, subscriber = state.subscriber;
	        if (done) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(value);
	        if (subscriber.closed) {
	            return;
	        }
	        state.done = true;
	        this.schedule(state);
	    };
	    ScalarObservable.prototype._subscribe = function (subscriber) {
	        var value = this.value;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(ScalarObservable.dispatch, 0, {
	                done: false, value: value, subscriber: subscriber
	            });
	        }
	        else {
	            subscriber.next(value);
	            if (!subscriber.closed) {
	                subscriber.complete();
	            }
	        }
	    };
	    return ScalarObservable;
	}(Observable_1.Observable));
	exports.ScalarObservable = ScalarObservable;
	//# sourceMappingURL=ScalarObservable.js.map

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var subscribeToResult_1 = __webpack_require__(42);
	var OuterSubscriber_1 = __webpack_require__(35);
	/* tslint:enable:max-line-length */
	/**
	 * Projects each source value to an Observable which is merged in the output
	 * Observable.
	 *
	 * <span class="informal">Maps each value to an Observable, then flattens all of
	 * these inner Observables using {@link mergeAll}.</span>
	 *
	 * <img src="./img/mergeMap.png" width="100%">
	 *
	 * Returns an Observable that emits items based on applying a function that you
	 * supply to each item emitted by the source Observable, where that function
	 * returns an Observable, and then merging those resulting Observables and
	 * emitting the results of this merger.
	 *
	 * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
	 * var letters = Rx.Observable.of('a', 'b', 'c');
	 * var result = letters.mergeMap(x =>
	 *   Rx.Observable.interval(1000).map(i => x+i)
	 * );
	 * result.subscribe(x => console.log(x));
	 *
	 * // Results in the following:
	 * // a0
	 * // b0
	 * // c0
	 * // a1
	 * // b1
	 * // c1
	 * // continues to list a,b,c with respective ascending integers
	 *
	 * @see {@link concatMap}
	 * @see {@link exhaustMap}
	 * @see {@link merge}
	 * @see {@link mergeAll}
	 * @see {@link mergeMapTo}
	 * @see {@link mergeScan}
	 * @see {@link switchMap}
	 *
	 * @param {function(value: T, ?index: number): ObservableInput} project A function
	 * that, when applied to an item emitted by the source Observable, returns an
	 * Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
	 * Observables being subscribed to concurrently.
	 * @return {Observable} An Observable that emits the result of applying the
	 * projection function (and the optional `resultSelector`) to each item emitted
	 * by the source Observable and merging the results of the Observables obtained
	 * from this transformation.
	 * @method mergeMap
	 * @owner Observable
	 */
	function mergeMap(project, resultSelector, concurrent) {
	    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	    if (typeof resultSelector === 'number') {
	        concurrent = resultSelector;
	        resultSelector = null;
	    }
	    return this.lift(new MergeMapOperator(project, resultSelector, concurrent));
	}
	exports.mergeMap = mergeMap;
	var MergeMapOperator = (function () {
	    function MergeMapOperator(project, resultSelector, concurrent) {
	        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	        this.project = project;
	        this.resultSelector = resultSelector;
	        this.concurrent = concurrent;
	    }
	    MergeMapOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));
	    };
	    return MergeMapOperator;
	}());
	exports.MergeMapOperator = MergeMapOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MergeMapSubscriber = (function (_super) {
	    __extends(MergeMapSubscriber, _super);
	    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {
	        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	        _super.call(this, destination);
	        this.project = project;
	        this.resultSelector = resultSelector;
	        this.concurrent = concurrent;
	        this.hasCompleted = false;
	        this.buffer = [];
	        this.active = 0;
	        this.index = 0;
	    }
	    MergeMapSubscriber.prototype._next = function (value) {
	        if (this.active < this.concurrent) {
	            this._tryNext(value);
	        }
	        else {
	            this.buffer.push(value);
	        }
	    };
	    MergeMapSubscriber.prototype._tryNext = function (value) {
	        var result;
	        var index = this.index++;
	        try {
	            result = this.project(value, index);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.active++;
	        this._innerSub(result, value, index);
	    };
	    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
	        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
	    };
	    MergeMapSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.active === 0 && this.buffer.length === 0) {
	            this.destination.complete();
	        }
	    };
	    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        if (this.resultSelector) {
	            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        else {
	            this.destination.next(innerValue);
	        }
	    };
	    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
	        var result;
	        try {
	            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer.length > 0) {
	            this._next(buffer.shift());
	        }
	        else if (this.active === 0 && this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	    return MergeMapSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	exports.MergeMapSubscriber = MergeMapSubscriber;
	//# sourceMappingURL=mergeMap.js.map

/***/ }),
/* 72 */
/***/ (function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when an action is invalid because the object has been
	 * unsubscribed.
	 *
	 * @see {@link Subject}
	 * @see {@link BehaviorSubject}
	 *
	 * @class ObjectUnsubscribedError
	 */
	var ObjectUnsubscribedError = (function (_super) {
	    __extends(ObjectUnsubscribedError, _super);
	    function ObjectUnsubscribedError() {
	        var err = _super.call(this, 'object unsubscribed');
	        this.name = err.name = 'ObjectUnsubscribedError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return ObjectUnsubscribedError;
	}(Error));
	exports.ObjectUnsubscribedError = ObjectUnsubscribedError;
	//# sourceMappingURL=ObjectUnsubscribedError.js.map

/***/ }),
/* 73 */
/***/ (function(module, exports) {

	"use strict";
	// typeof any so that it we don't have to cast when comparing a result to the error object
	exports.errorObject = { e: {} };
	//# sourceMappingURL=errorObject.js.map

/***/ }),
/* 74 */
/***/ (function(module, exports) {

	"use strict";
	exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });
	//# sourceMappingURL=isArray.js.map

/***/ }),
/* 75 */
/***/ (function(module, exports) {

	"use strict";
	exports.isArrayLike = (function (x) { return x && typeof x.length === 'number'; });
	//# sourceMappingURL=isArrayLike.js.map

/***/ }),
/* 76 */
/***/ (function(module, exports) {

	"use strict";
	function isFunction(x) {
	    return typeof x === 'function';
	}
	exports.isFunction = isFunction;
	//# sourceMappingURL=isFunction.js.map

/***/ }),
/* 77 */
/***/ (function(module, exports) {

	"use strict";
	function isObject(x) {
	    return x != null && typeof x === 'object';
	}
	exports.isObject = isObject;
	//# sourceMappingURL=isObject.js.map

/***/ }),
/* 78 */
/***/ (function(module, exports) {

	"use strict";
	function isPromise(value) {
	    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
	}
	exports.isPromise = isPromise;
	//# sourceMappingURL=isPromise.js.map

/***/ }),
/* 79 */
/***/ (function(module, exports) {

	"use strict";
	function isScheduler(value) {
	    return value && typeof value.schedule === 'function';
	}
	exports.isScheduler = isScheduler;
	//# sourceMappingURL=isScheduler.js.map

/***/ }),
/* 80 */,
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @license Angular v4.3.3
	 * (c) 2010-2017 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	(function (global, factory) {
		 true ? factory(exports, __webpack_require__(12), __webpack_require__(6), __webpack_require__(21)) :
		typeof define === 'function' && define.amd ? define(['exports', '@angular/core', 'rxjs/Observable', '@angular/platform-browser'], factory) :
		(factory((global.ng = global.ng || {}, global.ng.http = global.ng.http || {}),global.ng.core,global.Rx,global.ng.platformBrowser));
	}(this, (function (exports,_angular_core,rxjs_Observable,_angular_platformBrowser) { 'use strict';
	
	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0
	
	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.
	
	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
	/* global Reflect, Promise */
	
	var extendStatics = Object.setPrototypeOf ||
	    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	
	function __extends(d, b) {
	    extendStatics(d, b);
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}
	
	/**
	 * @license Angular v4.3.3
	 * (c) 2010-2017 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * A backend for http that uses the `XMLHttpRequest` browser API.
	 *
	 * Take care not to evaluate this in non-browser contexts.
	 *
	 * \@experimental
	 */
	var BrowserXhr = (function () {
	    function BrowserXhr() {
	    }
	    /**
	     * @return {?}
	     */
	    BrowserXhr.prototype.build = function () { return ((new XMLHttpRequest())); };
	    return BrowserXhr;
	}());
	BrowserXhr.decorators = [
	    { type: _angular_core.Injectable },
	];
	/**
	 * @nocollapse
	 */
	BrowserXhr.ctorParameters = function () { return []; };
	var RequestMethod = {};
	RequestMethod.Get = 0;
	RequestMethod.Post = 1;
	RequestMethod.Put = 2;
	RequestMethod.Delete = 3;
	RequestMethod.Options = 4;
	RequestMethod.Head = 5;
	RequestMethod.Patch = 6;
	RequestMethod[RequestMethod.Get] = "Get";
	RequestMethod[RequestMethod.Post] = "Post";
	RequestMethod[RequestMethod.Put] = "Put";
	RequestMethod[RequestMethod.Delete] = "Delete";
	RequestMethod[RequestMethod.Options] = "Options";
	RequestMethod[RequestMethod.Head] = "Head";
	RequestMethod[RequestMethod.Patch] = "Patch";
	var ReadyState = {};
	ReadyState.Unsent = 0;
	ReadyState.Open = 1;
	ReadyState.HeadersReceived = 2;
	ReadyState.Loading = 3;
	ReadyState.Done = 4;
	ReadyState.Cancelled = 5;
	ReadyState[ReadyState.Unsent] = "Unsent";
	ReadyState[ReadyState.Open] = "Open";
	ReadyState[ReadyState.HeadersReceived] = "HeadersReceived";
	ReadyState[ReadyState.Loading] = "Loading";
	ReadyState[ReadyState.Done] = "Done";
	ReadyState[ReadyState.Cancelled] = "Cancelled";
	var ResponseType = {};
	ResponseType.Basic = 0;
	ResponseType.Cors = 1;
	ResponseType.Default = 2;
	ResponseType.Error = 3;
	ResponseType.Opaque = 4;
	ResponseType[ResponseType.Basic] = "Basic";
	ResponseType[ResponseType.Cors] = "Cors";
	ResponseType[ResponseType.Default] = "Default";
	ResponseType[ResponseType.Error] = "Error";
	ResponseType[ResponseType.Opaque] = "Opaque";
	var ContentType = {};
	ContentType.NONE = 0;
	ContentType.JSON = 1;
	ContentType.FORM = 2;
	ContentType.FORM_DATA = 3;
	ContentType.TEXT = 4;
	ContentType.BLOB = 5;
	ContentType.ARRAY_BUFFER = 6;
	ContentType[ContentType.NONE] = "NONE";
	ContentType[ContentType.JSON] = "JSON";
	ContentType[ContentType.FORM] = "FORM";
	ContentType[ContentType.FORM_DATA] = "FORM_DATA";
	ContentType[ContentType.TEXT] = "TEXT";
	ContentType[ContentType.BLOB] = "BLOB";
	ContentType[ContentType.ARRAY_BUFFER] = "ARRAY_BUFFER";
	var ResponseContentType = {};
	ResponseContentType.Text = 0;
	ResponseContentType.Json = 1;
	ResponseContentType.ArrayBuffer = 2;
	ResponseContentType.Blob = 3;
	ResponseContentType[ResponseContentType.Text] = "Text";
	ResponseContentType[ResponseContentType.Json] = "Json";
	ResponseContentType[ResponseContentType.ArrayBuffer] = "ArrayBuffer";
	ResponseContentType[ResponseContentType.Blob] = "Blob";
	/**
	 * Polyfill for [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers/Headers), as
	 * specified in the [Fetch Spec](https://fetch.spec.whatwg.org/#headers-class).
	 *
	 * The only known difference between this `Headers` implementation and the spec is the
	 * lack of an `entries` method.
	 *
	 * ### Example
	 *
	 * ```
	 * import {Headers} from '\@angular/http';
	 *
	 * var firstHeaders = new Headers();
	 * firstHeaders.append('Content-Type', 'image/jpeg');
	 * console.log(firstHeaders.get('Content-Type')) //'image/jpeg'
	 *
	 * // Create headers from Plain Old JavaScript Object
	 * var secondHeaders = new Headers({
	 *   'X-My-Custom-Header': 'Angular'
	 * });
	 * console.log(secondHeaders.get('X-My-Custom-Header')); //'Angular'
	 *
	 * var thirdHeaders = new Headers(secondHeaders);
	 * console.log(thirdHeaders.get('X-My-Custom-Header')); //'Angular'
	 * ```
	 *
	 * \@experimental
	 */
	var Headers = (function () {
	    /**
	     * @param {?=} headers
	     */
	    function Headers(headers) {
	        var _this = this;
	        /**
	         * \@internal header names are lower case
	         */
	        this._headers = new Map();
	        /**
	         * \@internal map lower case names to actual names
	         */
	        this._normalizedNames = new Map();
	        if (!headers) {
	            return;
	        }
	        if (headers instanceof Headers) {
	            headers.forEach(function (values, name) {
	                values.forEach(function (value) { return _this.append(name, value); });
	            });
	            return;
	        }
	        Object.keys(headers).forEach(function (name) {
	            var values = Array.isArray(headers[name]) ? headers[name] : [headers[name]];
	            _this.delete(name);
	            values.forEach(function (value) { return _this.append(name, value); });
	        });
	    }
	    /**
	     * Returns a new Headers instance from the given DOMString of Response Headers
	     * @param {?} headersString
	     * @return {?}
	     */
	    Headers.fromResponseHeaderString = function (headersString) {
	        var /** @type {?} */ headers = new Headers();
	        headersString.split('\n').forEach(function (line) {
	            var /** @type {?} */ index = line.indexOf(':');
	            if (index > 0) {
	                var /** @type {?} */ name = line.slice(0, index);
	                var /** @type {?} */ value = line.slice(index + 1).trim();
	                headers.set(name, value);
	            }
	        });
	        return headers;
	    };
	    /**
	     * Appends a header to existing list of header values for a given header name.
	     * @param {?} name
	     * @param {?} value
	     * @return {?}
	     */
	    Headers.prototype.append = function (name, value) {
	        var /** @type {?} */ values = this.getAll(name);
	        if (values === null) {
	            this.set(name, value);
	        }
	        else {
	            values.push(value);
	        }
	    };
	    /**
	     * Deletes all header values for the given name.
	     * @param {?} name
	     * @return {?}
	     */
	    Headers.prototype.delete = function (name) {
	        var /** @type {?} */ lcName = name.toLowerCase();
	        this._normalizedNames.delete(lcName);
	        this._headers.delete(lcName);
	    };
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    Headers.prototype.forEach = function (fn) {
	        var _this = this;
	        this._headers.forEach(function (values, lcName) { return fn(values, _this._normalizedNames.get(lcName), _this._headers); });
	    };
	    /**
	     * Returns first header that matches given name.
	     * @param {?} name
	     * @return {?}
	     */
	    Headers.prototype.get = function (name) {
	        var /** @type {?} */ values = this.getAll(name);
	        if (values === null) {
	            return null;
	        }
	        return values.length > 0 ? values[0] : null;
	    };
	    /**
	     * Checks for existence of header by given name.
	     * @param {?} name
	     * @return {?}
	     */
	    Headers.prototype.has = function (name) { return this._headers.has(name.toLowerCase()); };
	    /**
	     * Returns the names of the headers
	     * @return {?}
	     */
	    Headers.prototype.keys = function () { return Array.from(this._normalizedNames.values()); };
	    /**
	     * Sets or overrides header value for given name.
	     * @param {?} name
	     * @param {?} value
	     * @return {?}
	     */
	    Headers.prototype.set = function (name, value) {
	        if (Array.isArray(value)) {
	            if (value.length) {
	                this._headers.set(name.toLowerCase(), [value.join(',')]);
	            }
	        }
	        else {
	            this._headers.set(name.toLowerCase(), [value]);
	        }
	        this.mayBeSetNormalizedName(name);
	    };
	    /**
	     * Returns values of all headers.
	     * @return {?}
	     */
	    Headers.prototype.values = function () { return Array.from(this._headers.values()); };
	    /**
	     * @return {?}
	     */
	    Headers.prototype.toJSON = function () {
	        var _this = this;
	        var /** @type {?} */ serialized = {};
	        this._headers.forEach(function (values, name) {
	            var /** @type {?} */ split = [];
	            values.forEach(function (v) { return split.push.apply(split, v.split(',')); });
	            serialized[((_this._normalizedNames.get(name)))] = split;
	        });
	        return serialized;
	    };
	    /**
	     * Returns list of header values for a given name.
	     * @param {?} name
	     * @return {?}
	     */
	    Headers.prototype.getAll = function (name) {
	        return this.has(name) ? this._headers.get(name.toLowerCase()) || null : null;
	    };
	    /**
	     * This method is not implemented.
	     * @return {?}
	     */
	    Headers.prototype.entries = function () { throw new Error('"entries" method is not implemented on Headers class'); };
	    /**
	     * @param {?} name
	     * @return {?}
	     */
	    Headers.prototype.mayBeSetNormalizedName = function (name) {
	        var /** @type {?} */ lcName = name.toLowerCase();
	        if (!this._normalizedNames.has(lcName)) {
	            this._normalizedNames.set(lcName, name);
	        }
	    };
	    return Headers;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Creates a response options object to be optionally provided when instantiating a
	 * {\@link Response}.
	 *
	 * This class is based on the `ResponseInit` description in the [Fetch
	 * Spec](https://fetch.spec.whatwg.org/#responseinit).
	 *
	 * All values are null by default. Typical defaults can be found in the
	 * {\@link BaseResponseOptions} class, which sub-classes `ResponseOptions`.
	 *
	 * This class may be used in tests to build {\@link Response Responses} for
	 * mock responses (see {\@link MockBackend}).
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/P9Jkk8e8cz6NVzbcxEsD?p=preview))
	 *
	 * ```typescript
	 * import {ResponseOptions, Response} from '\@angular/http';
	 *
	 * var options = new ResponseOptions({
	 *   body: '{"name":"Jeff"}'
	 * });
	 * var res = new Response(options);
	 *
	 * console.log('res.json():', res.json()); // Object {name: "Jeff"}
	 * ```
	 *
	 * \@experimental
	 */
	var ResponseOptions = (function () {
	    /**
	     * @param {?=} opts
	     */
	    function ResponseOptions(opts) {
	        if (opts === void 0) { opts = {}; }
	        var body = opts.body, status = opts.status, headers = opts.headers, statusText = opts.statusText, type = opts.type, url = opts.url;
	        this.body = body != null ? body : null;
	        this.status = status != null ? status : null;
	        this.headers = headers != null ? headers : null;
	        this.statusText = statusText != null ? statusText : null;
	        this.type = type != null ? type : null;
	        this.url = url != null ? url : null;
	    }
	    /**
	     * Creates a copy of the `ResponseOptions` instance, using the optional input as values to
	     * override
	     * existing values. This method will not change the values of the instance on which it is being
	     * called.
	     *
	     * This may be useful when sharing a base `ResponseOptions` object inside tests,
	     * where certain properties may change from test to test.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/1lXquqFfgduTFBWjNoRE?p=preview))
	     *
	     * ```typescript
	     * import {ResponseOptions, Response} from '\@angular/http';
	     *
	     * var options = new ResponseOptions({
	     *   body: {name: 'Jeff'}
	     * });
	     * var res = new Response(options.merge({
	     *   url: 'https://google.com'
	     * }));
	     * console.log('options.url:', options.url); // null
	     * console.log('res.json():', res.json()); // Object {name: "Jeff"}
	     * console.log('res.url:', res.url); // https://google.com
	     * ```
	     * @param {?=} options
	     * @return {?}
	     */
	    ResponseOptions.prototype.merge = function (options) {
	        return new ResponseOptions({
	            body: options && options.body != null ? options.body : this.body,
	            status: options && options.status != null ? options.status : this.status,
	            headers: options && options.headers != null ? options.headers : this.headers,
	            statusText: options && options.statusText != null ? options.statusText : this.statusText,
	            type: options && options.type != null ? options.type : this.type,
	            url: options && options.url != null ? options.url : this.url,
	        });
	    };
	    return ResponseOptions;
	}());
	/**
	 * Subclass of {\@link ResponseOptions}, with default values.
	 *
	 * Default values:
	 *  * status: 200
	 *  * headers: empty {\@link Headers} object
	 *
	 * This class could be extended and bound to the {\@link ResponseOptions} class
	 * when configuring an {\@link Injector}, in order to override the default options
	 * used by {\@link Http} to create {\@link Response Responses}.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/qv8DLT?p=preview))
	 *
	 * ```typescript
	 * import {provide} from '\@angular/core';
	 * import {bootstrap} from '\@angular/platform-browser/browser';
	 * import {HTTP_PROVIDERS, Headers, Http, BaseResponseOptions, ResponseOptions} from
	 * '\@angular/http';
	 * import {App} from './myapp';
	 *
	 * class MyOptions extends BaseResponseOptions {
	 *   headers:Headers = new Headers({network: 'github'});
	 * }
	 *
	 * bootstrap(App, [HTTP_PROVIDERS, {provide: ResponseOptions, useClass: MyOptions}]);
	 * ```
	 *
	 * The options could also be extended when manually creating a {\@link Response}
	 * object.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/VngosOWiaExEtbstDoix?p=preview))
	 *
	 * ```
	 * import {BaseResponseOptions, Response} from '\@angular/http';
	 *
	 * var options = new BaseResponseOptions();
	 * var res = new Response(options.merge({
	 *   body: 'Angular',
	 *   headers: new Headers({framework: 'angular'})
	 * }));
	 * console.log('res.headers.get("framework"):', res.headers.get('framework')); // angular
	 * console.log('res.text():', res.text()); // Angular;
	 * ```
	 *
	 * \@experimental
	 */
	var BaseResponseOptions = (function (_super) {
	    __extends(BaseResponseOptions, _super);
	    function BaseResponseOptions() {
	        return _super.call(this, { status: 200, statusText: 'Ok', type: ResponseType.Default, headers: new Headers() }) || this;
	    }
	    return BaseResponseOptions;
	}(ResponseOptions));
	BaseResponseOptions.decorators = [
	    { type: _angular_core.Injectable },
	];
	/**
	 * @nocollapse
	 */
	BaseResponseOptions.ctorParameters = function () { return []; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Abstract class from which real backends are derived.
	 *
	 * The primary purpose of a `ConnectionBackend` is to create new connections to fulfill a given
	 * {\@link Request}.
	 *
	 * \@experimental
	 * @abstract
	 */
	var ConnectionBackend = (function () {
	    function ConnectionBackend() {
	    }
	    /**
	     * @abstract
	     * @param {?} request
	     * @return {?}
	     */
	    ConnectionBackend.prototype.createConnection = function (request) { };
	    return ConnectionBackend;
	}());
	/**
	 * Abstract class from which real connections are derived.
	 *
	 * \@experimental
	 * @abstract
	 */
	var Connection = (function () {
	    function Connection() {
	    }
	    return Connection;
	}());
	/**
	 * An XSRFStrategy configures XSRF protection (e.g. via headers) on an HTTP request.
	 *
	 * \@experimental
	 * @abstract
	 */
	var XSRFStrategy = (function () {
	    function XSRFStrategy() {
	    }
	    /**
	     * @abstract
	     * @param {?} req
	     * @return {?}
	     */
	    XSRFStrategy.prototype.configureRequest = function (req) { };
	    return XSRFStrategy;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} method
	 * @return {?}
	 */
	function normalizeMethodName(method) {
	    if (typeof method !== 'string')
	        return method;
	    switch (method.toUpperCase()) {
	        case 'GET':
	            return RequestMethod.Get;
	        case 'POST':
	            return RequestMethod.Post;
	        case 'PUT':
	            return RequestMethod.Put;
	        case 'DELETE':
	            return RequestMethod.Delete;
	        case 'OPTIONS':
	            return RequestMethod.Options;
	        case 'HEAD':
	            return RequestMethod.Head;
	        case 'PATCH':
	            return RequestMethod.Patch;
	    }
	    throw new Error("Invalid request method. The method \"" + method + "\" is not supported.");
	}
	var isSuccess = function (status) { return (status >= 200 && status < 300); };
	/**
	 * @param {?} xhr
	 * @return {?}
	 */
	function getResponseURL(xhr) {
	    if ('responseURL' in xhr) {
	        return xhr.responseURL;
	    }
	    if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
	        return xhr.getResponseHeader('X-Request-URL');
	    }
	    return null;
	}
	/**
	 * @param {?} input
	 * @return {?}
	 */
	/**
	 * @param {?} input
	 * @return {?}
	 */
	function stringToArrayBuffer(input) {
	    var /** @type {?} */ view = new Uint16Array(input.length);
	    for (var /** @type {?} */ i = 0, /** @type {?} */ strLen = input.length; i < strLen; i++) {
	        view[i] = input.charCodeAt(i);
	    }
	    return view.buffer;
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 * @param {?=} rawParams
	 * @return {?}
	 */
	function paramParser(rawParams) {
	    if (rawParams === void 0) { rawParams = ''; }
	    var /** @type {?} */ map = new Map();
	    if (rawParams.length > 0) {
	        var /** @type {?} */ params = rawParams.split('&');
	        params.forEach(function (param) {
	            var /** @type {?} */ eqIdx = param.indexOf('=');
	            var _a = eqIdx == -1 ? [param, ''] : [param.slice(0, eqIdx), param.slice(eqIdx + 1)], key = _a[0], val = _a[1];
	            var /** @type {?} */ list = map.get(key) || [];
	            list.push(val);
	            map.set(key, list);
	        });
	    }
	    return map;
	}
	/**
	 * \@experimental
	 *
	 */
	var QueryEncoder = (function () {
	    function QueryEncoder() {
	    }
	    /**
	     * @param {?} k
	     * @return {?}
	     */
	    QueryEncoder.prototype.encodeKey = function (k) { return standardEncoding(k); };
	    /**
	     * @param {?} v
	     * @return {?}
	     */
	    QueryEncoder.prototype.encodeValue = function (v) { return standardEncoding(v); };
	    return QueryEncoder;
	}());
	/**
	 * @param {?} v
	 * @return {?}
	 */
	function standardEncoding(v) {
	    return encodeURIComponent(v)
	        .replace(/%40/gi, '@')
	        .replace(/%3A/gi, ':')
	        .replace(/%24/gi, '$')
	        .replace(/%2C/gi, ',')
	        .replace(/%3B/gi, ';')
	        .replace(/%2B/gi, '+')
	        .replace(/%3D/gi, '=')
	        .replace(/%3F/gi, '?')
	        .replace(/%2F/gi, '/');
	}
	/**
	 * Map-like representation of url search parameters, based on
	 * [URLSearchParams](https://url.spec.whatwg.org/#urlsearchparams) in the url living standard,
	 * with several extensions for merging URLSearchParams objects:
	 *   - setAll()
	 *   - appendAll()
	 *   - replaceAll()
	 *
	 * This class accepts an optional second parameter of ${\@link QueryEncoder},
	 * which is used to serialize parameters before making a request. By default,
	 * `QueryEncoder` encodes keys and values of parameters using `encodeURIComponent`,
	 * and then un-encodes certain characters that are allowed to be part of the query
	 * according to IETF RFC 3986: https://tools.ietf.org/html/rfc3986.
	 *
	 * These are the characters that are not encoded: `! $ \' ( ) * + , ; A 9 - . _ ~ ? /`
	 *
	 * If the set of allowed query characters is not acceptable for a particular backend,
	 * `QueryEncoder` can be subclassed and provided as the 2nd argument to URLSearchParams.
	 *
	 * ```
	 * import {URLSearchParams, QueryEncoder} from '\@angular/http';
	 * class MyQueryEncoder extends QueryEncoder {
	 *   encodeKey(k: string): string {
	 *     return myEncodingFunction(k);
	 *   }
	 *
	 *   encodeValue(v: string): string {
	 *     return myEncodingFunction(v);
	 *   }
	 * }
	 *
	 * let params = new URLSearchParams('', new MyQueryEncoder());
	 * ```
	 * \@experimental
	 */
	var URLSearchParams = (function () {
	    /**
	     * @param {?=} rawParams
	     * @param {?=} queryEncoder
	     */
	    function URLSearchParams(rawParams, queryEncoder) {
	        if (rawParams === void 0) { rawParams = ''; }
	        if (queryEncoder === void 0) { queryEncoder = new QueryEncoder(); }
	        this.rawParams = rawParams;
	        this.queryEncoder = queryEncoder;
	        this.paramsMap = paramParser(rawParams);
	    }
	    /**
	     * @return {?}
	     */
	    URLSearchParams.prototype.clone = function () {
	        var /** @type {?} */ clone = new URLSearchParams('', this.queryEncoder);
	        clone.appendAll(this);
	        return clone;
	    };
	    /**
	     * @param {?} param
	     * @return {?}
	     */
	    URLSearchParams.prototype.has = function (param) { return this.paramsMap.has(param); };
	    /**
	     * @param {?} param
	     * @return {?}
	     */
	    URLSearchParams.prototype.get = function (param) {
	        var /** @type {?} */ storedParam = this.paramsMap.get(param);
	        return Array.isArray(storedParam) ? storedParam[0] : null;
	    };
	    /**
	     * @param {?} param
	     * @return {?}
	     */
	    URLSearchParams.prototype.getAll = function (param) { return this.paramsMap.get(param) || []; };
	    /**
	     * @param {?} param
	     * @param {?} val
	     * @return {?}
	     */
	    URLSearchParams.prototype.set = function (param, val) {
	        if (val === void 0 || val === null) {
	            this.delete(param);
	            return;
	        }
	        var /** @type {?} */ list = this.paramsMap.get(param) || [];
	        list.length = 0;
	        list.push(val);
	        this.paramsMap.set(param, list);
	    };
	    /**
	     * @param {?} searchParams
	     * @return {?}
	     */
	    URLSearchParams.prototype.setAll = function (searchParams) {
	        var _this = this;
	        searchParams.paramsMap.forEach(function (value, param) {
	            var /** @type {?} */ list = _this.paramsMap.get(param) || [];
	            list.length = 0;
	            list.push(value[0]);
	            _this.paramsMap.set(param, list);
	        });
	    };
	    /**
	     * @param {?} param
	     * @param {?} val
	     * @return {?}
	     */
	    URLSearchParams.prototype.append = function (param, val) {
	        if (val === void 0 || val === null)
	            return;
	        var /** @type {?} */ list = this.paramsMap.get(param) || [];
	        list.push(val);
	        this.paramsMap.set(param, list);
	    };
	    /**
	     * @param {?} searchParams
	     * @return {?}
	     */
	    URLSearchParams.prototype.appendAll = function (searchParams) {
	        var _this = this;
	        searchParams.paramsMap.forEach(function (value, param) {
	            var /** @type {?} */ list = _this.paramsMap.get(param) || [];
	            for (var /** @type {?} */ i = 0; i < value.length; ++i) {
	                list.push(value[i]);
	            }
	            _this.paramsMap.set(param, list);
	        });
	    };
	    /**
	     * @param {?} searchParams
	     * @return {?}
	     */
	    URLSearchParams.prototype.replaceAll = function (searchParams) {
	        var _this = this;
	        searchParams.paramsMap.forEach(function (value, param) {
	            var /** @type {?} */ list = _this.paramsMap.get(param) || [];
	            list.length = 0;
	            for (var /** @type {?} */ i = 0; i < value.length; ++i) {
	                list.push(value[i]);
	            }
	            _this.paramsMap.set(param, list);
	        });
	    };
	    /**
	     * @return {?}
	     */
	    URLSearchParams.prototype.toString = function () {
	        var _this = this;
	        var /** @type {?} */ paramsList = [];
	        this.paramsMap.forEach(function (values, k) {
	            values.forEach(function (v) { return paramsList.push(_this.queryEncoder.encodeKey(k) + '=' + _this.queryEncoder.encodeValue(v)); });
	        });
	        return paramsList.join('&');
	    };
	    /**
	     * @param {?} param
	     * @return {?}
	     */
	    URLSearchParams.prototype.delete = function (param) { this.paramsMap.delete(param); };
	    return URLSearchParams;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * HTTP request body used by both {\@link Request} and {\@link Response}
	 * https://fetch.spec.whatwg.org/#body
	 * @abstract
	 */
	var Body = (function () {
	    function Body() {
	    }
	    /**
	     * Attempts to return body as parsed `JSON` object, or raises an exception.
	     * @return {?}
	     */
	    Body.prototype.json = function () {
	        if (typeof this._body === 'string') {
	            return JSON.parse(/** @type {?} */ (this._body));
	        }
	        if (this._body instanceof ArrayBuffer) {
	            return JSON.parse(this.text());
	        }
	        return this._body;
	    };
	    /**
	     * Returns the body as a string, presuming `toString()` can be called on the response body.
	     *
	     * When decoding an `ArrayBuffer`, the optional `encodingHint` parameter determines how the
	     * bytes in the buffer will be interpreted. Valid values are:
	     *
	     * - `legacy` - incorrectly interpret the bytes as UTF-16 (technically, UCS-2). Only characters
	     *   in the Basic Multilingual Plane are supported, surrogate pairs are not handled correctly.
	     *   In addition, the endianness of the 16-bit octet pairs in the `ArrayBuffer` is not taken
	     *   into consideration. This is the default behavior to avoid breaking apps, but should be
	     *   considered deprecated.
	     *
	     * - `iso-8859` - interpret the bytes as ISO-8859 (which can be used for ASCII encoded text).
	     * @param {?=} encodingHint
	     * @return {?}
	     */
	    Body.prototype.text = function (encodingHint) {
	        if (encodingHint === void 0) { encodingHint = 'legacy'; }
	        if (this._body instanceof URLSearchParams) {
	            return this._body.toString();
	        }
	        if (this._body instanceof ArrayBuffer) {
	            switch (encodingHint) {
	                case 'legacy':
	                    return String.fromCharCode.apply(null, new Uint16Array(/** @type {?} */ (this._body)));
	                case 'iso-8859':
	                    return String.fromCharCode.apply(null, new Uint8Array(/** @type {?} */ (this._body)));
	                default:
	                    throw new Error("Invalid value for encodingHint: " + encodingHint);
	            }
	        }
	        if (this._body == null) {
	            return '';
	        }
	        if (typeof this._body === 'object') {
	            return JSON.stringify(this._body, null, 2);
	        }
	        return this._body.toString();
	    };
	    /**
	     * Return the body as an ArrayBuffer
	     * @return {?}
	     */
	    Body.prototype.arrayBuffer = function () {
	        if (this._body instanceof ArrayBuffer) {
	            return (this._body);
	        }
	        return stringToArrayBuffer(this.text());
	    };
	    /**
	     * Returns the request's body as a Blob, assuming that body exists.
	     * @return {?}
	     */
	    Body.prototype.blob = function () {
	        if (this._body instanceof Blob) {
	            return (this._body);
	        }
	        if (this._body instanceof ArrayBuffer) {
	            return new Blob([this._body]);
	        }
	        throw new Error('The request body isn\'t either a blob or an array buffer');
	    };
	    return Body;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Creates `Response` instances from provided values.
	 *
	 * Though this object isn't
	 * usually instantiated by end-users, it is the primary object interacted with when it comes time to
	 * add data to a view.
	 *
	 * ### Example
	 *
	 * ```
	 * http.request('my-friends.txt').subscribe(response => this.friends = response.text());
	 * ```
	 *
	 * The Response's interface is inspired by the Response constructor defined in the [Fetch
	 * Spec](https://fetch.spec.whatwg.org/#response-class), but is considered a static value whose body
	 * can be accessed many times. There are other differences in the implementation, but this is the
	 * most significant.
	 *
	 * \@experimental
	 */
	var Response = (function (_super) {
	    __extends(Response, _super);
	    /**
	     * @param {?} responseOptions
	     */
	    function Response(responseOptions) {
	        var _this = _super.call(this) || this;
	        _this._body = responseOptions.body;
	        _this.status = responseOptions.status;
	        _this.ok = (_this.status >= 200 && _this.status <= 299);
	        _this.statusText = responseOptions.statusText;
	        _this.headers = responseOptions.headers;
	        _this.type = responseOptions.type;
	        _this.url = responseOptions.url;
	        return _this;
	    }
	    /**
	     * @return {?}
	     */
	    Response.prototype.toString = function () {
	        return "Response with status: " + this.status + " " + this.statusText + " for URL: " + this.url;
	    };
	    return Response;
	}(Body));
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var _nextRequestId = 0;
	var JSONP_HOME = '__ng_jsonp__';
	var _jsonpConnections = null;
	/**
	 * @return {?}
	 */
	function _getJsonpConnections() {
	    var /** @type {?} */ w = typeof window == 'object' ? window : {};
	    if (_jsonpConnections === null) {
	        _jsonpConnections = w[JSONP_HOME] = {};
	    }
	    return _jsonpConnections;
	}
	var BrowserJsonp = (function () {
	    function BrowserJsonp() {
	    }
	    /**
	     * @param {?} url
	     * @return {?}
	     */
	    BrowserJsonp.prototype.build = function (url) {
	        var /** @type {?} */ node = document.createElement('script');
	        node.src = url;
	        return node;
	    };
	    /**
	     * @return {?}
	     */
	    BrowserJsonp.prototype.nextRequestID = function () { return "__req" + _nextRequestId++; };
	    /**
	     * @param {?} id
	     * @return {?}
	     */
	    BrowserJsonp.prototype.requestCallback = function (id) { return JSONP_HOME + "." + id + ".finished"; };
	    /**
	     * @param {?} id
	     * @param {?} connection
	     * @return {?}
	     */
	    BrowserJsonp.prototype.exposeConnection = function (id, connection) {
	        var /** @type {?} */ connections = _getJsonpConnections();
	        connections[id] = connection;
	    };
	    /**
	     * @param {?} id
	     * @return {?}
	     */
	    BrowserJsonp.prototype.removeConnection = function (id) {
	        var /** @type {?} */ connections = _getJsonpConnections();
	        connections[id] = null;
	    };
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    BrowserJsonp.prototype.send = function (node) { document.body.appendChild(/** @type {?} */ ((node))); };
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    BrowserJsonp.prototype.cleanup = function (node) {
	        if (node.parentNode) {
	            node.parentNode.removeChild(/** @type {?} */ ((node)));
	        }
	    };
	    return BrowserJsonp;
	}());
	BrowserJsonp.decorators = [
	    { type: _angular_core.Injectable },
	];
	/**
	 * @nocollapse
	 */
	BrowserJsonp.ctorParameters = function () { return []; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';
	var JSONP_ERR_WRONG_METHOD = 'JSONP requests must use GET request method.';
	/**
	 * Abstract base class for an in-flight JSONP request.
	 *
	 * \@experimental
	 * @abstract
	 */
	var JSONPConnection = (function () {
	    function JSONPConnection() {
	    }
	    /**
	     * Callback called when the JSONP request completes, to notify the application
	     * of the new data.
	     * @abstract
	     * @param {?=} data
	     * @return {?}
	     */
	    JSONPConnection.prototype.finished = function (data) { };
	    return JSONPConnection;
	}());
	var JSONPConnection_ = (function (_super) {
	    __extends(JSONPConnection_, _super);
	    /**
	     * @param {?} req
	     * @param {?} _dom
	     * @param {?=} baseResponseOptions
	     */
	    function JSONPConnection_(req, _dom, baseResponseOptions) {
	        var _this = _super.call(this) || this;
	        _this._dom = _dom;
	        _this.baseResponseOptions = baseResponseOptions;
	        _this._finished = false;
	        if (req.method !== RequestMethod.Get) {
	            throw new TypeError(JSONP_ERR_WRONG_METHOD);
	        }
	        _this.request = req;
	        _this.response = new rxjs_Observable.Observable(function (responseObserver) {
	            _this.readyState = ReadyState.Loading;
	            var id = _this._id = _dom.nextRequestID();
	            _dom.exposeConnection(id, _this);
	            // Workaround Dart
	            // url = url.replace(/=JSONP_CALLBACK(&|$)/, `generated method`);
	            var callback = _dom.requestCallback(_this._id);
	            var url = req.url;
	            if (url.indexOf('=JSONP_CALLBACK&') > -1) {
	                url = url.replace('=JSONP_CALLBACK&', "=" + callback + "&");
	            }
	            else if (url.lastIndexOf('=JSONP_CALLBACK') === url.length - '=JSONP_CALLBACK'.length) {
	                url = url.substring(0, url.length - '=JSONP_CALLBACK'.length) + ("=" + callback);
	            }
	            var script = _this._script = _dom.build(url);
	            var onLoad = function (event) {
	                if (_this.readyState === ReadyState.Cancelled)
	                    return;
	                _this.readyState = ReadyState.Done;
	                _dom.cleanup(script);
	                if (!_this._finished) {
	                    var responseOptions_1 = new ResponseOptions({ body: JSONP_ERR_NO_CALLBACK, type: ResponseType.Error, url: url });
	                    if (baseResponseOptions) {
	                        responseOptions_1 = baseResponseOptions.merge(responseOptions_1);
	                    }
	                    responseObserver.error(new Response(responseOptions_1));
	                    return;
	                }
	                var responseOptions = new ResponseOptions({ body: _this._responseData, url: url });
	                if (_this.baseResponseOptions) {
	                    responseOptions = _this.baseResponseOptions.merge(responseOptions);
	                }
	                responseObserver.next(new Response(responseOptions));
	                responseObserver.complete();
	            };
	            var onError = function (error) {
	                if (_this.readyState === ReadyState.Cancelled)
	                    return;
	                _this.readyState = ReadyState.Done;
	                _dom.cleanup(script);
	                var responseOptions = new ResponseOptions({ body: error.message, type: ResponseType.Error });
	                if (baseResponseOptions) {
	                    responseOptions = baseResponseOptions.merge(responseOptions);
	                }
	                responseObserver.error(new Response(responseOptions));
	            };
	            script.addEventListener('load', onLoad);
	            script.addEventListener('error', onError);
	            _dom.send(script);
	            return function () {
	                _this.readyState = ReadyState.Cancelled;
	                script.removeEventListener('load', onLoad);
	                script.removeEventListener('error', onError);
	                _this._dom.cleanup(script);
	            };
	        });
	        return _this;
	    }
	    /**
	     * @param {?=} data
	     * @return {?}
	     */
	    JSONPConnection_.prototype.finished = function (data) {
	        // Don't leak connections
	        this._finished = true;
	        this._dom.removeConnection(this._id);
	        if (this.readyState === ReadyState.Cancelled)
	            return;
	        this._responseData = data;
	    };
	    return JSONPConnection_;
	}(JSONPConnection));
	/**
	 * A {\@link ConnectionBackend} that uses the JSONP strategy of making requests.
	 *
	 * \@experimental
	 * @abstract
	 */
	var JSONPBackend = (function (_super) {
	    __extends(JSONPBackend, _super);
	    function JSONPBackend() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    return JSONPBackend;
	}(ConnectionBackend));
	var JSONPBackend_ = (function (_super) {
	    __extends(JSONPBackend_, _super);
	    /**
	     * @param {?} _browserJSONP
	     * @param {?} _baseResponseOptions
	     */
	    function JSONPBackend_(_browserJSONP, _baseResponseOptions) {
	        var _this = _super.call(this) || this;
	        _this._browserJSONP = _browserJSONP;
	        _this._baseResponseOptions = _baseResponseOptions;
	        return _this;
	    }
	    /**
	     * @param {?} request
	     * @return {?}
	     */
	    JSONPBackend_.prototype.createConnection = function (request) {
	        return new JSONPConnection_(request, this._browserJSONP, this._baseResponseOptions);
	    };
	    return JSONPBackend_;
	}(JSONPBackend));
	JSONPBackend_.decorators = [
	    { type: _angular_core.Injectable },
	];
	/**
	 * @nocollapse
	 */
	JSONPBackend_.ctorParameters = function () { return [
	    { type: BrowserJsonp, },
	    { type: ResponseOptions, },
	]; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var XSSI_PREFIX = /^\)\]\}',?\n/;
	/**
	 * Creates connections using `XMLHttpRequest`. Given a fully-qualified
	 * request, an `XHRConnection` will immediately create an `XMLHttpRequest` object and send the
	 * request.
	 *
	 * This class would typically not be created or interacted with directly inside applications, though
	 * the {\@link MockConnection} may be interacted with in tests.
	 *
	 * \@experimental
	 */
	var XHRConnection = (function () {
	    /**
	     * @param {?} req
	     * @param {?} browserXHR
	     * @param {?=} baseResponseOptions
	     */
	    function XHRConnection(req, browserXHR, baseResponseOptions) {
	        var _this = this;
	        this.request = req;
	        this.response = new rxjs_Observable.Observable(function (responseObserver) {
	            var _xhr = browserXHR.build();
	            _xhr.open(RequestMethod[req.method].toUpperCase(), req.url);
	            if (req.withCredentials != null) {
	                _xhr.withCredentials = req.withCredentials;
	            }
	            // load event handler
	            var onLoad = function () {
	                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
	                var status = _xhr.status === 1223 ? 204 : _xhr.status;
	                var body = null;
	                // HTTP 204 means no content
	                if (status !== 204) {
	                    // responseText is the old-school way of retrieving response (supported by IE8 & 9)
	                    // response/responseType properties were introduced in ResourceLoader Level2 spec
	                    // (supported by IE10)
	                    body = (typeof _xhr.response === 'undefined') ? _xhr.responseText : _xhr.response;
	                    // Implicitly strip a potential XSSI prefix.
	                    if (typeof body === 'string') {
	                        body = body.replace(XSSI_PREFIX, '');
	                    }
	                }
	                // fix status code when it is 0 (0 status is undocumented).
	                // Occurs when accessing file resources or on Android 4.1 stock browser
	                // while retrieving files from application cache.
	                if (status === 0) {
	                    status = body ? 200 : 0;
	                }
	                var headers = Headers.fromResponseHeaderString(_xhr.getAllResponseHeaders());
	                // IE 9 does not provide the way to get URL of response
	                var url = getResponseURL(_xhr) || req.url;
	                var statusText = _xhr.statusText || 'OK';
	                var responseOptions = new ResponseOptions({ body: body, status: status, headers: headers, statusText: statusText, url: url });
	                if (baseResponseOptions != null) {
	                    responseOptions = baseResponseOptions.merge(responseOptions);
	                }
	                var response = new Response(responseOptions);
	                response.ok = isSuccess(status);
	                if (response.ok) {
	                    responseObserver.next(response);
	                    // TODO(gdi2290): defer complete if array buffer until done
	                    responseObserver.complete();
	                    return;
	                }
	                responseObserver.error(response);
	            };
	            // error event handler
	            var onError = function (err) {
	                var responseOptions = new ResponseOptions({
	                    body: err,
	                    type: ResponseType.Error,
	                    status: _xhr.status,
	                    statusText: _xhr.statusText,
	                });
	                if (baseResponseOptions != null) {
	                    responseOptions = baseResponseOptions.merge(responseOptions);
	                }
	                responseObserver.error(new Response(responseOptions));
	            };
	            _this.setDetectedContentType(req, _xhr);
	            if (req.headers == null) {
	                req.headers = new Headers();
	            }
	            if (!req.headers.has('Accept')) {
	                req.headers.append('Accept', 'application/json, text/plain, */*');
	            }
	            req.headers.forEach(function (values, name) { return _xhr.setRequestHeader(name, values.join(',')); });
	            // Select the correct buffer type to store the response
	            if (req.responseType != null && _xhr.responseType != null) {
	                switch (req.responseType) {
	                    case ResponseContentType.ArrayBuffer:
	                        _xhr.responseType = 'arraybuffer';
	                        break;
	                    case ResponseContentType.Json:
	                        _xhr.responseType = 'json';
	                        break;
	                    case ResponseContentType.Text:
	                        _xhr.responseType = 'text';
	                        break;
	                    case ResponseContentType.Blob:
	                        _xhr.responseType = 'blob';
	                        break;
	                    default:
	                        throw new Error('The selected responseType is not supported');
	                }
	            }
	            _xhr.addEventListener('load', onLoad);
	            _xhr.addEventListener('error', onError);
	            _xhr.send(_this.request.getBody());
	            return function () {
	                _xhr.removeEventListener('load', onLoad);
	                _xhr.removeEventListener('error', onError);
	                _xhr.abort();
	            };
	        });
	    }
	    /**
	     * @param {?} req
	     * @param {?} _xhr
	     * @return {?}
	     */
	    XHRConnection.prototype.setDetectedContentType = function (req /** TODO Request */, _xhr /** XMLHttpRequest */) {
	        // Skip if a custom Content-Type header is provided
	        if (req.headers != null && req.headers.get('Content-Type') != null) {
	            return;
	        }
	        // Set the detected content type
	        switch (req.contentType) {
	            case ContentType.NONE:
	                break;
	            case ContentType.JSON:
	                _xhr.setRequestHeader('content-type', 'application/json');
	                break;
	            case ContentType.FORM:
	                _xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
	                break;
	            case ContentType.TEXT:
	                _xhr.setRequestHeader('content-type', 'text/plain');
	                break;
	            case ContentType.BLOB:
	                var /** @type {?} */ blob = req.blob();
	                if (blob.type) {
	                    _xhr.setRequestHeader('content-type', blob.type);
	                }
	                break;
	        }
	    };
	    return XHRConnection;
	}());
	/**
	 * `XSRFConfiguration` sets up Cross Site Request Forgery (XSRF) protection for the application
	 * using a cookie. See https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)
	 * for more information on XSRF.
	 *
	 * Applications can configure custom cookie and header names by binding an instance of this class
	 * with different `cookieName` and `headerName` values. See the main HTTP documentation for more
	 * details.
	 *
	 * \@experimental
	 */
	var CookieXSRFStrategy = (function () {
	    /**
	     * @param {?=} _cookieName
	     * @param {?=} _headerName
	     */
	    function CookieXSRFStrategy(_cookieName, _headerName) {
	        if (_cookieName === void 0) { _cookieName = 'XSRF-TOKEN'; }
	        if (_headerName === void 0) { _headerName = 'X-XSRF-TOKEN'; }
	        this._cookieName = _cookieName;
	        this._headerName = _headerName;
	    }
	    /**
	     * @param {?} req
	     * @return {?}
	     */
	    CookieXSRFStrategy.prototype.configureRequest = function (req) {
	        var /** @type {?} */ xsrfToken = _angular_platformBrowser.ɵgetDOM().getCookie(this._cookieName);
	        if (xsrfToken) {
	            req.headers.set(this._headerName, xsrfToken);
	        }
	    };
	    return CookieXSRFStrategy;
	}());
	/**
	 * Creates {\@link XHRConnection} instances.
	 *
	 * This class would typically not be used by end users, but could be
	 * overridden if a different backend implementation should be used,
	 * such as in a node backend.
	 *
	 * ### Example
	 *
	 * ```
	 * import {Http, MyNodeBackend, HTTP_PROVIDERS, BaseRequestOptions} from '\@angular/http';
	 * \@Component({
	 *   viewProviders: [
	 *     HTTP_PROVIDERS,
	 *     {provide: Http, useFactory: (backend, options) => {
	 *       return new Http(backend, options);
	 *     }, deps: [MyNodeBackend, BaseRequestOptions]}]
	 * })
	 * class MyComponent {
	 *   constructor(http:Http) {
	 *     http.request('people.json').subscribe(res => this.people = res.json());
	 *   }
	 * }
	 * ```
	 * \@experimental
	 */
	var XHRBackend = (function () {
	    /**
	     * @param {?} _browserXHR
	     * @param {?} _baseResponseOptions
	     * @param {?} _xsrfStrategy
	     */
	    function XHRBackend(_browserXHR, _baseResponseOptions, _xsrfStrategy) {
	        this._browserXHR = _browserXHR;
	        this._baseResponseOptions = _baseResponseOptions;
	        this._xsrfStrategy = _xsrfStrategy;
	    }
	    /**
	     * @param {?} request
	     * @return {?}
	     */
	    XHRBackend.prototype.createConnection = function (request) {
	        this._xsrfStrategy.configureRequest(request);
	        return new XHRConnection(request, this._browserXHR, this._baseResponseOptions);
	    };
	    return XHRBackend;
	}());
	XHRBackend.decorators = [
	    { type: _angular_core.Injectable },
	];
	/**
	 * @nocollapse
	 */
	XHRBackend.ctorParameters = function () { return [
	    { type: BrowserXhr, },
	    { type: ResponseOptions, },
	    { type: XSRFStrategy, },
	]; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Creates a request options object to be optionally provided when instantiating a
	 * {\@link Request}.
	 *
	 * This class is based on the `RequestInit` description in the [Fetch
	 * Spec](https://fetch.spec.whatwg.org/#requestinit).
	 *
	 * All values are null by default. Typical defaults can be found in the {\@link BaseRequestOptions}
	 * class, which sub-classes `RequestOptions`.
	 *
	 * ```typescript
	 * import {RequestOptions, Request, RequestMethod} from '\@angular/http';
	 *
	 * const options = new RequestOptions({
	 *   method: RequestMethod.Post,
	 *   url: 'https://google.com'
	 * });
	 * const req = new Request(options);
	 * console.log('req.method:', RequestMethod[req.method]); // Post
	 * console.log('options.url:', options.url); // https://google.com
	 * ```
	 *
	 * \@experimental
	 */
	var RequestOptions = (function () {
	    /**
	     * @param {?=} opts
	     */
	    function RequestOptions(opts) {
	        if (opts === void 0) { opts = {}; }
	        var method = opts.method, headers = opts.headers, body = opts.body, url = opts.url, search = opts.search, params = opts.params, withCredentials = opts.withCredentials, responseType = opts.responseType;
	        this.method = method != null ? normalizeMethodName(method) : null;
	        this.headers = headers != null ? headers : null;
	        this.body = body != null ? body : null;
	        this.url = url != null ? url : null;
	        this.params = this._mergeSearchParams(params || search);
	        this.withCredentials = withCredentials != null ? withCredentials : null;
	        this.responseType = responseType != null ? responseType : null;
	    }
	    Object.defineProperty(RequestOptions.prototype, "search", {
	        /**
	         * @deprecated from 4.0.0. Use params instead.
	         * @return {?}
	         */
	        get: function () { return this.params; },
	        /**
	         * @deprecated from 4.0.0. Use params instead.
	         * @param {?} params
	         * @return {?}
	         */
	        set: function (params) { this.params = params; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Creates a copy of the `RequestOptions` instance, using the optional input as values to override
	     * existing values. This method will not change the values of the instance on which it is being
	     * called.
	     *
	     * Note that `headers` and `search` will override existing values completely if present in
	     * the `options` object. If these values should be merged, it should be done prior to calling
	     * `merge` on the `RequestOptions` instance.
	     *
	     * ```typescript
	     * import {RequestOptions, Request, RequestMethod} from '\@angular/http';
	     *
	     * const options = new RequestOptions({
	     *   method: RequestMethod.Post
	     * });
	     * const req = new Request(options.merge({
	     *   url: 'https://google.com'
	     * }));
	     * console.log('req.method:', RequestMethod[req.method]); // Post
	     * console.log('options.url:', options.url); // null
	     * console.log('req.url:', req.url); // https://google.com
	     * ```
	     * @param {?=} options
	     * @return {?}
	     */
	    RequestOptions.prototype.merge = function (options) {
	        return new RequestOptions({
	            method: options && options.method != null ? options.method : this.method,
	            headers: options && options.headers != null ? options.headers : new Headers(this.headers),
	            body: options && options.body != null ? options.body : this.body,
	            url: options && options.url != null ? options.url : this.url,
	            params: options && this._mergeSearchParams(options.params || options.search),
	            withCredentials: options && options.withCredentials != null ? options.withCredentials :
	                this.withCredentials,
	            responseType: options && options.responseType != null ? options.responseType :
	                this.responseType
	        });
	    };
	    /**
	     * @param {?=} params
	     * @return {?}
	     */
	    RequestOptions.prototype._mergeSearchParams = function (params) {
	        if (!params)
	            return this.params;
	        if (params instanceof URLSearchParams) {
	            return params.clone();
	        }
	        if (typeof params === 'string') {
	            return new URLSearchParams(params);
	        }
	        return this._parseParams(params);
	    };
	    /**
	     * @param {?=} objParams
	     * @return {?}
	     */
	    RequestOptions.prototype._parseParams = function (objParams) {
	        var _this = this;
	        if (objParams === void 0) { objParams = {}; }
	        var /** @type {?} */ params = new URLSearchParams();
	        Object.keys(objParams).forEach(function (key) {
	            var /** @type {?} */ value = objParams[key];
	            if (Array.isArray(value)) {
	                value.forEach(function (item) { return _this._appendParam(key, item, params); });
	            }
	            else {
	                _this._appendParam(key, value, params);
	            }
	        });
	        return params;
	    };
	    /**
	     * @param {?} key
	     * @param {?} value
	     * @param {?} params
	     * @return {?}
	     */
	    RequestOptions.prototype._appendParam = function (key, value, params) {
	        if (typeof value !== 'string') {
	            value = JSON.stringify(value);
	        }
	        params.append(key, value);
	    };
	    return RequestOptions;
	}());
	/**
	 * Subclass of {\@link RequestOptions}, with default values.
	 *
	 * Default values:
	 *  * method: {\@link RequestMethod RequestMethod.Get}
	 *  * headers: empty {\@link Headers} object
	 *
	 * This class could be extended and bound to the {\@link RequestOptions} class
	 * when configuring an {\@link Injector}, in order to override the default options
	 * used by {\@link Http} to create and send {\@link Request Requests}.
	 *
	 * ```typescript
	 * import {BaseRequestOptions, RequestOptions} from '\@angular/http';
	 *
	 * class MyOptions extends BaseRequestOptions {
	 *   search: string = 'coreTeam=true';
	 * }
	 *
	 * {provide: RequestOptions, useClass: MyOptions};
	 * ```
	 *
	 * The options could also be extended when manually creating a {\@link Request}
	 * object.
	 *
	 * ```
	 * import {BaseRequestOptions, Request, RequestMethod} from '\@angular/http';
	 *
	 * const options = new BaseRequestOptions();
	 * const req = new Request(options.merge({
	 *   method: RequestMethod.Post,
	 *   url: 'https://google.com'
	 * }));
	 * console.log('req.method:', RequestMethod[req.method]); // Post
	 * console.log('options.url:', options.url); // null
	 * console.log('req.url:', req.url); // https://google.com
	 * ```
	 *
	 * \@experimental
	 */
	var BaseRequestOptions = (function (_super) {
	    __extends(BaseRequestOptions, _super);
	    function BaseRequestOptions() {
	        return _super.call(this, { method: RequestMethod.Get, headers: new Headers() }) || this;
	    }
	    return BaseRequestOptions;
	}(RequestOptions));
	BaseRequestOptions.decorators = [
	    { type: _angular_core.Injectable },
	];
	/**
	 * @nocollapse
	 */
	BaseRequestOptions.ctorParameters = function () { return []; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Creates `Request` instances from provided values.
	 *
	 * The Request's interface is inspired by the Request constructor defined in the [Fetch
	 * Spec](https://fetch.spec.whatwg.org/#request-class),
	 * but is considered a static value whose body can be accessed many times. There are other
	 * differences in the implementation, but this is the most significant.
	 *
	 * `Request` instances are typically created by higher-level classes, like {\@link Http} and
	 * {\@link Jsonp}, but it may occasionally be useful to explicitly create `Request` instances.
	 * One such example is when creating services that wrap higher-level services, like {\@link Http},
	 * where it may be useful to generate a `Request` with arbitrary headers and search params.
	 *
	 * ```typescript
	 * import {Injectable, Injector} from '\@angular/core';
	 * import {HTTP_PROVIDERS, Http, Request, RequestMethod} from '\@angular/http';
	 *
	 * \@Injectable()
	 * class AutoAuthenticator {
	 *   constructor(public http:Http) {}
	 *   request(url:string) {
	 *     return this.http.request(new Request({
	 *       method: RequestMethod.Get,
	 *       url: url,
	 *       search: 'password=123'
	 *     }));
	 *   }
	 * }
	 *
	 * var injector = Injector.resolveAndCreate([HTTP_PROVIDERS, AutoAuthenticator]);
	 * var authenticator = injector.get(AutoAuthenticator);
	 * authenticator.request('people.json').subscribe(res => {
	 *   //URL should have included '?password=123'
	 *   console.log('people', res.json());
	 * });
	 * ```
	 *
	 * \@experimental
	 */
	var Request = (function (_super) {
	    __extends(Request, _super);
	    /**
	     * @param {?} requestOptions
	     */
	    function Request(requestOptions) {
	        var _this = _super.call(this) || this;
	        // TODO: assert that url is present
	        var url = requestOptions.url;
	        _this.url = requestOptions.url;
	        var paramsArg = requestOptions.params || requestOptions.search;
	        if (paramsArg) {
	            var params = void 0;
	            if (typeof paramsArg === 'object' && !(paramsArg instanceof URLSearchParams)) {
	                params = urlEncodeParams(paramsArg).toString();
	            }
	            else {
	                params = paramsArg.toString();
	            }
	            if (params.length > 0) {
	                var prefix = '?';
	                if (_this.url.indexOf('?') != -1) {
	                    prefix = (_this.url[_this.url.length - 1] == '&') ? '' : '&';
	                }
	                // TODO: just delete search-query-looking string in url?
	                _this.url = url + prefix + params;
	            }
	        }
	        _this._body = requestOptions.body;
	        _this.method = normalizeMethodName(requestOptions.method);
	        // TODO(jeffbcross): implement behavior
	        // Defaults to 'omit', consistent with browser
	        _this.headers = new Headers(requestOptions.headers);
	        _this.contentType = _this.detectContentType();
	        _this.withCredentials = requestOptions.withCredentials;
	        _this.responseType = requestOptions.responseType;
	        return _this;
	    }
	    /**
	     * Returns the content type enum based on header options.
	     * @return {?}
	     */
	    Request.prototype.detectContentType = function () {
	        switch (this.headers.get('content-type')) {
	            case 'application/json':
	                return ContentType.JSON;
	            case 'application/x-www-form-urlencoded':
	                return ContentType.FORM;
	            case 'multipart/form-data':
	                return ContentType.FORM_DATA;
	            case 'text/plain':
	            case 'text/html':
	                return ContentType.TEXT;
	            case 'application/octet-stream':
	                return this._body instanceof ArrayBuffer$1 ? ContentType.ARRAY_BUFFER : ContentType.BLOB;
	            default:
	                return this.detectContentTypeFromBody();
	        }
	    };
	    /**
	     * Returns the content type of request's body based on its type.
	     * @return {?}
	     */
	    Request.prototype.detectContentTypeFromBody = function () {
	        if (this._body == null) {
	            return ContentType.NONE;
	        }
	        else if (this._body instanceof URLSearchParams) {
	            return ContentType.FORM;
	        }
	        else if (this._body instanceof FormData) {
	            return ContentType.FORM_DATA;
	        }
	        else if (this._body instanceof Blob$1) {
	            return ContentType.BLOB;
	        }
	        else if (this._body instanceof ArrayBuffer$1) {
	            return ContentType.ARRAY_BUFFER;
	        }
	        else if (this._body && typeof this._body === 'object') {
	            return ContentType.JSON;
	        }
	        else {
	            return ContentType.TEXT;
	        }
	    };
	    /**
	     * Returns the request's body according to its type. If body is undefined, return
	     * null.
	     * @return {?}
	     */
	    Request.prototype.getBody = function () {
	        switch (this.contentType) {
	            case ContentType.JSON:
	                return this.text();
	            case ContentType.FORM:
	                return this.text();
	            case ContentType.FORM_DATA:
	                return this._body;
	            case ContentType.TEXT:
	                return this.text();
	            case ContentType.BLOB:
	                return this.blob();
	            case ContentType.ARRAY_BUFFER:
	                return this.arrayBuffer();
	            default:
	                return null;
	        }
	    };
	    return Request;
	}(Body));
	/**
	 * @param {?} params
	 * @return {?}
	 */
	function urlEncodeParams(params) {
	    var /** @type {?} */ searchParams = new URLSearchParams();
	    Object.keys(params).forEach(function (key) {
	        var /** @type {?} */ value = params[key];
	        if (value && Array.isArray(value)) {
	            value.forEach(function (element) { return searchParams.append(key, element.toString()); });
	        }
	        else {
	            searchParams.append(key, value.toString());
	        }
	    });
	    return searchParams;
	}
	var noop = function () { };
	var w = typeof window == 'object' ? window : noop;
	var FormData = ((w) /** TODO #9100 */)['FormData'] || noop;
	var Blob$1 = ((w) /** TODO #9100 */)['Blob'] || noop;
	var ArrayBuffer$1 = ((w) /** TODO #9100 */)['ArrayBuffer'] || noop;
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} backend
	 * @param {?} request
	 * @return {?}
	 */
	function httpRequest(backend, request) {
	    return backend.createConnection(request).response;
	}
	/**
	 * @param {?} defaultOpts
	 * @param {?} providedOpts
	 * @param {?} method
	 * @param {?} url
	 * @return {?}
	 */
	function mergeOptions(defaultOpts, providedOpts, method, url) {
	    var /** @type {?} */ newOptions = defaultOpts;
	    if (providedOpts) {
	        // Hack so Dart can used named parameters
	        return (newOptions.merge(new RequestOptions({
	            method: providedOpts.method || method,
	            url: providedOpts.url || url,
	            search: providedOpts.search,
	            params: providedOpts.params,
	            headers: providedOpts.headers,
	            body: providedOpts.body,
	            withCredentials: providedOpts.withCredentials,
	            responseType: providedOpts.responseType
	        })));
	    }
	    return (newOptions.merge(new RequestOptions({ method: method, url: url })));
	}
	/**
	 * Performs http requests using `XMLHttpRequest` as the default backend.
	 *
	 * `Http` is available as an injectable class, with methods to perform http requests. Calling
	 * `request` returns an `Observable` which will emit a single {\@link Response} when a
	 * response is received.
	 *
	 * ### Example
	 *
	 * ```typescript
	 * import {Http, HTTP_PROVIDERS} from '\@angular/http';
	 * import 'rxjs/add/operator/map'
	 * \@Component({
	 *   selector: 'http-app',
	 *   viewProviders: [HTTP_PROVIDERS],
	 *   templateUrl: 'people.html'
	 * })
	 * class PeopleComponent {
	 *   constructor(http: Http) {
	 *     http.get('people.json')
	 *       // Call map on the response observable to get the parsed people object
	 *       .map(res => res.json())
	 *       // Subscribe to the observable to get the parsed people object and attach it to the
	 *       // component
	 *       .subscribe(people => this.people = people);
	 *   }
	 * }
	 * ```
	 *
	 *
	 * ### Example
	 *
	 * ```
	 * http.get('people.json').subscribe((res:Response) => this.people = res.json());
	 * ```
	 *
	 * The default construct used to perform requests, `XMLHttpRequest`, is abstracted as a "Backend" (
	 * {\@link XHRBackend} in this case), which could be mocked with dependency injection by replacing
	 * the {\@link XHRBackend} provider, as in the following example:
	 *
	 * ### Example
	 *
	 * ```typescript
	 * import {BaseRequestOptions, Http} from '\@angular/http';
	 * import {MockBackend} from '\@angular/http/testing';
	 * var injector = Injector.resolveAndCreate([
	 *   BaseRequestOptions,
	 *   MockBackend,
	 *   {provide: Http, useFactory:
	 *       function(backend, defaultOptions) {
	 *         return new Http(backend, defaultOptions);
	 *       },
	 *       deps: [MockBackend, BaseRequestOptions]}
	 * ]);
	 * var http = injector.get(Http);
	 * http.get('request-from-mock-backend.json').subscribe((res:Response) => doSomething(res));
	 * ```
	 *
	 * \@experimental
	 */
	var Http = (function () {
	    /**
	     * @param {?} _backend
	     * @param {?} _defaultOptions
	     */
	    function Http(_backend, _defaultOptions) {
	        this._backend = _backend;
	        this._defaultOptions = _defaultOptions;
	    }
	    /**
	     * Performs any type of http request. First argument is required, and can either be a url or
	     * a {\@link Request} instance. If the first argument is a url, an optional {\@link RequestOptions}
	     * object can be provided as the 2nd argument. The options object will be merged with the values
	     * of {\@link BaseRequestOptions} before performing the request.
	     * @param {?} url
	     * @param {?=} options
	     * @return {?}
	     */
	    Http.prototype.request = function (url, options) {
	        var /** @type {?} */ responseObservable;
	        if (typeof url === 'string') {
	            responseObservable = httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Get, /** @type {?} */ (url))));
	        }
	        else if (url instanceof Request) {
	            responseObservable = httpRequest(this._backend, url);
	        }
	        else {
	            throw new Error('First argument must be a url string or Request instance.');
	        }
	        return responseObservable;
	    };
	    /**
	     * Performs a request with `get` http method.
	     * @param {?} url
	     * @param {?=} options
	     * @return {?}
	     */
	    Http.prototype.get = function (url, options) {
	        return this.request(new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Get, url)));
	    };
	    /**
	     * Performs a request with `post` http method.
	     * @param {?} url
	     * @param {?} body
	     * @param {?=} options
	     * @return {?}
	     */
	    Http.prototype.post = function (url, body, options) {
	        return this.request(new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({ body: body })), options, RequestMethod.Post, url)));
	    };
	    /**
	     * Performs a request with `put` http method.
	     * @param {?} url
	     * @param {?} body
	     * @param {?=} options
	     * @return {?}
	     */
	    Http.prototype.put = function (url, body, options) {
	        return this.request(new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({ body: body })), options, RequestMethod.Put, url)));
	    };
	    /**
	     * Performs a request with `delete` http method.
	     * @param {?} url
	     * @param {?=} options
	     * @return {?}
	     */
	    Http.prototype.delete = function (url, options) {
	        return this.request(new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Delete, url)));
	    };
	    /**
	     * Performs a request with `patch` http method.
	     * @param {?} url
	     * @param {?} body
	     * @param {?=} options
	     * @return {?}
	     */
	    Http.prototype.patch = function (url, body, options) {
	        return this.request(new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({ body: body })), options, RequestMethod.Patch, url)));
	    };
	    /**
	     * Performs a request with `head` http method.
	     * @param {?} url
	     * @param {?=} options
	     * @return {?}
	     */
	    Http.prototype.head = function (url, options) {
	        return this.request(new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Head, url)));
	    };
	    /**
	     * Performs a request with `options` http method.
	     * @param {?} url
	     * @param {?=} options
	     * @return {?}
	     */
	    Http.prototype.options = function (url, options) {
	        return this.request(new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Options, url)));
	    };
	    return Http;
	}());
	Http.decorators = [
	    { type: _angular_core.Injectable },
	];
	/**
	 * @nocollapse
	 */
	Http.ctorParameters = function () { return [
	    { type: ConnectionBackend, },
	    { type: RequestOptions, },
	]; };
	/**
	 * \@experimental
	 */
	var Jsonp = (function (_super) {
	    __extends(Jsonp, _super);
	    /**
	     * @param {?} backend
	     * @param {?} defaultOptions
	     */
	    function Jsonp(backend, defaultOptions) {
	        return _super.call(this, backend, defaultOptions) || this;
	    }
	    /**
	     * Performs any type of http request. First argument is required, and can either be a url or
	     * a {\@link Request} instance. If the first argument is a url, an optional {\@link RequestOptions}
	     * object can be provided as the 2nd argument. The options object will be merged with the values
	     * of {\@link BaseRequestOptions} before performing the request.
	     *
	     * \@security Regular XHR is the safest alternative to JSONP for most applications, and is
	     * supported by all current browsers. Because JSONP creates a `<script>` element with
	     * contents retrieved from a remote source, attacker-controlled data introduced by an untrusted
	     * source could expose your application to XSS risks. Data exposed by JSONP may also be
	     * readable by malicious third-party websites. In addition, JSONP introduces potential risk for
	     * future security issues (e.g. content sniffing).  For more detail, see the
	     * [Security Guide](http://g.co/ng/security).
	     * @param {?} url
	     * @param {?=} options
	     * @return {?}
	     */
	    Jsonp.prototype.request = function (url, options) {
	        var /** @type {?} */ responseObservable;
	        if (typeof url === 'string') {
	            url =
	                new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Get, /** @type {?} */ (url)));
	        }
	        if (url instanceof Request) {
	            if (url.method !== RequestMethod.Get) {
	                throw new Error('JSONP requests must use GET request method.');
	            }
	            responseObservable = httpRequest(this._backend, url);
	        }
	        else {
	            throw new Error('First argument must be a url string or Request instance.');
	        }
	        return responseObservable;
	    };
	    return Jsonp;
	}(Http));
	Jsonp.decorators = [
	    { type: _angular_core.Injectable },
	];
	/**
	 * @nocollapse
	 */
	Jsonp.ctorParameters = function () { return [
	    { type: ConnectionBackend, },
	    { type: RequestOptions, },
	]; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @module
	 * @description
	 * The http module provides services to perform http requests. To get started, see the {@link Http}
	 * class.
	 */
	/**
	 * @return {?}
	 */
	function _createDefaultCookieXSRFStrategy() {
	    return new CookieXSRFStrategy();
	}
	/**
	 * @param {?} xhrBackend
	 * @param {?} requestOptions
	 * @return {?}
	 */
	function httpFactory(xhrBackend, requestOptions) {
	    return new Http(xhrBackend, requestOptions);
	}
	/**
	 * @param {?} jsonpBackend
	 * @param {?} requestOptions
	 * @return {?}
	 */
	function jsonpFactory(jsonpBackend, requestOptions) {
	    return new Jsonp(jsonpBackend, requestOptions);
	}
	/**
	 * The module that includes http's providers
	 *
	 * \@experimental
	 */
	var HttpModule = (function () {
	    function HttpModule() {
	    }
	    return HttpModule;
	}());
	HttpModule.decorators = [
	    { type: _angular_core.NgModule, args: [{
	                providers: [
	                    // TODO(pascal): use factory type annotations once supported in DI
	                    // issue: https://github.com/angular/angular/issues/3183
	                    { provide: Http, useFactory: httpFactory, deps: [XHRBackend, RequestOptions] },
	                    BrowserXhr,
	                    { provide: RequestOptions, useClass: BaseRequestOptions },
	                    { provide: ResponseOptions, useClass: BaseResponseOptions },
	                    XHRBackend,
	                    { provide: XSRFStrategy, useFactory: _createDefaultCookieXSRFStrategy },
	                ],
	            },] },
	];
	/**
	 * @nocollapse
	 */
	HttpModule.ctorParameters = function () { return []; };
	/**
	 * The module that includes jsonp's providers
	 *
	 * \@experimental
	 */
	var JsonpModule = (function () {
	    function JsonpModule() {
	    }
	    return JsonpModule;
	}());
	JsonpModule.decorators = [
	    { type: _angular_core.NgModule, args: [{
	                providers: [
	                    // TODO(pascal): use factory type annotations once supported in DI
	                    // issue: https://github.com/angular/angular/issues/3183
	                    { provide: Jsonp, useFactory: jsonpFactory, deps: [JSONPBackend, RequestOptions] },
	                    BrowserJsonp,
	                    { provide: RequestOptions, useClass: BaseRequestOptions },
	                    { provide: ResponseOptions, useClass: BaseResponseOptions },
	                    { provide: JSONPBackend, useClass: JSONPBackend_ },
	                ],
	            },] },
	];
	/**
	 * @nocollapse
	 */
	JsonpModule.ctorParameters = function () { return []; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @module
	 * @description
	 * Entry point for all public APIs of the common package.
	 */
	/**
	 * \@stable
	 */
	var VERSION = new _angular_core.Version('4.3.3');
	
	exports.BrowserXhr = BrowserXhr;
	exports.JSONPBackend = JSONPBackend;
	exports.JSONPConnection = JSONPConnection;
	exports.CookieXSRFStrategy = CookieXSRFStrategy;
	exports.XHRBackend = XHRBackend;
	exports.XHRConnection = XHRConnection;
	exports.BaseRequestOptions = BaseRequestOptions;
	exports.RequestOptions = RequestOptions;
	exports.BaseResponseOptions = BaseResponseOptions;
	exports.ResponseOptions = ResponseOptions;
	exports.ReadyState = ReadyState;
	exports.RequestMethod = RequestMethod;
	exports.ResponseContentType = ResponseContentType;
	exports.ResponseType = ResponseType;
	exports.Headers = Headers;
	exports.Http = Http;
	exports.Jsonp = Jsonp;
	exports.HttpModule = HttpModule;
	exports.JsonpModule = JsonpModule;
	exports.Connection = Connection;
	exports.ConnectionBackend = ConnectionBackend;
	exports.XSRFStrategy = XSRFStrategy;
	exports.Request = Request;
	exports.Response = Response;
	exports.QueryEncoder = QueryEncoder;
	exports.URLSearchParams = URLSearchParams;
	exports.VERSION = VERSION;
	exports.ɵg = BrowserJsonp;
	exports.ɵa = JSONPBackend_;
	exports.ɵf = Body;
	exports.ɵb = _createDefaultCookieXSRFStrategy;
	exports.ɵc = httpFactory;
	exports.ɵd = jsonpFactory;
	
	Object.defineProperty(exports, '__esModule', { value: true });
	
	})));
	//# sourceMappingURL=http.umd.js.map


/***/ }),
/* 82 */,
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @license Angular v4.3.3
	 * (c) 2010-2017 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	(function (global, factory) {
		 true ? factory(exports, __webpack_require__(20), __webpack_require__(12), __webpack_require__(192), __webpack_require__(19), __webpack_require__(200), __webpack_require__(203), __webpack_require__(206), __webpack_require__(207), __webpack_require__(209), __webpack_require__(210), __webpack_require__(211), __webpack_require__(71), __webpack_require__(215), __webpack_require__(6), __webpack_require__(204), __webpack_require__(205), __webpack_require__(41), __webpack_require__(201), __webpack_require__(37), __webpack_require__(21), __webpack_require__(208)) :
		typeof define === 'function' && define.amd ? define(['exports', '@angular/common', '@angular/core', 'rxjs/BehaviorSubject', 'rxjs/Subject', 'rxjs/observable/from', 'rxjs/observable/of', 'rxjs/operator/concatMap', 'rxjs/operator/every', 'rxjs/operator/first', 'rxjs/operator/last', 'rxjs/operator/map', 'rxjs/operator/mergeMap', 'rxjs/operator/reduce', 'rxjs/Observable', 'rxjs/operator/catch', 'rxjs/operator/concatAll', 'rxjs/util/EmptyError', 'rxjs/observable/fromPromise', 'rxjs/operator/mergeAll', '@angular/platform-browser', 'rxjs/operator/filter'], factory) :
		(factory((global.ng = global.ng || {}, global.ng.router = global.ng.router || {}),global.ng.common,global.ng.core,global.Rx,global.Rx,global.Rx.Observable,global.Rx.Observable,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx,global.Rx.Observable,global.Rx.Observable.prototype,global.ng.platformBrowser,global.Rx.Observable.prototype));
	}(this, (function (exports,_angular_common,_angular_core,rxjs_BehaviorSubject,rxjs_Subject,rxjs_observable_from,rxjs_observable_of,rxjs_operator_concatMap,rxjs_operator_every,rxjs_operator_first,rxjs_operator_last,rxjs_operator_map,rxjs_operator_mergeMap,rxjs_operator_reduce,rxjs_Observable,rxjs_operator_catch,rxjs_operator_concatAll,rxjs_util_EmptyError,rxjs_observable_fromPromise,rxjs_operator_mergeAll,_angular_platformBrowser,rxjs_operator_filter) { 'use strict';
	
	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0
	
	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.
	
	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
	/* global Reflect, Promise */
	
	var extendStatics = Object.setPrototypeOf ||
	    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	
	function __extends(d, b) {
	    extendStatics(d, b);
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}
	
	/**
	 * @license Angular v4.3.3
	 * (c) 2010-2017 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@whatItDoes Represents an event triggered when a navigation starts.
	 *
	 * \@stable
	 */
	var NavigationStart = (function () {
	    /**
	     * @param {?} id
	     * @param {?} url
	     */
	    function NavigationStart(id, url) {
	        this.id = id;
	        this.url = url;
	    }
	    /**
	     * \@docsNotRequired
	     * @return {?}
	     */
	    NavigationStart.prototype.toString = function () { return "NavigationStart(id: " + this.id + ", url: '" + this.url + "')"; };
	    return NavigationStart;
	}());
	/**
	 * \@whatItDoes Represents an event triggered when a navigation ends successfully.
	 *
	 * \@stable
	 */
	var NavigationEnd = (function () {
	    /**
	     * @param {?} id
	     * @param {?} url
	     * @param {?} urlAfterRedirects
	     */
	    function NavigationEnd(id, url, urlAfterRedirects) {
	        this.id = id;
	        this.url = url;
	        this.urlAfterRedirects = urlAfterRedirects;
	    }
	    /**
	     * \@docsNotRequired
	     * @return {?}
	     */
	    NavigationEnd.prototype.toString = function () {
	        return "NavigationEnd(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "')";
	    };
	    return NavigationEnd;
	}());
	/**
	 * \@whatItDoes Represents an event triggered when a navigation is canceled.
	 *
	 * \@stable
	 */
	var NavigationCancel = (function () {
	    /**
	     * @param {?} id
	     * @param {?} url
	     * @param {?} reason
	     */
	    function NavigationCancel(id, url, reason) {
	        this.id = id;
	        this.url = url;
	        this.reason = reason;
	    }
	    /**
	     * \@docsNotRequired
	     * @return {?}
	     */
	    NavigationCancel.prototype.toString = function () { return "NavigationCancel(id: " + this.id + ", url: '" + this.url + "')"; };
	    return NavigationCancel;
	}());
	/**
	 * \@whatItDoes Represents an event triggered when a navigation fails due to an unexpected error.
	 *
	 * \@stable
	 */
	var NavigationError = (function () {
	    /**
	     * @param {?} id
	     * @param {?} url
	     * @param {?} error
	     */
	    function NavigationError(id, url, error) {
	        this.id = id;
	        this.url = url;
	        this.error = error;
	    }
	    /**
	     * \@docsNotRequired
	     * @return {?}
	     */
	    NavigationError.prototype.toString = function () {
	        return "NavigationError(id: " + this.id + ", url: '" + this.url + "', error: " + this.error + ")";
	    };
	    return NavigationError;
	}());
	/**
	 * \@whatItDoes Represents an event triggered when routes are recognized.
	 *
	 * \@stable
	 */
	var RoutesRecognized = (function () {
	    /**
	     * @param {?} id
	     * @param {?} url
	     * @param {?} urlAfterRedirects
	     * @param {?} state
	     */
	    function RoutesRecognized(id, url, urlAfterRedirects, state) {
	        this.id = id;
	        this.url = url;
	        this.urlAfterRedirects = urlAfterRedirects;
	        this.state = state;
	    }
	    /**
	     * \@docsNotRequired
	     * @return {?}
	     */
	    RoutesRecognized.prototype.toString = function () {
	        return "RoutesRecognized(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ")";
	    };
	    return RoutesRecognized;
	}());
	/**
	 * \@whatItDoes Represents an event triggered before lazy loading a route config.
	 *
	 * \@experimental
	 */
	var RouteConfigLoadStart = (function () {
	    /**
	     * @param {?} route
	     */
	    function RouteConfigLoadStart(route) {
	        this.route = route;
	    }
	    /**
	     * @return {?}
	     */
	    RouteConfigLoadStart.prototype.toString = function () { return "RouteConfigLoadStart(path: " + this.route.path + ")"; };
	    return RouteConfigLoadStart;
	}());
	/**
	 * \@whatItDoes Represents an event triggered when a route has been lazy loaded.
	 *
	 * \@experimental
	 */
	var RouteConfigLoadEnd = (function () {
	    /**
	     * @param {?} route
	     */
	    function RouteConfigLoadEnd(route) {
	        this.route = route;
	    }
	    /**
	     * @return {?}
	     */
	    RouteConfigLoadEnd.prototype.toString = function () { return "RouteConfigLoadEnd(path: " + this.route.path + ")"; };
	    return RouteConfigLoadEnd;
	}());
	/**
	 * \@whatItDoes Represents the start of the Guard phase of routing.
	 *
	 * \@experimental
	 */
	var GuardsCheckStart = (function () {
	    /**
	     * @param {?} id
	     * @param {?} url
	     * @param {?} urlAfterRedirects
	     * @param {?} state
	     */
	    function GuardsCheckStart(id, url, urlAfterRedirects, state) {
	        this.id = id;
	        this.url = url;
	        this.urlAfterRedirects = urlAfterRedirects;
	        this.state = state;
	    }
	    /**
	     * @return {?}
	     */
	    GuardsCheckStart.prototype.toString = function () {
	        return "GuardsCheckStart(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ")";
	    };
	    return GuardsCheckStart;
	}());
	/**
	 * \@whatItDoes Represents the end of the Guard phase of routing.
	 *
	 * \@experimental
	 */
	var GuardsCheckEnd = (function () {
	    /**
	     * @param {?} id
	     * @param {?} url
	     * @param {?} urlAfterRedirects
	     * @param {?} state
	     * @param {?} shouldActivate
	     */
	    function GuardsCheckEnd(id, url, urlAfterRedirects, state, shouldActivate) {
	        this.id = id;
	        this.url = url;
	        this.urlAfterRedirects = urlAfterRedirects;
	        this.state = state;
	        this.shouldActivate = shouldActivate;
	    }
	    /**
	     * @return {?}
	     */
	    GuardsCheckEnd.prototype.toString = function () {
	        return "GuardsCheckEnd(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ", shouldActivate: " + this.shouldActivate + ")";
	    };
	    return GuardsCheckEnd;
	}());
	/**
	 * \@whatItDoes Represents the start of the Resolve phase of routing. The timing of this
	 * event may change, thus it's experimental. In the current iteration it will run
	 * in the "resolve" phase whether there's things to resolve or not. In the future this
	 * behavior may change to only run when there are things to be resolved.
	 *
	 * \@experimental
	 */
	var ResolveStart = (function () {
	    /**
	     * @param {?} id
	     * @param {?} url
	     * @param {?} urlAfterRedirects
	     * @param {?} state
	     */
	    function ResolveStart(id, url, urlAfterRedirects, state) {
	        this.id = id;
	        this.url = url;
	        this.urlAfterRedirects = urlAfterRedirects;
	        this.state = state;
	    }
	    /**
	     * @return {?}
	     */
	    ResolveStart.prototype.toString = function () {
	        return "ResolveStart(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ")";
	    };
	    return ResolveStart;
	}());
	/**
	 * \@whatItDoes Represents the end of the Resolve phase of routing. See note on
	 * {\@link ResolveStart} for use of this experimental API.
	 *
	 * \@experimental
	 */
	var ResolveEnd = (function () {
	    /**
	     * @param {?} id
	     * @param {?} url
	     * @param {?} urlAfterRedirects
	     * @param {?} state
	     */
	    function ResolveEnd(id, url, urlAfterRedirects, state) {
	        this.id = id;
	        this.url = url;
	        this.urlAfterRedirects = urlAfterRedirects;
	        this.state = state;
	    }
	    /**
	     * @return {?}
	     */
	    ResolveEnd.prototype.toString = function () {
	        return "ResolveEnd(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ")";
	    };
	    return ResolveEnd;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@whatItDoes Name of the primary outlet.
	 *
	 * \@stable
	 */
	var PRIMARY_OUTLET = 'primary';
	var ParamsAsMap = (function () {
	    /**
	     * @param {?} params
	     */
	    function ParamsAsMap(params) {
	        this.params = params || {};
	    }
	    /**
	     * @param {?} name
	     * @return {?}
	     */
	    ParamsAsMap.prototype.has = function (name) { return this.params.hasOwnProperty(name); };
	    /**
	     * @param {?} name
	     * @return {?}
	     */
	    ParamsAsMap.prototype.get = function (name) {
	        if (this.has(name)) {
	            var /** @type {?} */ v = this.params[name];
	            return Array.isArray(v) ? v[0] : v;
	        }
	        return null;
	    };
	    /**
	     * @param {?} name
	     * @return {?}
	     */
	    ParamsAsMap.prototype.getAll = function (name) {
	        if (this.has(name)) {
	            var /** @type {?} */ v = this.params[name];
	            return Array.isArray(v) ? v : [v];
	        }
	        return [];
	    };
	    Object.defineProperty(ParamsAsMap.prototype, "keys", {
	        /**
	         * @return {?}
	         */
	        get: function () { return Object.keys(this.params); },
	        enumerable: true,
	        configurable: true
	    });
	    return ParamsAsMap;
	}());
	/**
	 * Convert a {\@link Params} instance to a {\@link ParamMap}.
	 *
	 * \@stable
	 * @param {?} params
	 * @return {?}
	 */
	function convertToParamMap(params) {
	    return new ParamsAsMap(params);
	}
	var NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';
	/**
	 * @param {?} message
	 * @return {?}
	 */
	function navigationCancelingError(message) {
	    var /** @type {?} */ error = Error('NavigationCancelingError: ' + message);
	    ((error))[NAVIGATION_CANCELING_ERROR] = true;
	    return error;
	}
	/**
	 * @param {?} error
	 * @return {?}
	 */
	function isNavigationCancelingError(error) {
	    return ((error))[NAVIGATION_CANCELING_ERROR];
	}
	/**
	 * @param {?} segments
	 * @param {?} segmentGroup
	 * @param {?} route
	 * @return {?}
	 */
	function defaultUrlMatcher(segments, segmentGroup, route) {
	    var /** @type {?} */ parts = ((route.path)).split('/');
	    if (parts.length > segments.length) {
	        // The actual URL is shorter than the config, no match
	        return null;
	    }
	    if (route.pathMatch === 'full' &&
	        (segmentGroup.hasChildren() || parts.length < segments.length)) {
	        // The config is longer than the actual URL but we are looking for a full match, return null
	        return null;
	    }
	    var /** @type {?} */ posParams = {};
	    // Check each config part against the actual URL
	    for (var /** @type {?} */ index = 0; index < parts.length; index++) {
	        var /** @type {?} */ part = parts[index];
	        var /** @type {?} */ segment = segments[index];
	        var /** @type {?} */ isParameter = part.startsWith(':');
	        if (isParameter) {
	            posParams[part.substring(1)] = segment;
	        }
	        else if (part !== segment.path) {
	            // The actual URL part does not match the config, no match
	            return null;
	        }
	    }
	    return { consumed: segments.slice(0, parts.length), posParams: posParams };
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var LoadedRouterConfig = (function () {
	    /**
	     * @param {?} routes
	     * @param {?} module
	     */
	    function LoadedRouterConfig(routes, module) {
	        this.routes = routes;
	        this.module = module;
	    }
	    return LoadedRouterConfig;
	}());
	/**
	 * @param {?} config
	 * @param {?=} parentPath
	 * @return {?}
	 */
	function validateConfig(config, parentPath) {
	    if (parentPath === void 0) { parentPath = ''; }
	    // forEach doesn't iterate undefined values
	    for (var /** @type {?} */ i = 0; i < config.length; i++) {
	        var /** @type {?} */ route = config[i];
	        var /** @type {?} */ fullPath = getFullPath(parentPath, route);
	        validateNode(route, fullPath);
	    }
	}
	/**
	 * @param {?} route
	 * @param {?} fullPath
	 * @return {?}
	 */
	function validateNode(route, fullPath) {
	    if (!route) {
	        throw new Error("\n      Invalid configuration of route '" + fullPath + "': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    ");
	    }
	    if (Array.isArray(route)) {
	        throw new Error("Invalid configuration of route '" + fullPath + "': Array cannot be specified");
	    }
	    if (!route.component && (route.outlet && route.outlet !== PRIMARY_OUTLET)) {
	        throw new Error("Invalid configuration of route '" + fullPath + "': a componentless route cannot have a named outlet set");
	    }
	    if (route.redirectTo && route.children) {
	        throw new Error("Invalid configuration of route '" + fullPath + "': redirectTo and children cannot be used together");
	    }
	    if (route.redirectTo && route.loadChildren) {
	        throw new Error("Invalid configuration of route '" + fullPath + "': redirectTo and loadChildren cannot be used together");
	    }
	    if (route.children && route.loadChildren) {
	        throw new Error("Invalid configuration of route '" + fullPath + "': children and loadChildren cannot be used together");
	    }
	    if (route.redirectTo && route.component) {
	        throw new Error("Invalid configuration of route '" + fullPath + "': redirectTo and component cannot be used together");
	    }
	    if (route.path && route.matcher) {
	        throw new Error("Invalid configuration of route '" + fullPath + "': path and matcher cannot be used together");
	    }
	    if (route.redirectTo === void 0 && !route.component && !route.children && !route.loadChildren) {
	        throw new Error("Invalid configuration of route '" + fullPath + "'. One of the following must be provided: component, redirectTo, children or loadChildren");
	    }
	    if (route.path === void 0 && route.matcher === void 0) {
	        throw new Error("Invalid configuration of route '" + fullPath + "': routes must have either a path or a matcher specified");
	    }
	    if (typeof route.path === 'string' && route.path.charAt(0) === '/') {
	        throw new Error("Invalid configuration of route '" + fullPath + "': path cannot start with a slash");
	    }
	    if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {
	        var /** @type {?} */ exp = "The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.";
	        throw new Error("Invalid configuration of route '{path: \"" + fullPath + "\", redirectTo: \"" + route.redirectTo + "\"}': please provide 'pathMatch'. " + exp);
	    }
	    if (route.pathMatch !== void 0 && route.pathMatch !== 'full' && route.pathMatch !== 'prefix') {
	        throw new Error("Invalid configuration of route '" + fullPath + "': pathMatch can only be set to 'prefix' or 'full'");
	    }
	    if (route.children) {
	        validateConfig(route.children, fullPath);
	    }
	}
	/**
	 * @param {?} parentPath
	 * @param {?} currentRoute
	 * @return {?}
	 */
	function getFullPath(parentPath, currentRoute) {
	    if (!currentRoute) {
	        return parentPath;
	    }
	    if (!parentPath && !currentRoute.path) {
	        return '';
	    }
	    else if (parentPath && !currentRoute.path) {
	        return parentPath + "/";
	    }
	    else if (!parentPath && currentRoute.path) {
	        return currentRoute.path;
	    }
	    else {
	        return parentPath + "/" + currentRoute.path;
	    }
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} a
	 * @param {?} b
	 * @return {?}
	 */
	function shallowEqualArrays(a, b) {
	    if (a.length !== b.length)
	        return false;
	    for (var /** @type {?} */ i = 0; i < a.length; ++i) {
	        if (!shallowEqual(a[i], b[i]))
	            return false;
	    }
	    return true;
	}
	/**
	 * @param {?} a
	 * @param {?} b
	 * @return {?}
	 */
	function shallowEqual(a, b) {
	    var /** @type {?} */ k1 = Object.keys(a);
	    var /** @type {?} */ k2 = Object.keys(b);
	    if (k1.length != k2.length) {
	        return false;
	    }
	    var /** @type {?} */ key;
	    for (var /** @type {?} */ i = 0; i < k1.length; i++) {
	        key = k1[i];
	        if (a[key] !== b[key]) {
	            return false;
	        }
	    }
	    return true;
	}
	/**
	 * @template T
	 * @param {?} arr
	 * @return {?}
	 */
	function flatten(arr) {
	    return Array.prototype.concat.apply([], arr);
	}
	/**
	 * @template T
	 * @param {?} a
	 * @return {?}
	 */
	function last$1(a) {
	    return a.length > 0 ? a[a.length - 1] : null;
	}
	/**
	 * @param {?} bools
	 * @return {?}
	 */
	/**
	 * @template K, V
	 * @param {?} map
	 * @param {?} callback
	 * @return {?}
	 */
	function forEach(map$$1, callback) {
	    for (var /** @type {?} */ prop in map$$1) {
	        if (map$$1.hasOwnProperty(prop)) {
	            callback(map$$1[prop], prop);
	        }
	    }
	}
	/**
	 * @template A, B
	 * @param {?} obj
	 * @param {?} fn
	 * @return {?}
	 */
	function waitForMap(obj, fn) {
	    if (Object.keys(obj).length === 0) {
	        return rxjs_observable_of.of({});
	    }
	    var /** @type {?} */ waitHead = [];
	    var /** @type {?} */ waitTail = [];
	    var /** @type {?} */ res = {};
	    forEach(obj, function (a, k) {
	        var /** @type {?} */ mapped = rxjs_operator_map.map.call(fn(k, a), function (r) { return res[k] = r; });
	        if (k === PRIMARY_OUTLET) {
	            waitHead.push(mapped);
	        }
	        else {
	            waitTail.push(mapped);
	        }
	    });
	    var /** @type {?} */ concat$ = rxjs_operator_concatAll.concatAll.call(rxjs_observable_of.of.apply(void 0, waitHead.concat(waitTail)));
	    var /** @type {?} */ last$ = rxjs_operator_last.last.call(concat$);
	    return rxjs_operator_map.map.call(last$, function () { return res; });
	}
	/**
	 * @param {?} observables
	 * @return {?}
	 */
	function andObservables(observables) {
	    var /** @type {?} */ merged$ = rxjs_operator_mergeAll.mergeAll.call(observables);
	    return rxjs_operator_every.every.call(merged$, function (result) { return result === true; });
	}
	/**
	 * @template T
	 * @param {?} value
	 * @return {?}
	 */
	function wrapIntoObservable(value) {
	    if (_angular_core.ɵisObservable(value)) {
	        return value;
	    }
	    if (_angular_core.ɵisPromise(value)) {
	        // Use `Promise.resolve()` to wrap promise-like instances.
	        // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the
	        // change detection.
	        return rxjs_observable_fromPromise.fromPromise(Promise.resolve(value));
	    }
	    return rxjs_observable_of.of(value);
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @return {?}
	 */
	function createEmptyUrlTree() {
	    return new UrlTree(new UrlSegmentGroup([], {}), {}, null);
	}
	/**
	 * @param {?} container
	 * @param {?} containee
	 * @param {?} exact
	 * @return {?}
	 */
	function containsTree(container, containee, exact) {
	    if (exact) {
	        return equalQueryParams(container.queryParams, containee.queryParams) &&
	            equalSegmentGroups(container.root, containee.root);
	    }
	    return containsQueryParams(container.queryParams, containee.queryParams) &&
	        containsSegmentGroup(container.root, containee.root);
	}
	/**
	 * @param {?} container
	 * @param {?} containee
	 * @return {?}
	 */
	function equalQueryParams(container, containee) {
	    return shallowEqual(container, containee);
	}
	/**
	 * @param {?} container
	 * @param {?} containee
	 * @return {?}
	 */
	function equalSegmentGroups(container, containee) {
	    if (!equalPath(container.segments, containee.segments))
	        return false;
	    if (container.numberOfChildren !== containee.numberOfChildren)
	        return false;
	    for (var /** @type {?} */ c in containee.children) {
	        if (!container.children[c])
	            return false;
	        if (!equalSegmentGroups(container.children[c], containee.children[c]))
	            return false;
	    }
	    return true;
	}
	/**
	 * @param {?} container
	 * @param {?} containee
	 * @return {?}
	 */
	function containsQueryParams(container, containee) {
	    return Object.keys(containee).length <= Object.keys(container).length &&
	        Object.keys(containee).every(function (key) { return containee[key] === container[key]; });
	}
	/**
	 * @param {?} container
	 * @param {?} containee
	 * @return {?}
	 */
	function containsSegmentGroup(container, containee) {
	    return containsSegmentGroupHelper(container, containee, containee.segments);
	}
	/**
	 * @param {?} container
	 * @param {?} containee
	 * @param {?} containeePaths
	 * @return {?}
	 */
	function containsSegmentGroupHelper(container, containee, containeePaths) {
	    if (container.segments.length > containeePaths.length) {
	        var /** @type {?} */ current = container.segments.slice(0, containeePaths.length);
	        if (!equalPath(current, containeePaths))
	            return false;
	        if (containee.hasChildren())
	            return false;
	        return true;
	    }
	    else if (container.segments.length === containeePaths.length) {
	        if (!equalPath(container.segments, containeePaths))
	            return false;
	        for (var /** @type {?} */ c in containee.children) {
	            if (!container.children[c])
	                return false;
	            if (!containsSegmentGroup(container.children[c], containee.children[c]))
	                return false;
	        }
	        return true;
	    }
	    else {
	        var /** @type {?} */ current = containeePaths.slice(0, container.segments.length);
	        var /** @type {?} */ next = containeePaths.slice(container.segments.length);
	        if (!equalPath(container.segments, current))
	            return false;
	        if (!container.children[PRIMARY_OUTLET])
	            return false;
	        return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next);
	    }
	}
	/**
	 * \@whatItDoes Represents the parsed URL.
	 *
	 * \@howToUse
	 *
	 * ```
	 * \@Component({templateUrl:'template.html'})
	 * class MyComponent {
	 *   constructor(router: Router) {
	 *     const tree: UrlTree =
	 *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');
	 *     const f = tree.fragment; // return 'fragment'
	 *     const q = tree.queryParams; // returns {debug: 'true'}
	 *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];
	 *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'
	 *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'
	 *     g.children['support'].segments; // return 1 segment 'help'
	 *   }
	 * }
	 * ```
	 *
	 * \@description
	 *
	 * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a
	 * serialized tree.
	 * UrlTree is a data structure that provides a lot of affordances in dealing with URLs
	 *
	 * \@stable
	 */
	var UrlTree = (function () {
	    /**
	     * \@internal
	     * @param {?} root
	     * @param {?} queryParams
	     * @param {?} fragment
	     */
	    function UrlTree(root, queryParams, fragment) {
	        this.root = root;
	        this.queryParams = queryParams;
	        this.fragment = fragment;
	    }
	    Object.defineProperty(UrlTree.prototype, "queryParamMap", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            if (!this._queryParamMap) {
	                this._queryParamMap = convertToParamMap(this.queryParams);
	            }
	            return this._queryParamMap;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * \@docsNotRequired
	     * @return {?}
	     */
	    UrlTree.prototype.toString = function () { return DEFAULT_SERIALIZER.serialize(this); };
	    return UrlTree;
	}());
	/**
	 * \@whatItDoes Represents the parsed URL segment group.
	 *
	 * See {\@link UrlTree} for more information.
	 *
	 * \@stable
	 */
	var UrlSegmentGroup = (function () {
	    /**
	     * @param {?} segments
	     * @param {?} children
	     */
	    function UrlSegmentGroup(segments, children) {
	        var _this = this;
	        this.segments = segments;
	        this.children = children;
	        /**
	         * The parent node in the url tree
	         */
	        this.parent = null;
	        forEach(children, function (v, k) { return v.parent = _this; });
	    }
	    /**
	     * Whether the segment has child segments
	     * @return {?}
	     */
	    UrlSegmentGroup.prototype.hasChildren = function () { return this.numberOfChildren > 0; };
	    Object.defineProperty(UrlSegmentGroup.prototype, "numberOfChildren", {
	        /**
	         * Number of child segments
	         * @return {?}
	         */
	        get: function () { return Object.keys(this.children).length; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * \@docsNotRequired
	     * @return {?}
	     */
	    UrlSegmentGroup.prototype.toString = function () { return serializePaths(this); };
	    return UrlSegmentGroup;
	}());
	/**
	 * \@whatItDoes Represents a single URL segment.
	 *
	 * \@howToUse
	 *
	 * ```
	 * \@Component({templateUrl:'template.html'})
	 * class MyComponent {
	 *   constructor(router: Router) {
	 *     const tree: UrlTree = router.parseUrl('/team;id=33');
	 *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];
	 *     const s: UrlSegment[] = g.segments;
	 *     s[0].path; // returns 'team'
	 *     s[0].parameters; // returns {id: 33}
	 *   }
	 * }
	 * ```
	 *
	 * \@description
	 *
	 * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix
	 * parameters associated with the segment.
	 *
	 * \@stable
	 */
	var UrlSegment = (function () {
	    /**
	     * @param {?} path
	     * @param {?} parameters
	     */
	    function UrlSegment(path, parameters) {
	        this.path = path;
	        this.parameters = parameters;
	    }
	    Object.defineProperty(UrlSegment.prototype, "parameterMap", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            if (!this._parameterMap) {
	                this._parameterMap = convertToParamMap(this.parameters);
	            }
	            return this._parameterMap;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * \@docsNotRequired
	     * @return {?}
	     */
	    UrlSegment.prototype.toString = function () { return serializePath(this); };
	    return UrlSegment;
	}());
	/**
	 * @param {?} as
	 * @param {?} bs
	 * @return {?}
	 */
	function equalSegments(as, bs) {
	    return equalPath(as, bs) && as.every(function (a, i) { return shallowEqual(a.parameters, bs[i].parameters); });
	}
	/**
	 * @param {?} as
	 * @param {?} bs
	 * @return {?}
	 */
	function equalPath(as, bs) {
	    if (as.length !== bs.length)
	        return false;
	    return as.every(function (a, i) { return a.path === bs[i].path; });
	}
	/**
	 * @template T
	 * @param {?} segment
	 * @param {?} fn
	 * @return {?}
	 */
	function mapChildrenIntoArray(segment, fn) {
	    var /** @type {?} */ res = [];
	    forEach(segment.children, function (child, childOutlet) {
	        if (childOutlet === PRIMARY_OUTLET) {
	            res = res.concat(fn(child, childOutlet));
	        }
	    });
	    forEach(segment.children, function (child, childOutlet) {
	        if (childOutlet !== PRIMARY_OUTLET) {
	            res = res.concat(fn(child, childOutlet));
	        }
	    });
	    return res;
	}
	/**
	 * \@whatItDoes Serializes and deserializes a URL string into a URL tree.
	 *
	 * \@description The url serialization strategy is customizable. You can
	 * make all URLs case insensitive by providing a custom UrlSerializer.
	 *
	 * See {\@link DefaultUrlSerializer} for an example of a URL serializer.
	 *
	 * \@stable
	 * @abstract
	 */
	var UrlSerializer = (function () {
	    function UrlSerializer() {
	    }
	    /**
	     * Parse a url into a {\@link UrlTree}
	     * @abstract
	     * @param {?} url
	     * @return {?}
	     */
	    UrlSerializer.prototype.parse = function (url) { };
	    /**
	     * Converts a {\@link UrlTree} into a url
	     * @abstract
	     * @param {?} tree
	     * @return {?}
	     */
	    UrlSerializer.prototype.serialize = function (tree) { };
	    return UrlSerializer;
	}());
	/**
	 * \@whatItDoes A default implementation of the {\@link UrlSerializer}.
	 *
	 * \@description
	 *
	 * Example URLs:
	 *
	 * ```
	 * /inbox/33(popup:compose)
	 * /inbox/33;open=true/messages/44
	 * ```
	 *
	 * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the
	 * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to
	 * specify route specific parameters.
	 *
	 * \@stable
	 */
	var DefaultUrlSerializer = (function () {
	    function DefaultUrlSerializer() {
	    }
	    /**
	     * Parses a url into a {\@link UrlTree}
	     * @param {?} url
	     * @return {?}
	     */
	    DefaultUrlSerializer.prototype.parse = function (url) {
	        var /** @type {?} */ p = new UrlParser(url);
	        return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());
	    };
	    /**
	     * Converts a {\@link UrlTree} into a url
	     * @param {?} tree
	     * @return {?}
	     */
	    DefaultUrlSerializer.prototype.serialize = function (tree) {
	        var /** @type {?} */ segment = "/" + serializeSegment(tree.root, true);
	        var /** @type {?} */ query = serializeQueryParams(tree.queryParams);
	        var /** @type {?} */ fragment = typeof tree.fragment === "string" ? "#" + encodeURI(/** @type {?} */ ((tree.fragment))) : '';
	        return "" + segment + query + fragment;
	    };
	    return DefaultUrlSerializer;
	}());
	var DEFAULT_SERIALIZER = new DefaultUrlSerializer();
	/**
	 * @param {?} segment
	 * @return {?}
	 */
	function serializePaths(segment) {
	    return segment.segments.map(function (p) { return serializePath(p); }).join('/');
	}
	/**
	 * @param {?} segment
	 * @param {?} root
	 * @return {?}
	 */
	function serializeSegment(segment, root) {
	    if (!segment.hasChildren()) {
	        return serializePaths(segment);
	    }
	    if (root) {
	        var /** @type {?} */ primary = segment.children[PRIMARY_OUTLET] ?
	            serializeSegment(segment.children[PRIMARY_OUTLET], false) :
	            '';
	        var /** @type {?} */ children_1 = [];
	        forEach(segment.children, function (v, k) {
	            if (k !== PRIMARY_OUTLET) {
	                children_1.push(k + ":" + serializeSegment(v, false));
	            }
	        });
	        return children_1.length > 0 ? primary + "(" + children_1.join('//') + ")" : primary;
	    }
	    else {
	        var /** @type {?} */ children = mapChildrenIntoArray(segment, function (v, k) {
	            if (k === PRIMARY_OUTLET) {
	                return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];
	            }
	            return [k + ":" + serializeSegment(v, false)];
	        });
	        return serializePaths(segment) + "/(" + children.join('//') + ")";
	    }
	}
	/**
	 * This method is intended for encoding *key* or *value* parts of query component. We need a custom
	 * method because encodeURIComponent is too aggressive and encodes stuff that doesn't have to be
	 * encoded per http://tools.ietf.org/html/rfc3986:
	 *    query         = *( pchar / "/" / "?" )
	 *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "\@"
	 *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
	 *    pct-encoded   = "%" HEXDIG HEXDIG
	 *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
	 *                     / "*" / "+" / "," / ";" / "="
	 * @param {?} s
	 * @return {?}
	 */
	function encode(s) {
	    return encodeURIComponent(s)
	        .replace(/%40/g, '@')
	        .replace(/%3A/gi, ':')
	        .replace(/%24/g, '$')
	        .replace(/%2C/gi, ',')
	        .replace(/%3B/gi, ';');
	}
	/**
	 * @param {?} s
	 * @return {?}
	 */
	function decode(s) {
	    return decodeURIComponent(s);
	}
	/**
	 * @param {?} path
	 * @return {?}
	 */
	function serializePath(path) {
	    return "" + encode(path.path) + serializeParams(path.parameters);
	}
	/**
	 * @param {?} params
	 * @return {?}
	 */
	function serializeParams(params) {
	    return Object.keys(params).map(function (key) { return ";" + encode(key) + "=" + encode(params[key]); }).join('');
	}
	/**
	 * @param {?} params
	 * @return {?}
	 */
	function serializeQueryParams(params) {
	    var /** @type {?} */ strParams = Object.keys(params).map(function (name) {
	        var /** @type {?} */ value = params[name];
	        return Array.isArray(value) ? value.map(function (v) { return encode(name) + "=" + encode(v); }).join('&') :
	            encode(name) + "=" + encode(value);
	    });
	    return strParams.length ? "?" + strParams.join("&") : '';
	}
	var SEGMENT_RE = /^[^\/()?;=&#]+/;
	/**
	 * @param {?} str
	 * @return {?}
	 */
	function matchSegments(str) {
	    var /** @type {?} */ match = str.match(SEGMENT_RE);
	    return match ? match[0] : '';
	}
	var QUERY_PARAM_RE = /^[^=?&#]+/;
	/**
	 * @param {?} str
	 * @return {?}
	 */
	function matchQueryParams(str) {
	    var /** @type {?} */ match = str.match(QUERY_PARAM_RE);
	    return match ? match[0] : '';
	}
	var QUERY_PARAM_VALUE_RE = /^[^?&#]+/;
	/**
	 * @param {?} str
	 * @return {?}
	 */
	function matchUrlQueryParamValue(str) {
	    var /** @type {?} */ match = str.match(QUERY_PARAM_VALUE_RE);
	    return match ? match[0] : '';
	}
	var UrlParser = (function () {
	    /**
	     * @param {?} url
	     */
	    function UrlParser(url) {
	        this.url = url;
	        this.remaining = url;
	    }
	    /**
	     * @return {?}
	     */
	    UrlParser.prototype.parseRootSegment = function () {
	        this.consumeOptional('/');
	        if (this.remaining === '' || this.peekStartsWith('?') || this.peekStartsWith('#')) {
	            return new UrlSegmentGroup([], {});
	        }
	        // The root segment group never has segments
	        return new UrlSegmentGroup([], this.parseChildren());
	    };
	    /**
	     * @return {?}
	     */
	    UrlParser.prototype.parseQueryParams = function () {
	        var /** @type {?} */ params = {};
	        if (this.consumeOptional('?')) {
	            do {
	                this.parseQueryParam(params);
	            } while (this.consumeOptional('&'));
	        }
	        return params;
	    };
	    /**
	     * @return {?}
	     */
	    UrlParser.prototype.parseFragment = function () {
	        return this.consumeOptional('#') ? decodeURI(this.remaining) : null;
	    };
	    /**
	     * @return {?}
	     */
	    UrlParser.prototype.parseChildren = function () {
	        if (this.remaining === '') {
	            return {};
	        }
	        this.consumeOptional('/');
	        var /** @type {?} */ segments = [];
	        if (!this.peekStartsWith('(')) {
	            segments.push(this.parseSegment());
	        }
	        while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {
	            this.capture('/');
	            segments.push(this.parseSegment());
	        }
	        var /** @type {?} */ children = {};
	        if (this.peekStartsWith('/(')) {
	            this.capture('/');
	            children = this.parseParens(true);
	        }
	        var /** @type {?} */ res = {};
	        if (this.peekStartsWith('(')) {
	            res = this.parseParens(false);
	        }
	        if (segments.length > 0 || Object.keys(children).length > 0) {
	            res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);
	        }
	        return res;
	    };
	    /**
	     * @return {?}
	     */
	    UrlParser.prototype.parseSegment = function () {
	        var /** @type {?} */ path = matchSegments(this.remaining);
	        if (path === '' && this.peekStartsWith(';')) {
	            throw new Error("Empty path url segment cannot have parameters: '" + this.remaining + "'.");
	        }
	        this.capture(path);
	        return new UrlSegment(decode(path), this.parseMatrixParams());
	    };
	    /**
	     * @return {?}
	     */
	    UrlParser.prototype.parseMatrixParams = function () {
	        var /** @type {?} */ params = {};
	        while (this.consumeOptional(';')) {
	            this.parseParam(params);
	        }
	        return params;
	    };
	    /**
	     * @param {?} params
	     * @return {?}
	     */
	    UrlParser.prototype.parseParam = function (params) {
	        var /** @type {?} */ key = matchSegments(this.remaining);
	        if (!key) {
	            return;
	        }
	        this.capture(key);
	        var /** @type {?} */ value = '';
	        if (this.consumeOptional('=')) {
	            var /** @type {?} */ valueMatch = matchSegments(this.remaining);
	            if (valueMatch) {
	                value = valueMatch;
	                this.capture(value);
	            }
	        }
	        params[decode(key)] = decode(value);
	    };
	    /**
	     * @param {?} params
	     * @return {?}
	     */
	    UrlParser.prototype.parseQueryParam = function (params) {
	        var /** @type {?} */ key = matchQueryParams(this.remaining);
	        if (!key) {
	            return;
	        }
	        this.capture(key);
	        var /** @type {?} */ value = '';
	        if (this.consumeOptional('=')) {
	            var /** @type {?} */ valueMatch = matchUrlQueryParamValue(this.remaining);
	            if (valueMatch) {
	                value = valueMatch;
	                this.capture(value);
	            }
	        }
	        var /** @type {?} */ decodedKey = decode(key);
	        var /** @type {?} */ decodedVal = decode(value);
	        if (params.hasOwnProperty(decodedKey)) {
	            // Append to existing values
	            var /** @type {?} */ currentVal = params[decodedKey];
	            if (!Array.isArray(currentVal)) {
	                currentVal = [currentVal];
	                params[decodedKey] = currentVal;
	            }
	            currentVal.push(decodedVal);
	        }
	        else {
	            // Create a new value
	            params[decodedKey] = decodedVal;
	        }
	    };
	    /**
	     * @param {?} allowPrimary
	     * @return {?}
	     */
	    UrlParser.prototype.parseParens = function (allowPrimary) {
	        var /** @type {?} */ segments = {};
	        this.capture('(');
	        while (!this.consumeOptional(')') && this.remaining.length > 0) {
	            var /** @type {?} */ path = matchSegments(this.remaining);
	            var /** @type {?} */ next = this.remaining[path.length];
	            // if is is not one of these characters, then the segment was unescaped
	            // or the group was not closed
	            if (next !== '/' && next !== ')' && next !== ';') {
	                throw new Error("Cannot parse url '" + this.url + "'");
	            }
	            var /** @type {?} */ outletName = ((undefined));
	            if (path.indexOf(':') > -1) {
	                outletName = path.substr(0, path.indexOf(':'));
	                this.capture(outletName);
	                this.capture(':');
	            }
	            else if (allowPrimary) {
	                outletName = PRIMARY_OUTLET;
	            }
	            var /** @type {?} */ children = this.parseChildren();
	            segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] :
	                new UrlSegmentGroup([], children);
	            this.consumeOptional('//');
	        }
	        return segments;
	    };
	    /**
	     * @param {?} str
	     * @return {?}
	     */
	    UrlParser.prototype.peekStartsWith = function (str) { return this.remaining.startsWith(str); };
	    /**
	     * @param {?} str
	     * @return {?}
	     */
	    UrlParser.prototype.consumeOptional = function (str) {
	        if (this.peekStartsWith(str)) {
	            this.remaining = this.remaining.substring(str.length);
	            return true;
	        }
	        return false;
	    };
	    /**
	     * @param {?} str
	     * @return {?}
	     */
	    UrlParser.prototype.capture = function (str) {
	        if (!this.consumeOptional(str)) {
	            throw new Error("Expected \"" + str + "\".");
	        }
	    };
	    return UrlParser;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var NoMatch = (function () {
	    /**
	     * @param {?=} segmentGroup
	     */
	    function NoMatch(segmentGroup) {
	        this.segmentGroup = segmentGroup || null;
	    }
	    return NoMatch;
	}());
	var AbsoluteRedirect = (function () {
	    /**
	     * @param {?} urlTree
	     */
	    function AbsoluteRedirect(urlTree) {
	        this.urlTree = urlTree;
	    }
	    return AbsoluteRedirect;
	}());
	/**
	 * @param {?} segmentGroup
	 * @return {?}
	 */
	function noMatch(segmentGroup) {
	    return new rxjs_Observable.Observable(function (obs) { return obs.error(new NoMatch(segmentGroup)); });
	}
	/**
	 * @param {?} newTree
	 * @return {?}
	 */
	function absoluteRedirect(newTree) {
	    return new rxjs_Observable.Observable(function (obs) { return obs.error(new AbsoluteRedirect(newTree)); });
	}
	/**
	 * @param {?} redirectTo
	 * @return {?}
	 */
	function namedOutletsRedirect(redirectTo) {
	    return new rxjs_Observable.Observable(function (obs) { return obs.error(new Error("Only absolute redirects can have named outlets. redirectTo: '" + redirectTo + "'")); });
	}
	/**
	 * @param {?} route
	 * @return {?}
	 */
	function canLoadFails(route) {
	    return new rxjs_Observable.Observable(function (obs) { return obs.error(navigationCancelingError("Cannot load children because the guard of the route \"path: '" + route.path + "'\" returned false")); });
	}
	/**
	 * Returns the `UrlTree` with the redirection applied.
	 *
	 * Lazy modules are loaded along the way.
	 * @param {?} moduleInjector
	 * @param {?} configLoader
	 * @param {?} urlSerializer
	 * @param {?} urlTree
	 * @param {?} config
	 * @return {?}
	 */
	function applyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config) {
	    return new ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config).apply();
	}
	var ApplyRedirects = (function () {
	    /**
	     * @param {?} moduleInjector
	     * @param {?} configLoader
	     * @param {?} urlSerializer
	     * @param {?} urlTree
	     * @param {?} config
	     */
	    function ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config) {
	        this.configLoader = configLoader;
	        this.urlSerializer = urlSerializer;
	        this.urlTree = urlTree;
	        this.config = config;
	        this.allowRedirects = true;
	        this.ngModule = moduleInjector.get(_angular_core.NgModuleRef);
	    }
	    /**
	     * @return {?}
	     */
	    ApplyRedirects.prototype.apply = function () {
	        var _this = this;
	        var /** @type {?} */ expanded$ = this.expandSegmentGroup(this.ngModule, this.config, this.urlTree.root, PRIMARY_OUTLET);
	        var /** @type {?} */ urlTrees$ = rxjs_operator_map.map.call(expanded$, function (rootSegmentGroup) { return _this.createUrlTree(rootSegmentGroup, _this.urlTree.queryParams, /** @type {?} */ ((_this.urlTree.fragment))); });
	        return rxjs_operator_catch._catch.call(urlTrees$, function (e) {
	            if (e instanceof AbsoluteRedirect) {
	                // after an absolute redirect we do not apply any more redirects!
	                _this.allowRedirects = false;
	                // we need to run matching, so we can fetch all lazy-loaded modules
	                return _this.match(e.urlTree);
	            }
	            if (e instanceof NoMatch) {
	                throw _this.noMatchError(e);
	            }
	            throw e;
	        });
	    };
	    /**
	     * @param {?} tree
	     * @return {?}
	     */
	    ApplyRedirects.prototype.match = function (tree) {
	        var _this = this;
	        var /** @type {?} */ expanded$ = this.expandSegmentGroup(this.ngModule, this.config, tree.root, PRIMARY_OUTLET);
	        var /** @type {?} */ mapped$ = rxjs_operator_map.map.call(expanded$, function (rootSegmentGroup) { return _this.createUrlTree(rootSegmentGroup, tree.queryParams, /** @type {?} */ ((tree.fragment))); });
	        return rxjs_operator_catch._catch.call(mapped$, function (e) {
	            if (e instanceof NoMatch) {
	                throw _this.noMatchError(e);
	            }
	            throw e;
	        });
	    };
	    /**
	     * @param {?} e
	     * @return {?}
	     */
	    ApplyRedirects.prototype.noMatchError = function (e) {
	        return new Error("Cannot match any routes. URL Segment: '" + e.segmentGroup + "'");
	    };
	    /**
	     * @param {?} rootCandidate
	     * @param {?} queryParams
	     * @param {?} fragment
	     * @return {?}
	     */
	    ApplyRedirects.prototype.createUrlTree = function (rootCandidate, queryParams, fragment) {
	        var /** @type {?} */ root = rootCandidate.segments.length > 0 ?
	            new UrlSegmentGroup([], (_a = {}, _a[PRIMARY_OUTLET] = rootCandidate, _a)) :
	            rootCandidate;
	        return new UrlTree(root, queryParams, fragment);
	        var _a;
	    };
	    /**
	     * @param {?} ngModule
	     * @param {?} routes
	     * @param {?} segmentGroup
	     * @param {?} outlet
	     * @return {?}
	     */
	    ApplyRedirects.prototype.expandSegmentGroup = function (ngModule, routes, segmentGroup, outlet) {
	        if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
	            return rxjs_operator_map.map.call(this.expandChildren(ngModule, routes, segmentGroup), function (children) { return new UrlSegmentGroup([], children); });
	        }
	        return this.expandSegment(ngModule, segmentGroup, routes, segmentGroup.segments, outlet, true);
	    };
	    /**
	     * @param {?} ngModule
	     * @param {?} routes
	     * @param {?} segmentGroup
	     * @return {?}
	     */
	    ApplyRedirects.prototype.expandChildren = function (ngModule, routes, segmentGroup) {
	        var _this = this;
	        return waitForMap(segmentGroup.children, function (childOutlet, child) { return _this.expandSegmentGroup(ngModule, routes, child, childOutlet); });
	    };
	    /**
	     * @param {?} ngModule
	     * @param {?} segmentGroup
	     * @param {?} routes
	     * @param {?} segments
	     * @param {?} outlet
	     * @param {?} allowRedirects
	     * @return {?}
	     */
	    ApplyRedirects.prototype.expandSegment = function (ngModule, segmentGroup, routes, segments, outlet, allowRedirects) {
	        var _this = this;
	        var /** @type {?} */ routes$ = rxjs_observable_of.of.apply(void 0, routes);
	        var /** @type {?} */ processedRoutes$ = rxjs_operator_map.map.call(routes$, function (r) {
	            var /** @type {?} */ expanded$ = _this.expandSegmentAgainstRoute(ngModule, segmentGroup, routes, r, segments, outlet, allowRedirects);
	            return rxjs_operator_catch._catch.call(expanded$, function (e) {
	                if (e instanceof NoMatch) {
	                    return rxjs_observable_of.of(null);
	                }
	                throw e;
	            });
	        });
	        var /** @type {?} */ concattedProcessedRoutes$ = rxjs_operator_concatAll.concatAll.call(processedRoutes$);
	        var /** @type {?} */ first$ = rxjs_operator_first.first.call(concattedProcessedRoutes$, function (s) { return !!s; });
	        return rxjs_operator_catch._catch.call(first$, function (e, _) {
	            if (e instanceof rxjs_util_EmptyError.EmptyError) {
	                if (_this.noLeftoversInUrl(segmentGroup, segments, outlet)) {
	                    return rxjs_observable_of.of(new UrlSegmentGroup([], {}));
	                }
	                throw new NoMatch(segmentGroup);
	            }
	            throw e;
	        });
	    };
	    /**
	     * @param {?} segmentGroup
	     * @param {?} segments
	     * @param {?} outlet
	     * @return {?}
	     */
	    ApplyRedirects.prototype.noLeftoversInUrl = function (segmentGroup, segments, outlet) {
	        return segments.length === 0 && !segmentGroup.children[outlet];
	    };
	    /**
	     * @param {?} ngModule
	     * @param {?} segmentGroup
	     * @param {?} routes
	     * @param {?} route
	     * @param {?} paths
	     * @param {?} outlet
	     * @param {?} allowRedirects
	     * @return {?}
	     */
	    ApplyRedirects.prototype.expandSegmentAgainstRoute = function (ngModule, segmentGroup, routes, route, paths, outlet, allowRedirects) {
	        if (getOutlet(route) !== outlet) {
	            return noMatch(segmentGroup);
	        }
	        if (route.redirectTo === undefined) {
	            return this.matchSegmentAgainstRoute(ngModule, segmentGroup, route, paths);
	        }
	        if (allowRedirects && this.allowRedirects) {
	            return this.expandSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, paths, outlet);
	        }
	        return noMatch(segmentGroup);
	    };
	    /**
	     * @param {?} ngModule
	     * @param {?} segmentGroup
	     * @param {?} routes
	     * @param {?} route
	     * @param {?} segments
	     * @param {?} outlet
	     * @return {?}
	     */
	    ApplyRedirects.prototype.expandSegmentAgainstRouteUsingRedirect = function (ngModule, segmentGroup, routes, route, segments, outlet) {
	        if (route.path === '**') {
	            return this.expandWildCardWithParamsAgainstRouteUsingRedirect(ngModule, routes, route, outlet);
	        }
	        return this.expandRegularSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, segments, outlet);
	    };
	    /**
	     * @param {?} ngModule
	     * @param {?} routes
	     * @param {?} route
	     * @param {?} outlet
	     * @return {?}
	     */
	    ApplyRedirects.prototype.expandWildCardWithParamsAgainstRouteUsingRedirect = function (ngModule, routes, route, outlet) {
	        var _this = this;
	        var /** @type {?} */ newTree = this.applyRedirectCommands([], /** @type {?} */ ((route.redirectTo)), {});
	        if (((route.redirectTo)).startsWith('/')) {
	            return absoluteRedirect(newTree);
	        }
	        return rxjs_operator_mergeMap.mergeMap.call(this.lineralizeSegments(route, newTree), function (newSegments) {
	            var /** @type {?} */ group = new UrlSegmentGroup(newSegments, {});
	            return _this.expandSegment(ngModule, group, routes, newSegments, outlet, false);
	        });
	    };
	    /**
	     * @param {?} ngModule
	     * @param {?} segmentGroup
	     * @param {?} routes
	     * @param {?} route
	     * @param {?} segments
	     * @param {?} outlet
	     * @return {?}
	     */
	    ApplyRedirects.prototype.expandRegularSegmentAgainstRouteUsingRedirect = function (ngModule, segmentGroup, routes, route, segments, outlet) {
	        var _this = this;
	        var _a = match(segmentGroup, route, segments), matched = _a.matched, consumedSegments = _a.consumedSegments, lastChild = _a.lastChild, positionalParamSegments = _a.positionalParamSegments;
	        if (!matched)
	            return noMatch(segmentGroup);
	        var /** @type {?} */ newTree = this.applyRedirectCommands(consumedSegments, /** @type {?} */ ((route.redirectTo)), /** @type {?} */ (positionalParamSegments));
	        if (((route.redirectTo)).startsWith('/')) {
	            return absoluteRedirect(newTree);
	        }
	        return rxjs_operator_mergeMap.mergeMap.call(this.lineralizeSegments(route, newTree), function (newSegments) {
	            return _this.expandSegment(ngModule, segmentGroup, routes, newSegments.concat(segments.slice(lastChild)), outlet, false);
	        });
	    };
	    /**
	     * @param {?} ngModule
	     * @param {?} rawSegmentGroup
	     * @param {?} route
	     * @param {?} segments
	     * @return {?}
	     */
	    ApplyRedirects.prototype.matchSegmentAgainstRoute = function (ngModule, rawSegmentGroup, route, segments) {
	        var _this = this;
	        if (route.path === '**') {
	            if (route.loadChildren) {
	                return rxjs_operator_map.map.call(this.configLoader.load(ngModule.injector, route), function (cfg) {
	                    route._loadedConfig = cfg;
	                    return new UrlSegmentGroup(segments, {});
	                });
	            }
	            return rxjs_observable_of.of(new UrlSegmentGroup(segments, {}));
	        }
	        var _a = match(rawSegmentGroup, route, segments), matched = _a.matched, consumedSegments = _a.consumedSegments, lastChild = _a.lastChild;
	        if (!matched)
	            return noMatch(rawSegmentGroup);
	        var /** @type {?} */ rawSlicedSegments = segments.slice(lastChild);
	        var /** @type {?} */ childConfig$ = this.getChildConfig(ngModule, route);
	        return rxjs_operator_mergeMap.mergeMap.call(childConfig$, function (routerConfig) {
	            var /** @type {?} */ childModule = routerConfig.module;
	            var /** @type {?} */ childConfig = routerConfig.routes;
	            var _a = split(rawSegmentGroup, consumedSegments, rawSlicedSegments, childConfig), segmentGroup = _a.segmentGroup, slicedSegments = _a.slicedSegments;
	            if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {
	                var /** @type {?} */ expanded$_1 = _this.expandChildren(childModule, childConfig, segmentGroup);
	                return rxjs_operator_map.map.call(expanded$_1, function (children) { return new UrlSegmentGroup(consumedSegments, children); });
	            }
	            if (childConfig.length === 0 && slicedSegments.length === 0) {
	                return rxjs_observable_of.of(new UrlSegmentGroup(consumedSegments, {}));
	            }
	            var /** @type {?} */ expanded$ = _this.expandSegment(childModule, segmentGroup, childConfig, slicedSegments, PRIMARY_OUTLET, true);
	            return rxjs_operator_map.map.call(expanded$, function (cs) { return new UrlSegmentGroup(consumedSegments.concat(cs.segments), cs.children); });
	        });
	    };
	    /**
	     * @param {?} ngModule
	     * @param {?} route
	     * @return {?}
	     */
	    ApplyRedirects.prototype.getChildConfig = function (ngModule, route) {
	        var _this = this;
	        if (route.children) {
	            // The children belong to the same module
	            return rxjs_observable_of.of(new LoadedRouterConfig(route.children, ngModule));
	        }
	        if (route.loadChildren) {
	            // lazy children belong to the loaded module
	            if (route._loadedConfig !== undefined) {
	                return rxjs_observable_of.of(route._loadedConfig);
	            }
	            return rxjs_operator_mergeMap.mergeMap.call(runCanLoadGuard(ngModule.injector, route), function (shouldLoad) {
	                if (shouldLoad) {
	                    return rxjs_operator_map.map.call(_this.configLoader.load(ngModule.injector, route), function (cfg) {
	                        route._loadedConfig = cfg;
	                        return cfg;
	                    });
	                }
	                return canLoadFails(route);
	            });
	        }
	        return rxjs_observable_of.of(new LoadedRouterConfig([], ngModule));
	    };
	    /**
	     * @param {?} route
	     * @param {?} urlTree
	     * @return {?}
	     */
	    ApplyRedirects.prototype.lineralizeSegments = function (route, urlTree) {
	        var /** @type {?} */ res = [];
	        var /** @type {?} */ c = urlTree.root;
	        while (true) {
	            res = res.concat(c.segments);
	            if (c.numberOfChildren === 0) {
	                return rxjs_observable_of.of(res);
	            }
	            if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {
	                return namedOutletsRedirect(/** @type {?} */ ((route.redirectTo)));
	            }
	            c = c.children[PRIMARY_OUTLET];
	        }
	    };
	    /**
	     * @param {?} segments
	     * @param {?} redirectTo
	     * @param {?} posParams
	     * @return {?}
	     */
	    ApplyRedirects.prototype.applyRedirectCommands = function (segments, redirectTo, posParams) {
	        return this.applyRedirectCreatreUrlTree(redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);
	    };
	    /**
	     * @param {?} redirectTo
	     * @param {?} urlTree
	     * @param {?} segments
	     * @param {?} posParams
	     * @return {?}
	     */
	    ApplyRedirects.prototype.applyRedirectCreatreUrlTree = function (redirectTo, urlTree, segments, posParams) {
	        var /** @type {?} */ newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);
	        return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);
	    };
	    /**
	     * @param {?} redirectToParams
	     * @param {?} actualParams
	     * @return {?}
	     */
	    ApplyRedirects.prototype.createQueryParams = function (redirectToParams, actualParams) {
	        var /** @type {?} */ res = {};
	        forEach(redirectToParams, function (v, k) {
	            var /** @type {?} */ copySourceValue = typeof v === 'string' && v.startsWith(':');
	            if (copySourceValue) {
	                var /** @type {?} */ sourceName = v.substring(1);
	                res[k] = actualParams[sourceName];
	            }
	            else {
	                res[k] = v;
	            }
	        });
	        return res;
	    };
	    /**
	     * @param {?} redirectTo
	     * @param {?} group
	     * @param {?} segments
	     * @param {?} posParams
	     * @return {?}
	     */
	    ApplyRedirects.prototype.createSegmentGroup = function (redirectTo, group, segments, posParams) {
	        var _this = this;
	        var /** @type {?} */ updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);
	        var /** @type {?} */ children = {};
	        forEach(group.children, function (child, name) {
	            children[name] = _this.createSegmentGroup(redirectTo, child, segments, posParams);
	        });
	        return new UrlSegmentGroup(updatedSegments, children);
	    };
	    /**
	     * @param {?} redirectTo
	     * @param {?} redirectToSegments
	     * @param {?} actualSegments
	     * @param {?} posParams
	     * @return {?}
	     */
	    ApplyRedirects.prototype.createSegments = function (redirectTo, redirectToSegments, actualSegments, posParams) {
	        var _this = this;
	        return redirectToSegments.map(function (s) { return s.path.startsWith(':') ? _this.findPosParam(redirectTo, s, posParams) :
	            _this.findOrReturn(s, actualSegments); });
	    };
	    /**
	     * @param {?} redirectTo
	     * @param {?} redirectToUrlSegment
	     * @param {?} posParams
	     * @return {?}
	     */
	    ApplyRedirects.prototype.findPosParam = function (redirectTo, redirectToUrlSegment, posParams) {
	        var /** @type {?} */ pos = posParams[redirectToUrlSegment.path.substring(1)];
	        if (!pos)
	            throw new Error("Cannot redirect to '" + redirectTo + "'. Cannot find '" + redirectToUrlSegment.path + "'.");
	        return pos;
	    };
	    /**
	     * @param {?} redirectToUrlSegment
	     * @param {?} actualSegments
	     * @return {?}
	     */
	    ApplyRedirects.prototype.findOrReturn = function (redirectToUrlSegment, actualSegments) {
	        var /** @type {?} */ idx = 0;
	        for (var _i = 0, actualSegments_1 = actualSegments; _i < actualSegments_1.length; _i++) {
	            var s = actualSegments_1[_i];
	            if (s.path === redirectToUrlSegment.path) {
	                actualSegments.splice(idx);
	                return s;
	            }
	            idx++;
	        }
	        return redirectToUrlSegment;
	    };
	    return ApplyRedirects;
	}());
	/**
	 * @param {?} moduleInjector
	 * @param {?} route
	 * @return {?}
	 */
	function runCanLoadGuard(moduleInjector, route) {
	    var /** @type {?} */ canLoad = route.canLoad;
	    if (!canLoad || canLoad.length === 0)
	        return rxjs_observable_of.of(true);
	    var /** @type {?} */ obs = rxjs_operator_map.map.call(rxjs_observable_from.from(canLoad), function (injectionToken) {
	        var /** @type {?} */ guard = moduleInjector.get(injectionToken);
	        return wrapIntoObservable(guard.canLoad ? guard.canLoad(route) : guard(route));
	    });
	    return andObservables(obs);
	}
	/**
	 * @param {?} segmentGroup
	 * @param {?} route
	 * @param {?} segments
	 * @return {?}
	 */
	function match(segmentGroup, route, segments) {
	    if (route.path === '') {
	        if ((route.pathMatch === 'full') && (segmentGroup.hasChildren() || segments.length > 0)) {
	            return { matched: false, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };
	        }
	        return { matched: true, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };
	    }
	    var /** @type {?} */ matcher = route.matcher || defaultUrlMatcher;
	    var /** @type {?} */ res = matcher(segments, segmentGroup, route);
	    if (!res) {
	        return {
	            matched: false, consumedSegments: /** @type {?} */ ([]), lastChild: 0, positionalParamSegments: {},
	        };
	    }
	    return {
	        matched: true,
	        consumedSegments: /** @type {?} */ ((res.consumed)),
	        lastChild: /** @type {?} */ ((res.consumed.length)),
	        positionalParamSegments: /** @type {?} */ ((res.posParams)),
	    };
	}
	/**
	 * @param {?} segmentGroup
	 * @param {?} consumedSegments
	 * @param {?} slicedSegments
	 * @param {?} config
	 * @return {?}
	 */
	function split(segmentGroup, consumedSegments, slicedSegments, config) {
	    if (slicedSegments.length > 0 &&
	        containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, config)) {
	        var /** @type {?} */ s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptySegments(config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));
	        return { segmentGroup: mergeTrivialChildren(s), slicedSegments: [] };
	    }
	    if (slicedSegments.length === 0 &&
	        containsEmptyPathRedirects(segmentGroup, slicedSegments, config)) {
	        var /** @type {?} */ s = new UrlSegmentGroup(segmentGroup.segments, addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));
	        return { segmentGroup: mergeTrivialChildren(s), slicedSegments: slicedSegments };
	    }
	    return { segmentGroup: segmentGroup, slicedSegments: slicedSegments };
	}
	/**
	 * @param {?} s
	 * @return {?}
	 */
	function mergeTrivialChildren(s) {
	    if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {
	        var /** @type {?} */ c = s.children[PRIMARY_OUTLET];
	        return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);
	    }
	    return s;
	}
	/**
	 * @param {?} segmentGroup
	 * @param {?} slicedSegments
	 * @param {?} routes
	 * @param {?} children
	 * @return {?}
	 */
	function addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {
	    var /** @type {?} */ res = {};
	    for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {
	        var r = routes_1[_i];
	        if (isEmptyPathRedirect(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {
	            res[getOutlet(r)] = new UrlSegmentGroup([], {});
	        }
	    }
	    return Object.assign({}, children, res);
	}
	/**
	 * @param {?} routes
	 * @param {?} primarySegmentGroup
	 * @return {?}
	 */
	function createChildrenForEmptySegments(routes, primarySegmentGroup) {
	    var /** @type {?} */ res = {};
	    res[PRIMARY_OUTLET] = primarySegmentGroup;
	    for (var _i = 0, routes_2 = routes; _i < routes_2.length; _i++) {
	        var r = routes_2[_i];
	        if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {
	            res[getOutlet(r)] = new UrlSegmentGroup([], {});
	        }
	    }
	    return res;
	}
	/**
	 * @param {?} segmentGroup
	 * @param {?} segments
	 * @param {?} routes
	 * @return {?}
	 */
	function containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, segments, routes) {
	    return routes.some(function (r) { return isEmptyPathRedirect(segmentGroup, segments, r) && getOutlet(r) !== PRIMARY_OUTLET; });
	}
	/**
	 * @param {?} segmentGroup
	 * @param {?} segments
	 * @param {?} routes
	 * @return {?}
	 */
	function containsEmptyPathRedirects(segmentGroup, segments, routes) {
	    return routes.some(function (r) { return isEmptyPathRedirect(segmentGroup, segments, r); });
	}
	/**
	 * @param {?} segmentGroup
	 * @param {?} segments
	 * @param {?} r
	 * @return {?}
	 */
	function isEmptyPathRedirect(segmentGroup, segments, r) {
	    if ((segmentGroup.hasChildren() || segments.length > 0) && r.pathMatch === 'full') {
	        return false;
	    }
	    return r.path === '' && r.redirectTo !== undefined;
	}
	/**
	 * @param {?} route
	 * @return {?}
	 */
	function getOutlet(route) {
	    return route.outlet || PRIMARY_OUTLET;
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var Tree = (function () {
	    /**
	     * @param {?} root
	     */
	    function Tree(root) {
	        this._root = root;
	    }
	    Object.defineProperty(Tree.prototype, "root", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._root.value; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * \@internal
	     * @param {?} t
	     * @return {?}
	     */
	    Tree.prototype.parent = function (t) {
	        var /** @type {?} */ p = this.pathFromRoot(t);
	        return p.length > 1 ? p[p.length - 2] : null;
	    };
	    /**
	     * \@internal
	     * @param {?} t
	     * @return {?}
	     */
	    Tree.prototype.children = function (t) {
	        var /** @type {?} */ n = findNode(t, this._root);
	        return n ? n.children.map(function (t) { return t.value; }) : [];
	    };
	    /**
	     * \@internal
	     * @param {?} t
	     * @return {?}
	     */
	    Tree.prototype.firstChild = function (t) {
	        var /** @type {?} */ n = findNode(t, this._root);
	        return n && n.children.length > 0 ? n.children[0].value : null;
	    };
	    /**
	     * \@internal
	     * @param {?} t
	     * @return {?}
	     */
	    Tree.prototype.siblings = function (t) {
	        var /** @type {?} */ p = findPath(t, this._root);
	        if (p.length < 2)
	            return [];
	        var /** @type {?} */ c = p[p.length - 2].children.map(function (c) { return c.value; });
	        return c.filter(function (cc) { return cc !== t; });
	    };
	    /**
	     * \@internal
	     * @param {?} t
	     * @return {?}
	     */
	    Tree.prototype.pathFromRoot = function (t) { return findPath(t, this._root).map(function (s) { return s.value; }); };
	    return Tree;
	}());
	/**
	 * @template T
	 * @param {?} value
	 * @param {?} node
	 * @return {?}
	 */
	function findNode(value, node) {
	    if (value === node.value)
	        return node;
	    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
	        var child = _a[_i];
	        var /** @type {?} */ node_1 = findNode(value, child);
	        if (node_1)
	            return node_1;
	    }
	    return null;
	}
	/**
	 * @template T
	 * @param {?} value
	 * @param {?} node
	 * @return {?}
	 */
	function findPath(value, node) {
	    if (value === node.value)
	        return [node];
	    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
	        var child = _a[_i];
	        var /** @type {?} */ path = findPath(value, child);
	        if (path.length) {
	            path.unshift(node);
	            return path;
	        }
	    }
	    return [];
	}
	var TreeNode = (function () {
	    /**
	     * @param {?} value
	     * @param {?} children
	     */
	    function TreeNode(value, children) {
	        this.value = value;
	        this.children = children;
	    }
	    /**
	     * @return {?}
	     */
	    TreeNode.prototype.toString = function () { return "TreeNode(" + this.value + ")"; };
	    return TreeNode;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@whatItDoes Represents the state of the router.
	 *
	 * \@howToUse
	 *
	 * ```
	 * \@Component({templateUrl:'template.html'})
	 * class MyComponent {
	 *   constructor(router: Router) {
	 *     const state: RouterState = router.routerState;
	 *     const root: ActivatedRoute = state.root;
	 *     const child = root.firstChild;
	 *     const id: Observable<string> = child.params.map(p => p.id);
	 *     //...
	 *   }
	 * }
	 * ```
	 *
	 * \@description
	 * RouterState is a tree of activated routes. Every node in this tree knows about the "consumed" URL
	 * segments, the extracted parameters, and the resolved data.
	 *
	 * See {\@link ActivatedRoute} for more information.
	 *
	 * \@stable
	 */
	var RouterState = (function (_super) {
	    __extends(RouterState, _super);
	    /**
	     * \@internal
	     * @param {?} root
	     * @param {?} snapshot
	     */
	    function RouterState(root, snapshot) {
	        var _this = _super.call(this, root) || this;
	        _this.snapshot = snapshot;
	        setRouterState(_this, root);
	        return _this;
	    }
	    /**
	     * @return {?}
	     */
	    RouterState.prototype.toString = function () { return this.snapshot.toString(); };
	    return RouterState;
	}(Tree));
	/**
	 * @param {?} urlTree
	 * @param {?} rootComponent
	 * @return {?}
	 */
	function createEmptyState(urlTree, rootComponent) {
	    var /** @type {?} */ snapshot = createEmptyStateSnapshot(urlTree, rootComponent);
	    var /** @type {?} */ emptyUrl = new rxjs_BehaviorSubject.BehaviorSubject([new UrlSegment('', {})]);
	    var /** @type {?} */ emptyParams = new rxjs_BehaviorSubject.BehaviorSubject({});
	    var /** @type {?} */ emptyData = new rxjs_BehaviorSubject.BehaviorSubject({});
	    var /** @type {?} */ emptyQueryParams = new rxjs_BehaviorSubject.BehaviorSubject({});
	    var /** @type {?} */ fragment = new rxjs_BehaviorSubject.BehaviorSubject('');
	    var /** @type {?} */ activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);
	    activated.snapshot = snapshot.root;
	    return new RouterState(new TreeNode(activated, []), snapshot);
	}
	/**
	 * @param {?} urlTree
	 * @param {?} rootComponent
	 * @return {?}
	 */
	function createEmptyStateSnapshot(urlTree, rootComponent) {
	    var /** @type {?} */ emptyParams = {};
	    var /** @type {?} */ emptyData = {};
	    var /** @type {?} */ emptyQueryParams = {};
	    var /** @type {?} */ fragment = '';
	    var /** @type {?} */ activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, urlTree.root, -1, {});
	    return new RouterStateSnapshot('', new TreeNode(activated, []));
	}
	/**
	 * \@whatItDoes Contains the information about a route associated with a component loaded in an
	 * outlet.
	 * An `ActivatedRoute` can also be used to traverse the router state tree.
	 *
	 * \@howToUse
	 *
	 * ```
	 * \@Component({...})
	 * class MyComponent {
	 *   constructor(route: ActivatedRoute) {
	 *     const id: Observable<string> = route.params.map(p => p.id);
	 *     const url: Observable<string> = route.url.map(segments => segments.join(''));
	 *     // route.data includes both `data` and `resolve`
	 *     const user = route.data.map(d => d.user);
	 *   }
	 * }
	 * ```
	 *
	 * \@stable
	 */
	var ActivatedRoute = (function () {
	    /**
	     * \@internal
	     * @param {?} url
	     * @param {?} params
	     * @param {?} queryParams
	     * @param {?} fragment
	     * @param {?} data
	     * @param {?} outlet
	     * @param {?} component
	     * @param {?} futureSnapshot
	     */
	    function ActivatedRoute(url, params, queryParams, fragment, data, outlet, component, futureSnapshot) {
	        this.url = url;
	        this.params = params;
	        this.queryParams = queryParams;
	        this.fragment = fragment;
	        this.data = data;
	        this.outlet = outlet;
	        this.component = component;
	        this._futureSnapshot = futureSnapshot;
	    }
	    Object.defineProperty(ActivatedRoute.prototype, "routeConfig", {
	        /**
	         * The configuration used to match this route
	         * @return {?}
	         */
	        get: function () { return this._futureSnapshot.routeConfig; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ActivatedRoute.prototype, "root", {
	        /**
	         * The root of the router state
	         * @return {?}
	         */
	        get: function () { return this._routerState.root; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ActivatedRoute.prototype, "parent", {
	        /**
	         * The parent of this route in the router state tree
	         * @return {?}
	         */
	        get: function () { return this._routerState.parent(this); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ActivatedRoute.prototype, "firstChild", {
	        /**
	         * The first child of this route in the router state tree
	         * @return {?}
	         */
	        get: function () { return this._routerState.firstChild(this); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ActivatedRoute.prototype, "children", {
	        /**
	         * The children of this route in the router state tree
	         * @return {?}
	         */
	        get: function () { return this._routerState.children(this); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ActivatedRoute.prototype, "pathFromRoot", {
	        /**
	         * The path from the root of the router state tree to this route
	         * @return {?}
	         */
	        get: function () { return this._routerState.pathFromRoot(this); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ActivatedRoute.prototype, "paramMap", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            if (!this._paramMap) {
	                this._paramMap = rxjs_operator_map.map.call(this.params, function (p) { return convertToParamMap(p); });
	            }
	            return this._paramMap;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ActivatedRoute.prototype, "queryParamMap", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            if (!this._queryParamMap) {
	                this._queryParamMap =
	                    rxjs_operator_map.map.call(this.queryParams, function (p) { return convertToParamMap(p); });
	            }
	            return this._queryParamMap;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @return {?}
	     */
	    ActivatedRoute.prototype.toString = function () {
	        return this.snapshot ? this.snapshot.toString() : "Future(" + this._futureSnapshot + ")";
	    };
	    return ActivatedRoute;
	}());
	/**
	 * \@internal
	 * @param {?} route
	 * @return {?}
	 */
	function inheritedParamsDataResolve(route) {
	    var /** @type {?} */ pathToRoot = route.pathFromRoot;
	    var /** @type {?} */ inhertingStartingFrom = pathToRoot.length - 1;
	    while (inhertingStartingFrom >= 1) {
	        var /** @type {?} */ current = pathToRoot[inhertingStartingFrom];
	        var /** @type {?} */ parent = pathToRoot[inhertingStartingFrom - 1];
	        // current route is an empty path => inherits its parent's params and data
	        if (current.routeConfig && current.routeConfig.path === '') {
	            inhertingStartingFrom--;
	            // parent is componentless => current route should inherit its params and data
	        }
	        else if (!parent.component) {
	            inhertingStartingFrom--;
	        }
	        else {
	            break;
	        }
	    }
	    return pathToRoot.slice(inhertingStartingFrom).reduce(function (res, curr) {
	        var /** @type {?} */ params = Object.assign({}, res.params, curr.params);
	        var /** @type {?} */ data = Object.assign({}, res.data, curr.data);
	        var /** @type {?} */ resolve = Object.assign({}, res.resolve, curr._resolvedData);
	        return { params: params, data: data, resolve: resolve };
	    }, /** @type {?} */ ({ params: {}, data: {}, resolve: {} }));
	}
	/**
	 * \@whatItDoes Contains the information about a route associated with a component loaded in an
	 * outlet
	 * at a particular moment in time. ActivatedRouteSnapshot can also be used to traverse the router
	 * state tree.
	 *
	 * \@howToUse
	 *
	 * ```
	 * \@Component({templateUrl:'./my-component.html'})
	 * class MyComponent {
	 *   constructor(route: ActivatedRoute) {
	 *     const id: string = route.snapshot.params.id;
	 *     const url: string = route.snapshot.url.join('');
	 *     const user = route.snapshot.data.user;
	 *   }
	 * }
	 * ```
	 *
	 * \@stable
	 */
	var ActivatedRouteSnapshot = (function () {
	    /**
	     * \@internal
	     * @param {?} url
	     * @param {?} params
	     * @param {?} queryParams
	     * @param {?} fragment
	     * @param {?} data
	     * @param {?} outlet
	     * @param {?} component
	     * @param {?} routeConfig
	     * @param {?} urlSegment
	     * @param {?} lastPathIndex
	     * @param {?} resolve
	     */
	    function ActivatedRouteSnapshot(url, params, queryParams, fragment, data, outlet, component, routeConfig, urlSegment, lastPathIndex, resolve) {
	        this.url = url;
	        this.params = params;
	        this.queryParams = queryParams;
	        this.fragment = fragment;
	        this.data = data;
	        this.outlet = outlet;
	        this.component = component;
	        this._routeConfig = routeConfig;
	        this._urlSegment = urlSegment;
	        this._lastPathIndex = lastPathIndex;
	        this._resolve = resolve;
	    }
	    Object.defineProperty(ActivatedRouteSnapshot.prototype, "routeConfig", {
	        /**
	         * The configuration used to match this route
	         * @return {?}
	         */
	        get: function () { return this._routeConfig; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ActivatedRouteSnapshot.prototype, "root", {
	        /**
	         * The root of the router state
	         * @return {?}
	         */
	        get: function () { return this._routerState.root; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ActivatedRouteSnapshot.prototype, "parent", {
	        /**
	         * The parent of this route in the router state tree
	         * @return {?}
	         */
	        get: function () { return this._routerState.parent(this); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ActivatedRouteSnapshot.prototype, "firstChild", {
	        /**
	         * The first child of this route in the router state tree
	         * @return {?}
	         */
	        get: function () { return this._routerState.firstChild(this); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ActivatedRouteSnapshot.prototype, "children", {
	        /**
	         * The children of this route in the router state tree
	         * @return {?}
	         */
	        get: function () { return this._routerState.children(this); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ActivatedRouteSnapshot.prototype, "pathFromRoot", {
	        /**
	         * The path from the root of the router state tree to this route
	         * @return {?}
	         */
	        get: function () { return this._routerState.pathFromRoot(this); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ActivatedRouteSnapshot.prototype, "paramMap", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            if (!this._paramMap) {
	                this._paramMap = convertToParamMap(this.params);
	            }
	            return this._paramMap;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ActivatedRouteSnapshot.prototype, "queryParamMap", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            if (!this._queryParamMap) {
	                this._queryParamMap = convertToParamMap(this.queryParams);
	            }
	            return this._queryParamMap;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @return {?}
	     */
	    ActivatedRouteSnapshot.prototype.toString = function () {
	        var /** @type {?} */ url = this.url.map(function (segment) { return segment.toString(); }).join('/');
	        var /** @type {?} */ matched = this._routeConfig ? this._routeConfig.path : '';
	        return "Route(url:'" + url + "', path:'" + matched + "')";
	    };
	    return ActivatedRouteSnapshot;
	}());
	/**
	 * \@whatItDoes Represents the state of the router at a moment in time.
	 *
	 * \@howToUse
	 *
	 * ```
	 * \@Component({templateUrl:'template.html'})
	 * class MyComponent {
	 *   constructor(router: Router) {
	 *     const state: RouterState = router.routerState;
	 *     const snapshot: RouterStateSnapshot = state.snapshot;
	 *     const root: ActivatedRouteSnapshot = snapshot.root;
	 *     const child = root.firstChild;
	 *     const id: Observable<string> = child.params.map(p => p.id);
	 *     //...
	 *   }
	 * }
	 * ```
	 *
	 * \@description
	 * RouterStateSnapshot is a tree of activated route snapshots. Every node in this tree knows about
	 * the "consumed" URL segments, the extracted parameters, and the resolved data.
	 *
	 * \@stable
	 */
	var RouterStateSnapshot = (function (_super) {
	    __extends(RouterStateSnapshot, _super);
	    /**
	     * \@internal
	     * @param {?} url
	     * @param {?} root
	     */
	    function RouterStateSnapshot(url, root) {
	        var _this = _super.call(this, root) || this;
	        _this.url = url;
	        setRouterState(_this, root);
	        return _this;
	    }
	    /**
	     * @return {?}
	     */
	    RouterStateSnapshot.prototype.toString = function () { return serializeNode(this._root); };
	    return RouterStateSnapshot;
	}(Tree));
	/**
	 * @template U, T
	 * @param {?} state
	 * @param {?} node
	 * @return {?}
	 */
	function setRouterState(state, node) {
	    node.value._routerState = state;
	    node.children.forEach(function (c) { return setRouterState(state, c); });
	}
	/**
	 * @param {?} node
	 * @return {?}
	 */
	function serializeNode(node) {
	    var /** @type {?} */ c = node.children.length > 0 ? " { " + node.children.map(serializeNode).join(", ") + " } " : '';
	    return "" + node.value + c;
	}
	/**
	 * The expectation is that the activate route is created with the right set of parameters.
	 * So we push new values into the observables only when they are not the initial values.
	 * And we detect that by checking if the snapshot field is set.
	 * @param {?} route
	 * @return {?}
	 */
	function advanceActivatedRoute(route) {
	    if (route.snapshot) {
	        var /** @type {?} */ currentSnapshot = route.snapshot;
	        var /** @type {?} */ nextSnapshot = route._futureSnapshot;
	        route.snapshot = nextSnapshot;
	        if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {
	            ((route.queryParams)).next(nextSnapshot.queryParams);
	        }
	        if (currentSnapshot.fragment !== nextSnapshot.fragment) {
	            ((route.fragment)).next(nextSnapshot.fragment);
	        }
	        if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {
	            ((route.params)).next(nextSnapshot.params);
	        }
	        if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {
	            ((route.url)).next(nextSnapshot.url);
	        }
	        if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {
	            ((route.data)).next(nextSnapshot.data);
	        }
	    }
	    else {
	        route.snapshot = route._futureSnapshot;
	        // this is for resolved data
	        ((route.data)).next(route._futureSnapshot.data);
	    }
	}
	/**
	 * @param {?} a
	 * @param {?} b
	 * @return {?}
	 */
	function equalParamsAndUrlSegments(a, b) {
	    var /** @type {?} */ equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);
	    var /** @type {?} */ parentsMismatch = !a.parent !== !b.parent;
	    return equalUrlParams && !parentsMismatch &&
	        (!a.parent || equalParamsAndUrlSegments(a.parent, /** @type {?} */ ((b.parent))));
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} routeReuseStrategy
	 * @param {?} curr
	 * @param {?} prevState
	 * @return {?}
	 */
	function createRouterState(routeReuseStrategy, curr, prevState) {
	    var /** @type {?} */ root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);
	    return new RouterState(root, curr);
	}
	/**
	 * @param {?} routeReuseStrategy
	 * @param {?} curr
	 * @param {?=} prevState
	 * @return {?}
	 */
	function createNode(routeReuseStrategy, curr, prevState) {
	    // reuse an activated route that is currently displayed on the screen
	    if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {
	        var /** @type {?} */ value = prevState.value;
	        value._futureSnapshot = curr.value;
	        var /** @type {?} */ children = createOrReuseChildren(routeReuseStrategy, curr, prevState);
	        return new TreeNode(value, children);
	        // retrieve an activated route that is used to be displayed, but is not currently displayed
	    }
	    else if (routeReuseStrategy.retrieve(curr.value)) {
	        var /** @type {?} */ tree_1 = ((routeReuseStrategy.retrieve(curr.value))).route;
	        setFutureSnapshotsOfActivatedRoutes(curr, tree_1);
	        return tree_1;
	    }
	    else {
	        var /** @type {?} */ value = createActivatedRoute(curr.value);
	        var /** @type {?} */ children = curr.children.map(function (c) { return createNode(routeReuseStrategy, c); });
	        return new TreeNode(value, children);
	    }
	}
	/**
	 * @param {?} curr
	 * @param {?} result
	 * @return {?}
	 */
	function setFutureSnapshotsOfActivatedRoutes(curr, result) {
	    if (curr.value.routeConfig !== result.value.routeConfig) {
	        throw new Error('Cannot reattach ActivatedRouteSnapshot created from a different route');
	    }
	    if (curr.children.length !== result.children.length) {
	        throw new Error('Cannot reattach ActivatedRouteSnapshot with a different number of children');
	    }
	    result.value._futureSnapshot = curr.value;
	    for (var /** @type {?} */ i = 0; i < curr.children.length; ++i) {
	        setFutureSnapshotsOfActivatedRoutes(curr.children[i], result.children[i]);
	    }
	}
	/**
	 * @param {?} routeReuseStrategy
	 * @param {?} curr
	 * @param {?} prevState
	 * @return {?}
	 */
	function createOrReuseChildren(routeReuseStrategy, curr, prevState) {
	    return curr.children.map(function (child) {
	        for (var _i = 0, _a = prevState.children; _i < _a.length; _i++) {
	            var p = _a[_i];
	            if (routeReuseStrategy.shouldReuseRoute(p.value.snapshot, child.value)) {
	                return createNode(routeReuseStrategy, child, p);
	            }
	        }
	        return createNode(routeReuseStrategy, child);
	    });
	}
	/**
	 * @param {?} c
	 * @return {?}
	 */
	function createActivatedRoute(c) {
	    return new ActivatedRoute(new rxjs_BehaviorSubject.BehaviorSubject(c.url), new rxjs_BehaviorSubject.BehaviorSubject(c.params), new rxjs_BehaviorSubject.BehaviorSubject(c.queryParams), new rxjs_BehaviorSubject.BehaviorSubject(c.fragment), new rxjs_BehaviorSubject.BehaviorSubject(c.data), c.outlet, c.component, c);
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} route
	 * @param {?} urlTree
	 * @param {?} commands
	 * @param {?} queryParams
	 * @param {?} fragment
	 * @return {?}
	 */
	function createUrlTree(route, urlTree, commands, queryParams, fragment) {
	    if (commands.length === 0) {
	        return tree(urlTree.root, urlTree.root, urlTree, queryParams, fragment);
	    }
	    var /** @type {?} */ nav = computeNavigation(commands);
	    if (nav.toRoot()) {
	        return tree(urlTree.root, new UrlSegmentGroup([], {}), urlTree, queryParams, fragment);
	    }
	    var /** @type {?} */ startingPosition = findStartingPosition(nav, urlTree, route);
	    var /** @type {?} */ segmentGroup = startingPosition.processChildren ?
	        updateSegmentGroupChildren(startingPosition.segmentGroup, startingPosition.index, nav.commands) :
	        updateSegmentGroup(startingPosition.segmentGroup, startingPosition.index, nav.commands);
	    return tree(startingPosition.segmentGroup, segmentGroup, urlTree, queryParams, fragment);
	}
	/**
	 * @param {?} command
	 * @return {?}
	 */
	function isMatrixParams(command) {
	    return typeof command === 'object' && command != null && !command.outlets && !command.segmentPath;
	}
	/**
	 * @param {?} oldSegmentGroup
	 * @param {?} newSegmentGroup
	 * @param {?} urlTree
	 * @param {?} queryParams
	 * @param {?} fragment
	 * @return {?}
	 */
	function tree(oldSegmentGroup, newSegmentGroup, urlTree, queryParams, fragment) {
	    var /** @type {?} */ qp = {};
	    if (queryParams) {
	        forEach(queryParams, function (value, name) {
	            qp[name] = Array.isArray(value) ? value.map(function (v) { return "" + v; }) : "" + value;
	        });
	    }
	    if (urlTree.root === oldSegmentGroup) {
	        return new UrlTree(newSegmentGroup, qp, fragment);
	    }
	    return new UrlTree(replaceSegment(urlTree.root, oldSegmentGroup, newSegmentGroup), qp, fragment);
	}
	/**
	 * @param {?} current
	 * @param {?} oldSegment
	 * @param {?} newSegment
	 * @return {?}
	 */
	function replaceSegment(current, oldSegment, newSegment) {
	    var /** @type {?} */ children = {};
	    forEach(current.children, function (c, outletName) {
	        if (c === oldSegment) {
	            children[outletName] = newSegment;
	        }
	        else {
	            children[outletName] = replaceSegment(c, oldSegment, newSegment);
	        }
	    });
	    return new UrlSegmentGroup(current.segments, children);
	}
	var Navigation = (function () {
	    /**
	     * @param {?} isAbsolute
	     * @param {?} numberOfDoubleDots
	     * @param {?} commands
	     */
	    function Navigation(isAbsolute, numberOfDoubleDots, commands) {
	        this.isAbsolute = isAbsolute;
	        this.numberOfDoubleDots = numberOfDoubleDots;
	        this.commands = commands;
	        if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {
	            throw new Error('Root segment cannot have matrix parameters');
	        }
	        var cmdWithOutlet = commands.find(function (c) { return typeof c === 'object' && c != null && c.outlets; });
	        if (cmdWithOutlet && cmdWithOutlet !== last$1(commands)) {
	            throw new Error('{outlets:{}} has to be the last command');
	        }
	    }
	    /**
	     * @return {?}
	     */
	    Navigation.prototype.toRoot = function () {
	        return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';
	    };
	    return Navigation;
	}());
	/**
	 * Transforms commands to a normalized `Navigation`
	 * @param {?} commands
	 * @return {?}
	 */
	function computeNavigation(commands) {
	    if ((typeof commands[0] === 'string') && commands.length === 1 && commands[0] === '/') {
	        return new Navigation(true, 0, commands);
	    }
	    var /** @type {?} */ numberOfDoubleDots = 0;
	    var /** @type {?} */ isAbsolute = false;
	    var /** @type {?} */ res = commands.reduce(function (res, cmd, cmdIdx) {
	        if (typeof cmd === 'object' && cmd != null) {
	            if (cmd.outlets) {
	                var /** @type {?} */ outlets_1 = {};
	                forEach(cmd.outlets, function (commands, name) {
	                    outlets_1[name] = typeof commands === 'string' ? commands.split('/') : commands;
	                });
	                return res.concat([{ outlets: outlets_1 }]);
	            }
	            if (cmd.segmentPath) {
	                return res.concat([cmd.segmentPath]);
	            }
	        }
	        if (!(typeof cmd === 'string')) {
	            return res.concat([cmd]);
	        }
	        if (cmdIdx === 0) {
	            cmd.split('/').forEach(function (urlPart, partIndex) {
	                if (partIndex == 0 && urlPart === '.') {
	                    // skip './a'
	                }
	                else if (partIndex == 0 && urlPart === '') {
	                    isAbsolute = true;
	                }
	                else if (urlPart === '..') {
	                    numberOfDoubleDots++;
	                }
	                else if (urlPart != '') {
	                    res.push(urlPart);
	                }
	            });
	            return res;
	        }
	        return res.concat([cmd]);
	    }, []);
	    return new Navigation(isAbsolute, numberOfDoubleDots, res);
	}
	var Position = (function () {
	    /**
	     * @param {?} segmentGroup
	     * @param {?} processChildren
	     * @param {?} index
	     */
	    function Position(segmentGroup, processChildren, index) {
	        this.segmentGroup = segmentGroup;
	        this.processChildren = processChildren;
	        this.index = index;
	    }
	    return Position;
	}());
	/**
	 * @param {?} nav
	 * @param {?} tree
	 * @param {?} route
	 * @return {?}
	 */
	function findStartingPosition(nav, tree, route) {
	    if (nav.isAbsolute) {
	        return new Position(tree.root, true, 0);
	    }
	    if (route.snapshot._lastPathIndex === -1) {
	        return new Position(route.snapshot._urlSegment, true, 0);
	    }
	    var /** @type {?} */ modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;
	    var /** @type {?} */ index = route.snapshot._lastPathIndex + modifier;
	    return createPositionApplyingDoubleDots(route.snapshot._urlSegment, index, nav.numberOfDoubleDots);
	}
	/**
	 * @param {?} group
	 * @param {?} index
	 * @param {?} numberOfDoubleDots
	 * @return {?}
	 */
	function createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {
	    var /** @type {?} */ g = group;
	    var /** @type {?} */ ci = index;
	    var /** @type {?} */ dd = numberOfDoubleDots;
	    while (dd > ci) {
	        dd -= ci;
	        g = ((g.parent));
	        if (!g) {
	            throw new Error('Invalid number of \'../\'');
	        }
	        ci = g.segments.length;
	    }
	    return new Position(g, false, ci - dd);
	}
	/**
	 * @param {?} command
	 * @return {?}
	 */
	function getPath(command) {
	    if (typeof command === 'object' && command != null && command.outlets) {
	        return command.outlets[PRIMARY_OUTLET];
	    }
	    return "" + command;
	}
	/**
	 * @param {?} commands
	 * @return {?}
	 */
	function getOutlets(commands) {
	    if (!(typeof commands[0] === 'object'))
	        return _a = {}, _a[PRIMARY_OUTLET] = commands, _a;
	    if (commands[0].outlets === undefined)
	        return _b = {}, _b[PRIMARY_OUTLET] = commands, _b;
	    return commands[0].outlets;
	    var _a, _b;
	}
	/**
	 * @param {?} segmentGroup
	 * @param {?} startIndex
	 * @param {?} commands
	 * @return {?}
	 */
	function updateSegmentGroup(segmentGroup, startIndex, commands) {
	    if (!segmentGroup) {
	        segmentGroup = new UrlSegmentGroup([], {});
	    }
	    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
	        return updateSegmentGroupChildren(segmentGroup, startIndex, commands);
	    }
	    var /** @type {?} */ m = prefixedWith(segmentGroup, startIndex, commands);
	    var /** @type {?} */ slicedCommands = commands.slice(m.commandIndex);
	    if (m.match && m.pathIndex < segmentGroup.segments.length) {
	        var /** @type {?} */ g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});
	        g.children[PRIMARY_OUTLET] =
	            new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);
	        return updateSegmentGroupChildren(g, 0, slicedCommands);
	    }
	    else if (m.match && slicedCommands.length === 0) {
	        return new UrlSegmentGroup(segmentGroup.segments, {});
	    }
	    else if (m.match && !segmentGroup.hasChildren()) {
	        return createNewSegmentGroup(segmentGroup, startIndex, commands);
	    }
	    else if (m.match) {
	        return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);
	    }
	    else {
	        return createNewSegmentGroup(segmentGroup, startIndex, commands);
	    }
	}
	/**
	 * @param {?} segmentGroup
	 * @param {?} startIndex
	 * @param {?} commands
	 * @return {?}
	 */
	function updateSegmentGroupChildren(segmentGroup, startIndex, commands) {
	    if (commands.length === 0) {
	        return new UrlSegmentGroup(segmentGroup.segments, {});
	    }
	    else {
	        var /** @type {?} */ outlets_2 = getOutlets(commands);
	        var /** @type {?} */ children_2 = {};
	        forEach(outlets_2, function (commands, outlet) {
	            if (commands !== null) {
	                children_2[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);
	            }
	        });
	        forEach(segmentGroup.children, function (child, childOutlet) {
	            if (outlets_2[childOutlet] === undefined) {
	                children_2[childOutlet] = child;
	            }
	        });
	        return new UrlSegmentGroup(segmentGroup.segments, children_2);
	    }
	}
	/**
	 * @param {?} segmentGroup
	 * @param {?} startIndex
	 * @param {?} commands
	 * @return {?}
	 */
	function prefixedWith(segmentGroup, startIndex, commands) {
	    var /** @type {?} */ currentCommandIndex = 0;
	    var /** @type {?} */ currentPathIndex = startIndex;
	    var /** @type {?} */ noMatch = { match: false, pathIndex: 0, commandIndex: 0 };
	    while (currentPathIndex < segmentGroup.segments.length) {
	        if (currentCommandIndex >= commands.length)
	            return noMatch;
	        var /** @type {?} */ path = segmentGroup.segments[currentPathIndex];
	        var /** @type {?} */ curr = getPath(commands[currentCommandIndex]);
	        var /** @type {?} */ next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;
	        if (currentPathIndex > 0 && curr === undefined)
	            break;
	        if (curr && next && (typeof next === 'object') && next.outlets === undefined) {
	            if (!compare(curr, next, path))
	                return noMatch;
	            currentCommandIndex += 2;
	        }
	        else {
	            if (!compare(curr, {}, path))
	                return noMatch;
	            currentCommandIndex++;
	        }
	        currentPathIndex++;
	    }
	    return { match: true, pathIndex: currentPathIndex, commandIndex: currentCommandIndex };
	}
	/**
	 * @param {?} segmentGroup
	 * @param {?} startIndex
	 * @param {?} commands
	 * @return {?}
	 */
	function createNewSegmentGroup(segmentGroup, startIndex, commands) {
	    var /** @type {?} */ paths = segmentGroup.segments.slice(0, startIndex);
	    var /** @type {?} */ i = 0;
	    while (i < commands.length) {
	        if (typeof commands[i] === 'object' && commands[i].outlets !== undefined) {
	            var /** @type {?} */ children = createNewSegmentChildren(commands[i].outlets);
	            return new UrlSegmentGroup(paths, children);
	        }
	        // if we start with an object literal, we need to reuse the path part from the segment
	        if (i === 0 && isMatrixParams(commands[0])) {
	            var /** @type {?} */ p = segmentGroup.segments[startIndex];
	            paths.push(new UrlSegment(p.path, commands[0]));
	            i++;
	            continue;
	        }
	        var /** @type {?} */ curr = getPath(commands[i]);
	        var /** @type {?} */ next = (i < commands.length - 1) ? commands[i + 1] : null;
	        if (curr && next && isMatrixParams(next)) {
	            paths.push(new UrlSegment(curr, stringify(next)));
	            i += 2;
	        }
	        else {
	            paths.push(new UrlSegment(curr, {}));
	            i++;
	        }
	    }
	    return new UrlSegmentGroup(paths, {});
	}
	/**
	 * @param {?} outlets
	 * @return {?}
	 */
	function createNewSegmentChildren(outlets) {
	    var /** @type {?} */ children = {};
	    forEach(outlets, function (commands, outlet) {
	        if (commands !== null) {
	            children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);
	        }
	    });
	    return children;
	}
	/**
	 * @param {?} params
	 * @return {?}
	 */
	function stringify(params) {
	    var /** @type {?} */ res = {};
	    forEach(params, function (v, k) { return res[k] = "" + v; });
	    return res;
	}
	/**
	 * @param {?} path
	 * @param {?} params
	 * @param {?} segment
	 * @return {?}
	 */
	function compare(path, params, segment) {
	    return path == segment.path && shallowEqual(params, segment.parameters);
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var NoMatch$1 = (function () {
	    function NoMatch$1() {
	    }
	    return NoMatch$1;
	}());
	/**
	 * @param {?} rootComponentType
	 * @param {?} config
	 * @param {?} urlTree
	 * @param {?} url
	 * @return {?}
	 */
	function recognize(rootComponentType, config, urlTree, url) {
	    return new Recognizer(rootComponentType, config, urlTree, url).recognize();
	}
	var Recognizer = (function () {
	    /**
	     * @param {?} rootComponentType
	     * @param {?} config
	     * @param {?} urlTree
	     * @param {?} url
	     */
	    function Recognizer(rootComponentType, config, urlTree, url) {
	        this.rootComponentType = rootComponentType;
	        this.config = config;
	        this.urlTree = urlTree;
	        this.url = url;
	    }
	    /**
	     * @return {?}
	     */
	    Recognizer.prototype.recognize = function () {
	        try {
	            var /** @type {?} */ rootSegmentGroup = split$1(this.urlTree.root, [], [], this.config).segmentGroup;
	            var /** @type {?} */ children = this.processSegmentGroup(this.config, rootSegmentGroup, PRIMARY_OUTLET);
	            var /** @type {?} */ root = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze(this.urlTree.queryParams), /** @type {?} */ ((this.urlTree.fragment)), {}, PRIMARY_OUTLET, this.rootComponentType, null, this.urlTree.root, -1, {});
	            var /** @type {?} */ rootNode = new TreeNode(root, children);
	            var /** @type {?} */ routeState = new RouterStateSnapshot(this.url, rootNode);
	            this.inheritParamsAndData(routeState._root);
	            return rxjs_observable_of.of(routeState);
	        }
	        catch (e) {
	            return new rxjs_Observable.Observable(function (obs) { return obs.error(e); });
	        }
	    };
	    /**
	     * @param {?} routeNode
	     * @return {?}
	     */
	    Recognizer.prototype.inheritParamsAndData = function (routeNode) {
	        var _this = this;
	        var /** @type {?} */ route = routeNode.value;
	        var /** @type {?} */ i = inheritedParamsDataResolve(route);
	        route.params = Object.freeze(i.params);
	        route.data = Object.freeze(i.data);
	        routeNode.children.forEach(function (n) { return _this.inheritParamsAndData(n); });
	    };
	    /**
	     * @param {?} config
	     * @param {?} segmentGroup
	     * @param {?} outlet
	     * @return {?}
	     */
	    Recognizer.prototype.processSegmentGroup = function (config, segmentGroup, outlet) {
	        if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
	            return this.processChildren(config, segmentGroup);
	        }
	        return this.processSegment(config, segmentGroup, segmentGroup.segments, outlet);
	    };
	    /**
	     * @param {?} config
	     * @param {?} segmentGroup
	     * @return {?}
	     */
	    Recognizer.prototype.processChildren = function (config, segmentGroup) {
	        var _this = this;
	        var /** @type {?} */ children = mapChildrenIntoArray(segmentGroup, function (child, childOutlet) { return _this.processSegmentGroup(config, child, childOutlet); });
	        checkOutletNameUniqueness(children);
	        sortActivatedRouteSnapshots(children);
	        return children;
	    };
	    /**
	     * @param {?} config
	     * @param {?} segmentGroup
	     * @param {?} segments
	     * @param {?} outlet
	     * @return {?}
	     */
	    Recognizer.prototype.processSegment = function (config, segmentGroup, segments, outlet) {
	        for (var _i = 0, config_1 = config; _i < config_1.length; _i++) {
	            var r = config_1[_i];
	            try {
	                return this.processSegmentAgainstRoute(r, segmentGroup, segments, outlet);
	            }
	            catch (e) {
	                if (!(e instanceof NoMatch$1))
	                    throw e;
	            }
	        }
	        if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {
	            return [];
	        }
	        throw new NoMatch$1();
	    };
	    /**
	     * @param {?} segmentGroup
	     * @param {?} segments
	     * @param {?} outlet
	     * @return {?}
	     */
	    Recognizer.prototype.noLeftoversInUrl = function (segmentGroup, segments, outlet) {
	        return segments.length === 0 && !segmentGroup.children[outlet];
	    };
	    /**
	     * @param {?} route
	     * @param {?} rawSegment
	     * @param {?} segments
	     * @param {?} outlet
	     * @return {?}
	     */
	    Recognizer.prototype.processSegmentAgainstRoute = function (route, rawSegment, segments, outlet) {
	        if (route.redirectTo)
	            throw new NoMatch$1();
	        if ((route.outlet || PRIMARY_OUTLET) !== outlet)
	            throw new NoMatch$1();
	        if (route.path === '**') {
	            var /** @type {?} */ params = segments.length > 0 ? ((last$1(segments))).parameters : {};
	            var /** @type {?} */ snapshot_1 = new ActivatedRouteSnapshot(segments, params, Object.freeze(this.urlTree.queryParams), /** @type {?} */ ((this.urlTree.fragment)), getData(route), outlet, /** @type {?} */ ((route.component)), route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + segments.length, getResolve(route));
	            return [new TreeNode(snapshot_1, [])];
	        }
	        var _a = match$1(rawSegment, route, segments), consumedSegments = _a.consumedSegments, parameters = _a.parameters, lastChild = _a.lastChild;
	        var /** @type {?} */ rawSlicedSegments = segments.slice(lastChild);
	        var /** @type {?} */ childConfig = getChildConfig(route);
	        var _b = split$1(rawSegment, consumedSegments, rawSlicedSegments, childConfig), segmentGroup = _b.segmentGroup, slicedSegments = _b.slicedSegments;
	        var /** @type {?} */ snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze(this.urlTree.queryParams), /** @type {?} */ ((this.urlTree.fragment)), getData(route), outlet, /** @type {?} */ ((route.component)), route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + consumedSegments.length, getResolve(route));
	        if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {
	            var /** @type {?} */ children_3 = this.processChildren(childConfig, segmentGroup);
	            return [new TreeNode(snapshot, children_3)];
	        }
	        if (childConfig.length === 0 && slicedSegments.length === 0) {
	            return [new TreeNode(snapshot, [])];
	        }
	        var /** @type {?} */ children = this.processSegment(childConfig, segmentGroup, slicedSegments, PRIMARY_OUTLET);
	        return [new TreeNode(snapshot, children)];
	    };
	    return Recognizer;
	}());
	/**
	 * @param {?} nodes
	 * @return {?}
	 */
	function sortActivatedRouteSnapshots(nodes) {
	    nodes.sort(function (a, b) {
	        if (a.value.outlet === PRIMARY_OUTLET)
	            return -1;
	        if (b.value.outlet === PRIMARY_OUTLET)
	            return 1;
	        return a.value.outlet.localeCompare(b.value.outlet);
	    });
	}
	/**
	 * @param {?} route
	 * @return {?}
	 */
	function getChildConfig(route) {
	    if (route.children) {
	        return route.children;
	    }
	    if (route.loadChildren) {
	        return ((route._loadedConfig)).routes;
	    }
	    return [];
	}
	/**
	 * @param {?} segmentGroup
	 * @param {?} route
	 * @param {?} segments
	 * @return {?}
	 */
	function match$1(segmentGroup, route, segments) {
	    if (route.path === '') {
	        if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {
	            throw new NoMatch$1();
	        }
	        return { consumedSegments: [], lastChild: 0, parameters: {} };
	    }
	    var /** @type {?} */ matcher = route.matcher || defaultUrlMatcher;
	    var /** @type {?} */ res = matcher(segments, segmentGroup, route);
	    if (!res)
	        throw new NoMatch$1();
	    var /** @type {?} */ posParams = {};
	    forEach(/** @type {?} */ ((res.posParams)), function (v, k) { posParams[k] = v.path; });
	    var /** @type {?} */ parameters = res.consumed.length > 0 ? Object.assign({}, posParams, res.consumed[res.consumed.length - 1].parameters) :
	        posParams;
	    return { consumedSegments: res.consumed, lastChild: res.consumed.length, parameters: parameters };
	}
	/**
	 * @param {?} nodes
	 * @return {?}
	 */
	function checkOutletNameUniqueness(nodes) {
	    var /** @type {?} */ names = {};
	    nodes.forEach(function (n) {
	        var /** @type {?} */ routeWithSameOutletName = names[n.value.outlet];
	        if (routeWithSameOutletName) {
	            var /** @type {?} */ p = routeWithSameOutletName.url.map(function (s) { return s.toString(); }).join('/');
	            var /** @type {?} */ c = n.value.url.map(function (s) { return s.toString(); }).join('/');
	            throw new Error("Two segments cannot have the same outlet name: '" + p + "' and '" + c + "'.");
	        }
	        names[n.value.outlet] = n.value;
	    });
	}
	/**
	 * @param {?} segmentGroup
	 * @return {?}
	 */
	function getSourceSegmentGroup(segmentGroup) {
	    var /** @type {?} */ s = segmentGroup;
	    while (s._sourceSegment) {
	        s = s._sourceSegment;
	    }
	    return s;
	}
	/**
	 * @param {?} segmentGroup
	 * @return {?}
	 */
	function getPathIndexShift(segmentGroup) {
	    var /** @type {?} */ s = segmentGroup;
	    var /** @type {?} */ res = (s._segmentIndexShift ? s._segmentIndexShift : 0);
	    while (s._sourceSegment) {
	        s = s._sourceSegment;
	        res += (s._segmentIndexShift ? s._segmentIndexShift : 0);
	    }
	    return res - 1;
	}
	/**
	 * @param {?} segmentGroup
	 * @param {?} consumedSegments
	 * @param {?} slicedSegments
	 * @param {?} config
	 * @return {?}
	 */
	function split$1(segmentGroup, consumedSegments, slicedSegments, config) {
	    if (slicedSegments.length > 0 &&
	        containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {
	        var /** @type {?} */ s_1 = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(segmentGroup, consumedSegments, config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));
	        s_1._sourceSegment = segmentGroup;
	        s_1._segmentIndexShift = consumedSegments.length;
	        return { segmentGroup: s_1, slicedSegments: [] };
	    }
	    if (slicedSegments.length === 0 &&
	        containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {
	        var /** @type {?} */ s_2 = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));
	        s_2._sourceSegment = segmentGroup;
	        s_2._segmentIndexShift = consumedSegments.length;
	        return { segmentGroup: s_2, slicedSegments: slicedSegments };
	    }
	    var /** @type {?} */ s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);
	    s._sourceSegment = segmentGroup;
	    s._segmentIndexShift = consumedSegments.length;
	    return { segmentGroup: s, slicedSegments: slicedSegments };
	}
	/**
	 * @param {?} segmentGroup
	 * @param {?} slicedSegments
	 * @param {?} routes
	 * @param {?} children
	 * @return {?}
	 */
	function addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {
	    var /** @type {?} */ res = {};
	    for (var _i = 0, routes_3 = routes; _i < routes_3.length; _i++) {
	        var r = routes_3[_i];
	        if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet$1(r)]) {
	            var /** @type {?} */ s = new UrlSegmentGroup([], {});
	            s._sourceSegment = segmentGroup;
	            s._segmentIndexShift = segmentGroup.segments.length;
	            res[getOutlet$1(r)] = s;
	        }
	    }
	    return Object.assign({}, children, res);
	}
	/**
	 * @param {?} segmentGroup
	 * @param {?} consumedSegments
	 * @param {?} routes
	 * @param {?} primarySegment
	 * @return {?}
	 */
	function createChildrenForEmptyPaths(segmentGroup, consumedSegments, routes, primarySegment) {
	    var /** @type {?} */ res = {};
	    res[PRIMARY_OUTLET] = primarySegment;
	    primarySegment._sourceSegment = segmentGroup;
	    primarySegment._segmentIndexShift = consumedSegments.length;
	    for (var _i = 0, routes_4 = routes; _i < routes_4.length; _i++) {
	        var r = routes_4[_i];
	        if (r.path === '' && getOutlet$1(r) !== PRIMARY_OUTLET) {
	            var /** @type {?} */ s = new UrlSegmentGroup([], {});
	            s._sourceSegment = segmentGroup;
	            s._segmentIndexShift = consumedSegments.length;
	            res[getOutlet$1(r)] = s;
	        }
	    }
	    return res;
	}
	/**
	 * @param {?} segmentGroup
	 * @param {?} slicedSegments
	 * @param {?} routes
	 * @return {?}
	 */
	function containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {
	    return routes.some(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet$1(r) !== PRIMARY_OUTLET; });
	}
	/**
	 * @param {?} segmentGroup
	 * @param {?} slicedSegments
	 * @param {?} routes
	 * @return {?}
	 */
	function containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {
	    return routes.some(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r); });
	}
	/**
	 * @param {?} segmentGroup
	 * @param {?} slicedSegments
	 * @param {?} r
	 * @return {?}
	 */
	function emptyPathMatch(segmentGroup, slicedSegments, r) {
	    if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full') {
	        return false;
	    }
	    return r.path === '' && r.redirectTo === undefined;
	}
	/**
	 * @param {?} route
	 * @return {?}
	 */
	function getOutlet$1(route) {
	    return route.outlet || PRIMARY_OUTLET;
	}
	/**
	 * @param {?} route
	 * @return {?}
	 */
	function getData(route) {
	    return route.data || {};
	}
	/**
	 * @param {?} route
	 * @return {?}
	 */
	function getResolve(route) {
	    return route.resolve || {};
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@whatItDoes Provides a way to customize when activated routes get reused.
	 *
	 * \@experimental
	 * @abstract
	 */
	var RouteReuseStrategy = (function () {
	    function RouteReuseStrategy() {
	    }
	    /**
	     * Determines if this route (and its subtree) should be detached to be reused later
	     * @abstract
	     * @param {?} route
	     * @return {?}
	     */
	    RouteReuseStrategy.prototype.shouldDetach = function (route) { };
	    /**
	     * Stores the detached route.
	     *
	     * Storing a `null` value should erase the previously stored value.
	     * @abstract
	     * @param {?} route
	     * @param {?} handle
	     * @return {?}
	     */
	    RouteReuseStrategy.prototype.store = function (route, handle) { };
	    /**
	     * Determines if this route (and its subtree) should be reattached
	     * @abstract
	     * @param {?} route
	     * @return {?}
	     */
	    RouteReuseStrategy.prototype.shouldAttach = function (route) { };
	    /**
	     * Retrieves the previously stored route
	     * @abstract
	     * @param {?} route
	     * @return {?}
	     */
	    RouteReuseStrategy.prototype.retrieve = function (route) { };
	    /**
	     * Determines if a route should be reused
	     * @abstract
	     * @param {?} future
	     * @param {?} curr
	     * @return {?}
	     */
	    RouteReuseStrategy.prototype.shouldReuseRoute = function (future, curr) { };
	    return RouteReuseStrategy;
	}());
	/**
	 * Does not detach any subtrees. Reuses routes as long as their route config is the same.
	 */
	var DefaultRouteReuseStrategy = (function () {
	    function DefaultRouteReuseStrategy() {
	    }
	    /**
	     * @param {?} route
	     * @return {?}
	     */
	    DefaultRouteReuseStrategy.prototype.shouldDetach = function (route) { return false; };
	    /**
	     * @param {?} route
	     * @param {?} detachedTree
	     * @return {?}
	     */
	    DefaultRouteReuseStrategy.prototype.store = function (route, detachedTree) { };
	    /**
	     * @param {?} route
	     * @return {?}
	     */
	    DefaultRouteReuseStrategy.prototype.shouldAttach = function (route) { return false; };
	    /**
	     * @param {?} route
	     * @return {?}
	     */
	    DefaultRouteReuseStrategy.prototype.retrieve = function (route) { return null; };
	    /**
	     * @param {?} future
	     * @param {?} curr
	     * @return {?}
	     */
	    DefaultRouteReuseStrategy.prototype.shouldReuseRoute = function (future, curr) {
	        return future.routeConfig === curr.routeConfig;
	    };
	    return DefaultRouteReuseStrategy;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@docsNotRequired
	 * \@experimental
	 */
	var ROUTES = new _angular_core.InjectionToken('ROUTES');
	var RouterConfigLoader = (function () {
	    /**
	     * @param {?} loader
	     * @param {?} compiler
	     * @param {?=} onLoadStartListener
	     * @param {?=} onLoadEndListener
	     */
	    function RouterConfigLoader(loader, compiler, onLoadStartListener, onLoadEndListener) {
	        this.loader = loader;
	        this.compiler = compiler;
	        this.onLoadStartListener = onLoadStartListener;
	        this.onLoadEndListener = onLoadEndListener;
	    }
	    /**
	     * @param {?} parentInjector
	     * @param {?} route
	     * @return {?}
	     */
	    RouterConfigLoader.prototype.load = function (parentInjector, route) {
	        var _this = this;
	        if (this.onLoadStartListener) {
	            this.onLoadStartListener(route);
	        }
	        var /** @type {?} */ moduleFactory$ = this.loadModuleFactory(/** @type {?} */ ((route.loadChildren)));
	        return rxjs_operator_map.map.call(moduleFactory$, function (factory) {
	            if (_this.onLoadEndListener) {
	                _this.onLoadEndListener(route);
	            }
	            var /** @type {?} */ module = factory.create(parentInjector);
	            return new LoadedRouterConfig(flatten(module.injector.get(ROUTES)), module);
	        });
	    };
	    /**
	     * @param {?} loadChildren
	     * @return {?}
	     */
	    RouterConfigLoader.prototype.loadModuleFactory = function (loadChildren) {
	        var _this = this;
	        if (typeof loadChildren === 'string') {
	            return rxjs_observable_fromPromise.fromPromise(this.loader.load(loadChildren));
	        }
	        else {
	            return rxjs_operator_mergeMap.mergeMap.call(wrapIntoObservable(loadChildren()), function (t) {
	                if (t instanceof _angular_core.NgModuleFactory) {
	                    return rxjs_observable_of.of(t);
	                }
	                else {
	                    return rxjs_observable_fromPromise.fromPromise(_this.compiler.compileModuleAsync(t));
	                }
	            });
	        }
	    };
	    return RouterConfigLoader;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@whatItDoes Provides a way to migrate AngularJS applications to Angular.
	 *
	 * \@experimental
	 * @abstract
	 */
	var UrlHandlingStrategy = (function () {
	    function UrlHandlingStrategy() {
	    }
	    /**
	     * Tells the router if this URL should be processed.
	     *
	     * When it returns true, the router will execute the regular navigation.
	     * When it returns false, the router will set the router state to an empty state.
	     * As a result, all the active components will be destroyed.
	     *
	     * @abstract
	     * @param {?} url
	     * @return {?}
	     */
	    UrlHandlingStrategy.prototype.shouldProcessUrl = function (url) { };
	    /**
	     * Extracts the part of the URL that should be handled by the router.
	     * The rest of the URL will remain untouched.
	     * @abstract
	     * @param {?} url
	     * @return {?}
	     */
	    UrlHandlingStrategy.prototype.extract = function (url) { };
	    /**
	     * Merges the URL fragment with the rest of the URL.
	     * @abstract
	     * @param {?} newUrlPart
	     * @param {?} rawUrl
	     * @return {?}
	     */
	    UrlHandlingStrategy.prototype.merge = function (newUrlPart, rawUrl) { };
	    return UrlHandlingStrategy;
	}());
	/**
	 * \@experimental
	 */
	var DefaultUrlHandlingStrategy = (function () {
	    function DefaultUrlHandlingStrategy() {
	    }
	    /**
	     * @param {?} url
	     * @return {?}
	     */
	    DefaultUrlHandlingStrategy.prototype.shouldProcessUrl = function (url) { return true; };
	    /**
	     * @param {?} url
	     * @return {?}
	     */
	    DefaultUrlHandlingStrategy.prototype.extract = function (url) { return url; };
	    /**
	     * @param {?} newUrlPart
	     * @param {?} wholeUrl
	     * @return {?}
	     */
	    DefaultUrlHandlingStrategy.prototype.merge = function (newUrlPart, wholeUrl) { return newUrlPart; };
	    return DefaultUrlHandlingStrategy;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} error
	 * @return {?}
	 */
	function defaultErrorHandler(error) {
	    throw error;
	}
	/**
	 * \@internal
	 * @param {?} snapshot
	 * @return {?}
	 */
	function defaultRouterHook(snapshot) {
	    return (rxjs_observable_of.of(null));
	}
	/**
	 * \@whatItDoes Provides the navigation and url manipulation capabilities.
	 *
	 * See {\@link Routes} for more details and examples.
	 *
	 * \@ngModule RouterModule
	 *
	 * \@stable
	 */
	var Router = (function () {
	    /**
	     * @param {?} rootComponentType
	     * @param {?} urlSerializer
	     * @param {?} rootContexts
	     * @param {?} location
	     * @param {?} injector
	     * @param {?} loader
	     * @param {?} compiler
	     * @param {?} config
	     */
	    function Router(rootComponentType, urlSerializer, rootContexts, location, injector, loader, compiler, config) {
	        var _this = this;
	        this.rootComponentType = rootComponentType;
	        this.urlSerializer = urlSerializer;
	        this.rootContexts = rootContexts;
	        this.location = location;
	        this.config = config;
	        this.navigations = new rxjs_BehaviorSubject.BehaviorSubject(/** @type {?} */ ((null)));
	        this.routerEvents = new rxjs_Subject.Subject();
	        this.navigationId = 0;
	        /**
	         * Error handler that is invoked when a navigation errors.
	         *
	         * See {\@link ErrorHandler} for more information.
	         */
	        this.errorHandler = defaultErrorHandler;
	        /**
	         * Indicates if at least one navigation happened.
	         */
	        this.navigated = false;
	        /**
	         * Used by RouterModule. This allows us to
	         * pause the navigation either before preactivation or after it.
	         * \@internal
	         */
	        this.hooks = {
	            beforePreactivation: defaultRouterHook,
	            afterPreactivation: defaultRouterHook
	        };
	        /**
	         * Extracts and merges URLs. Used for AngularJS to Angular migrations.
	         */
	        this.urlHandlingStrategy = new DefaultUrlHandlingStrategy();
	        this.routeReuseStrategy = new DefaultRouteReuseStrategy();
	        var onLoadStart = function (r) { return _this.triggerEvent(new RouteConfigLoadStart(r)); };
	        var onLoadEnd = function (r) { return _this.triggerEvent(new RouteConfigLoadEnd(r)); };
	        this.ngModule = injector.get(_angular_core.NgModuleRef);
	        this.resetConfig(config);
	        this.currentUrlTree = createEmptyUrlTree();
	        this.rawUrlTree = this.currentUrlTree;
	        this.configLoader = new RouterConfigLoader(loader, compiler, onLoadStart, onLoadEnd);
	        this.currentRouterState = createEmptyState(this.currentUrlTree, this.rootComponentType);
	        this.processNavigations();
	    }
	    /**
	     * \@internal
	     * TODO: this should be removed once the constructor of the router made internal
	     * @param {?} rootComponentType
	     * @return {?}
	     */
	    Router.prototype.resetRootComponentType = function (rootComponentType) {
	        this.rootComponentType = rootComponentType;
	        // TODO: vsavkin router 4.0 should make the root component set to null
	        // this will simplify the lifecycle of the router.
	        this.currentRouterState.root.component = this.rootComponentType;
	    };
	    /**
	     * Sets up the location change listener and performs the initial navigation.
	     * @return {?}
	     */
	    Router.prototype.initialNavigation = function () {
	        this.setUpLocationChangeListener();
	        if (this.navigationId === 0) {
	            this.navigateByUrl(this.location.path(true), { replaceUrl: true });
	        }
	    };
	    /**
	     * Sets up the location change listener.
	     * @return {?}
	     */
	    Router.prototype.setUpLocationChangeListener = function () {
	        var _this = this;
	        // Zone.current.wrap is needed because of the issue with RxJS scheduler,
	        // which does not work properly with zone.js in IE and Safari
	        if (!this.locationSubscription) {
	            this.locationSubscription = (this.location.subscribe(Zone.current.wrap(function (change) {
	                var /** @type {?} */ rawUrlTree = _this.urlSerializer.parse(change['url']);
	                var /** @type {?} */ source = change['type'] === 'popstate' ? 'popstate' : 'hashchange';
	                setTimeout(function () { _this.scheduleNavigation(rawUrlTree, source, { replaceUrl: true }); }, 0);
	            })));
	        }
	    };
	    Object.defineProperty(Router.prototype, "routerState", {
	        /**
	         * The current route state
	         * @return {?}
	         */
	        get: function () { return this.currentRouterState; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Router.prototype, "url", {
	        /**
	         * The current url
	         * @return {?}
	         */
	        get: function () { return this.serializeUrl(this.currentUrlTree); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Router.prototype, "events", {
	        /**
	         * An observable of router events
	         * @return {?}
	         */
	        get: function () { return this.routerEvents; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * \@internal
	     * @param {?} e
	     * @return {?}
	     */
	    Router.prototype.triggerEvent = function (e) { this.routerEvents.next(e); };
	    /**
	     * Resets the configuration used for navigation and generating links.
	     *
	     * ### Usage
	     *
	     * ```
	     * router.resetConfig([
	     *  { path: 'team/:id', component: TeamCmp, children: [
	     *    { path: 'simple', component: SimpleCmp },
	     *    { path: 'user/:name', component: UserCmp }
	     *  ]}
	     * ]);
	     * ```
	     * @param {?} config
	     * @return {?}
	     */
	    Router.prototype.resetConfig = function (config) {
	        validateConfig(config);
	        this.config = config;
	        this.navigated = false;
	    };
	    /**
	     * \@docsNotRequired
	     * @return {?}
	     */
	    Router.prototype.ngOnDestroy = function () { this.dispose(); };
	    /**
	     * Disposes of the router
	     * @return {?}
	     */
	    Router.prototype.dispose = function () {
	        if (this.locationSubscription) {
	            this.locationSubscription.unsubscribe();
	            this.locationSubscription = ((null));
	        }
	    };
	    /**
	     * Applies an array of commands to the current url tree and creates a new url tree.
	     *
	     * When given an activate route, applies the given commands starting from the route.
	     * When not given a route, applies the given command starting from the root.
	     *
	     * ### Usage
	     *
	     * ```
	     * // create /team/33/user/11
	     * router.createUrlTree(['/team', 33, 'user', 11]);
	     *
	     * // create /team/33;expand=true/user/11
	     * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);
	     *
	     * // you can collapse static segments like this (this works only with the first passed-in value):
	     * router.createUrlTree(['/team/33/user', userId]);
	     *
	     * // If the first segment can contain slashes, and you do not want the router to split it, you
	     * // can do the following:
	     *
	     * router.createUrlTree([{segmentPath: '/one/two'}]);
	     *
	     * // create /team/33/(user/11//right:chat)
	     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);
	     *
	     * // remove the right secondary node
	     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);
	     *
	     * // assuming the current url is `/team/33/user/11` and the route points to `user/11`
	     *
	     * // navigate to /team/33/user/11/details
	     * router.createUrlTree(['details'], {relativeTo: route});
	     *
	     * // navigate to /team/33/user/22
	     * router.createUrlTree(['../22'], {relativeTo: route});
	     *
	     * // navigate to /team/44/user/22
	     * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});
	     * ```
	     * @param {?} commands
	     * @param {?=} navigationExtras
	     * @return {?}
	     */
	    Router.prototype.createUrlTree = function (commands, navigationExtras) {
	        if (navigationExtras === void 0) { navigationExtras = {}; }
	        var relativeTo = navigationExtras.relativeTo, queryParams = navigationExtras.queryParams, fragment = navigationExtras.fragment, preserveQueryParams = navigationExtras.preserveQueryParams, queryParamsHandling = navigationExtras.queryParamsHandling, preserveFragment = navigationExtras.preserveFragment;
	        if (_angular_core.isDevMode() && preserveQueryParams && (console) && (console.warn)) {
	            console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');
	        }
	        var /** @type {?} */ a = relativeTo || this.routerState.root;
	        var /** @type {?} */ f = preserveFragment ? this.currentUrlTree.fragment : fragment;
	        var /** @type {?} */ q = null;
	        if (queryParamsHandling) {
	            switch (queryParamsHandling) {
	                case 'merge':
	                    q = Object.assign({}, this.currentUrlTree.queryParams, queryParams);
	                    break;
	                case 'preserve':
	                    q = this.currentUrlTree.queryParams;
	                    break;
	                default:
	                    q = queryParams || null;
	            }
	        }
	        else {
	            q = preserveQueryParams ? this.currentUrlTree.queryParams : queryParams || null;
	        }
	        return createUrlTree(a, this.currentUrlTree, commands, /** @type {?} */ ((q)), /** @type {?} */ ((f)));
	    };
	    /**
	     * Navigate based on the provided url. This navigation is always absolute.
	     *
	     * Returns a promise that:
	     * - resolves to 'true' when navigation succeeds,
	     * - resolves to 'false' when navigation fails,
	     * - is rejected when an error happens.
	     *
	     * ### Usage
	     *
	     * ```
	     * router.navigateByUrl("/team/33/user/11");
	     *
	     * // Navigate without updating the URL
	     * router.navigateByUrl("/team/33/user/11", { skipLocationChange: true });
	     * ```
	     *
	     * In opposite to `navigate`, `navigateByUrl` takes a whole URL
	     * and does not apply any delta to the current one.
	     * @param {?} url
	     * @param {?=} extras
	     * @return {?}
	     */
	    Router.prototype.navigateByUrl = function (url, extras) {
	        if (extras === void 0) { extras = { skipLocationChange: false }; }
	        var /** @type {?} */ urlTree = url instanceof UrlTree ? url : this.parseUrl(url);
	        var /** @type {?} */ mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);
	        return this.scheduleNavigation(mergedTree, 'imperative', extras);
	    };
	    /**
	     * Navigate based on the provided array of commands and a starting point.
	     * If no starting route is provided, the navigation is absolute.
	     *
	     * Returns a promise that:
	     * - resolves to 'true' when navigation succeeds,
	     * - resolves to 'false' when navigation fails,
	     * - is rejected when an error happens.
	     *
	     * ### Usage
	     *
	     * ```
	     * router.navigate(['team', 33, 'user', 11], {relativeTo: route});
	     *
	     * // Navigate without updating the URL
	     * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});
	     * ```
	     *
	     * In opposite to `navigateByUrl`, `navigate` always takes a delta that is applied to the current
	     * URL.
	     * @param {?} commands
	     * @param {?=} extras
	     * @return {?}
	     */
	    Router.prototype.navigate = function (commands, extras) {
	        if (extras === void 0) { extras = { skipLocationChange: false }; }
	        validateCommands(commands);
	        if (typeof extras.queryParams === 'object' && extras.queryParams !== null) {
	            extras.queryParams = this.removeEmptyProps(extras.queryParams);
	        }
	        return this.navigateByUrl(this.createUrlTree(commands, extras), extras);
	    };
	    /**
	     * Serializes a {\@link UrlTree} into a string
	     * @param {?} url
	     * @return {?}
	     */
	    Router.prototype.serializeUrl = function (url) { return this.urlSerializer.serialize(url); };
	    /**
	     * Parses a string into a {\@link UrlTree}
	     * @param {?} url
	     * @return {?}
	     */
	    Router.prototype.parseUrl = function (url) { return this.urlSerializer.parse(url); };
	    /**
	     * Returns whether the url is activated
	     * @param {?} url
	     * @param {?} exact
	     * @return {?}
	     */
	    Router.prototype.isActive = function (url, exact) {
	        if (url instanceof UrlTree) {
	            return containsTree(this.currentUrlTree, url, exact);
	        }
	        var /** @type {?} */ urlTree = this.urlSerializer.parse(url);
	        return containsTree(this.currentUrlTree, urlTree, exact);
	    };
	    /**
	     * @param {?} params
	     * @return {?}
	     */
	    Router.prototype.removeEmptyProps = function (params) {
	        return Object.keys(params).reduce(function (result, key) {
	            var /** @type {?} */ value = params[key];
	            if (value !== null && value !== undefined) {
	                result[key] = value;
	            }
	            return result;
	        }, {});
	    };
	    /**
	     * @return {?}
	     */
	    Router.prototype.processNavigations = function () {
	        var _this = this;
	        rxjs_operator_concatMap.concatMap
	            .call(this.navigations, function (nav) {
	            if (nav) {
	                _this.executeScheduledNavigation(nav);
	                // a failed navigation should not stop the router from processing
	                // further navigations => the catch
	                return nav.promise.catch(function () { });
	            }
	            else {
	                return (rxjs_observable_of.of(null));
	            }
	        })
	            .subscribe(function () { });
	    };
	    /**
	     * @param {?} rawUrl
	     * @param {?} source
	     * @param {?} extras
	     * @return {?}
	     */
	    Router.prototype.scheduleNavigation = function (rawUrl, source, extras) {
	        var /** @type {?} */ lastNavigation = this.navigations.value;
	        // If the user triggers a navigation imperatively (e.g., by using navigateByUrl),
	        // and that navigation results in 'replaceState' that leads to the same URL,
	        // we should skip those.
	        if (lastNavigation && source !== 'imperative' && lastNavigation.source === 'imperative' &&
	            lastNavigation.rawUrl.toString() === rawUrl.toString()) {
	            return Promise.resolve(true); // return value is not used
	        }
	        // Because of a bug in IE and Edge, the location class fires two events (popstate and
	        // hashchange) every single time. The second one should be ignored. Otherwise, the URL will
	        // flicker.
	        if (lastNavigation && source == 'hashchange' && lastNavigation.source === 'popstate' &&
	            lastNavigation.rawUrl.toString() === rawUrl.toString()) {
	            return Promise.resolve(true); // return value is not used
	        }
	        var /** @type {?} */ resolve = null;
	        var /** @type {?} */ reject = null;
	        var /** @type {?} */ promise = new Promise(function (res, rej) {
	            resolve = res;
	            reject = rej;
	        });
	        var /** @type {?} */ id = ++this.navigationId;
	        this.navigations.next({ id: id, source: source, rawUrl: rawUrl, extras: extras, resolve: resolve, reject: reject, promise: promise });
	        // Make sure that the error is propagated even though `processNavigations` catch
	        // handler does not rethrow
	        return promise.catch(function (e) { return Promise.reject(e); });
	    };
	    /**
	     * @param {?} __0
	     * @return {?}
	     */
	    Router.prototype.executeScheduledNavigation = function (_a) {
	        var _this = this;
	        var id = _a.id, rawUrl = _a.rawUrl, extras = _a.extras, resolve = _a.resolve, reject = _a.reject;
	        var /** @type {?} */ url = this.urlHandlingStrategy.extract(rawUrl);
	        var /** @type {?} */ urlTransition = !this.navigated || url.toString() !== this.currentUrlTree.toString();
	        if (urlTransition && this.urlHandlingStrategy.shouldProcessUrl(rawUrl)) {
	            this.routerEvents.next(new NavigationStart(id, this.serializeUrl(url)));
	            Promise.resolve()
	                .then(function (_) { return _this.runNavigate(url, rawUrl, !!extras.skipLocationChange, !!extras.replaceUrl, id, null); })
	                .then(resolve, reject);
	            // we cannot process the current URL, but we could process the previous one =>
	            // we need to do some cleanup
	        }
	        else if (urlTransition && this.rawUrlTree &&
	            this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) {
	            this.routerEvents.next(new NavigationStart(id, this.serializeUrl(url)));
	            Promise.resolve()
	                .then(function (_) { return _this.runNavigate(url, rawUrl, false, false, id, createEmptyState(url, _this.rootComponentType).snapshot); })
	                .then(resolve, reject);
	        }
	        else {
	            this.rawUrlTree = rawUrl;
	            resolve(null);
	        }
	    };
	    /**
	     * @param {?} url
	     * @param {?} rawUrl
	     * @param {?} shouldPreventPushState
	     * @param {?} shouldReplaceUrl
	     * @param {?} id
	     * @param {?} precreatedState
	     * @return {?}
	     */
	    Router.prototype.runNavigate = function (url, rawUrl, shouldPreventPushState, shouldReplaceUrl, id, precreatedState) {
	        var _this = this;
	        if (id !== this.navigationId) {
	            this.location.go(this.urlSerializer.serialize(this.currentUrlTree));
	            this.routerEvents.next(new NavigationCancel(id, this.serializeUrl(url), "Navigation ID " + id + " is not equal to the current navigation id " + this.navigationId));
	            return Promise.resolve(false);
	        }
	        return new Promise(function (resolvePromise, rejectPromise) {
	            // create an observable of the url and route state snapshot
	            // this operation do not result in any side effects
	            var /** @type {?} */ urlAndSnapshot$;
	            if (!precreatedState) {
	                var /** @type {?} */ moduleInjector = _this.ngModule.injector;
	                var /** @type {?} */ redirectsApplied$ = applyRedirects(moduleInjector, _this.configLoader, _this.urlSerializer, url, _this.config);
	                urlAndSnapshot$ = rxjs_operator_mergeMap.mergeMap.call(redirectsApplied$, function (appliedUrl) {
	                    return rxjs_operator_map.map.call(recognize(_this.rootComponentType, _this.config, appliedUrl, _this.serializeUrl(appliedUrl)), function (snapshot) {
	                        _this.routerEvents.next(new RoutesRecognized(id, _this.serializeUrl(url), _this.serializeUrl(appliedUrl), snapshot));
	                        return { appliedUrl: appliedUrl, snapshot: snapshot };
	                    });
	                });
	            }
	            else {
	                urlAndSnapshot$ = rxjs_observable_of.of({ appliedUrl: url, snapshot: precreatedState });
	            }
	            var /** @type {?} */ beforePreactivationDone$ = rxjs_operator_mergeMap.mergeMap.call(urlAndSnapshot$, function (p) {
	                return rxjs_operator_map.map.call(_this.hooks.beforePreactivation(p.snapshot), function () { return p; });
	            });
	            // run preactivation: guards and data resolvers
	            var /** @type {?} */ preActivation;
	            var /** @type {?} */ preactivationTraverse$ = rxjs_operator_map.map.call(beforePreactivationDone$, function (_a) {
	                var appliedUrl = _a.appliedUrl, snapshot = _a.snapshot;
	                var /** @type {?} */ moduleInjector = _this.ngModule.injector;
	                preActivation =
	                    new PreActivation(snapshot, _this.currentRouterState.snapshot, moduleInjector);
	                preActivation.traverse(_this.rootContexts);
	                return { appliedUrl: appliedUrl, snapshot: snapshot };
	            });
	            var /** @type {?} */ preactivationCheckGuards$ = rxjs_operator_mergeMap.mergeMap.call(preactivationTraverse$, function (_a) {
	                var appliedUrl = _a.appliedUrl, snapshot = _a.snapshot;
	                if (_this.navigationId !== id)
	                    return rxjs_observable_of.of(false);
	                _this.triggerEvent(new GuardsCheckStart(id, _this.serializeUrl(url), appliedUrl, snapshot));
	                return rxjs_operator_map.map.call(preActivation.checkGuards(), function (shouldActivate) {
	                    _this.triggerEvent(new GuardsCheckEnd(id, _this.serializeUrl(url), appliedUrl, snapshot, shouldActivate));
	                    return { appliedUrl: appliedUrl, snapshot: snapshot, shouldActivate: shouldActivate };
	                });
	            });
	            var /** @type {?} */ preactivationResolveData$ = rxjs_operator_mergeMap.mergeMap.call(preactivationCheckGuards$, function (p) {
	                if (_this.navigationId !== id)
	                    return rxjs_observable_of.of(false);
	                if (p.shouldActivate && preActivation.isActivating()) {
	                    _this.triggerEvent(new ResolveStart(id, _this.serializeUrl(url), p.appliedUrl, p.snapshot));
	                    return rxjs_operator_map.map.call(preActivation.resolveData(), function () {
	                        _this.triggerEvent(new ResolveEnd(id, _this.serializeUrl(url), p.appliedUrl, p.snapshot));
	                        return p;
	                    });
	                }
	                else {
	                    return rxjs_observable_of.of(p);
	                }
	            });
	            var /** @type {?} */ preactivationDone$ = rxjs_operator_mergeMap.mergeMap.call(preactivationResolveData$, function (p) {
	                return rxjs_operator_map.map.call(_this.hooks.afterPreactivation(p.snapshot), function () { return p; });
	            });
	            // create router state
	            // this operation has side effects => route state is being affected
	            var /** @type {?} */ routerState$ = rxjs_operator_map.map.call(preactivationDone$, function (_a) {
	                var appliedUrl = _a.appliedUrl, snapshot = _a.snapshot, shouldActivate = _a.shouldActivate;
	                if (shouldActivate) {
	                    var /** @type {?} */ state = createRouterState(_this.routeReuseStrategy, snapshot, _this.currentRouterState);
	                    return { appliedUrl: appliedUrl, state: state, shouldActivate: shouldActivate };
	                }
	                else {
	                    return { appliedUrl: appliedUrl, state: null, shouldActivate: shouldActivate };
	                }
	            });
	            // applied the new router state
	            // this operation has side effects
	            var /** @type {?} */ navigationIsSuccessful;
	            var /** @type {?} */ storedState = _this.currentRouterState;
	            var /** @type {?} */ storedUrl = _this.currentUrlTree;
	            routerState$
	                .forEach(function (_a) {
	                var appliedUrl = _a.appliedUrl, state = _a.state, shouldActivate = _a.shouldActivate;
	                if (!shouldActivate || id !== _this.navigationId) {
	                    navigationIsSuccessful = false;
	                    return;
	                }
	                _this.currentUrlTree = appliedUrl;
	                _this.rawUrlTree = _this.urlHandlingStrategy.merge(_this.currentUrlTree, rawUrl);
	                _this.currentRouterState = state;
	                if (!shouldPreventPushState) {
	                    var /** @type {?} */ path = _this.urlSerializer.serialize(_this.rawUrlTree);
	                    if (_this.location.isCurrentPathEqualTo(path) || shouldReplaceUrl) {
	                        _this.location.replaceState(path);
	                    }
	                    else {
	                        _this.location.go(path);
	                    }
	                }
	                new ActivateRoutes(_this.routeReuseStrategy, state, storedState)
	                    .activate(_this.rootContexts);
	                navigationIsSuccessful = true;
	            })
	                .then(function () {
	                if (navigationIsSuccessful) {
	                    _this.navigated = true;
	                    _this.routerEvents.next(new NavigationEnd(id, _this.serializeUrl(url), _this.serializeUrl(_this.currentUrlTree)));
	                    resolvePromise(true);
	                }
	                else {
	                    _this.resetUrlToCurrentUrlTree();
	                    _this.routerEvents.next(new NavigationCancel(id, _this.serializeUrl(url), ''));
	                    resolvePromise(false);
	                }
	            }, function (e) {
	                if (isNavigationCancelingError(e)) {
	                    _this.resetUrlToCurrentUrlTree();
	                    _this.navigated = true;
	                    _this.routerEvents.next(new NavigationCancel(id, _this.serializeUrl(url), e.message));
	                    resolvePromise(false);
	                }
	                else {
	                    _this.routerEvents.next(new NavigationError(id, _this.serializeUrl(url), e));
	                    try {
	                        resolvePromise(_this.errorHandler(e));
	                    }
	                    catch (ee) {
	                        rejectPromise(ee);
	                    }
	                }
	                _this.currentRouterState = storedState;
	                _this.currentUrlTree = storedUrl;
	                _this.rawUrlTree = _this.urlHandlingStrategy.merge(_this.currentUrlTree, rawUrl);
	                _this.location.replaceState(_this.serializeUrl(_this.rawUrlTree));
	            });
	        });
	    };
	    /**
	     * @return {?}
	     */
	    Router.prototype.resetUrlToCurrentUrlTree = function () {
	        var /** @type {?} */ path = this.urlSerializer.serialize(this.rawUrlTree);
	        this.location.replaceState(path);
	    };
	    return Router;
	}());
	var CanActivate = (function () {
	    /**
	     * @param {?} path
	     */
	    function CanActivate(path) {
	        this.path = path;
	    }
	    Object.defineProperty(CanActivate.prototype, "route", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.path[this.path.length - 1]; },
	        enumerable: true,
	        configurable: true
	    });
	    return CanActivate;
	}());
	var CanDeactivate = (function () {
	    /**
	     * @param {?} component
	     * @param {?} route
	     */
	    function CanDeactivate(component, route) {
	        this.component = component;
	        this.route = route;
	    }
	    return CanDeactivate;
	}());
	var PreActivation = (function () {
	    /**
	     * @param {?} future
	     * @param {?} curr
	     * @param {?} moduleInjector
	     */
	    function PreActivation(future, curr, moduleInjector) {
	        this.future = future;
	        this.curr = curr;
	        this.moduleInjector = moduleInjector;
	        this.canActivateChecks = [];
	        this.canDeactivateChecks = [];
	    }
	    /**
	     * @param {?} parentContexts
	     * @return {?}
	     */
	    PreActivation.prototype.traverse = function (parentContexts) {
	        var /** @type {?} */ futureRoot = this.future._root;
	        var /** @type {?} */ currRoot = this.curr ? this.curr._root : null;
	        this.traverseChildRoutes(futureRoot, currRoot, parentContexts, [futureRoot.value]);
	    };
	    /**
	     * @return {?}
	     */
	    PreActivation.prototype.checkGuards = function () {
	        var _this = this;
	        if (!this.isDeactivating() && !this.isActivating()) {
	            return rxjs_observable_of.of(true);
	        }
	        var /** @type {?} */ canDeactivate$ = this.runCanDeactivateChecks();
	        return rxjs_operator_mergeMap.mergeMap.call(canDeactivate$, function (canDeactivate) { return canDeactivate ? _this.runCanActivateChecks() : rxjs_observable_of.of(false); });
	    };
	    /**
	     * @return {?}
	     */
	    PreActivation.prototype.resolveData = function () {
	        var _this = this;
	        if (!this.isActivating())
	            return rxjs_observable_of.of(null);
	        var /** @type {?} */ checks$ = rxjs_observable_from.from(this.canActivateChecks);
	        var /** @type {?} */ runningChecks$ = rxjs_operator_concatMap.concatMap.call(checks$, function (check) { return _this.runResolve(check.route); });
	        return rxjs_operator_reduce.reduce.call(runningChecks$, function (_, __) { return _; });
	    };
	    /**
	     * @return {?}
	     */
	    PreActivation.prototype.isDeactivating = function () { return this.canDeactivateChecks.length !== 0; };
	    /**
	     * @return {?}
	     */
	    PreActivation.prototype.isActivating = function () { return this.canActivateChecks.length !== 0; };
	    /**
	     * @param {?} futureNode
	     * @param {?} currNode
	     * @param {?} contexts
	     * @param {?} futurePath
	     * @return {?}
	     */
	    PreActivation.prototype.traverseChildRoutes = function (futureNode, currNode, contexts, futurePath) {
	        var _this = this;
	        var /** @type {?} */ prevChildren = nodeChildrenAsMap(currNode);
	        // Process the children of the future route
	        futureNode.children.forEach(function (c) {
	            _this.traverseRoutes(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]));
	            delete prevChildren[c.value.outlet];
	        });
	        // Process any children left from the current route (not active for the future route)
	        forEach(prevChildren, function (v, k) { return _this.deactivateRouteAndItsChildren(v, /** @type {?} */ ((contexts)).getContext(k)); });
	    };
	    /**
	     * @param {?} futureNode
	     * @param {?} currNode
	     * @param {?} parentContexts
	     * @param {?} futurePath
	     * @return {?}
	     */
	    PreActivation.prototype.traverseRoutes = function (futureNode, currNode, parentContexts, futurePath) {
	        var /** @type {?} */ future = futureNode.value;
	        var /** @type {?} */ curr = currNode ? currNode.value : null;
	        var /** @type {?} */ context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;
	        // reusing the node
	        if (curr && future._routeConfig === curr._routeConfig) {
	            var /** @type {?} */ shouldRunGuardsAndResolvers = this.shouldRunGuardsAndResolvers(curr, future, /** @type {?} */ ((future._routeConfig)).runGuardsAndResolvers);
	            if (shouldRunGuardsAndResolvers) {
	                this.canActivateChecks.push(new CanActivate(futurePath));
	            }
	            else {
	                // we need to set the data
	                future.data = curr.data;
	                future._resolvedData = curr._resolvedData;
	            }
	            // If we have a component, we need to go through an outlet.
	            if (future.component) {
	                this.traverseChildRoutes(futureNode, currNode, context ? context.children : null, futurePath);
	                // if we have a componentless route, we recurse but keep the same outlet map.
	            }
	            else {
	                this.traverseChildRoutes(futureNode, currNode, parentContexts, futurePath);
	            }
	            if (shouldRunGuardsAndResolvers) {
	                var /** @type {?} */ outlet = ((((context)).outlet));
	                this.canDeactivateChecks.push(new CanDeactivate(outlet.component, curr));
	            }
	        }
	        else {
	            if (curr) {
	                this.deactivateRouteAndItsChildren(currNode, context);
	            }
	            this.canActivateChecks.push(new CanActivate(futurePath));
	            // If we have a component, we need to go through an outlet.
	            if (future.component) {
	                this.traverseChildRoutes(futureNode, null, context ? context.children : null, futurePath);
	                // if we have a componentless route, we recurse but keep the same outlet map.
	            }
	            else {
	                this.traverseChildRoutes(futureNode, null, parentContexts, futurePath);
	            }
	        }
	    };
	    /**
	     * @param {?} curr
	     * @param {?} future
	     * @param {?} mode
	     * @return {?}
	     */
	    PreActivation.prototype.shouldRunGuardsAndResolvers = function (curr, future, mode) {
	        switch (mode) {
	            case 'always':
	                return true;
	            case 'paramsOrQueryParamsChange':
	                return !equalParamsAndUrlSegments(curr, future) ||
	                    !shallowEqual(curr.queryParams, future.queryParams);
	            case 'paramsChange':
	            default:
	                return !equalParamsAndUrlSegments(curr, future);
	        }
	    };
	    /**
	     * @param {?} route
	     * @param {?} context
	     * @return {?}
	     */
	    PreActivation.prototype.deactivateRouteAndItsChildren = function (route, context) {
	        var _this = this;
	        var /** @type {?} */ children = nodeChildrenAsMap(route);
	        var /** @type {?} */ r = route.value;
	        forEach(children, function (node, childName) {
	            if (!r.component) {
	                _this.deactivateRouteAndItsChildren(node, context);
	            }
	            else if (context) {
	                _this.deactivateRouteAndItsChildren(node, context.children.getContext(childName));
	            }
	            else {
	                _this.deactivateRouteAndItsChildren(node, null);
	            }
	        });
	        if (!r.component) {
	            this.canDeactivateChecks.push(new CanDeactivate(null, r));
	        }
	        else if (context && context.outlet && context.outlet.isActivated) {
	            this.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));
	        }
	        else {
	            this.canDeactivateChecks.push(new CanDeactivate(null, r));
	        }
	    };
	    /**
	     * @return {?}
	     */
	    PreActivation.prototype.runCanDeactivateChecks = function () {
	        var _this = this;
	        var /** @type {?} */ checks$ = rxjs_observable_from.from(this.canDeactivateChecks);
	        var /** @type {?} */ runningChecks$ = rxjs_operator_mergeMap.mergeMap.call(checks$, function (check) { return _this.runCanDeactivate(check.component, check.route); });
	        return rxjs_operator_every.every.call(runningChecks$, function (result) { return result === true; });
	    };
	    /**
	     * @return {?}
	     */
	    PreActivation.prototype.runCanActivateChecks = function () {
	        var _this = this;
	        var /** @type {?} */ checks$ = rxjs_observable_from.from(this.canActivateChecks);
	        var /** @type {?} */ runningChecks$ = rxjs_operator_concatMap.concatMap.call(checks$, function (check) { return andObservables(rxjs_observable_from.from([_this.runCanActivateChild(check.path), _this.runCanActivate(check.route)])); });
	        return rxjs_operator_every.every.call(runningChecks$, function (result) { return result === true; });
	    };
	    /**
	     * @param {?} future
	     * @return {?}
	     */
	    PreActivation.prototype.runCanActivate = function (future) {
	        var _this = this;
	        var /** @type {?} */ canActivate = future._routeConfig ? future._routeConfig.canActivate : null;
	        if (!canActivate || canActivate.length === 0)
	            return rxjs_observable_of.of(true);
	        var /** @type {?} */ obs = rxjs_operator_map.map.call(rxjs_observable_from.from(canActivate), function (c) {
	            var /** @type {?} */ guard = _this.getToken(c, future);
	            var /** @type {?} */ observable;
	            if (guard.canActivate) {
	                observable = wrapIntoObservable(guard.canActivate(future, _this.future));
	            }
	            else {
	                observable = wrapIntoObservable(guard(future, _this.future));
	            }
	            return rxjs_operator_first.first.call(observable);
	        });
	        return andObservables(obs);
	    };
	    /**
	     * @param {?} path
	     * @return {?}
	     */
	    PreActivation.prototype.runCanActivateChild = function (path) {
	        var _this = this;
	        var /** @type {?} */ future = path[path.length - 1];
	        var /** @type {?} */ canActivateChildGuards = path.slice(0, path.length - 1)
	            .reverse()
	            .map(function (p) { return _this.extractCanActivateChild(p); })
	            .filter(function (_) { return _ !== null; });
	        return andObservables(rxjs_operator_map.map.call(rxjs_observable_from.from(canActivateChildGuards), function (d) {
	            var /** @type {?} */ obs = rxjs_operator_map.map.call(rxjs_observable_from.from(d.guards), function (c) {
	                var /** @type {?} */ guard = _this.getToken(c, d.node);
	                var /** @type {?} */ observable;
	                if (guard.canActivateChild) {
	                    observable = wrapIntoObservable(guard.canActivateChild(future, _this.future));
	                }
	                else {
	                    observable = wrapIntoObservable(guard(future, _this.future));
	                }
	                return rxjs_operator_first.first.call(observable);
	            });
	            return andObservables(obs);
	        }));
	    };
	    /**
	     * @param {?} p
	     * @return {?}
	     */
	    PreActivation.prototype.extractCanActivateChild = function (p) {
	        var /** @type {?} */ canActivateChild = p._routeConfig ? p._routeConfig.canActivateChild : null;
	        if (!canActivateChild || canActivateChild.length === 0)
	            return null;
	        return { node: p, guards: canActivateChild };
	    };
	    /**
	     * @param {?} component
	     * @param {?} curr
	     * @return {?}
	     */
	    PreActivation.prototype.runCanDeactivate = function (component, curr) {
	        var _this = this;
	        var /** @type {?} */ canDeactivate = curr && curr._routeConfig ? curr._routeConfig.canDeactivate : null;
	        if (!canDeactivate || canDeactivate.length === 0)
	            return rxjs_observable_of.of(true);
	        var /** @type {?} */ canDeactivate$ = rxjs_operator_mergeMap.mergeMap.call(rxjs_observable_from.from(canDeactivate), function (c) {
	            var /** @type {?} */ guard = _this.getToken(c, curr);
	            var /** @type {?} */ observable;
	            if (guard.canDeactivate) {
	                observable =
	                    wrapIntoObservable(guard.canDeactivate(component, curr, _this.curr, _this.future));
	            }
	            else {
	                observable = wrapIntoObservable(guard(component, curr, _this.curr, _this.future));
	            }
	            return rxjs_operator_first.first.call(observable);
	        });
	        return rxjs_operator_every.every.call(canDeactivate$, function (result) { return result === true; });
	    };
	    /**
	     * @param {?} future
	     * @return {?}
	     */
	    PreActivation.prototype.runResolve = function (future) {
	        var /** @type {?} */ resolve = future._resolve;
	        return rxjs_operator_map.map.call(this.resolveNode(resolve, future), function (resolvedData) {
	            future._resolvedData = resolvedData;
	            future.data = Object.assign({}, future.data, inheritedParamsDataResolve(future).resolve);
	            return null;
	        });
	    };
	    /**
	     * @param {?} resolve
	     * @param {?} future
	     * @return {?}
	     */
	    PreActivation.prototype.resolveNode = function (resolve, future) {
	        var _this = this;
	        var /** @type {?} */ keys = Object.keys(resolve);
	        if (keys.length === 0) {
	            return rxjs_observable_of.of({});
	        }
	        if (keys.length === 1) {
	            var /** @type {?} */ key_1 = keys[0];
	            return rxjs_operator_map.map.call(this.getResolver(resolve[key_1], future), function (value) {
	                return _a = {}, _a[key_1] = value, _a;
	                var _a;
	            });
	        }
	        var /** @type {?} */ data = {};
	        var /** @type {?} */ runningResolvers$ = rxjs_operator_mergeMap.mergeMap.call(rxjs_observable_from.from(keys), function (key) {
	            return rxjs_operator_map.map.call(_this.getResolver(resolve[key], future), function (value) {
	                data[key] = value;
	                return value;
	            });
	        });
	        return rxjs_operator_map.map.call(rxjs_operator_last.last.call(runningResolvers$), function () { return data; });
	    };
	    /**
	     * @param {?} injectionToken
	     * @param {?} future
	     * @return {?}
	     */
	    PreActivation.prototype.getResolver = function (injectionToken, future) {
	        var /** @type {?} */ resolver = this.getToken(injectionToken, future);
	        return resolver.resolve ? wrapIntoObservable(resolver.resolve(future, this.future)) :
	            wrapIntoObservable(resolver(future, this.future));
	    };
	    /**
	     * @param {?} token
	     * @param {?} snapshot
	     * @return {?}
	     */
	    PreActivation.prototype.getToken = function (token, snapshot) {
	        var /** @type {?} */ config = closestLoadedConfig(snapshot);
	        var /** @type {?} */ injector = config ? config.module.injector : this.moduleInjector;
	        return injector.get(token);
	    };
	    return PreActivation;
	}());
	var ActivateRoutes = (function () {
	    /**
	     * @param {?} routeReuseStrategy
	     * @param {?} futureState
	     * @param {?} currState
	     */
	    function ActivateRoutes(routeReuseStrategy, futureState, currState) {
	        this.routeReuseStrategy = routeReuseStrategy;
	        this.futureState = futureState;
	        this.currState = currState;
	    }
	    /**
	     * @param {?} parentContexts
	     * @return {?}
	     */
	    ActivateRoutes.prototype.activate = function (parentContexts) {
	        var /** @type {?} */ futureRoot = this.futureState._root;
	        var /** @type {?} */ currRoot = this.currState ? this.currState._root : null;
	        this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);
	        advanceActivatedRoute(this.futureState.root);
	        this.activateChildRoutes(futureRoot, currRoot, parentContexts);
	    };
	    /**
	     * @param {?} futureNode
	     * @param {?} currNode
	     * @param {?} contexts
	     * @return {?}
	     */
	    ActivateRoutes.prototype.deactivateChildRoutes = function (futureNode, currNode, contexts) {
	        var _this = this;
	        var /** @type {?} */ children = nodeChildrenAsMap(currNode);
	        // Recurse on the routes active in the future state to de-activate deeper children
	        futureNode.children.forEach(function (futureChild) {
	            var /** @type {?} */ childOutletName = futureChild.value.outlet;
	            _this.deactivateRoutes(futureChild, children[childOutletName], contexts);
	            delete children[childOutletName];
	        });
	        // De-activate the routes that will not be re-used
	        forEach(children, function (v, childName) {
	            _this.deactivateRouteAndItsChildren(v, contexts);
	        });
	    };
	    /**
	     * @param {?} futureNode
	     * @param {?} currNode
	     * @param {?} parentContext
	     * @return {?}
	     */
	    ActivateRoutes.prototype.deactivateRoutes = function (futureNode, currNode, parentContext) {
	        var /** @type {?} */ future = futureNode.value;
	        var /** @type {?} */ curr = currNode ? currNode.value : null;
	        if (future === curr) {
	            // Reusing the node, check to see if the children need to be de-activated
	            if (future.component) {
	                // If we have a normal route, we need to go through an outlet.
	                var /** @type {?} */ context = parentContext.getContext(future.outlet);
	                if (context) {
	                    this.deactivateChildRoutes(futureNode, currNode, context.children);
	                }
	            }
	            else {
	                // if we have a componentless route, we recurse but keep the same outlet map.
	                this.deactivateChildRoutes(futureNode, currNode, parentContext);
	            }
	        }
	        else {
	            if (curr) {
	                // Deactivate the current route which will not be re-used
	                this.deactivateRouteAndItsChildren(currNode, parentContext);
	            }
	        }
	    };
	    /**
	     * @param {?} route
	     * @param {?} parentContexts
	     * @return {?}
	     */
	    ActivateRoutes.prototype.deactivateRouteAndItsChildren = function (route, parentContexts) {
	        if (this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {
	            this.detachAndStoreRouteSubtree(route, parentContexts);
	        }
	        else {
	            this.deactivateRouteAndOutlet(route, parentContexts);
	        }
	    };
	    /**
	     * @param {?} route
	     * @param {?} parentContexts
	     * @return {?}
	     */
	    ActivateRoutes.prototype.detachAndStoreRouteSubtree = function (route, parentContexts) {
	        var /** @type {?} */ context = parentContexts.getContext(route.value.outlet);
	        if (context && context.outlet) {
	            var /** @type {?} */ componentRef = context.outlet.detach();
	            var /** @type {?} */ contexts = context.children.onOutletDeactivated();
	            this.routeReuseStrategy.store(route.value.snapshot, { componentRef: componentRef, route: route, contexts: contexts });
	        }
	    };
	    /**
	     * @param {?} route
	     * @param {?} parentContexts
	     * @return {?}
	     */
	    ActivateRoutes.prototype.deactivateRouteAndOutlet = function (route, parentContexts) {
	        var _this = this;
	        var /** @type {?} */ context = parentContexts.getContext(route.value.outlet);
	        if (context) {
	            var /** @type {?} */ children = nodeChildrenAsMap(route);
	            var /** @type {?} */ contexts_1 = route.value.component ? context.children : parentContexts;
	            forEach(children, function (v, k) { _this.deactivateRouteAndItsChildren(v, contexts_1); });
	            if (context.outlet) {
	                // Destroy the component
	                context.outlet.deactivate();
	                // Destroy the contexts for all the outlets that were in the component
	                context.children.onOutletDeactivated();
	            }
	        }
	    };
	    /**
	     * @param {?} futureNode
	     * @param {?} currNode
	     * @param {?} contexts
	     * @return {?}
	     */
	    ActivateRoutes.prototype.activateChildRoutes = function (futureNode, currNode, contexts) {
	        var _this = this;
	        var /** @type {?} */ children = nodeChildrenAsMap(currNode);
	        futureNode.children.forEach(function (c) { _this.activateRoutes(c, children[c.value.outlet], contexts); });
	    };
	    /**
	     * @param {?} futureNode
	     * @param {?} currNode
	     * @param {?} parentContexts
	     * @return {?}
	     */
	    ActivateRoutes.prototype.activateRoutes = function (futureNode, currNode, parentContexts) {
	        var /** @type {?} */ future = futureNode.value;
	        var /** @type {?} */ curr = currNode ? currNode.value : null;
	        advanceActivatedRoute(future);
	        // reusing the node
	        if (future === curr) {
	            if (future.component) {
	                // If we have a normal route, we need to go through an outlet.
	                var /** @type {?} */ context = parentContexts.getOrCreateContext(future.outlet);
	                this.activateChildRoutes(futureNode, currNode, context.children);
	            }
	            else {
	                // if we have a componentless route, we recurse but keep the same outlet map.
	                this.activateChildRoutes(futureNode, currNode, parentContexts);
	            }
	        }
	        else {
	            if (future.component) {
	                // if we have a normal route, we need to place the component into the outlet and recurse.
	                var /** @type {?} */ context = parentContexts.getOrCreateContext(future.outlet);
	                if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {
	                    var /** @type {?} */ stored = ((this.routeReuseStrategy.retrieve(future.snapshot)));
	                    this.routeReuseStrategy.store(future.snapshot, null);
	                    context.children.onOutletReAttached(stored.contexts);
	                    context.attachRef = stored.componentRef;
	                    context.route = stored.route.value;
	                    if (context.outlet) {
	                        // Attach right away when the outlet has already been instantiated
	                        // Otherwise attach from `RouterOutlet.ngOnInit` when it is instantiated
	                        context.outlet.attach(stored.componentRef, stored.route.value);
	                    }
	                    advanceActivatedRouteNodeAndItsChildren(stored.route);
	                }
	                else {
	                    var /** @type {?} */ config = parentLoadedConfig(future.snapshot);
	                    var /** @type {?} */ cmpFactoryResolver = config ? config.module.componentFactoryResolver : null;
	                    context.route = future;
	                    context.resolver = cmpFactoryResolver;
	                    if (context.outlet) {
	                        // Activate the outlet when it has already been instantiated
	                        // Otherwise it will get activated from its `ngOnInit` when instantiated
	                        context.outlet.activateWith(future, cmpFactoryResolver);
	                    }
	                    this.activateChildRoutes(futureNode, null, context.children);
	                }
	            }
	            else {
	                // if we have a componentless route, we recurse but keep the same outlet map.
	                this.activateChildRoutes(futureNode, null, parentContexts);
	            }
	        }
	    };
	    return ActivateRoutes;
	}());
	/**
	 * @param {?} node
	 * @return {?}
	 */
	function advanceActivatedRouteNodeAndItsChildren(node) {
	    advanceActivatedRoute(node.value);
	    node.children.forEach(advanceActivatedRouteNodeAndItsChildren);
	}
	/**
	 * @param {?} snapshot
	 * @return {?}
	 */
	function parentLoadedConfig(snapshot) {
	    for (var /** @type {?} */ s = snapshot.parent; s; s = s.parent) {
	        var /** @type {?} */ route = s._routeConfig;
	        if (route && route._loadedConfig)
	            return route._loadedConfig;
	        if (route && route.component)
	            return null;
	    }
	    return null;
	}
	/**
	 * @param {?} snapshot
	 * @return {?}
	 */
	function closestLoadedConfig(snapshot) {
	    if (!snapshot)
	        return null;
	    for (var /** @type {?} */ s = snapshot.parent; s; s = s.parent) {
	        var /** @type {?} */ route = s._routeConfig;
	        if (route && route._loadedConfig)
	            return route._loadedConfig;
	    }
	    return null;
	}
	/**
	 * @template T
	 * @param {?} node
	 * @return {?}
	 */
	function nodeChildrenAsMap(node) {
	    var /** @type {?} */ map$$1 = {};
	    if (node) {
	        node.children.forEach(function (child) { return map$$1[child.value.outlet] = child; });
	    }
	    return map$$1;
	}
	/**
	 * @param {?} commands
	 * @return {?}
	 */
	function validateCommands(commands) {
	    for (var /** @type {?} */ i = 0; i < commands.length; i++) {
	        var /** @type {?} */ cmd = commands[i];
	        if (cmd == null) {
	            throw new Error("The requested path contains " + cmd + " segment at index " + i);
	        }
	    }
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@whatItDoes Lets you link to specific parts of your app.
	 *
	 * \@howToUse
	 *
	 * Consider the following route configuration:
	 * `[{ path: 'user/:name', component: UserCmp }]`
	 *
	 * When linking to this `user/:name` route, you can write:
	 * `<a routerLink='/user/bob'>link to user component</a>`
	 *
	 * \@description
	 *
	 * The RouterLink directives let you link to specific parts of your app.
	 *
	 * When the link is static, you can use the directive as follows:
	 * `<a routerLink="/user/bob">link to user component</a>`
	 *
	 * If you use dynamic values to generate the link, you can pass an array of path
	 * segments, followed by the params for each segment.
	 *
	 * For instance `['/team', teamId, 'user', userName, {details: true}]`
	 * means that we want to generate a link to `/team/11/user/bob;details=true`.
	 *
	 * Multiple static segments can be merged into one
	 * (e.g., `['/team/11/user', userName, {details: true}]`).
	 *
	 * The first segment name can be prepended with `/`, `./`, or `../`:
	 * * If the first segment begins with `/`, the router will look up the route from the root of the
	 *   app.
	 * * If the first segment begins with `./`, or doesn't begin with a slash, the router will
	 *   instead look in the children of the current activated route.
	 * * And if the first segment begins with `../`, the router will go up one level.
	 *
	 * You can set query params and fragment as follows:
	 *
	 * ```
	 * <a [routerLink]="['/user/bob']" [queryParams]="{debug: true}" fragment="education">
	 *   link to user component
	 * </a>
	 * ```
	 * RouterLink will use these to generate this link: `/user/bob#education?debug=true`.
	 *
	 * (Deprecated in v4.0.0 use `queryParamsHandling` instead) You can also tell the
	 * directive to preserve the current query params and fragment:
	 *
	 * ```
	 * <a [routerLink]="['/user/bob']" preserveQueryParams preserveFragment>
	 *   link to user component
	 * </a>
	 * ```
	 *
	 * You can tell the directive to how to handle queryParams, available options are:
	 *  - 'merge' merge the queryParams into the current queryParams
	 *  - 'preserve' prserve the current queryParams
	 *  - default / '' use the queryParams only
	 *  same options for {\@link NavigationExtras#queryParamsHandling}
	 *
	 * ```
	 * <a [routerLink]="['/user/bob']" [queryParams]="{debug: true}" queryParamsHandling="merge">
	 *   link to user component
	 * </a>
	 * ```
	 *
	 * The router link directive always treats the provided input as a delta to the current url.
	 *
	 * For instance, if the current url is `/user/(box//aux:team)`.
	 *
	 * Then the following link `<a [routerLink]="['/user/jim']">Jim</a>` will generate the link
	 * `/user/(jim//aux:team)`.
	 *
	 * \@ngModule RouterModule
	 *
	 * See {\@link Router#createUrlTree} for more information.
	 *
	 * \@stable
	 */
	var RouterLink = (function () {
	    /**
	     * @param {?} router
	     * @param {?} route
	     * @param {?} tabIndex
	     * @param {?} renderer
	     * @param {?} el
	     */
	    function RouterLink(router, route, tabIndex, renderer, el) {
	        this.router = router;
	        this.route = route;
	        this.commands = [];
	        if (tabIndex == null) {
	            renderer.setAttribute(el.nativeElement, 'tabindex', '0');
	        }
	    }
	    Object.defineProperty(RouterLink.prototype, "routerLink", {
	        /**
	         * @param {?} commands
	         * @return {?}
	         */
	        set: function (commands) {
	            if (commands != null) {
	                this.commands = Array.isArray(commands) ? commands : [commands];
	            }
	            else {
	                this.commands = [];
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RouterLink.prototype, "preserveQueryParams", {
	        /**
	         * @deprecated 4.0.0 use `queryParamsHandling` instead.
	         * @param {?} value
	         * @return {?}
	         */
	        set: function (value) {
	            if (_angular_core.isDevMode() && (console) && (console.warn)) {
	                console.warn('preserveQueryParams is deprecated!, use queryParamsHandling instead.');
	            }
	            this.preserve = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @return {?}
	     */
	    RouterLink.prototype.onClick = function () {
	        var /** @type {?} */ extras = {
	            skipLocationChange: attrBoolValue(this.skipLocationChange),
	            replaceUrl: attrBoolValue(this.replaceUrl),
	        };
	        this.router.navigateByUrl(this.urlTree, extras);
	        return true;
	    };
	    Object.defineProperty(RouterLink.prototype, "urlTree", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            return this.router.createUrlTree(this.commands, {
	                relativeTo: this.route,
	                queryParams: this.queryParams,
	                fragment: this.fragment,
	                preserveQueryParams: attrBoolValue(this.preserve),
	                queryParamsHandling: this.queryParamsHandling,
	                preserveFragment: attrBoolValue(this.preserveFragment),
	            });
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return RouterLink;
	}());
	RouterLink.decorators = [
	    { type: _angular_core.Directive, args: [{ selector: ':not(a)[routerLink]' },] },
	];
	/**
	 * @nocollapse
	 */
	RouterLink.ctorParameters = function () { return [
	    { type: Router, },
	    { type: ActivatedRoute, },
	    { type: undefined, decorators: [{ type: _angular_core.Attribute, args: ['tabindex',] },] },
	    { type: _angular_core.Renderer2, },
	    { type: _angular_core.ElementRef, },
	]; };
	RouterLink.propDecorators = {
	    'queryParams': [{ type: _angular_core.Input },],
	    'fragment': [{ type: _angular_core.Input },],
	    'queryParamsHandling': [{ type: _angular_core.Input },],
	    'preserveFragment': [{ type: _angular_core.Input },],
	    'skipLocationChange': [{ type: _angular_core.Input },],
	    'replaceUrl': [{ type: _angular_core.Input },],
	    'routerLink': [{ type: _angular_core.Input },],
	    'preserveQueryParams': [{ type: _angular_core.Input },],
	    'onClick': [{ type: _angular_core.HostListener, args: ['click',] },],
	};
	/**
	 * \@whatItDoes Lets you link to specific parts of your app.
	 *
	 * See {\@link RouterLink} for more information.
	 *
	 * \@ngModule RouterModule
	 *
	 * \@stable
	 */
	var RouterLinkWithHref = (function () {
	    /**
	     * @param {?} router
	     * @param {?} route
	     * @param {?} locationStrategy
	     */
	    function RouterLinkWithHref(router, route, locationStrategy) {
	        var _this = this;
	        this.router = router;
	        this.route = route;
	        this.locationStrategy = locationStrategy;
	        this.commands = [];
	        this.subscription = router.events.subscribe(function (s) {
	            if (s instanceof NavigationEnd) {
	                _this.updateTargetUrlAndHref();
	            }
	        });
	    }
	    Object.defineProperty(RouterLinkWithHref.prototype, "routerLink", {
	        /**
	         * @param {?} commands
	         * @return {?}
	         */
	        set: function (commands) {
	            if (commands != null) {
	                this.commands = Array.isArray(commands) ? commands : [commands];
	            }
	            else {
	                this.commands = [];
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RouterLinkWithHref.prototype, "preserveQueryParams", {
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        set: function (value) {
	            if (_angular_core.isDevMode() && (console) && (console.warn)) {
	                console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');
	            }
	            this.preserve = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @param {?} changes
	     * @return {?}
	     */
	    RouterLinkWithHref.prototype.ngOnChanges = function (changes) { this.updateTargetUrlAndHref(); };
	    /**
	     * @return {?}
	     */
	    RouterLinkWithHref.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };
	    /**
	     * @param {?} button
	     * @param {?} ctrlKey
	     * @param {?} metaKey
	     * @param {?} shiftKey
	     * @return {?}
	     */
	    RouterLinkWithHref.prototype.onClick = function (button, ctrlKey, metaKey, shiftKey) {
	        if (button !== 0 || ctrlKey || metaKey || shiftKey) {
	            return true;
	        }
	        if (typeof this.target === 'string' && this.target != '_self') {
	            return true;
	        }
	        var /** @type {?} */ extras = {
	            skipLocationChange: attrBoolValue(this.skipLocationChange),
	            replaceUrl: attrBoolValue(this.replaceUrl),
	        };
	        this.router.navigateByUrl(this.urlTree, extras);
	        return false;
	    };
	    /**
	     * @return {?}
	     */
	    RouterLinkWithHref.prototype.updateTargetUrlAndHref = function () {
	        this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree));
	    };
	    Object.defineProperty(RouterLinkWithHref.prototype, "urlTree", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            return this.router.createUrlTree(this.commands, {
	                relativeTo: this.route,
	                queryParams: this.queryParams,
	                fragment: this.fragment,
	                preserveQueryParams: attrBoolValue(this.preserve),
	                queryParamsHandling: this.queryParamsHandling,
	                preserveFragment: attrBoolValue(this.preserveFragment),
	            });
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return RouterLinkWithHref;
	}());
	RouterLinkWithHref.decorators = [
	    { type: _angular_core.Directive, args: [{ selector: 'a[routerLink]' },] },
	];
	/**
	 * @nocollapse
	 */
	RouterLinkWithHref.ctorParameters = function () { return [
	    { type: Router, },
	    { type: ActivatedRoute, },
	    { type: _angular_common.LocationStrategy, },
	]; };
	RouterLinkWithHref.propDecorators = {
	    'target': [{ type: _angular_core.HostBinding, args: ['attr.target',] }, { type: _angular_core.Input },],
	    'queryParams': [{ type: _angular_core.Input },],
	    'fragment': [{ type: _angular_core.Input },],
	    'queryParamsHandling': [{ type: _angular_core.Input },],
	    'preserveFragment': [{ type: _angular_core.Input },],
	    'skipLocationChange': [{ type: _angular_core.Input },],
	    'replaceUrl': [{ type: _angular_core.Input },],
	    'href': [{ type: _angular_core.HostBinding },],
	    'routerLink': [{ type: _angular_core.Input },],
	    'preserveQueryParams': [{ type: _angular_core.Input },],
	    'onClick': [{ type: _angular_core.HostListener, args: ['click', ['$event.button', '$event.ctrlKey', '$event.metaKey', '$event.shiftKey'],] },],
	};
	/**
	 * @param {?} s
	 * @return {?}
	 */
	function attrBoolValue(s) {
	    return s === '' || !!s;
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@whatItDoes Lets you add a CSS class to an element when the link's route becomes active.
	 *
	 * \@howToUse
	 *
	 * ```
	 * <a routerLink="/user/bob" routerLinkActive="active-link">Bob</a>
	 * ```
	 *
	 * \@description
	 *
	 * The RouterLinkActive directive lets you add a CSS class to an element when the link's route
	 * becomes active.
	 *
	 * Consider the following example:
	 *
	 * ```
	 * <a routerLink="/user/bob" routerLinkActive="active-link">Bob</a>
	 * ```
	 *
	 * When the url is either '/user' or '/user/bob', the active-link class will
	 * be added to the `a` tag. If the url changes, the class will be removed.
	 *
	 * You can set more than one class, as follows:
	 *
	 * ```
	 * <a routerLink="/user/bob" routerLinkActive="class1 class2">Bob</a>
	 * <a routerLink="/user/bob" [routerLinkActive]="['class1', 'class2']">Bob</a>
	 * ```
	 *
	 * You can configure RouterLinkActive by passing `exact: true`. This will add the classes
	 * only when the url matches the link exactly.
	 *
	 * ```
	 * <a routerLink="/user/bob" routerLinkActive="active-link" [routerLinkActiveOptions]="{exact:
	 * true}">Bob</a>
	 * ```
	 *
	 * You can assign the RouterLinkActive instance to a template variable and directly check
	 * the `isActive` status.
	 * ```
	 * <a routerLink="/user/bob" routerLinkActive #rla="routerLinkActive">
	 *   Bob {{ rla.isActive ? '(already open)' : ''}}
	 * </a>
	 * ```
	 *
	 * Finally, you can apply the RouterLinkActive directive to an ancestor of a RouterLink.
	 *
	 * ```
	 * <div routerLinkActive="active-link" [routerLinkActiveOptions]="{exact: true}">
	 *   <a routerLink="/user/jim">Jim</a>
	 *   <a routerLink="/user/bob">Bob</a>
	 * </div>
	 * ```
	 *
	 * This will set the active-link class on the div tag if the url is either '/user/jim' or
	 * '/user/bob'.
	 *
	 * \@ngModule RouterModule
	 *
	 * \@stable
	 */
	var RouterLinkActive = (function () {
	    /**
	     * @param {?} router
	     * @param {?} element
	     * @param {?} renderer
	     * @param {?} cdr
	     */
	    function RouterLinkActive(router, element, renderer, cdr) {
	        var _this = this;
	        this.router = router;
	        this.element = element;
	        this.renderer = renderer;
	        this.cdr = cdr;
	        this.classes = [];
	        this.active = false;
	        this.routerLinkActiveOptions = { exact: false };
	        this.subscription = router.events.subscribe(function (s) {
	            if (s instanceof NavigationEnd) {
	                _this.update();
	            }
	        });
	    }
	    Object.defineProperty(RouterLinkActive.prototype, "isActive", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.active; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @return {?}
	     */
	    RouterLinkActive.prototype.ngAfterContentInit = function () {
	        var _this = this;
	        this.links.changes.subscribe(function (_) { return _this.update(); });
	        this.linksWithHrefs.changes.subscribe(function (_) { return _this.update(); });
	        this.update();
	    };
	    Object.defineProperty(RouterLinkActive.prototype, "routerLinkActive", {
	        /**
	         * @param {?} data
	         * @return {?}
	         */
	        set: function (data) {
	            var /** @type {?} */ classes = Array.isArray(data) ? data : data.split(' ');
	            this.classes = classes.filter(function (c) { return !!c; });
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @param {?} changes
	     * @return {?}
	     */
	    RouterLinkActive.prototype.ngOnChanges = function (changes) { this.update(); };
	    /**
	     * @return {?}
	     */
	    RouterLinkActive.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };
	    /**
	     * @return {?}
	     */
	    RouterLinkActive.prototype.update = function () {
	        var _this = this;
	        if (!this.links || !this.linksWithHrefs || !this.router.navigated)
	            return;
	        var /** @type {?} */ hasActiveLinks = this.hasActiveLinks();
	        // react only when status has changed to prevent unnecessary dom updates
	        if (this.active !== hasActiveLinks) {
	            this.classes.forEach(function (c) {
	                if (hasActiveLinks) {
	                    _this.renderer.addClass(_this.element.nativeElement, c);
	                }
	                else {
	                    _this.renderer.removeClass(_this.element.nativeElement, c);
	                }
	            });
	            Promise.resolve(hasActiveLinks).then(function (active) { return _this.active = active; });
	        }
	    };
	    /**
	     * @param {?} router
	     * @return {?}
	     */
	    RouterLinkActive.prototype.isLinkActive = function (router) {
	        var _this = this;
	        return function (link) { return router.isActive(link.urlTree, _this.routerLinkActiveOptions.exact); };
	    };
	    /**
	     * @return {?}
	     */
	    RouterLinkActive.prototype.hasActiveLinks = function () {
	        return this.links.some(this.isLinkActive(this.router)) ||
	            this.linksWithHrefs.some(this.isLinkActive(this.router));
	    };
	    return RouterLinkActive;
	}());
	RouterLinkActive.decorators = [
	    { type: _angular_core.Directive, args: [{
	                selector: '[routerLinkActive]',
	                exportAs: 'routerLinkActive',
	            },] },
	];
	/**
	 * @nocollapse
	 */
	RouterLinkActive.ctorParameters = function () { return [
	    { type: Router, },
	    { type: _angular_core.ElementRef, },
	    { type: _angular_core.Renderer2, },
	    { type: _angular_core.ChangeDetectorRef, },
	]; };
	RouterLinkActive.propDecorators = {
	    'links': [{ type: _angular_core.ContentChildren, args: [RouterLink, { descendants: true },] },],
	    'linksWithHrefs': [{ type: _angular_core.ContentChildren, args: [RouterLinkWithHref, { descendants: true },] },],
	    'routerLinkActiveOptions': [{ type: _angular_core.Input },],
	    'routerLinkActive': [{ type: _angular_core.Input },],
	};
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Store contextual information about a {\@link RouterOutlet}
	 *
	 * \@stable
	 */
	var OutletContext = (function () {
	    function OutletContext() {
	        this.outlet = null;
	        this.route = null;
	        this.resolver = null;
	        this.children = new ChildrenOutletContexts();
	        this.attachRef = null;
	    }
	    return OutletContext;
	}());
	/**
	 * Store contextual information about the children (= nested) {\@link RouterOutlet}
	 *
	 * \@stable
	 */
	var ChildrenOutletContexts = (function () {
	    function ChildrenOutletContexts() {
	        this.contexts = new Map();
	    }
	    /**
	     * Called when a `RouterOutlet` directive is instantiated
	     * @param {?} childName
	     * @param {?} outlet
	     * @return {?}
	     */
	    ChildrenOutletContexts.prototype.onChildOutletCreated = function (childName, outlet) {
	        var /** @type {?} */ context = this.getOrCreateContext(childName);
	        context.outlet = outlet;
	        this.contexts.set(childName, context);
	    };
	    /**
	     * Called when a `RouterOutlet` directive is destroyed.
	     * We need to keep the context as the outlet could be destroyed inside a NgIf and might be
	     * re-created later.
	     * @param {?} childName
	     * @return {?}
	     */
	    ChildrenOutletContexts.prototype.onChildOutletDestroyed = function (childName) {
	        var /** @type {?} */ context = this.getContext(childName);
	        if (context) {
	            context.outlet = null;
	        }
	    };
	    /**
	     * Called when the corresponding route is deactivated during navigation.
	     * Because the component get destroyed, all children outlet are destroyed.
	     * @return {?}
	     */
	    ChildrenOutletContexts.prototype.onOutletDeactivated = function () {
	        var /** @type {?} */ contexts = this.contexts;
	        this.contexts = new Map();
	        return contexts;
	    };
	    /**
	     * @param {?} contexts
	     * @return {?}
	     */
	    ChildrenOutletContexts.prototype.onOutletReAttached = function (contexts) { this.contexts = contexts; };
	    /**
	     * @param {?} childName
	     * @return {?}
	     */
	    ChildrenOutletContexts.prototype.getOrCreateContext = function (childName) {
	        var /** @type {?} */ context = this.getContext(childName);
	        if (!context) {
	            context = new OutletContext();
	            this.contexts.set(childName, context);
	        }
	        return context;
	    };
	    /**
	     * @param {?} childName
	     * @return {?}
	     */
	    ChildrenOutletContexts.prototype.getContext = function (childName) { return this.contexts.get(childName) || null; };
	    return ChildrenOutletContexts;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@whatItDoes Acts as a placeholder that Angular dynamically fills based on the current router
	 * state.
	 *
	 * \@howToUse
	 *
	 * ```
	 * <router-outlet></router-outlet>
	 * <router-outlet name='left'></router-outlet>
	 * <router-outlet name='right'></router-outlet>
	 * ```
	 *
	 * A router outlet will emit an activate event any time a new component is being instantiated,
	 * and a deactivate event when it is being destroyed.
	 *
	 * ```
	 * <router-outlet
	 *   (activate)='onActivate($event)'
	 *   (deactivate)='onDeactivate($event)'></router-outlet>
	 * ```
	 * \@ngModule RouterModule
	 *
	 * \@stable
	 */
	var RouterOutlet = (function () {
	    /**
	     * @param {?} parentContexts
	     * @param {?} location
	     * @param {?} resolver
	     * @param {?} name
	     * @param {?} changeDetector
	     */
	    function RouterOutlet(parentContexts, location, resolver, name, changeDetector) {
	        this.parentContexts = parentContexts;
	        this.location = location;
	        this.resolver = resolver;
	        this.changeDetector = changeDetector;
	        this.activated = null;
	        this._activatedRoute = null;
	        this.activateEvents = new _angular_core.EventEmitter();
	        this.deactivateEvents = new _angular_core.EventEmitter();
	        this.name = name || PRIMARY_OUTLET;
	        parentContexts.onChildOutletCreated(this.name, this);
	    }
	    /**
	     * @return {?}
	     */
	    RouterOutlet.prototype.ngOnDestroy = function () { this.parentContexts.onChildOutletDestroyed(this.name); };
	    /**
	     * @return {?}
	     */
	    RouterOutlet.prototype.ngOnInit = function () {
	        if (!this.activated) {
	            // If the outlet was not instantiated at the time the route got activated we need to populate
	            // the outlet when it is initialized (ie inside a NgIf)
	            var /** @type {?} */ context = this.parentContexts.getContext(this.name);
	            if (context && context.route) {
	                if (context.attachRef) {
	                    // `attachRef` is populated when there is an existing component to mount
	                    this.attach(context.attachRef, context.route);
	                }
	                else {
	                    // otherwise the component defined in the configuration is created
	                    this.activateWith(context.route, context.resolver || null);
	                }
	            }
	        }
	    };
	    Object.defineProperty(RouterOutlet.prototype, "locationInjector", {
	        /**
	         * @deprecated since v4 *
	         * @return {?}
	         */
	        get: function () { return this.location.injector; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RouterOutlet.prototype, "locationFactoryResolver", {
	        /**
	         * @deprecated since v4 *
	         * @return {?}
	         */
	        get: function () { return this.resolver; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RouterOutlet.prototype, "isActivated", {
	        /**
	         * @return {?}
	         */
	        get: function () { return !!this.activated; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RouterOutlet.prototype, "component", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            if (!this.activated)
	                throw new Error('Outlet is not activated');
	            return this.activated.instance;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RouterOutlet.prototype, "activatedRoute", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            if (!this.activated)
	                throw new Error('Outlet is not activated');
	            return (this._activatedRoute);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RouterOutlet.prototype, "activatedRouteData", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            if (this._activatedRoute) {
	                return this._activatedRoute.snapshot.data;
	            }
	            return {};
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Called when the `RouteReuseStrategy` instructs to detach the subtree
	     * @return {?}
	     */
	    RouterOutlet.prototype.detach = function () {
	        if (!this.activated)
	            throw new Error('Outlet is not activated');
	        this.location.detach();
	        var /** @type {?} */ cmp = this.activated;
	        this.activated = null;
	        this._activatedRoute = null;
	        return cmp;
	    };
	    /**
	     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree
	     * @param {?} ref
	     * @param {?} activatedRoute
	     * @return {?}
	     */
	    RouterOutlet.prototype.attach = function (ref, activatedRoute) {
	        this.activated = ref;
	        this._activatedRoute = activatedRoute;
	        this.location.insert(ref.hostView);
	    };
	    /**
	     * @return {?}
	     */
	    RouterOutlet.prototype.deactivate = function () {
	        if (this.activated) {
	            var /** @type {?} */ c = this.component;
	            this.activated.destroy();
	            this.activated = null;
	            this._activatedRoute = null;
	            this.deactivateEvents.emit(c);
	        }
	    };
	    /**
	     * @param {?} activatedRoute
	     * @param {?} resolver
	     * @return {?}
	     */
	    RouterOutlet.prototype.activateWith = function (activatedRoute, resolver) {
	        if (this.isActivated) {
	            throw new Error('Cannot activate an already activated outlet');
	        }
	        this._activatedRoute = activatedRoute;
	        var /** @type {?} */ snapshot = activatedRoute._futureSnapshot;
	        var /** @type {?} */ component = (((snapshot._routeConfig)).component);
	        resolver = resolver || this.resolver;
	        var /** @type {?} */ factory = resolver.resolveComponentFactory(component);
	        var /** @type {?} */ childContexts = this.parentContexts.getOrCreateContext(this.name).children;
	        var /** @type {?} */ injector = new OutletInjector(activatedRoute, childContexts, this.location.injector);
	        this.activated = this.location.createComponent(factory, this.location.length, injector);
	        // Calling `markForCheck` to make sure we will run the change detection when the
	        // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.
	        this.changeDetector.markForCheck();
	        this.activateEvents.emit(this.activated.instance);
	    };
	    return RouterOutlet;
	}());
	RouterOutlet.decorators = [
	    { type: _angular_core.Directive, args: [{ selector: 'router-outlet', exportAs: 'outlet' },] },
	];
	/**
	 * @nocollapse
	 */
	RouterOutlet.ctorParameters = function () { return [
	    { type: ChildrenOutletContexts, },
	    { type: _angular_core.ViewContainerRef, },
	    { type: _angular_core.ComponentFactoryResolver, },
	    { type: undefined, decorators: [{ type: _angular_core.Attribute, args: ['name',] },] },
	    { type: _angular_core.ChangeDetectorRef, },
	]; };
	RouterOutlet.propDecorators = {
	    'activateEvents': [{ type: _angular_core.Output, args: ['activate',] },],
	    'deactivateEvents': [{ type: _angular_core.Output, args: ['deactivate',] },],
	};
	var OutletInjector = (function () {
	    /**
	     * @param {?} route
	     * @param {?} childContexts
	     * @param {?} parent
	     */
	    function OutletInjector(route, childContexts, parent) {
	        this.route = route;
	        this.childContexts = childContexts;
	        this.parent = parent;
	    }
	    /**
	     * @param {?} token
	     * @param {?=} notFoundValue
	     * @return {?}
	     */
	    OutletInjector.prototype.get = function (token, notFoundValue) {
	        if (token === ActivatedRoute) {
	            return this.route;
	        }
	        if (token === ChildrenOutletContexts) {
	            return this.childContexts;
	        }
	        return this.parent.get(token, notFoundValue);
	    };
	    return OutletInjector;
	}());
	/**
	*@license
	*Copyright Google Inc. All Rights Reserved.
	*
	*Use of this source code is governed by an MIT-style license that can be
	*found in the LICENSE file at https://angular.io/license
	*/
	/**
	 * \@whatItDoes Provides a preloading strategy.
	 *
	 * \@experimental
	 * @abstract
	 */
	var PreloadingStrategy = (function () {
	    function PreloadingStrategy() {
	    }
	    /**
	     * @abstract
	     * @param {?} route
	     * @param {?} fn
	     * @return {?}
	     */
	    PreloadingStrategy.prototype.preload = function (route, fn) { };
	    return PreloadingStrategy;
	}());
	/**
	 * \@whatItDoes Provides a preloading strategy that preloads all modules as quickly as possible.
	 *
	 * \@howToUse
	 *
	 * ```
	 * RouteModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})
	 * ```
	 *
	 * \@experimental
	 */
	var PreloadAllModules = (function () {
	    function PreloadAllModules() {
	    }
	    /**
	     * @param {?} route
	     * @param {?} fn
	     * @return {?}
	     */
	    PreloadAllModules.prototype.preload = function (route, fn) {
	        return rxjs_operator_catch._catch.call(fn(), function () { return rxjs_observable_of.of(null); });
	    };
	    return PreloadAllModules;
	}());
	/**
	 * \@whatItDoes Provides a preloading strategy that does not preload any modules.
	 *
	 * \@description
	 *
	 * This strategy is enabled by default.
	 *
	 * \@experimental
	 */
	var NoPreloading = (function () {
	    function NoPreloading() {
	    }
	    /**
	     * @param {?} route
	     * @param {?} fn
	     * @return {?}
	     */
	    NoPreloading.prototype.preload = function (route, fn) { return rxjs_observable_of.of(null); };
	    return NoPreloading;
	}());
	/**
	 * The preloader optimistically loads all router configurations to
	 * make navigations into lazily-loaded sections of the application faster.
	 *
	 * The preloader runs in the background. When the router bootstraps, the preloader
	 * starts listening to all navigation events. After every such event, the preloader
	 * will check if any configurations can be loaded lazily.
	 *
	 * If a route is protected by `canLoad` guards, the preloaded will not load it.
	 *
	 * \@stable
	 */
	var RouterPreloader = (function () {
	    /**
	     * @param {?} router
	     * @param {?} moduleLoader
	     * @param {?} compiler
	     * @param {?} injector
	     * @param {?} preloadingStrategy
	     */
	    function RouterPreloader(router, moduleLoader, compiler, injector, preloadingStrategy) {
	        this.router = router;
	        this.injector = injector;
	        this.preloadingStrategy = preloadingStrategy;
	        var onStartLoad = function (r) { return router.triggerEvent(new RouteConfigLoadStart(r)); };
	        var onEndLoad = function (r) { return router.triggerEvent(new RouteConfigLoadEnd(r)); };
	        this.loader = new RouterConfigLoader(moduleLoader, compiler, onStartLoad, onEndLoad);
	    }
	    
	    /**
	     * @return {?}
	     */
	    RouterPreloader.prototype.setUpPreloading = function () {
	        var _this = this;
	        var /** @type {?} */ navigations$ = rxjs_operator_filter.filter.call(this.router.events, function (e) { return e instanceof NavigationEnd; });
	        this.subscription = rxjs_operator_concatMap.concatMap.call(navigations$, function () { return _this.preload(); }).subscribe(function () { });
	    };
	    /**
	     * @return {?}
	     */
	    RouterPreloader.prototype.preload = function () {
	        var /** @type {?} */ ngModule = this.injector.get(_angular_core.NgModuleRef);
	        return this.processRoutes(ngModule, this.router.config);
	    };
	    /**
	     * @return {?}
	     */
	    RouterPreloader.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };
	    /**
	     * @param {?} ngModule
	     * @param {?} routes
	     * @return {?}
	     */
	    RouterPreloader.prototype.processRoutes = function (ngModule, routes) {
	        var /** @type {?} */ res = [];
	        for (var _i = 0, routes_5 = routes; _i < routes_5.length; _i++) {
	            var route = routes_5[_i];
	            // we already have the config loaded, just recurse
	            if (route.loadChildren && !route.canLoad && route._loadedConfig) {
	                var /** @type {?} */ childConfig = route._loadedConfig;
	                res.push(this.processRoutes(childConfig.module, childConfig.routes));
	                // no config loaded, fetch the config
	            }
	            else if (route.loadChildren && !route.canLoad) {
	                res.push(this.preloadConfig(ngModule, route));
	                // recurse into children
	            }
	            else if (route.children) {
	                res.push(this.processRoutes(ngModule, route.children));
	            }
	        }
	        return rxjs_operator_mergeAll.mergeAll.call(rxjs_observable_from.from(res));
	    };
	    /**
	     * @param {?} ngModule
	     * @param {?} route
	     * @return {?}
	     */
	    RouterPreloader.prototype.preloadConfig = function (ngModule, route) {
	        var _this = this;
	        return this.preloadingStrategy.preload(route, function () {
	            var /** @type {?} */ loaded$ = _this.loader.load(ngModule.injector, route);
	            return rxjs_operator_mergeMap.mergeMap.call(loaded$, function (config) {
	                route._loadedConfig = config;
	                return _this.processRoutes(config.module, config.routes);
	            });
	        });
	    };
	    return RouterPreloader;
	}());
	RouterPreloader.decorators = [
	    { type: _angular_core.Injectable },
	];
	/**
	 * @nocollapse
	 */
	RouterPreloader.ctorParameters = function () { return [
	    { type: Router, },
	    { type: _angular_core.NgModuleFactoryLoader, },
	    { type: _angular_core.Compiler, },
	    { type: _angular_core.Injector, },
	    { type: PreloadingStrategy, },
	]; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@whatItDoes Contains a list of directives
	 * \@stable
	 */
	var ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive];
	/**
	 * \@whatItDoes Is used in DI to configure the router.
	 * \@stable
	 */
	var ROUTER_CONFIGURATION = new _angular_core.InjectionToken('ROUTER_CONFIGURATION');
	/**
	 * \@docsNotRequired
	 */
	var ROUTER_FORROOT_GUARD = new _angular_core.InjectionToken('ROUTER_FORROOT_GUARD');
	var ROUTER_PROVIDERS = [
	    _angular_common.Location,
	    { provide: UrlSerializer, useClass: DefaultUrlSerializer },
	    {
	        provide: Router,
	        useFactory: setupRouter,
	        deps: [
	            _angular_core.ApplicationRef, UrlSerializer, ChildrenOutletContexts, _angular_common.Location, _angular_core.Injector,
	            _angular_core.NgModuleFactoryLoader, _angular_core.Compiler, ROUTES, ROUTER_CONFIGURATION,
	            [UrlHandlingStrategy, new _angular_core.Optional()], [RouteReuseStrategy, new _angular_core.Optional()]
	        ]
	    },
	    ChildrenOutletContexts,
	    { provide: ActivatedRoute, useFactory: rootRoute, deps: [Router] },
	    { provide: _angular_core.NgModuleFactoryLoader, useClass: _angular_core.SystemJsNgModuleLoader },
	    RouterPreloader,
	    NoPreloading,
	    PreloadAllModules,
	    { provide: ROUTER_CONFIGURATION, useValue: { enableTracing: false } },
	];
	/**
	 * @return {?}
	 */
	function routerNgProbeToken() {
	    return new _angular_core.NgProbeToken('Router', Router);
	}
	/**
	 * \@whatItDoes Adds router directives and providers.
	 *
	 * \@howToUse
	 *
	 * RouterModule can be imported multiple times: once per lazily-loaded bundle.
	 * Since the router deals with a global shared resource--location, we cannot have
	 * more than one router service active.
	 *
	 * That is why there are two ways to create the module: `RouterModule.forRoot` and
	 * `RouterModule.forChild`.
	 *
	 * * `forRoot` creates a module that contains all the directives, the given routes, and the router
	 *   service itself.
	 * * `forChild` creates a module that contains all the directives and the given routes, but does not
	 *   include the router service.
	 *
	 * When registered at the root, the module should be used as follows
	 *
	 * ```
	 * \@NgModule({
	 *   imports: [RouterModule.forRoot(ROUTES)]
	 * })
	 * class MyNgModule {}
	 * ```
	 *
	 * For submodules and lazy loaded submodules the module should be used as follows:
	 *
	 * ```
	 * \@NgModule({
	 *   imports: [RouterModule.forChild(ROUTES)]
	 * })
	 * class MyNgModule {}
	 * ```
	 *
	 * \@description
	 *
	 * Managing state transitions is one of the hardest parts of building applications. This is
	 * especially true on the web, where you also need to ensure that the state is reflected in the URL.
	 * In addition, we often want to split applications into multiple bundles and load them on demand.
	 * Doing this transparently is not trivial.
	 *
	 * The Angular router solves these problems. Using the router, you can declaratively specify
	 * application states, manage state transitions while taking care of the URL, and load bundles on
	 * demand.
	 *
	 * [Read this developer guide](https://angular.io/docs/ts/latest/guide/router.html) to get an
	 * overview of how the router should be used.
	 *
	 * \@stable
	 */
	var RouterModule = (function () {
	    /**
	     * @param {?} guard
	     * @param {?} router
	     */
	    function RouterModule(guard, router) {
	    }
	    /**
	     * Creates a module with all the router providers and directives. It also optionally sets up an
	     * application listener to perform an initial navigation.
	     *
	     * Options:
	     * * `enableTracing` makes the router log all its internal events to the console.
	     * * `useHash` enables the location strategy that uses the URL fragment instead of the history
	     * API.
	     * * `initialNavigation` disables the initial navigation.
	     * * `errorHandler` provides a custom error handler.
	     * @param {?} routes
	     * @param {?=} config
	     * @return {?}
	     */
	    RouterModule.forRoot = function (routes, config) {
	        return {
	            ngModule: RouterModule,
	            providers: [
	                ROUTER_PROVIDERS,
	                provideRoutes(routes),
	                {
	                    provide: ROUTER_FORROOT_GUARD,
	                    useFactory: provideForRootGuard,
	                    deps: [[Router, new _angular_core.Optional(), new _angular_core.SkipSelf()]]
	                },
	                { provide: ROUTER_CONFIGURATION, useValue: config ? config : {} },
	                {
	                    provide: _angular_common.LocationStrategy,
	                    useFactory: provideLocationStrategy,
	                    deps: [
	                        _angular_common.PlatformLocation, [new _angular_core.Inject(_angular_common.APP_BASE_HREF), new _angular_core.Optional()], ROUTER_CONFIGURATION
	                    ]
	                },
	                {
	                    provide: PreloadingStrategy,
	                    useExisting: config && config.preloadingStrategy ? config.preloadingStrategy :
	                        NoPreloading
	                },
	                { provide: _angular_core.NgProbeToken, multi: true, useFactory: routerNgProbeToken },
	                provideRouterInitializer(),
	            ],
	        };
	    };
	    /**
	     * Creates a module with all the router directives and a provider registering routes.
	     * @param {?} routes
	     * @return {?}
	     */
	    RouterModule.forChild = function (routes) {
	        return { ngModule: RouterModule, providers: [provideRoutes(routes)] };
	    };
	    return RouterModule;
	}());
	RouterModule.decorators = [
	    { type: _angular_core.NgModule, args: [{ declarations: ROUTER_DIRECTIVES, exports: ROUTER_DIRECTIVES },] },
	];
	/**
	 * @nocollapse
	 */
	RouterModule.ctorParameters = function () { return [
	    { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [ROUTER_FORROOT_GUARD,] },] },
	    { type: Router, decorators: [{ type: _angular_core.Optional },] },
	]; };
	/**
	 * @param {?} platformLocationStrategy
	 * @param {?} baseHref
	 * @param {?=} options
	 * @return {?}
	 */
	function provideLocationStrategy(platformLocationStrategy, baseHref, options) {
	    if (options === void 0) { options = {}; }
	    return options.useHash ? new _angular_common.HashLocationStrategy(platformLocationStrategy, baseHref) :
	        new _angular_common.PathLocationStrategy(platformLocationStrategy, baseHref);
	}
	/**
	 * @param {?} router
	 * @return {?}
	 */
	function provideForRootGuard(router) {
	    if (router) {
	        throw new Error("RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.");
	    }
	    return 'guarded';
	}
	/**
	 * \@whatItDoes Registers routes.
	 *
	 * \@howToUse
	 *
	 * ```
	 * \@NgModule({
	 *   imports: [RouterModule.forChild(ROUTES)],
	 *   providers: [provideRoutes(EXTRA_ROUTES)]
	 * })
	 * class MyNgModule {}
	 * ```
	 *
	 * \@stable
	 * @param {?} routes
	 * @return {?}
	 */
	function provideRoutes(routes) {
	    return [
	        { provide: _angular_core.ANALYZE_FOR_ENTRY_COMPONENTS, multi: true, useValue: routes },
	        { provide: ROUTES, multi: true, useValue: routes },
	    ];
	}
	/**
	 * @param {?} ref
	 * @param {?} urlSerializer
	 * @param {?} contexts
	 * @param {?} location
	 * @param {?} injector
	 * @param {?} loader
	 * @param {?} compiler
	 * @param {?} config
	 * @param {?=} opts
	 * @param {?=} urlHandlingStrategy
	 * @param {?=} routeReuseStrategy
	 * @return {?}
	 */
	function setupRouter(ref, urlSerializer, contexts, location, injector, loader, compiler, config, opts, urlHandlingStrategy, routeReuseStrategy) {
	    if (opts === void 0) { opts = {}; }
	    var /** @type {?} */ router = new Router(null, urlSerializer, contexts, location, injector, loader, compiler, flatten(config));
	    if (urlHandlingStrategy) {
	        router.urlHandlingStrategy = urlHandlingStrategy;
	    }
	    if (routeReuseStrategy) {
	        router.routeReuseStrategy = routeReuseStrategy;
	    }
	    if (opts.errorHandler) {
	        router.errorHandler = opts.errorHandler;
	    }
	    if (opts.enableTracing) {
	        var /** @type {?} */ dom_1 = _angular_platformBrowser.ɵgetDOM();
	        router.events.subscribe(function (e) {
	            dom_1.logGroup("Router Event: " + ((e.constructor)).name);
	            dom_1.log(e.toString());
	            dom_1.log(e);
	            dom_1.logGroupEnd();
	        });
	    }
	    return router;
	}
	/**
	 * @param {?} router
	 * @return {?}
	 */
	function rootRoute(router) {
	    return router.routerState.root;
	}
	/**
	 * To initialize the router properly we need to do in two steps:
	 *
	 * We need to start the navigation in a APP_INITIALIZER to block the bootstrap if
	 * a resolver or a guards executes asynchronously. Second, we need to actually run
	 * activation in a BOOTSTRAP_LISTENER. We utilize the afterPreactivation
	 * hook provided by the router to do that.
	 *
	 * The router navigation starts, reaches the point when preactivation is done, and then
	 * pauses. It waits for the hook to be resolved. We then resolve it only in a bootstrap listener.
	 */
	var RouterInitializer = (function () {
	    /**
	     * @param {?} injector
	     */
	    function RouterInitializer(injector) {
	        this.injector = injector;
	        this.initNavigation = false;
	        this.resultOfPreactivationDone = new rxjs_Subject.Subject();
	    }
	    /**
	     * @return {?}
	     */
	    RouterInitializer.prototype.appInitializer = function () {
	        var _this = this;
	        var /** @type {?} */ p = this.injector.get(_angular_common.LOCATION_INITIALIZED, Promise.resolve(null));
	        return p.then(function () {
	            var /** @type {?} */ resolve = ((null));
	            var /** @type {?} */ res = new Promise(function (r) { return resolve = r; });
	            var /** @type {?} */ router = _this.injector.get(Router);
	            var /** @type {?} */ opts = _this.injector.get(ROUTER_CONFIGURATION);
	            if (_this.isLegacyDisabled(opts) || _this.isLegacyEnabled(opts)) {
	                resolve(true);
	            }
	            else if (opts.initialNavigation === 'disabled') {
	                router.setUpLocationChangeListener();
	                resolve(true);
	            }
	            else if (opts.initialNavigation === 'enabled') {
	                router.hooks.afterPreactivation = function () {
	                    // only the initial navigation should be delayed
	                    if (!_this.initNavigation) {
	                        _this.initNavigation = true;
	                        resolve(true);
	                        return _this.resultOfPreactivationDone;
	                        // subsequent navigations should not be delayed
	                    }
	                    else {
	                        return (rxjs_observable_of.of(null));
	                    }
	                };
	                router.initialNavigation();
	            }
	            else {
	                throw new Error("Invalid initialNavigation options: '" + opts.initialNavigation + "'");
	            }
	            return res;
	        });
	    };
	    /**
	     * @param {?} bootstrappedComponentRef
	     * @return {?}
	     */
	    RouterInitializer.prototype.bootstrapListener = function (bootstrappedComponentRef) {
	        var /** @type {?} */ opts = this.injector.get(ROUTER_CONFIGURATION);
	        var /** @type {?} */ preloader = this.injector.get(RouterPreloader);
	        var /** @type {?} */ router = this.injector.get(Router);
	        var /** @type {?} */ ref = this.injector.get(_angular_core.ApplicationRef);
	        if (bootstrappedComponentRef !== ref.components[0]) {
	            return;
	        }
	        if (this.isLegacyEnabled(opts)) {
	            router.initialNavigation();
	        }
	        else if (this.isLegacyDisabled(opts)) {
	            router.setUpLocationChangeListener();
	        }
	        preloader.setUpPreloading();
	        router.resetRootComponentType(ref.componentTypes[0]);
	        this.resultOfPreactivationDone.next(/** @type {?} */ ((null)));
	        this.resultOfPreactivationDone.complete();
	    };
	    /**
	     * @param {?} opts
	     * @return {?}
	     */
	    RouterInitializer.prototype.isLegacyEnabled = function (opts) {
	        return opts.initialNavigation === 'legacy_enabled' || opts.initialNavigation === true ||
	            opts.initialNavigation === undefined;
	    };
	    /**
	     * @param {?} opts
	     * @return {?}
	     */
	    RouterInitializer.prototype.isLegacyDisabled = function (opts) {
	        return opts.initialNavigation === 'legacy_disabled' || opts.initialNavigation === false;
	    };
	    return RouterInitializer;
	}());
	RouterInitializer.decorators = [
	    { type: _angular_core.Injectable },
	];
	/**
	 * @nocollapse
	 */
	RouterInitializer.ctorParameters = function () { return [
	    { type: _angular_core.Injector, },
	]; };
	/**
	 * @param {?} r
	 * @return {?}
	 */
	function getAppInitializer(r) {
	    return r.appInitializer.bind(r);
	}
	/**
	 * @param {?} r
	 * @return {?}
	 */
	function getBootstrapListener(r) {
	    return r.bootstrapListener.bind(r);
	}
	/**
	 * A token for the router initializer that will be called after the app is bootstrapped.
	 *
	 * \@experimental
	 */
	var ROUTER_INITIALIZER = new _angular_core.InjectionToken('Router Initializer');
	/**
	 * @return {?}
	 */
	function provideRouterInitializer() {
	    return [
	        RouterInitializer,
	        {
	            provide: _angular_core.APP_INITIALIZER,
	            multi: true,
	            useFactory: getAppInitializer,
	            deps: [RouterInitializer]
	        },
	        { provide: ROUTER_INITIALIZER, useFactory: getBootstrapListener, deps: [RouterInitializer] },
	        { provide: _angular_core.APP_BOOTSTRAP_LISTENER, multi: true, useExisting: ROUTER_INITIALIZER },
	    ];
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @module
	 * @description
	 * Entry point for all public APIs of the common package.
	 */
	/**
	 * \@stable
	 */
	var VERSION = new _angular_core.Version('4.3.3');
	
	exports.RouterLink = RouterLink;
	exports.RouterLinkWithHref = RouterLinkWithHref;
	exports.RouterLinkActive = RouterLinkActive;
	exports.RouterOutlet = RouterOutlet;
	exports.GuardsCheckEnd = GuardsCheckEnd;
	exports.GuardsCheckStart = GuardsCheckStart;
	exports.NavigationCancel = NavigationCancel;
	exports.NavigationEnd = NavigationEnd;
	exports.NavigationError = NavigationError;
	exports.NavigationStart = NavigationStart;
	exports.ResolveEnd = ResolveEnd;
	exports.ResolveStart = ResolveStart;
	exports.RouteConfigLoadEnd = RouteConfigLoadEnd;
	exports.RouteConfigLoadStart = RouteConfigLoadStart;
	exports.RoutesRecognized = RoutesRecognized;
	exports.RouteReuseStrategy = RouteReuseStrategy;
	exports.Router = Router;
	exports.ROUTES = ROUTES;
	exports.ROUTER_CONFIGURATION = ROUTER_CONFIGURATION;
	exports.ROUTER_INITIALIZER = ROUTER_INITIALIZER;
	exports.RouterModule = RouterModule;
	exports.provideRoutes = provideRoutes;
	exports.ChildrenOutletContexts = ChildrenOutletContexts;
	exports.OutletContext = OutletContext;
	exports.NoPreloading = NoPreloading;
	exports.PreloadAllModules = PreloadAllModules;
	exports.PreloadingStrategy = PreloadingStrategy;
	exports.RouterPreloader = RouterPreloader;
	exports.ActivatedRoute = ActivatedRoute;
	exports.ActivatedRouteSnapshot = ActivatedRouteSnapshot;
	exports.RouterState = RouterState;
	exports.RouterStateSnapshot = RouterStateSnapshot;
	exports.PRIMARY_OUTLET = PRIMARY_OUTLET;
	exports.convertToParamMap = convertToParamMap;
	exports.UrlHandlingStrategy = UrlHandlingStrategy;
	exports.DefaultUrlSerializer = DefaultUrlSerializer;
	exports.UrlSegment = UrlSegment;
	exports.UrlSegmentGroup = UrlSegmentGroup;
	exports.UrlSerializer = UrlSerializer;
	exports.UrlTree = UrlTree;
	exports.VERSION = VERSION;
	exports.ɵROUTER_PROVIDERS = ROUTER_PROVIDERS;
	exports.ɵflatten = flatten;
	exports.ɵa = ROUTER_FORROOT_GUARD;
	exports.ɵg = RouterInitializer;
	exports.ɵh = getAppInitializer;
	exports.ɵi = getBootstrapListener;
	exports.ɵd = provideForRootGuard;
	exports.ɵc = provideLocationStrategy;
	exports.ɵj = provideRouterInitializer;
	exports.ɵf = rootRoute;
	exports.ɵb = routerNgProbeToken;
	exports.ɵe = setupRouter;
	exports.ɵk = Tree;
	exports.ɵl = TreeNode;
	
	Object.defineProperty(exports, '__esModule', { value: true });
	
	})));
	//# sourceMappingURL=router.umd.js.map


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	var InnerSubscriber = (function (_Subscriber) {
	    _inherits(InnerSubscriber, _Subscriber);
	
	    function InnerSubscriber(parent, outerValue, outerIndex) {
	        _classCallCheck(this, InnerSubscriber);
	
	        _Subscriber.call(this);
	        this.parent = parent;
	        this.outerValue = outerValue;
	        this.outerIndex = outerIndex;
	        this.index = 0;
	    }
	
	    InnerSubscriber.prototype._next = function _next(value) {
	        var index = this.index++;
	        this.parent.notifyNext(this.outerValue, value, this.outerIndex, index);
	    };
	
	    InnerSubscriber.prototype._error = function _error(error) {
	        this.parent.notifyError(error, this);
	    };
	
	    InnerSubscriber.prototype._complete = function _complete() {
	        this.parent.notifyComplete(this);
	    };
	
	    return InnerSubscriber;
	})(_Subscriber3['default']);
	
	exports['default'] = InnerSubscriber;
	module.exports = exports['default'];

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _Observable = __webpack_require__(4);
	
	var _Observable2 = _interopRequireDefault(_Observable);
	
	var _operatorsCombineLatestStatic = __webpack_require__(104);
	
	var _operatorsCombineLatestStatic2 = _interopRequireDefault(_operatorsCombineLatestStatic);
	
	var _operatorsConcatStatic = __webpack_require__(44);
	
	var _operatorsConcatStatic2 = _interopRequireDefault(_operatorsConcatStatic);
	
	var _observablesDeferObservable = __webpack_require__(86);
	
	var _observablesDeferObservable2 = _interopRequireDefault(_observablesDeferObservable);
	
	var _observablesEmptyObservable = __webpack_require__(22);
	
	var _observablesEmptyObservable2 = _interopRequireDefault(_observablesEmptyObservable);
	
	var _observablesForkJoinObservable = __webpack_require__(87);
	
	var _observablesForkJoinObservable2 = _interopRequireDefault(_observablesForkJoinObservable);
	
	var _observablesFromObservable = __webpack_require__(90);
	
	var _observablesFromObservable2 = _interopRequireDefault(_observablesFromObservable);
	
	var _observablesArrayObservable = __webpack_require__(14);
	
	var _observablesArrayObservable2 = _interopRequireDefault(_observablesArrayObservable);
	
	var _observablesFromEventObservable = __webpack_require__(88);
	
	var _observablesFromEventObservable2 = _interopRequireDefault(_observablesFromEventObservable);
	
	var _observablesFromEventPatternObservable = __webpack_require__(89);
	
	var _observablesFromEventPatternObservable2 = _interopRequireDefault(_observablesFromEventPatternObservable);
	
	var _observablesPromiseObservable = __webpack_require__(29);
	
	var _observablesPromiseObservable2 = _interopRequireDefault(_observablesPromiseObservable);
	
	var _observablesIntervalObservable = __webpack_require__(92);
	
	var _observablesIntervalObservable2 = _interopRequireDefault(_observablesIntervalObservable);
	
	var _operatorsMergeStatic = __webpack_require__(48);
	
	var _operatorsMergeStatic2 = _interopRequireDefault(_operatorsMergeStatic);
	
	var _observablesInfiniteObservable = __webpack_require__(91);
	
	var _observablesInfiniteObservable2 = _interopRequireDefault(_observablesInfiniteObservable);
	
	var _observablesRangeObservable = __webpack_require__(94);
	
	var _observablesRangeObservable2 = _interopRequireDefault(_observablesRangeObservable);
	
	var _observablesErrorObservable = __webpack_require__(28);
	
	var _observablesErrorObservable2 = _interopRequireDefault(_observablesErrorObservable);
	
	var _observablesTimerObservable = __webpack_require__(96);
	
	var _observablesTimerObservable2 = _interopRequireDefault(_observablesTimerObservable);
	
	var _operatorsZipStatic = __webpack_require__(53);
	
	var _operatorsZipStatic2 = _interopRequireDefault(_operatorsZipStatic);
	
	var _operatorsBuffer = __webpack_require__(97);
	
	var _operatorsBuffer2 = _interopRequireDefault(_operatorsBuffer);
	
	var _operatorsBufferCount = __webpack_require__(98);
	
	var _operatorsBufferCount2 = _interopRequireDefault(_operatorsBufferCount);
	
	var _operatorsBufferTime = __webpack_require__(99);
	
	var _operatorsBufferTime2 = _interopRequireDefault(_operatorsBufferTime);
	
	var _operatorsBufferToggle = __webpack_require__(100);
	
	var _operatorsBufferToggle2 = _interopRequireDefault(_operatorsBufferToggle);
	
	var _operatorsBufferWhen = __webpack_require__(101);
	
	var _operatorsBufferWhen2 = _interopRequireDefault(_operatorsBufferWhen);
	
	var _operatorsCatch = __webpack_require__(102);
	
	var _operatorsCatch2 = _interopRequireDefault(_operatorsCatch);
	
	var _operatorsCombineAll = __webpack_require__(103);
	
	var _operatorsCombineAll2 = _interopRequireDefault(_operatorsCombineAll);
	
	var _operatorsCombineLatest = __webpack_require__(105);
	
	var _operatorsCombineLatest2 = _interopRequireDefault(_operatorsCombineLatest);
	
	var _operatorsConcat = __webpack_require__(106);
	
	var _operatorsConcat2 = _interopRequireDefault(_operatorsConcat);
	
	var _operatorsConcatAll = __webpack_require__(107);
	
	var _operatorsConcatAll2 = _interopRequireDefault(_operatorsConcatAll);
	
	var _operatorsConcatMap = __webpack_require__(108);
	
	var _operatorsConcatMap2 = _interopRequireDefault(_operatorsConcatMap);
	
	var _operatorsConcatMapTo = __webpack_require__(109);
	
	var _operatorsConcatMapTo2 = _interopRequireDefault(_operatorsConcatMapTo);
	
	var _operatorsCount = __webpack_require__(110);
	
	var _operatorsCount2 = _interopRequireDefault(_operatorsCount);
	
	var _operatorsDematerialize = __webpack_require__(115);
	
	var _operatorsDematerialize2 = _interopRequireDefault(_operatorsDematerialize);
	
	var _operatorsDebounce = __webpack_require__(111);
	
	var _operatorsDebounce2 = _interopRequireDefault(_operatorsDebounce);
	
	var _operatorsDebounceTime = __webpack_require__(112);
	
	var _operatorsDebounceTime2 = _interopRequireDefault(_operatorsDebounceTime);
	
	var _operatorsDefaultIfEmpty = __webpack_require__(113);
	
	var _operatorsDefaultIfEmpty2 = _interopRequireDefault(_operatorsDefaultIfEmpty);
	
	var _operatorsDelay = __webpack_require__(114);
	
	var _operatorsDelay2 = _interopRequireDefault(_operatorsDelay);
	
	var _operatorsDistinctUntilChanged = __webpack_require__(45);
	
	var _operatorsDistinctUntilChanged2 = _interopRequireDefault(_operatorsDistinctUntilChanged);
	
	var _operatorsExtendedDistinctUntilKeyChanged = __webpack_require__(120);
	
	var _operatorsExtendedDistinctUntilKeyChanged2 = _interopRequireDefault(_operatorsExtendedDistinctUntilKeyChanged);
	
	var _operatorsDo = __webpack_require__(116);
	
	var _operatorsDo2 = _interopRequireDefault(_operatorsDo);
	
	var _operatorsExtendedElementAt = __webpack_require__(121);
	
	var _operatorsExtendedElementAt2 = _interopRequireDefault(_operatorsExtendedElementAt);
	
	var _operatorsExpand = __webpack_require__(119);
	
	var _operatorsExpand2 = _interopRequireDefault(_operatorsExpand);
	
	var _operatorsFilter = __webpack_require__(47);
	
	var _operatorsFilter2 = _interopRequireDefault(_operatorsFilter);
	
	var _operatorsExtendedFind = __webpack_require__(122);
	
	var _operatorsExtendedFind2 = _interopRequireDefault(_operatorsExtendedFind);
	
	var _operatorsExtendedFindIndex = __webpack_require__(123);
	
	var _operatorsExtendedFindIndex2 = _interopRequireDefault(_operatorsExtendedFindIndex);
	
	var _operatorsFinally = __webpack_require__(126);
	
	var _operatorsFinally2 = _interopRequireDefault(_operatorsFinally);
	
	var _operatorsFirst = __webpack_require__(127);
	
	var _operatorsFirst2 = _interopRequireDefault(_operatorsFirst);
	
	var _operatorsGroupBy = __webpack_require__(129);
	
	var _operatorsIgnoreElements = __webpack_require__(130);
	
	var _operatorsIgnoreElements2 = _interopRequireDefault(_operatorsIgnoreElements);
	
	var _operatorsExtendedIsEmpty = __webpack_require__(124);
	
	var _operatorsExtendedIsEmpty2 = _interopRequireDefault(_operatorsExtendedIsEmpty);
	
	var _operatorsEvery = __webpack_require__(117);
	
	var _operatorsEvery2 = _interopRequireDefault(_operatorsEvery);
	
	var _operatorsLast = __webpack_require__(131);
	
	var _operatorsLast2 = _interopRequireDefault(_operatorsLast);
	
	var _operatorsMap = __webpack_require__(132);
	
	var _operatorsMap2 = _interopRequireDefault(_operatorsMap);
	
	var _operatorsMapTo = __webpack_require__(133);
	
	var _operatorsMapTo2 = _interopRequireDefault(_operatorsMapTo);
	
	var _operatorsMaterialize = __webpack_require__(134);
	
	var _operatorsMaterialize2 = _interopRequireDefault(_operatorsMaterialize);
	
	var _operatorsMerge = __webpack_require__(135);
	
	var _operatorsMerge2 = _interopRequireDefault(_operatorsMerge);
	
	var _operatorsMergeAll = __webpack_require__(136);
	
	var _operatorsMergeAll2 = _interopRequireDefault(_operatorsMergeAll);
	
	var _operatorsMergeMap = __webpack_require__(137);
	
	var _operatorsMergeMap2 = _interopRequireDefault(_operatorsMergeMap);
	
	var _operatorsMergeMapTo = __webpack_require__(138);
	
	var _operatorsMergeMapTo2 = _interopRequireDefault(_operatorsMergeMapTo);
	
	var _operatorsMulticast = __webpack_require__(23);
	
	var _operatorsMulticast2 = _interopRequireDefault(_operatorsMulticast);
	
	var _operatorsObserveOn = __webpack_require__(139);
	
	var _operatorsObserveOn2 = _interopRequireDefault(_operatorsObserveOn);
	
	var _operatorsPartition = __webpack_require__(140);
	
	var _operatorsPartition2 = _interopRequireDefault(_operatorsPartition);
	
	var _operatorsPublish = __webpack_require__(51);
	
	var _operatorsPublish2 = _interopRequireDefault(_operatorsPublish);
	
	var _operatorsPublishBehavior = __webpack_require__(141);
	
	var _operatorsPublishBehavior2 = _interopRequireDefault(_operatorsPublishBehavior);
	
	var _operatorsPublishReplay = __webpack_require__(52);
	
	var _operatorsPublishReplay2 = _interopRequireDefault(_operatorsPublishReplay);
	
	var _operatorsReduce = __webpack_require__(142);
	
	var _operatorsReduce2 = _interopRequireDefault(_operatorsReduce);
	
	var _operatorsRepeat = __webpack_require__(143);
	
	var _operatorsRepeat2 = _interopRequireDefault(_operatorsRepeat);
	
	var _operatorsRetry = __webpack_require__(144);
	
	var _operatorsRetry2 = _interopRequireDefault(_operatorsRetry);
	
	var _operatorsRetryWhen = __webpack_require__(145);
	
	var _operatorsRetryWhen2 = _interopRequireDefault(_operatorsRetryWhen);
	
	var _operatorsSample = __webpack_require__(146);
	
	var _operatorsSample2 = _interopRequireDefault(_operatorsSample);
	
	var _operatorsSampleTime = __webpack_require__(147);
	
	var _operatorsSampleTime2 = _interopRequireDefault(_operatorsSampleTime);
	
	var _operatorsScan = __webpack_require__(148);
	
	var _operatorsScan2 = _interopRequireDefault(_operatorsScan);
	
	var _operatorsShare = __webpack_require__(149);
	
	var _operatorsShare2 = _interopRequireDefault(_operatorsShare);
	
	var _operatorsShareReplay = __webpack_require__(150);
	
	var _operatorsShareReplay2 = _interopRequireDefault(_operatorsShareReplay);
	
	var _operatorsSingle = __webpack_require__(151);
	
	var _operatorsSingle2 = _interopRequireDefault(_operatorsSingle);
	
	var _operatorsSkip = __webpack_require__(152);
	
	var _operatorsSkip2 = _interopRequireDefault(_operatorsSkip);
	
	var _operatorsSkipUntil = __webpack_require__(153);
	
	var _operatorsSkipUntil2 = _interopRequireDefault(_operatorsSkipUntil);
	
	var _operatorsStartWith = __webpack_require__(154);
	
	var _operatorsStartWith2 = _interopRequireDefault(_operatorsStartWith);
	
	var _operatorsSubscribeOn = __webpack_require__(155);
	
	var _operatorsSubscribeOn2 = _interopRequireDefault(_operatorsSubscribeOn);
	
	var _operatorsSwitch = __webpack_require__(156);
	
	var _operatorsSwitch2 = _interopRequireDefault(_operatorsSwitch);
	
	var _operatorsSwitchMap = __webpack_require__(157);
	
	var _operatorsSwitchMap2 = _interopRequireDefault(_operatorsSwitchMap);
	
	var _operatorsSwitchMapTo = __webpack_require__(158);
	
	var _operatorsSwitchMapTo2 = _interopRequireDefault(_operatorsSwitchMapTo);
	
	var _operatorsTake = __webpack_require__(159);
	
	var _operatorsTake2 = _interopRequireDefault(_operatorsTake);
	
	var _operatorsTakeUntil = __webpack_require__(160);
	
	var _operatorsTakeUntil2 = _interopRequireDefault(_operatorsTakeUntil);
	
	var _operatorsThrottle = __webpack_require__(161);
	
	var _operatorsThrottle2 = _interopRequireDefault(_operatorsThrottle);
	
	var _operatorsExtendedTimeInterval = __webpack_require__(125);
	
	var _operatorsExtendedTimeInterval2 = _interopRequireDefault(_operatorsExtendedTimeInterval);
	
	var _operatorsTimeout = __webpack_require__(162);
	
	var _operatorsTimeout2 = _interopRequireDefault(_operatorsTimeout);
	
	var _operatorsTimeoutWith = __webpack_require__(163);
	
	var _operatorsTimeoutWith2 = _interopRequireDefault(_operatorsTimeoutWith);
	
	var _operatorsToArray = __webpack_require__(164);
	
	var _operatorsToArray2 = _interopRequireDefault(_operatorsToArray);
	
	var _operatorsToPromise = __webpack_require__(165);
	
	var _operatorsToPromise2 = _interopRequireDefault(_operatorsToPromise);
	
	var _operatorsWindow = __webpack_require__(166);
	
	var _operatorsWindow2 = _interopRequireDefault(_operatorsWindow);
	
	var _operatorsWindowCount = __webpack_require__(167);
	
	var _operatorsWindowCount2 = _interopRequireDefault(_operatorsWindowCount);
	
	var _operatorsWindowTime = __webpack_require__(168);
	
	var _operatorsWindowTime2 = _interopRequireDefault(_operatorsWindowTime);
	
	var _operatorsWindowToggle = __webpack_require__(169);
	
	var _operatorsWindowToggle2 = _interopRequireDefault(_operatorsWindowToggle);
	
	var _operatorsWindowWhen = __webpack_require__(170);
	
	var _operatorsWindowWhen2 = _interopRequireDefault(_operatorsWindowWhen);
	
	var _operatorsWithLatestFrom = __webpack_require__(171);
	
	var _operatorsWithLatestFrom2 = _interopRequireDefault(_operatorsWithLatestFrom);
	
	var _operatorsZip = __webpack_require__(172);
	
	var _operatorsZip2 = _interopRequireDefault(_operatorsZip);
	
	var _operatorsZipAll = __webpack_require__(173);
	
	var _operatorsZipAll2 = _interopRequireDefault(_operatorsZipAll);
	
	var _Subject = __webpack_require__(7);
	
	var _Subject2 = _interopRequireDefault(_Subject);
	
	var _Subscription = __webpack_require__(5);
	
	var _Subscription2 = _interopRequireDefault(_Subscription);
	
	var _Subscriber = __webpack_require__(1);
	
	var _Subscriber2 = _interopRequireDefault(_Subscriber);
	
	var _subjectsReplaySubject = __webpack_require__(58);
	
	var _subjectsReplaySubject2 = _interopRequireDefault(_subjectsReplaySubject);
	
	var _subjectsBehaviorSubject = __webpack_require__(57);
	
	var _subjectsBehaviorSubject2 = _interopRequireDefault(_subjectsBehaviorSubject);
	
	var _observablesConnectableObservable = __webpack_require__(43);
	
	var _observablesConnectableObservable2 = _interopRequireDefault(_observablesConnectableObservable);
	
	var _Notification = __webpack_require__(18);
	
	var _Notification2 = _interopRequireDefault(_Notification);
	
	var _utilEmptyError = __webpack_require__(25);
	
	var _utilEmptyError2 = _interopRequireDefault(_utilEmptyError);
	
	var _utilArgumentOutOfRangeError = __webpack_require__(61);
	
	var _utilArgumentOutOfRangeError2 = _interopRequireDefault(_utilArgumentOutOfRangeError);
	
	var _schedulersNextTick = __webpack_require__(13);
	
	var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);
	
	var _schedulersImmediate = __webpack_require__(10);
	
	var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);
	
	var _testingTestScheduler = __webpack_require__(180);
	
	var _schedulersVirtualTimeScheduler = __webpack_require__(56);
	
	var _schedulersVirtualTimeScheduler2 = _interopRequireDefault(_schedulersVirtualTimeScheduler);
	
	_Observable2['default'].combineLatest = _operatorsCombineLatestStatic2['default'];
	
	_Observable2['default'].concat = _operatorsConcatStatic2['default'];
	
	_Observable2['default'].defer = _observablesDeferObservable2['default'].create;
	
	_Observable2['default'].empty = _observablesEmptyObservable2['default'].create;
	
	_Observable2['default'].forkJoin = _observablesForkJoinObservable2['default'].create;
	
	_Observable2['default'].from = _observablesFromObservable2['default'].create;
	
	_Observable2['default'].fromArray = _observablesArrayObservable2['default'].create;
	
	_Observable2['default'].fromEvent = _observablesFromEventObservable2['default'].create;
	
	_Observable2['default'].fromEventPattern = _observablesFromEventPatternObservable2['default'].create;
	
	_Observable2['default'].fromPromise = _observablesPromiseObservable2['default'].create;
	
	_Observable2['default'].interval = _observablesIntervalObservable2['default'].create;
	
	_Observable2['default'].merge = _operatorsMergeStatic2['default'];
	
	_Observable2['default'].never = _observablesInfiniteObservable2['default'].create;
	_Observable2['default'].of = _observablesArrayObservable2['default'].of;
	
	_Observable2['default'].range = _observablesRangeObservable2['default'].create;
	
	_Observable2['default']['throw'] = _observablesErrorObservable2['default'].create;
	
	_Observable2['default'].timer = _observablesTimerObservable2['default'].create;
	
	_Observable2['default'].zip = _operatorsZipStatic2['default'];
	// Operators
	var observableProto = _Observable2['default'].prototype;
	
	observableProto.buffer = _operatorsBuffer2['default'];
	
	observableProto.bufferCount = _operatorsBufferCount2['default'];
	
	observableProto.bufferTime = _operatorsBufferTime2['default'];
	
	observableProto.bufferToggle = _operatorsBufferToggle2['default'];
	
	observableProto.bufferWhen = _operatorsBufferWhen2['default'];
	
	observableProto['catch'] = _operatorsCatch2['default'];
	
	observableProto.combineAll = _operatorsCombineAll2['default'];
	
	observableProto.combineLatest = _operatorsCombineLatest2['default'];
	
	observableProto.concat = _operatorsConcat2['default'];
	
	observableProto.concatAll = _operatorsConcatAll2['default'];
	
	observableProto.concatMap = _operatorsConcatMap2['default'];
	
	observableProto.concatMapTo = _operatorsConcatMapTo2['default'];
	
	observableProto.count = _operatorsCount2['default'];
	
	observableProto.dematerialize = _operatorsDematerialize2['default'];
	
	observableProto.debounce = _operatorsDebounce2['default'];
	
	observableProto.debounceTime = _operatorsDebounceTime2['default'];
	
	observableProto.defaultIfEmpty = _operatorsDefaultIfEmpty2['default'];
	
	observableProto.delay = _operatorsDelay2['default'];
	
	observableProto.distinctUntilChanged = _operatorsDistinctUntilChanged2['default'];
	
	observableProto.distinctUntilKeyChanged = _operatorsExtendedDistinctUntilKeyChanged2['default'];
	
	observableProto['do'] = _operatorsDo2['default'];
	
	observableProto.elementAt = _operatorsExtendedElementAt2['default'];
	
	observableProto.expand = _operatorsExpand2['default'];
	
	observableProto.filter = _operatorsFilter2['default'];
	
	observableProto.find = _operatorsExtendedFind2['default'];
	
	observableProto.findIndex = _operatorsExtendedFindIndex2['default'];
	
	observableProto['finally'] = _operatorsFinally2['default'];
	
	observableProto.first = _operatorsFirst2['default'];
	
	observableProto.groupBy = _operatorsGroupBy.groupBy;
	
	observableProto.ignoreElements = _operatorsIgnoreElements2['default'];
	
	observableProto.isEmpty = _operatorsExtendedIsEmpty2['default'];
	
	observableProto.every = _operatorsEvery2['default'];
	
	observableProto.last = _operatorsLast2['default'];
	
	observableProto.map = _operatorsMap2['default'];
	
	observableProto.mapTo = _operatorsMapTo2['default'];
	
	observableProto.materialize = _operatorsMaterialize2['default'];
	
	observableProto.merge = _operatorsMerge2['default'];
	
	observableProto.mergeAll = _operatorsMergeAll2['default'];
	
	observableProto.mergeMap = _operatorsMergeMap2['default'];
	observableProto.flatMap = _operatorsMergeMap2['default'];
	
	observableProto.mergeMapTo = _operatorsMergeMapTo2['default'];
	observableProto.flatMapTo = _operatorsMergeMapTo2['default'];
	
	observableProto.multicast = _operatorsMulticast2['default'];
	
	observableProto.observeOn = _operatorsObserveOn2['default'];
	
	observableProto.partition = _operatorsPartition2['default'];
	
	observableProto.publish = _operatorsPublish2['default'];
	
	observableProto.publishBehavior = _operatorsPublishBehavior2['default'];
	
	observableProto.publishReplay = _operatorsPublishReplay2['default'];
	
	observableProto.reduce = _operatorsReduce2['default'];
	
	observableProto.repeat = _operatorsRepeat2['default'];
	
	observableProto.retry = _operatorsRetry2['default'];
	
	observableProto.retryWhen = _operatorsRetryWhen2['default'];
	
	observableProto.sample = _operatorsSample2['default'];
	
	observableProto.sampleTime = _operatorsSampleTime2['default'];
	
	observableProto.scan = _operatorsScan2['default'];
	
	observableProto.share = _operatorsShare2['default'];
	
	observableProto.shareReplay = _operatorsShareReplay2['default'];
	
	observableProto.single = _operatorsSingle2['default'];
	
	observableProto.skip = _operatorsSkip2['default'];
	
	observableProto.skipUntil = _operatorsSkipUntil2['default'];
	
	observableProto.startWith = _operatorsStartWith2['default'];
	
	observableProto.subscribeOn = _operatorsSubscribeOn2['default'];
	
	observableProto['switch'] = _operatorsSwitch2['default'];
	
	observableProto.switchMap = _operatorsSwitchMap2['default'];
	
	observableProto.switchMapTo = _operatorsSwitchMapTo2['default'];
	
	observableProto.take = _operatorsTake2['default'];
	
	observableProto.takeUntil = _operatorsTakeUntil2['default'];
	
	observableProto.throttle = _operatorsThrottle2['default'];
	
	observableProto.timeInterval = _operatorsExtendedTimeInterval2['default'];
	
	observableProto.timeout = _operatorsTimeout2['default'];
	
	observableProto.timeoutWith = _operatorsTimeoutWith2['default'];
	
	observableProto.toArray = _operatorsToArray2['default'];
	
	observableProto.toPromise = _operatorsToPromise2['default'];
	
	observableProto.window = _operatorsWindow2['default'];
	
	observableProto.windowCount = _operatorsWindowCount2['default'];
	
	observableProto.windowTime = _operatorsWindowTime2['default'];
	
	observableProto.windowToggle = _operatorsWindowToggle2['default'];
	
	observableProto.windowWhen = _operatorsWindowWhen2['default'];
	
	observableProto.withLatestFrom = _operatorsWithLatestFrom2['default'];
	
	observableProto.zip = _operatorsZip2['default'];
	
	observableProto.zipAll = _operatorsZipAll2['default'];
	
	var Scheduler = {
	    nextTick: _schedulersNextTick2['default'],
	    immediate: _schedulersImmediate2['default']
	};
	exports.Subject = _Subject2['default'];
	exports.Scheduler = Scheduler;
	exports.Observable = _Observable2['default'];
	exports.Subscriber = _Subscriber2['default'];
	exports.Subscription = _Subscription2['default'];
	exports.ReplaySubject = _subjectsReplaySubject2['default'];
	exports.BehaviorSubject = _subjectsBehaviorSubject2['default'];
	exports.ConnectableObservable = _observablesConnectableObservable2['default'];
	exports.Notification = _Notification2['default'];
	exports.EmptyError = _utilEmptyError2['default'];
	exports.ArgumentOutOfRangeError = _utilArgumentOutOfRangeError2['default'];
	exports.TestScheduler = _testingTestScheduler.TestScheduler;
	exports.VirtualTimeScheduler = _schedulersVirtualTimeScheduler2['default'];
	exports.TimeInterval = _operatorsExtendedTimeInterval.TimeInterval;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _Observable2 = __webpack_require__(4);
	
	var _Observable3 = _interopRequireDefault(_Observable2);
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	var DeferObservable = (function (_Observable) {
	    _inherits(DeferObservable, _Observable);
	
	    function DeferObservable(observableFactory) {
	        _classCallCheck(this, DeferObservable);
	
	        _Observable.call(this);
	        this.observableFactory = observableFactory;
	    }
	
	    DeferObservable.create = function create(observableFactory) {
	        return new DeferObservable(observableFactory);
	    };
	
	    DeferObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var result = _utilTryCatch2['default'](this.observableFactory)();
	        if (result === _utilErrorObject.errorObject) {
	            subscriber.error(_utilErrorObject.errorObject.e);
	        } else {
	            result.subscribe(subscriber);
	        }
	    };
	
	    return DeferObservable;
	})(_Observable3['default']);
	
	exports['default'] = DeferObservable;
	module.exports = exports['default'];

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _Observable2 = __webpack_require__(4);
	
	var _Observable3 = _interopRequireDefault(_Observable2);
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	var ForkJoinObservable = (function (_Observable) {
	    _inherits(ForkJoinObservable, _Observable);
	
	    function ForkJoinObservable(observables) {
	        _classCallCheck(this, ForkJoinObservable);
	
	        _Observable.call(this);
	        this.observables = observables;
	    }
	
	    ForkJoinObservable.create = function create() {
	        for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
	            observables[_key] = arguments[_key];
	        }
	
	        return new ForkJoinObservable(observables);
	    };
	
	    ForkJoinObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var observables = this.observables;
	        var len = observables.length;
	        var context = { complete: 0, total: len, values: emptyArray(len) };
	        for (var i = 0; i < len; i++) {
	            observables[i].subscribe(new AllSubscriber(subscriber, this, i, context));
	        }
	    };
	
	    return ForkJoinObservable;
	})(_Observable3['default']);
	
	exports['default'] = ForkJoinObservable;
	
	var AllSubscriber = (function (_Subscriber) {
	    _inherits(AllSubscriber, _Subscriber);
	
	    function AllSubscriber(destination, parent, index, context) {
	        _classCallCheck(this, AllSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.parent = parent;
	        this.index = index;
	        this.context = context;
	    }
	
	    AllSubscriber.prototype._next = function _next(value) {
	        this._value = value;
	    };
	
	    AllSubscriber.prototype._complete = function _complete() {
	        var context = this.context;
	        context.values[this.index] = this._value;
	        if (context.values.every(hasValue)) {
	            this.destination.next(context.values);
	            this.destination.complete();
	        }
	    };
	
	    return AllSubscriber;
	})(_Subscriber3['default']);
	
	function hasValue(x) {
	    return x !== null;
	}
	function emptyArray(len) {
	    var arr = [];
	    for (var i = 0; i < len; i++) {
	        arr.push(null);
	    }
	    return arr;
	}
	module.exports = exports['default'];

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _Observable2 = __webpack_require__(4);
	
	var _Observable3 = _interopRequireDefault(_Observable2);
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	var _Subscription = __webpack_require__(5);
	
	var _Subscription2 = _interopRequireDefault(_Subscription);
	
	var FromEventObservable = (function (_Observable) {
	    _inherits(FromEventObservable, _Observable);
	
	    function FromEventObservable(sourceObj, eventName, selector) {
	        _classCallCheck(this, FromEventObservable);
	
	        _Observable.call(this);
	        this.sourceObj = sourceObj;
	        this.eventName = eventName;
	        this.selector = selector;
	    }
	
	    FromEventObservable.create = function create(sourceObj, eventName, selector) {
	        return new FromEventObservable(sourceObj, eventName, selector);
	    };
	
	    FromEventObservable.setupSubscription = function setupSubscription(sourceObj, eventName, handler, subscriber) {
	        var unsubscribe = undefined;
	        var tag = sourceObj.toString();
	        if (tag === '[object NodeList]' || tag === '[object HTMLCollection]') {
	            for (var i = 0, len = sourceObj.length; i < len; i++) {
	                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber);
	            }
	        } else if (typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function') {
	            sourceObj.addEventListener(eventName, handler);
	            unsubscribe = function () {
	                return sourceObj.removeEventListener(eventName, handler);
	            };
	        } else if (typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function') {
	            sourceObj.on(eventName, handler);
	            unsubscribe = function () {
	                return sourceObj.off(eventName, handler);
	            };
	        } else if (typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function') {
	            sourceObj.addListener(eventName, handler);
	            unsubscribe = function () {
	                return sourceObj.removeListener(eventName, handler);
	            };
	        }
	        subscriber.add(new _Subscription2['default'](unsubscribe));
	    };
	
	    FromEventObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var sourceObj = this.sourceObj;
	        var eventName = this.eventName;
	        var selector = this.selector;
	        var handler = selector ? function (e) {
	            var result = _utilTryCatch2['default'](selector)(e);
	            if (result === _utilErrorObject.errorObject) {
	                subscriber.error(result.e);
	            } else {
	                subscriber.next(result);
	            }
	        } : function (e) {
	            return subscriber.next(e);
	        };
	        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber);
	    };
	
	    return FromEventObservable;
	})(_Observable3['default']);
	
	exports['default'] = FromEventObservable;
	module.exports = exports['default'];

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _Observable2 = __webpack_require__(4);
	
	var _Observable3 = _interopRequireDefault(_Observable2);
	
	var _Subscription = __webpack_require__(5);
	
	var _Subscription2 = _interopRequireDefault(_Subscription);
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	var FromEventPatternObservable = (function (_Observable) {
	    _inherits(FromEventPatternObservable, _Observable);
	
	    function FromEventPatternObservable(addHandler, removeHandler, selector) {
	        _classCallCheck(this, FromEventPatternObservable);
	
	        _Observable.call(this);
	        this.addHandler = addHandler;
	        this.removeHandler = removeHandler;
	        this.selector = selector;
	    }
	
	    FromEventPatternObservable.create = function create(addHandler, removeHandler, selector) {
	        return new FromEventPatternObservable(addHandler, removeHandler, selector);
	    };
	
	    FromEventPatternObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var addHandler = this.addHandler;
	        var removeHandler = this.removeHandler;
	        var selector = this.selector;
	        var handler = selector ? function (e) {
	            var result = _utilTryCatch2['default'](selector).apply(null, arguments);
	            if (result === _utilErrorObject.errorObject) {
	                subscriber.error(result.e);
	            } else {
	                subscriber.next(result);
	            }
	        } : function (e) {
	            subscriber.next(e);
	        };
	        var result = _utilTryCatch2['default'](addHandler)(handler);
	        if (result === _utilErrorObject.errorObject) {
	            subscriber.error(result.e);
	        }
	        subscriber.add(new _Subscription2['default'](function () {
	            //TODO: determine whether or not to forward to error handler
	            removeHandler(handler);
	        }));
	    };
	
	    return FromEventPatternObservable;
	})(_Observable3['default']);
	
	exports['default'] = FromEventPatternObservable;
	module.exports = exports['default'];

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _PromiseObservable = __webpack_require__(29);
	
	var _PromiseObservable2 = _interopRequireDefault(_PromiseObservable);
	
	var _IteratorObservable = __webpack_require__(93);
	
	var _IteratorObservable2 = _interopRequireDefault(_IteratorObservable);
	
	var _ArrayObservable = __webpack_require__(14);
	
	var _ArrayObservable2 = _interopRequireDefault(_ArrayObservable);
	
	var _utilSymbol_observable = __webpack_require__(34);
	
	var _utilSymbol_observable2 = _interopRequireDefault(_utilSymbol_observable);
	
	var _utilSymbol_iterator = __webpack_require__(26);
	
	var _utilSymbol_iterator2 = _interopRequireDefault(_utilSymbol_iterator);
	
	var _Observable2 = __webpack_require__(4);
	
	var _Observable3 = _interopRequireDefault(_Observable2);
	
	var _operatorsObserveOnSupport = __webpack_require__(50);
	
	var _schedulersImmediate = __webpack_require__(10);
	
	var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);
	
	var isArray = Array.isArray;
	
	var FromObservable = (function (_Observable) {
	    _inherits(FromObservable, _Observable);
	
	    function FromObservable(ish, scheduler) {
	        _classCallCheck(this, FromObservable);
	
	        _Observable.call(this, null);
	        this.ish = ish;
	        this.scheduler = scheduler;
	    }
	
	    FromObservable.create = function create(ish) {
	        var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersImmediate2['default'] : arguments[1];
	
	        if (ish) {
	            if (isArray(ish)) {
	                return new _ArrayObservable2['default'](ish, scheduler);
	            } else if (typeof ish.then === 'function') {
	                return new _PromiseObservable2['default'](ish, scheduler);
	            } else if (typeof ish[_utilSymbol_observable2['default']] === 'function') {
	                if (ish instanceof _Observable3['default']) {
	                    return ish;
	                }
	                return new FromObservable(ish, scheduler);
	            } else if (typeof ish[_utilSymbol_iterator2['default']] === 'function') {
	                return new _IteratorObservable2['default'](ish, null, null, scheduler);
	            }
	        }
	        throw new TypeError(typeof ish + ' is not observable');
	    };
	
	    FromObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var ish = this.ish;
	        var scheduler = this.scheduler;
	        if (scheduler === _schedulersImmediate2['default']) {
	            return this.ish[_utilSymbol_observable2['default']]().subscribe(subscriber);
	        } else {
	            return this.ish[_utilSymbol_observable2['default']]().subscribe(new _operatorsObserveOnSupport.ObserveOnSubscriber(subscriber, scheduler, 0));
	        }
	    };
	
	    return FromObservable;
	})(_Observable3['default']);
	
	exports['default'] = FromObservable;
	module.exports = exports['default'];

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _Observable2 = __webpack_require__(4);
	
	var _Observable3 = _interopRequireDefault(_Observable2);
	
	var InfiniteObservable = (function (_Observable) {
	    _inherits(InfiniteObservable, _Observable);
	
	    function InfiniteObservable() {
	        _classCallCheck(this, InfiniteObservable);
	
	        _Observable.call(this);
	    }
	
	    InfiniteObservable.create = function create() {
	        return new InfiniteObservable();
	    };
	
	    InfiniteObservable.prototype._subscribe = function _subscribe(subscriber) {};
	
	    return InfiniteObservable;
	})(_Observable3['default']);
	
	exports['default'] = InfiniteObservable;
	module.exports = exports['default'];

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _utilIsNumeric = __webpack_require__(64);
	
	var _utilIsNumeric2 = _interopRequireDefault(_utilIsNumeric);
	
	var _Observable2 = __webpack_require__(4);
	
	var _Observable3 = _interopRequireDefault(_Observable2);
	
	var _schedulersNextTick = __webpack_require__(13);
	
	var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);
	
	var IntervalObservable = (function (_Observable) {
	    _inherits(IntervalObservable, _Observable);
	
	    function IntervalObservable() {
	        var period = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	        var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersNextTick2['default'] : arguments[1];
	
	        _classCallCheck(this, IntervalObservable);
	
	        _Observable.call(this);
	        this.period = period;
	        this.scheduler = scheduler;
	        if (!_utilIsNumeric2['default'](period) || period < 0) {
	            this.period = 0;
	        }
	        if (!scheduler || typeof scheduler.schedule !== 'function') {
	            this.scheduler = _schedulersNextTick2['default'];
	        }
	    }
	
	    IntervalObservable.create = function create() {
	        var period = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	        var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersNextTick2['default'] : arguments[1];
	
	        return new IntervalObservable(period, scheduler);
	    };
	
	    IntervalObservable.dispatch = function dispatch(state) {
	        var index = state.index;
	        var subscriber = state.subscriber;
	        var period = state.period;
	
	        subscriber.next(index);
	        if (subscriber.isUnsubscribed) {
	            return;
	        }
	        state.index += 1;
	        this.schedule(state, period);
	    };
	
	    IntervalObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var index = 0;
	        var period = this.period;
	        var scheduler = this.scheduler;
	        subscriber.add(scheduler.schedule(IntervalObservable.dispatch, period, {
	            index: index, subscriber: subscriber, period: period
	        }));
	    };
	
	    return IntervalObservable;
	})(_Observable3['default']);
	
	exports['default'] = IntervalObservable;
	module.exports = exports['default'];

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _Observable2 = __webpack_require__(4);
	
	var _Observable3 = _interopRequireDefault(_Observable2);
	
	var _utilRoot = __webpack_require__(16);
	
	var _utilSymbol_iterator = __webpack_require__(26);
	
	var _utilSymbol_iterator2 = _interopRequireDefault(_utilSymbol_iterator);
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	var IteratorObservable = (function (_Observable) {
	    _inherits(IteratorObservable, _Observable);
	
	    function IteratorObservable(iterator, project, thisArg, scheduler) {
	        _classCallCheck(this, IteratorObservable);
	
	        _Observable.call(this);
	        this.iterator = iterator;
	        this.project = project;
	        this.thisArg = thisArg;
	        this.scheduler = scheduler;
	    }
	
	    IteratorObservable.create = function create(iterator, project, thisArg, scheduler) {
	        if (iterator == null) {
	            throw new Error('iterator cannot be null.');
	        }
	        if (project && typeof project !== 'function') {
	            throw new Error('When provided, `project` must be a function.');
	        }
	        return new IteratorObservable(iterator, project, thisArg, scheduler);
	    };
	
	    IteratorObservable.dispatch = function dispatch(state) {
	        var index = state.index;
	        var hasError = state.hasError;
	        var thisArg = state.thisArg;
	        var project = state.project;
	        var iterator = state.iterator;
	        var subscriber = state.subscriber;
	
	        if (hasError) {
	            subscriber.error(state.error);
	            return;
	        }
	        var result = iterator.next();
	        if (result.done) {
	            subscriber.complete();
	            return;
	        }
	        if (project) {
	            result = _utilTryCatch2['default'](project).call(thisArg, result.value, index);
	            if (result === _utilErrorObject.errorObject) {
	                state.error = _utilErrorObject.errorObject.e;
	                state.hasError = true;
	            } else {
	                subscriber.next(result);
	                state.index = index + 1;
	            }
	        } else {
	            subscriber.next(result.value);
	            state.index = index + 1;
	        }
	        if (subscriber.isUnsubscribed) {
	            return;
	        }
	        this.schedule(state);
	    };
	
	    IteratorObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var index = 0;
	        var project = this.project;
	        var thisArg = this.thisArg;
	        var iterator = getIterator(Object(this.iterator));
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            subscriber.add(scheduler.schedule(IteratorObservable.dispatch, 0, {
	                index: index, thisArg: thisArg, project: project, iterator: iterator, subscriber: subscriber
	            }));
	        } else {
	            do {
	                var result = iterator.next();
	                if (result.done) {
	                    subscriber.complete();
	                    break;
	                } else if (project) {
	                    result = _utilTryCatch2['default'](project).call(thisArg, result.value, index++);
	                    if (result === _utilErrorObject.errorObject) {
	                        subscriber.error(_utilErrorObject.errorObject.e);
	                        break;
	                    }
	                    subscriber.next(result);
	                } else {
	                    subscriber.next(result.value);
	                }
	                if (subscriber.isUnsubscribed) {
	                    break;
	                }
	            } while (true);
	        }
	    };
	
	    return IteratorObservable;
	})(_Observable3['default']);
	
	exports['default'] = IteratorObservable;
	
	var maxSafeInteger = Math.pow(2, 53) - 1;
	
	var StringIterator = (function () {
	    function StringIterator(str) {
	        var idx = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	        var len = arguments.length <= 2 || arguments[2] === undefined ? str.length : arguments[2];
	        return (function () {
	            _classCallCheck(this, StringIterator);
	
	            this.str = str;
	            this.idx = idx;
	            this.len = len;
	        }).apply(this, arguments);
	    }
	
	    StringIterator.prototype[_utilSymbol_iterator2['default']] = function () {
	        return this;
	    };
	
	    StringIterator.prototype.next = function next() {
	        return this.idx < this.len ? {
	            done: false,
	            value: this.str.charAt(this.idx++)
	        } : {
	            done: true,
	            value: undefined
	        };
	    };
	
	    return StringIterator;
	})();
	
	var ArrayIterator = (function () {
	    function ArrayIterator(arr) {
	        var idx = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	        var len = arguments.length <= 2 || arguments[2] === undefined ? toLength(arr) : arguments[2];
	        return (function () {
	            _classCallCheck(this, ArrayIterator);
	
	            this.arr = arr;
	            this.idx = idx;
	            this.len = len;
	        }).apply(this, arguments);
	    }
	
	    ArrayIterator.prototype[_utilSymbol_iterator2['default']] = function () {
	        return this;
	    };
	
	    ArrayIterator.prototype.next = function next() {
	        return this.idx < this.len ? {
	            done: false,
	            value: this.arr[this.idx++]
	        } : {
	            done: true,
	            value: undefined
	        };
	    };
	
	    return ArrayIterator;
	})();
	
	function getIterator(o) {
	    var i = o[_utilSymbol_iterator2['default']];
	    if (!i && typeof o === 'string') {
	        return new StringIterator(o);
	    }
	    if (!i && o.length !== undefined) {
	        return new ArrayIterator(o);
	    }
	    if (!i) {
	        throw new TypeError('Object is not iterable');
	    }
	    return o[_utilSymbol_iterator2['default']]();
	}
	function toLength(o) {
	    var len = +o.length;
	    if (isNaN(len)) {
	        return 0;
	    }
	    if (len === 0 || !numberIsFinite(len)) {
	        return len;
	    }
	    len = sign(len) * Math.floor(Math.abs(len));
	    if (len <= 0) {
	        return 0;
	    }
	    if (len > maxSafeInteger) {
	        return maxSafeInteger;
	    }
	    return len;
	}
	function numberIsFinite(value) {
	    return typeof value === 'number' && _utilRoot.root.isFinite(value);
	}
	function isNan(n) {
	    return n !== n;
	}
	function sign(value) {
	    var valueAsNumber = +value;
	    if (valueAsNumber === 0) {
	        return valueAsNumber;
	    }
	    if (isNaN(valueAsNumber)) {
	        return valueAsNumber;
	    }
	    return valueAsNumber < 0 ? -1 : 1;
	}
	module.exports = exports['default'];

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _Observable2 = __webpack_require__(4);
	
	var _Observable3 = _interopRequireDefault(_Observable2);
	
	var RangeObservable = (function (_Observable) {
	    _inherits(RangeObservable, _Observable);
	
	    function RangeObservable(start, end, scheduler) {
	        _classCallCheck(this, RangeObservable);
	
	        _Observable.call(this);
	        this.start = start;
	        this.end = end;
	        this.scheduler = scheduler;
	    }
	
	    RangeObservable.create = function create(start, end, scheduler) {
	        if (start === undefined) start = 0;
	        if (end === undefined) end = 0;
	
	        return new RangeObservable(start, end, scheduler);
	    };
	
	    RangeObservable.dispatch = function dispatch(state) {
	        var start = state.start;
	        var index = state.index;
	        var end = state.end;
	        var subscriber = state.subscriber;
	
	        if (index >= end) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(start);
	        if (subscriber.isUnsubscribed) {
	            return;
	        }
	        state.index = index + 1;
	        state.start = start + 1;
	        this.schedule(state);
	    };
	
	    RangeObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var index = 0;
	        var start = this.start;
	        var end = this.end;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            subscriber.add(scheduler.schedule(RangeObservable.dispatch, 0, {
	                index: index, end: end, start: start, subscriber: subscriber
	            }));
	        } else {
	            do {
	                if (index++ >= end) {
	                    subscriber.complete();
	                    break;
	                }
	                subscriber.next(start++);
	                if (subscriber.isUnsubscribed) {
	                    break;
	                }
	            } while (true);
	        }
	    };
	
	    return RangeObservable;
	})(_Observable3['default']);
	
	exports['default'] = RangeObservable;
	module.exports = exports['default'];

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _Observable2 = __webpack_require__(4);
	
	var _Observable3 = _interopRequireDefault(_Observable2);
	
	var _schedulersNextTick = __webpack_require__(13);
	
	var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);
	
	var SubscribeOnObservable = (function (_Observable) {
	    _inherits(SubscribeOnObservable, _Observable);
	
	    function SubscribeOnObservable(source) {
	        var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	        var scheduler = arguments.length <= 2 || arguments[2] === undefined ? _schedulersNextTick2['default'] : arguments[2];
	
	        _classCallCheck(this, SubscribeOnObservable);
	
	        _Observable.call(this);
	        this.source = source;
	        this.delayTime = delay;
	        this.scheduler = scheduler;
	    }
	
	    SubscribeOnObservable.create = function create(source) {
	        var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	        var scheduler = arguments.length <= 2 || arguments[2] === undefined ? _schedulersNextTick2['default'] : arguments[2];
	
	        return new SubscribeOnObservable(source, delay, scheduler);
	    };
	
	    SubscribeOnObservable.dispatch = function dispatch(_ref) {
	        var source = _ref.source;
	        var subscriber = _ref.subscriber;
	
	        return source.subscribe(subscriber);
	    };
	
	    SubscribeOnObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var delay = this.delayTime;
	        var source = this.source;
	        var scheduler = this.scheduler;
	        subscriber.add(scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
	            source: source, subscriber: subscriber
	        }));
	    };
	
	    return SubscribeOnObservable;
	})(_Observable3['default']);
	
	exports['default'] = SubscribeOnObservable;
	module.exports = exports['default'];

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _utilIsNumeric = __webpack_require__(64);
	
	var _utilIsNumeric2 = _interopRequireDefault(_utilIsNumeric);
	
	var _Observable2 = __webpack_require__(4);
	
	var _Observable3 = _interopRequireDefault(_Observable2);
	
	var _schedulersNextTick = __webpack_require__(13);
	
	var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);
	
	var TimerObservable = (function (_Observable) {
	    _inherits(TimerObservable, _Observable);
	
	    function TimerObservable(dueTime, period, scheduler) {
	        if (dueTime === undefined) dueTime = 0;
	
	        _classCallCheck(this, TimerObservable);
	
	        _Observable.call(this);
	        this.dueTime = dueTime;
	        this.period = period;
	        this.scheduler = scheduler;
	        if (_utilIsNumeric2['default'](period)) {
	            this._period = Number(period) < 1 && 1 || Number(period);
	        } else if (period && typeof period.schedule === 'function') {
	            scheduler = period;
	        }
	        if (!scheduler || typeof scheduler.schedule !== 'function') {
	            scheduler = _schedulersNextTick2['default'];
	        }
	        this.scheduler = scheduler;
	    }
	
	    TimerObservable.create = function create(dueTime, period, scheduler) {
	        if (dueTime === undefined) dueTime = 0;
	
	        return new TimerObservable(dueTime, period, scheduler);
	    };
	
	    TimerObservable.dispatch = function dispatch(state) {
	        var index = state.index;
	        var period = state.period;
	        var subscriber = state.subscriber;
	
	        var action = this;
	        subscriber.next(index);
	        if (typeof period === 'undefined') {
	            subscriber.complete();
	            return;
	        } else if (subscriber.isUnsubscribed) {
	            return;
	        }
	        if (typeof action.delay === 'undefined') {
	            action.add(action.scheduler.schedule(TimerObservable.dispatch, period, {
	                index: index + 1, period: period, subscriber: subscriber
	            }));
	        } else {
	            state.index = index + 1;
	            action.schedule(state, period);
	        }
	    };
	
	    TimerObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var index = 0;
	        var period = this._period;
	        var dueTime = this.dueTime;
	        var scheduler = this.scheduler;
	        subscriber.add(scheduler.schedule(TimerObservable.dispatch, dueTime, { index: index, period: period, subscriber: subscriber }));
	    };
	
	    return TimerObservable;
	})(_Observable3['default']);
	
	exports['default'] = TimerObservable;
	module.exports = exports['default'];

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = buffer;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber3 = __webpack_require__(1);
	
	var _Subscriber4 = _interopRequireDefault(_Subscriber3);
	
	/**
	 * buffers the incoming observable values until the passed `closingNotifier` emits a value, at which point
	 * it emits the buffer on the returned observable and starts a new buffer internally, awaiting the
	 * next time `closingNotifier` emits
	 *
	 * @param {Observable<any>} closingNotifier an observable, that signals the buffer to be emitted from the returned observable
	 * @returns {Observable<T[]>} an observable of buffers, which are arrays of values
	 */
	
	function buffer(closingNotifier) {
	    return this.lift(new BufferOperator(closingNotifier));
	}
	
	var BufferOperator = (function () {
	    function BufferOperator(closingNotifier) {
	        _classCallCheck(this, BufferOperator);
	
	        this.closingNotifier = closingNotifier;
	    }
	
	    BufferOperator.prototype.call = function call(subscriber) {
	        return new BufferSubscriber(subscriber, this.closingNotifier);
	    };
	
	    return BufferOperator;
	})();
	
	var BufferSubscriber = (function (_Subscriber) {
	    _inherits(BufferSubscriber, _Subscriber);
	
	    function BufferSubscriber(destination, closingNotifier) {
	        _classCallCheck(this, BufferSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.buffer = [];
	        this.add(closingNotifier._subscribe(new BufferClosingNotifierSubscriber(this)));
	    }
	
	    BufferSubscriber.prototype._next = function _next(value) {
	        this.buffer.push(value);
	    };
	
	    BufferSubscriber.prototype._error = function _error(err) {
	        this.destination.error(err);
	    };
	
	    BufferSubscriber.prototype._complete = function _complete() {
	        this.destination.complete();
	    };
	
	    BufferSubscriber.prototype.flushBuffer = function flushBuffer() {
	        var buffer = this.buffer;
	        this.buffer = [];
	        this.destination.next(buffer);
	    };
	
	    return BufferSubscriber;
	})(_Subscriber4['default']);
	
	var BufferClosingNotifierSubscriber = (function (_Subscriber2) {
	    _inherits(BufferClosingNotifierSubscriber, _Subscriber2);
	
	    function BufferClosingNotifierSubscriber(parent) {
	        _classCallCheck(this, BufferClosingNotifierSubscriber);
	
	        _Subscriber2.call(this, null);
	        this.parent = parent;
	    }
	
	    BufferClosingNotifierSubscriber.prototype._next = function _next(value) {
	        this.parent.flushBuffer();
	    };
	
	    BufferClosingNotifierSubscriber.prototype._error = function _error(err) {
	        this.parent.error(err);
	    };
	
	    BufferClosingNotifierSubscriber.prototype._complete = function _complete() {
	        this.parent.complete();
	    };
	
	    return BufferClosingNotifierSubscriber;
	})(_Subscriber4['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = bufferCount;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	/**
	 * buffers a number of values from the source observable by `bufferSize` then emits the buffer and clears it, and starts a
	 * new buffer each `startBufferEvery` values. If `startBufferEvery` is not provided or is `null`, then new buffers are
	 * started immediately at the start of the source and when each buffer closes and is emitted.
	 * @param {number} bufferSize the maximum size of the buffer emitted.
	 * @param {number} [startBufferEvery] optional interval at which to start a new buffer. (e.g. if `startBufferEvery` is `2`,asdf then a
	 *   new buffer will be started on every other value from the source.) A new buffer is started at the beginning of the source by default.
	 * @returns {Observable<T[]>} an observable of arrays of buffered values.
	 */
	
	function bufferCount(bufferSize) {
	    var startBufferEvery = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	
	    return this.lift(new BufferCountOperator(bufferSize, startBufferEvery));
	}
	
	var BufferCountOperator = (function () {
	    function BufferCountOperator(bufferSize, startBufferEvery) {
	        _classCallCheck(this, BufferCountOperator);
	
	        this.bufferSize = bufferSize;
	        this.startBufferEvery = startBufferEvery;
	    }
	
	    BufferCountOperator.prototype.call = function call(subscriber) {
	        return new BufferCountSubscriber(subscriber, this.bufferSize, this.startBufferEvery);
	    };
	
	    return BufferCountOperator;
	})();
	
	var BufferCountSubscriber = (function (_Subscriber) {
	    _inherits(BufferCountSubscriber, _Subscriber);
	
	    function BufferCountSubscriber(destination, bufferSize, startBufferEvery) {
	        _classCallCheck(this, BufferCountSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.bufferSize = bufferSize;
	        this.startBufferEvery = startBufferEvery;
	        this.buffers = [[]];
	        this.count = 0;
	    }
	
	    BufferCountSubscriber.prototype._next = function _next(value) {
	        var count = this.count += 1;
	        var destination = this.destination;
	        var bufferSize = this.bufferSize;
	        var startBufferEvery = this.startBufferEvery == null ? bufferSize : this.startBufferEvery;
	        var buffers = this.buffers;
	        var len = buffers.length;
	        var remove = -1;
	        if (count % startBufferEvery === 0) {
	            buffers.push([]);
	        }
	        for (var i = 0; i < len; i++) {
	            var buffer = buffers[i];
	            buffer.push(value);
	            if (buffer.length === bufferSize) {
	                remove = i;
	                this.destination.next(buffer);
	            }
	        }
	        if (remove !== -1) {
	            buffers.splice(remove, 1);
	        }
	    };
	
	    BufferCountSubscriber.prototype._error = function _error(err) {
	        this.destination.error(err);
	    };
	
	    BufferCountSubscriber.prototype._complete = function _complete() {
	        var destination = this.destination;
	        var buffers = this.buffers;
	        while (buffers.length > 0) {
	            var buffer = buffers.shift();
	            if (buffer.length > 0) {
	                destination.next(buffer);
	            }
	        }
	        destination.complete();
	    };
	
	    return BufferCountSubscriber;
	})(_Subscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = bufferTime;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	var _schedulersNextTick = __webpack_require__(13);
	
	var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);
	
	/**
	 * buffers values from the source for a specific time period. Optionally allows new buffers to be set up at an interval.
	 * @param {number} the amount of time to fill each buffer for before emitting them and clearing them.
	 * @param {number} [bufferCreationInterval] the interval at which to start new buffers.
	 * @param {Scheduler} [scheduler] (optional, defaults to `nextTick` scheduler) The scheduler on which to schedule the
	 *  intervals that determine buffer boundaries.
	 * @returns {Observable<T[]>} an observable of arrays of buffered values.
	 */
	
	function bufferTime(bufferTimeSpan) {
	    var bufferCreationInterval = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    var scheduler = arguments.length <= 2 || arguments[2] === undefined ? _schedulersNextTick2['default'] : arguments[2];
	
	    return this.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, scheduler));
	}
	
	var BufferTimeOperator = (function () {
	    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, scheduler) {
	        _classCallCheck(this, BufferTimeOperator);
	
	        this.bufferTimeSpan = bufferTimeSpan;
	        this.bufferCreationInterval = bufferCreationInterval;
	        this.scheduler = scheduler;
	    }
	
	    BufferTimeOperator.prototype.call = function call(subscriber) {
	        return new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.scheduler);
	    };
	
	    return BufferTimeOperator;
	})();
	
	var BufferTimeSubscriber = (function (_Subscriber) {
	    _inherits(BufferTimeSubscriber, _Subscriber);
	
	    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, scheduler) {
	        _classCallCheck(this, BufferTimeSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.bufferTimeSpan = bufferTimeSpan;
	        this.bufferCreationInterval = bufferCreationInterval;
	        this.scheduler = scheduler;
	        this.buffers = [];
	        var buffer = this.openBuffer();
	        if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
	            var closeState = { subscriber: this, buffer: buffer };
	            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: this, scheduler: scheduler };
	            this.add(scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
	            this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
	        } else {
	            var timeSpanOnlyState = { subscriber: this, buffer: buffer, bufferTimeSpan: bufferTimeSpan };
	            this.add(scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
	        }
	    }
	
	    BufferTimeSubscriber.prototype._next = function _next(value) {
	        var buffers = this.buffers;
	        var len = buffers.length;
	        for (var i = 0; i < len; i++) {
	            buffers[i].push(value);
	        }
	    };
	
	    BufferTimeSubscriber.prototype._error = function _error(err) {
	        this.buffers.length = 0;
	        this.destination.error(err);
	    };
	
	    BufferTimeSubscriber.prototype._complete = function _complete() {
	        var buffers = this.buffers;
	        while (buffers.length > 0) {
	            this.destination.next(buffers.shift());
	        }
	        this.destination.complete();
	    };
	
	    BufferTimeSubscriber.prototype.openBuffer = function openBuffer() {
	        var buffer = [];
	        this.buffers.push(buffer);
	        return buffer;
	    };
	
	    BufferTimeSubscriber.prototype.closeBuffer = function closeBuffer(buffer) {
	        this.destination.next(buffer);
	        var buffers = this.buffers;
	        buffers.splice(buffers.indexOf(buffer), 1);
	    };
	
	    return BufferTimeSubscriber;
	})(_Subscriber3['default']);
	
	function dispatchBufferTimeSpanOnly(state) {
	    var subscriber = state.subscriber;
	    var prevBuffer = state.buffer;
	    if (prevBuffer) {
	        subscriber.closeBuffer(prevBuffer);
	    }
	    state.buffer = subscriber.openBuffer();
	    if (!subscriber.isUnsubscribed) {
	        this.schedule(state, state.bufferTimeSpan);
	    }
	}
	function dispatchBufferCreation(state) {
	    var bufferCreationInterval = state.bufferCreationInterval;
	    var bufferTimeSpan = state.bufferTimeSpan;
	    var subscriber = state.subscriber;
	    var scheduler = state.scheduler;
	
	    var buffer = subscriber.openBuffer();
	    var action = this;
	    if (!subscriber.isUnsubscribed) {
	        action.add(scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, buffer: buffer }));
	        action.schedule(state, bufferCreationInterval);
	    }
	}
	function dispatchBufferClose(_ref) {
	    var subscriber = _ref.subscriber;
	    var buffer = _ref.buffer;
	
	    subscriber.closeBuffer(buffer);
	}
	module.exports = exports['default'];

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = bufferToggle;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber4 = __webpack_require__(1);
	
	var _Subscriber5 = _interopRequireDefault(_Subscriber4);
	
	var _Subscription = __webpack_require__(5);
	
	var _Subscription2 = _interopRequireDefault(_Subscription);
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	/**
	 * buffers values from the source by opening the buffer via signals from an observable provided to `openings`, and closing
	 * and sending the buffers when an observable returned by the `closingSelector` emits.
	 * @param {Observable<O>} openings An observable of notifications to start new buffers
	 * @param {Function} an function, that takes the value emitted by the `openings` observable and returns an Observable, which,
	 *  when it emits, signals that the associated buffer should be emitted and cleared.
	 * @returns {Observable<T[]>} an observable of arrays of buffered values.
	 */
	
	function bufferToggle(openings, closingSelector) {
	    return this.lift(new BufferToggleOperator(openings, closingSelector));
	}
	
	var BufferToggleOperator = (function () {
	    function BufferToggleOperator(openings, closingSelector) {
	        _classCallCheck(this, BufferToggleOperator);
	
	        this.openings = openings;
	        this.closingSelector = closingSelector;
	    }
	
	    BufferToggleOperator.prototype.call = function call(subscriber) {
	        return new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector);
	    };
	
	    return BufferToggleOperator;
	})();
	
	var BufferToggleSubscriber = (function (_Subscriber) {
	    _inherits(BufferToggleSubscriber, _Subscriber);
	
	    function BufferToggleSubscriber(destination, openings, closingSelector) {
	        _classCallCheck(this, BufferToggleSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.openings = openings;
	        this.closingSelector = closingSelector;
	        this.buffers = [];
	        this.add(this.openings._subscribe(new BufferToggleOpeningsSubscriber(this)));
	    }
	
	    BufferToggleSubscriber.prototype._next = function _next(value) {
	        var buffers = this.buffers;
	        var len = buffers.length;
	        for (var i = 0; i < len; i++) {
	            buffers[i].push(value);
	        }
	    };
	
	    BufferToggleSubscriber.prototype._error = function _error(err) {
	        this.buffers = null;
	        this.destination.error(err);
	    };
	
	    BufferToggleSubscriber.prototype._complete = function _complete() {
	        var buffers = this.buffers;
	        while (buffers.length > 0) {
	            this.destination.next(buffers.shift());
	        }
	        this.destination.complete();
	    };
	
	    BufferToggleSubscriber.prototype.openBuffer = function openBuffer(value) {
	        var closingSelector = this.closingSelector;
	        var buffers = this.buffers;
	        var closingNotifier = _utilTryCatch2['default'](closingSelector)(value);
	        if (closingNotifier === _utilErrorObject.errorObject) {
	            var err = closingNotifier.e;
	            this.buffers = null;
	            this.destination.error(err);
	        } else {
	            var buffer = [];
	            var context = {
	                buffer: buffer,
	                subscription: new _Subscription2['default']()
	            };
	            buffers.push(buffer);
	            var subscriber = new BufferClosingNotifierSubscriber(this, context);
	            var subscription = closingNotifier._subscribe(subscriber);
	            this.add(context.subscription.add(subscription));
	        }
	    };
	
	    BufferToggleSubscriber.prototype.closeBuffer = function closeBuffer(context) {
	        var buffer = context.buffer;
	        var subscription = context.subscription;
	
	        var buffers = this.buffers;
	        this.destination.next(buffer);
	        buffers.splice(buffers.indexOf(buffer), 1);
	        this.remove(subscription);
	        subscription.unsubscribe();
	    };
	
	    return BufferToggleSubscriber;
	})(_Subscriber5['default']);
	
	var BufferClosingNotifierSubscriber = (function (_Subscriber2) {
	    _inherits(BufferClosingNotifierSubscriber, _Subscriber2);
	
	    function BufferClosingNotifierSubscriber(parent, context) {
	        _classCallCheck(this, BufferClosingNotifierSubscriber);
	
	        _Subscriber2.call(this, null);
	        this.parent = parent;
	        this.context = context;
	    }
	
	    BufferClosingNotifierSubscriber.prototype._next = function _next() {
	        this.parent.closeBuffer(this.context);
	    };
	
	    BufferClosingNotifierSubscriber.prototype._error = function _error(err) {
	        this.parent.error(err);
	    };
	
	    BufferClosingNotifierSubscriber.prototype._complete = function _complete() {
	        // noop
	    };
	
	    return BufferClosingNotifierSubscriber;
	})(_Subscriber5['default']);
	
	var BufferToggleOpeningsSubscriber = (function (_Subscriber3) {
	    _inherits(BufferToggleOpeningsSubscriber, _Subscriber3);
	
	    function BufferToggleOpeningsSubscriber(parent) {
	        _classCallCheck(this, BufferToggleOpeningsSubscriber);
	
	        _Subscriber3.call(this, null);
	        this.parent = parent;
	    }
	
	    BufferToggleOpeningsSubscriber.prototype._next = function _next(value) {
	        this.parent.openBuffer(value);
	    };
	
	    BufferToggleOpeningsSubscriber.prototype._error = function _error(err) {
	        this.parent.error(err);
	    };
	
	    BufferToggleOpeningsSubscriber.prototype._complete = function _complete() {
	        // noop
	    };
	
	    return BufferToggleOpeningsSubscriber;
	})(_Subscriber5['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = bufferWhen;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber3 = __webpack_require__(1);
	
	var _Subscriber4 = _interopRequireDefault(_Subscriber3);
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	/**
	 * Opens a buffer immediately, then closes the buffer when the observable returned by calling `closingSelector` emits a value.
	 * It that immediately opens a new buffer and repeats the process
	 * @param {function} a function that takes no arguments and returns an Observable that signals buffer closure
	 * @returns {Observable<T[]>} an observable of arrays of buffered values.
	 */
	
	function bufferWhen(closingSelector) {
	    return this.lift(new BufferWhenOperator(closingSelector));
	}
	
	var BufferWhenOperator = (function () {
	    function BufferWhenOperator(closingSelector) {
	        _classCallCheck(this, BufferWhenOperator);
	
	        this.closingSelector = closingSelector;
	    }
	
	    BufferWhenOperator.prototype.call = function call(subscriber) {
	        return new BufferWhenSubscriber(subscriber, this.closingSelector);
	    };
	
	    return BufferWhenOperator;
	})();
	
	var BufferWhenSubscriber = (function (_Subscriber) {
	    _inherits(BufferWhenSubscriber, _Subscriber);
	
	    function BufferWhenSubscriber(destination, closingSelector) {
	        _classCallCheck(this, BufferWhenSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.closingSelector = closingSelector;
	        this.openBuffer();
	    }
	
	    BufferWhenSubscriber.prototype._next = function _next(value) {
	        this.buffer.push(value);
	    };
	
	    BufferWhenSubscriber.prototype._error = function _error(err) {
	        this.buffer = null;
	        this.destination.error(err);
	    };
	
	    BufferWhenSubscriber.prototype._complete = function _complete() {
	        var buffer = this.buffer;
	        this.destination.next(buffer);
	        this.buffer = null;
	        this.destination.complete();
	    };
	
	    BufferWhenSubscriber.prototype.openBuffer = function openBuffer() {
	        var prevClosingNotification = this.closingNotification;
	        if (prevClosingNotification) {
	            this.remove(prevClosingNotification);
	            prevClosingNotification.unsubscribe();
	        }
	        var buffer = this.buffer;
	        if (buffer) {
	            this.destination.next(buffer);
	        }
	        this.buffer = [];
	        var closingNotifier = _utilTryCatch2['default'](this.closingSelector)();
	        if (closingNotifier === _utilErrorObject.errorObject) {
	            var err = closingNotifier.e;
	            this.buffer = null;
	            this.destination.error(err);
	        } else {
	            this.add(this.closingNotification = closingNotifier._subscribe(new BufferClosingNotifierSubscriber(this)));
	        }
	    };
	
	    return BufferWhenSubscriber;
	})(_Subscriber4['default']);
	
	var BufferClosingNotifierSubscriber = (function (_Subscriber2) {
	    _inherits(BufferClosingNotifierSubscriber, _Subscriber2);
	
	    function BufferClosingNotifierSubscriber(parent) {
	        _classCallCheck(this, BufferClosingNotifierSubscriber);
	
	        _Subscriber2.call(this, null);
	        this.parent = parent;
	    }
	
	    BufferClosingNotifierSubscriber.prototype._next = function _next() {
	        this.parent.openBuffer();
	    };
	
	    BufferClosingNotifierSubscriber.prototype._error = function _error(err) {
	        this.parent.error(err);
	    };
	
	    BufferClosingNotifierSubscriber.prototype._complete = function _complete() {
	        this.parent.openBuffer();
	    };
	
	    return BufferClosingNotifierSubscriber;
	})(_Subscriber4['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = _catch;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	/**
	 * Catches errors on the observable to be handled by returning a new observable or throwing an error.
	 * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
	 *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
	 *  is returned by the `selector` will be used to continue the observable chain.
	 * @return {Observable} an observable that originates from either the source or the observable returned by the
	 *  catch `selector` function.
	 */
	
	function _catch(selector) {
	    var catchOperator = new CatchOperator(selector);
	    var caught = this.lift(catchOperator);
	    catchOperator.caught = caught;
	    return caught;
	}
	
	var CatchOperator = (function () {
	    function CatchOperator(selector) {
	        _classCallCheck(this, CatchOperator);
	
	        this.selector = selector;
	    }
	
	    CatchOperator.prototype.call = function call(subscriber) {
	        return new CatchSubscriber(subscriber, this.selector, this.caught);
	    };
	
	    return CatchOperator;
	})();
	
	var CatchSubscriber = (function (_Subscriber) {
	    _inherits(CatchSubscriber, _Subscriber);
	
	    function CatchSubscriber(destination, selector, caught) {
	        _classCallCheck(this, CatchSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.selector = selector;
	        this.caught = caught;
	    }
	
	    CatchSubscriber.prototype._error = function _error(err) {
	        var result = _utilTryCatch2['default'](this.selector)(err, this.caught);
	        if (result === _utilErrorObject.errorObject) {
	            this.destination.error(_utilErrorObject.errorObject.e);
	        } else {
	            this.add(result.subscribe(this.destination));
	        }
	    };
	
	    return CatchSubscriber;
	})(_Subscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = combineAll;
	
	var _combineLatestSupport = __webpack_require__(31);
	
	/**
	 * Takes an Observable of Observables, and collects all observables from it. Once the outer observable
	 * completes, it subscribes to all collected observables and "combines" their values, such that:
	 *  - every time an observable emits, the returned observable emits
	 *  - when the returned observable emits, it emits all of the most recent values by:
	 *    - if a `project` function is provided, it is called with each recent value from each observable in whatever order they arrived,
	 *      and the result of the `project` function is what is emitted by the returned observable
	 *    - if there is no `project` function, an array of all of the most recent values is emitted by the returned observable.
	 * @param {function} [project] an optional function to map the most recent values from each observable into a new result. Takes each of the
	 *   most recent values from each collected observable as arguments, in order.
	 * @returns {Observable} an observable of projected results or arrays of recent values.
	 */
	
	function combineAll(project) {
	  return this.lift(new _combineLatestSupport.CombineLatestOperator(project));
	}
	
	module.exports = exports['default'];

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = combineLatest;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _observablesArrayObservable = __webpack_require__(14);
	
	var _observablesArrayObservable2 = _interopRequireDefault(_observablesArrayObservable);
	
	var _combineLatestSupport = __webpack_require__(31);
	
	/**
	 * Combines the values from observables passed as arguments. This is done by subscribing
	 * to each observable, in order, and collecting an array of each of the most recent values any time any of the observables
	 * emits, then either taking that array and passing it as arguments to an option `project` function and emitting the return
	 * value of that, or just emitting the array of recent values directly if there is no `project` function.
	 * @param {...Observable} observables the observables to combine
	 * @param {function} [project] an optional function to project the values from the combined recent values into a new value for emission.
	 * @returns {Observable} an observable of other projected values from the most recent values from each observable, or an array of each of
	 * the most recent values from each observable.
	 */
	
	function combineLatest() {
	    var project = undefined,
	        scheduler = undefined;
	
	    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
	        observables[_key] = arguments[_key];
	    }
	
	    if (typeof observables[observables.length - 1].schedule === 'function') {
	        scheduler = observables.pop();
	    }
	    if (typeof observables[observables.length - 1] === 'function') {
	        project = observables.pop();
	    }
	    return new _observablesArrayObservable2['default'](observables, scheduler).lift(new _combineLatestSupport.CombineLatestOperator(project));
	}
	
	module.exports = exports['default'];

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = combineLatest;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _observablesArrayObservable = __webpack_require__(14);
	
	var _observablesArrayObservable2 = _interopRequireDefault(_observablesArrayObservable);
	
	var _combineLatestSupport = __webpack_require__(31);
	
	/**
	 * Combines the values from this observable with values from observables passed as arguments. This is done by subscribing
	 * to each observable, in order, and collecting an array of each of the most recent values any time any of the observables
	 * emits, then either taking that array and passing it as arguments to an option `project` function and emitting the return
	 * value of that, or just emitting the array of recent values directly if there is no `project` function.
	 * @param {...Observable} observables the observables to combine the source with
	 * @param {function} [project] an optional function to project the values from the combined recent values into a new value for emission.
	 * @returns {Observable} an observable of other projected values from the most recent values from each observable, or an array of each of
	 * the most recent values from each observable.
	 */
	
	function combineLatest() {
	    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
	        observables[_key] = arguments[_key];
	    }
	
	    observables.unshift(this);
	    var project = undefined;
	    if (typeof observables[observables.length - 1] === 'function') {
	        project = observables.pop();
	    }
	    return new _observablesArrayObservable2['default'](observables).lift(new _combineLatestSupport.CombineLatestOperator(project));
	}
	
	module.exports = exports['default'];

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = concat;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _Observable = __webpack_require__(4);
	
	var _Observable2 = _interopRequireDefault(_Observable);
	
	/**
	 * Joins this observable with multiple other observables by subscribing to them one at a time, starting with the source,
	 * and merging their results into the returned observable. Will wait for each observable to complete before moving
	 * on to the next.
	 * @params {...Observable} the observables to concatenate
	 * @params {Scheduler} [scheduler] an optional scheduler to schedule each observable subscription on.
	 * @returns {Observable} All values of each passed observable merged into a single observable, in order, in serial fashion.
	 */
	
	function concat() {
	    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
	        observables[_key] = arguments[_key];
	    }
	
	    var args = observables;
	    args.unshift(this);
	    if (args.length > 1 && typeof args[args.length - 1].schedule === 'function') {
	        args.splice(args.length - 2, 0, 1);
	    }
	    return _Observable2['default'].fromArray(args).mergeAll(1);
	}
	
	module.exports = exports['default'];

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = concatAll;
	
	var _mergeAllSupport = __webpack_require__(32);
	
	/**
	 * Joins every Observable emitted by the source (an Observable of Observables), in a serial
	 * fashion. Subscribing to each one only when the previous one has completed, and merging
	 * all of their values into the returned observable.
	 *
	 * __Warning:__ If the source Observable emits Observables quickly and endlessly, and the
	 * Observables it emits generally complete slower than the source emits, you can run into
	 * memory issues as the incoming observables collect in an unbounded buffer.
	 *
	 * @returns {Observable} an observable of values merged from the incoming observables.
	 */
	
	function concatAll() {
	  return this.lift(new _mergeAllSupport.MergeAllOperator(1));
	}
	
	module.exports = exports['default'];

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = concatMap;
	
	var _mergeMapSupport = __webpack_require__(49);
	
	/**
	 * Maps values from the source observable into new Observables, then merges them in a serialized fashion,
	 * waiting for each one to complete before merging the next.
	 *
	 * __Warning:__ if incoming values arrive endlessly and faster than the observables they're being mapped
	 * to can complete, it will result in memory issues as created observables amass in an unbounded buffer
	 * waiting for their turn to be subscribed to.
	 *
	 * @param {function} project a function to map incoming values into Observables to be concatenated. accepts
	 * the `value` and the `index` as arguments.
	 * @param {function} [projectResult] an optional result selector that is applied to values before they're
	 * merged into the returned observable. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @returns {Observable} an observable of values merged from the projected Observables as they were subscribed to,
	 * one at a time. Optionally, these values may have been projected from a passed `projectResult` argument.
	 */
	
	function concatMap(project, projectResult) {
	  return this.lift(new _mergeMapSupport.MergeMapOperator(project, projectResult, 1));
	}
	
	module.exports = exports['default'];

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = concatMapTo;
	
	var _mergeMapToSupport = __webpack_require__(33);
	
	/**
	 * Maps values from the source to a specific observable, and merges them together in a serialized fashion.
	 *
	 * @param {Observable} observable the observable to map each source value to
	 * @param {function} [projectResult] an optional result selector that is applied to values before they're
	 * merged into the returned observable. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @returns {Observable} an observable of values merged together by joining the passed observable
	 * with itself, one after the other, for each value emitted from the source.
	 */
	
	function concatMapTo(observable, projectResult) {
	  return this.lift(new _mergeMapToSupport.MergeMapToOperator(observable, projectResult, 1));
	}
	
	module.exports = exports['default'];

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = count;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	var _utilBindCallback = __webpack_require__(15);
	
	var _utilBindCallback2 = _interopRequireDefault(_utilBindCallback);
	
	/**
	 * Returns an observable of a single number that represents the number of items that either:
	 * Match a provided predicate function, _or_ if a predicate is not provided, the number
	 * represents the total count of all items in the source observable. The count is emitted
	 * by the returned observable when the source observable completes.
	 * @param {function} [predicate] a boolean function to select what values are to be counted.
	 * it is provided with arguments of:
	 *   - `value`: the value from the source observable
	 *   - `index`: the "index" of the value from the source observable
	 *   - `source`: the source observable instance itself.
	 * @param {any} [thisArg] the optional `this` context to use in the `predicate` function
	 * @returns {Observable} an observable of one number that represents the count as described
	 * above
	 */
	
	function count(predicate, thisArg) {
	    return this.lift(new CountOperator(predicate, thisArg, this));
	}
	
	var CountOperator = (function () {
	    function CountOperator(predicate, thisArg, source) {
	        _classCallCheck(this, CountOperator);
	
	        this.predicate = predicate;
	        this.thisArg = thisArg;
	        this.source = source;
	    }
	
	    CountOperator.prototype.call = function call(subscriber) {
	        return new CountSubscriber(subscriber, this.predicate, this.thisArg, this.source);
	    };
	
	    return CountOperator;
	})();
	
	var CountSubscriber = (function (_Subscriber) {
	    _inherits(CountSubscriber, _Subscriber);
	
	    function CountSubscriber(destination, predicate, thisArg, source) {
	        _classCallCheck(this, CountSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.thisArg = thisArg;
	        this.source = source;
	        this.count = 0;
	        this.index = 0;
	        if (typeof predicate === 'function') {
	            this.predicate = _utilBindCallback2['default'](predicate, thisArg, 3);
	        }
	    }
	
	    CountSubscriber.prototype._next = function _next(value) {
	        var predicate = this.predicate;
	        var passed = true;
	        if (predicate) {
	            passed = _utilTryCatch2['default'](predicate)(value, this.index++, this.source);
	            if (passed === _utilErrorObject.errorObject) {
	                this.destination.error(passed.e);
	                return;
	            }
	        }
	        if (passed) {
	            this.count += 1;
	        }
	    };
	
	    CountSubscriber.prototype._complete = function _complete() {
	        this.destination.next(this.count);
	        this.destination.complete();
	    };
	
	    return CountSubscriber;
	})(_Subscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	exports['default'] = debounce;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _observablesPromiseObservable = __webpack_require__(29);
	
	var _observablesPromiseObservable2 = _interopRequireDefault(_observablesPromiseObservable);
	
	var _Subscriber3 = __webpack_require__(1);
	
	var _Subscriber4 = _interopRequireDefault(_Subscriber3);
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	function debounce(durationSelector) {
	    return this.lift(new DebounceOperator(durationSelector));
	}
	
	var DebounceOperator = (function () {
	    function DebounceOperator(durationSelector) {
	        _classCallCheck(this, DebounceOperator);
	
	        this.durationSelector = durationSelector;
	    }
	
	    DebounceOperator.prototype.call = function call(observer) {
	        return new DebounceSubscriber(observer, this.durationSelector);
	    };
	
	    return DebounceOperator;
	})();
	
	var DebounceSubscriber = (function (_Subscriber) {
	    _inherits(DebounceSubscriber, _Subscriber);
	
	    function DebounceSubscriber(destination, durationSelector) {
	        _classCallCheck(this, DebounceSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.durationSelector = durationSelector;
	        this.debouncedSubscription = null;
	        this.lastValue = null;
	        this._index = 0;
	    }
	
	    DebounceSubscriber.prototype._next = function _next(value) {
	        var destination = this.destination;
	        var currentIndex = ++this._index;
	        var debounce = _utilTryCatch2['default'](this.durationSelector)(value);
	        if (debounce === _utilErrorObject.errorObject) {
	            destination.error(_utilErrorObject.errorObject.e);
	        } else {
	            if (typeof debounce.subscribe !== 'function' && typeof debounce.then === 'function') {
	                debounce = _observablesPromiseObservable2['default'].create(debounce);
	            }
	            this.lastValue = value;
	            this.add(this.debouncedSubscription = debounce._subscribe(new DurationSelectorSubscriber(this, currentIndex)));
	        }
	    };
	
	    DebounceSubscriber.prototype._complete = function _complete() {
	        this.debouncedNext();
	        this.destination.complete();
	    };
	
	    DebounceSubscriber.prototype.debouncedNext = function debouncedNext() {
	        this.clearDebounce();
	        if (this.lastValue != null) {
	            this.destination.next(this.lastValue);
	            this.lastValue = null;
	        }
	    };
	
	    DebounceSubscriber.prototype.clearDebounce = function clearDebounce() {
	        var debouncedSubscription = this.debouncedSubscription;
	        if (debouncedSubscription !== null) {
	            this.remove(debouncedSubscription);
	            this.debouncedSubscription = null;
	        }
	    };
	
	    _createClass(DebounceSubscriber, [{
	        key: 'index',
	        get: function get() {
	            return this._index;
	        }
	    }]);
	
	    return DebounceSubscriber;
	})(_Subscriber4['default']);
	
	var DurationSelectorSubscriber = (function (_Subscriber2) {
	    _inherits(DurationSelectorSubscriber, _Subscriber2);
	
	    function DurationSelectorSubscriber(parent, currentIndex) {
	        _classCallCheck(this, DurationSelectorSubscriber);
	
	        _Subscriber2.call(this, null);
	        this.parent = parent;
	        this.currentIndex = currentIndex;
	    }
	
	    DurationSelectorSubscriber.prototype.debounceNext = function debounceNext() {
	        var parent = this.parent;
	        if (this.currentIndex === parent.index) {
	            parent.debouncedNext();
	            if (!this.isUnsubscribed) {
	                this.unsubscribe();
	            }
	        }
	    };
	
	    DurationSelectorSubscriber.prototype._next = function _next(unused) {
	        this.debounceNext();
	    };
	
	    DurationSelectorSubscriber.prototype._error = function _error(err) {
	        this.parent.error(err);
	    };
	
	    DurationSelectorSubscriber.prototype._complete = function _complete() {
	        this.debounceNext();
	    };
	
	    return DurationSelectorSubscriber;
	})(_Subscriber4['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = debounceTime;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	var _schedulersNextTick = __webpack_require__(13);
	
	var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);
	
	function debounceTime(dueTime) {
	    var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersNextTick2['default'] : arguments[1];
	
	    return this.lift(new DebounceTimeOperator(dueTime, scheduler));
	}
	
	var DebounceTimeOperator = (function () {
	    function DebounceTimeOperator(dueTime, scheduler) {
	        _classCallCheck(this, DebounceTimeOperator);
	
	        this.dueTime = dueTime;
	        this.scheduler = scheduler;
	    }
	
	    DebounceTimeOperator.prototype.call = function call(subscriber) {
	        return new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler);
	    };
	
	    return DebounceTimeOperator;
	})();
	
	var DebounceTimeSubscriber = (function (_Subscriber) {
	    _inherits(DebounceTimeSubscriber, _Subscriber);
	
	    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
	        _classCallCheck(this, DebounceTimeSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.dueTime = dueTime;
	        this.scheduler = scheduler;
	        this.debouncedSubscription = null;
	        this.lastValue = null;
	    }
	
	    DebounceTimeSubscriber.prototype._next = function _next(value) {
	        this.clearDebounce();
	        this.lastValue = value;
	        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
	    };
	
	    DebounceTimeSubscriber.prototype._complete = function _complete() {
	        this.debouncedNext();
	        this.destination.complete();
	    };
	
	    DebounceTimeSubscriber.prototype.debouncedNext = function debouncedNext() {
	        this.clearDebounce();
	        if (this.lastValue != null) {
	            this.destination.next(this.lastValue);
	            this.lastValue = null;
	        }
	    };
	
	    DebounceTimeSubscriber.prototype.clearDebounce = function clearDebounce() {
	        var debouncedSubscription = this.debouncedSubscription;
	        if (debouncedSubscription !== null) {
	            this.remove(debouncedSubscription);
	            debouncedSubscription.unsubscribe();
	            this.debouncedSubscription = null;
	        }
	    };
	
	    return DebounceTimeSubscriber;
	})(_Subscriber3['default']);
	
	function dispatchNext(subscriber) {
	    subscriber.debouncedNext();
	}
	module.exports = exports['default'];

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = defaultIfEmpty;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	function defaultIfEmpty() {
	    var defaultValue = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	
	    return this.lift(new DefaultIfEmptyOperator(defaultValue));
	}
	
	var DefaultIfEmptyOperator = (function () {
	    function DefaultIfEmptyOperator(defaultValue) {
	        _classCallCheck(this, DefaultIfEmptyOperator);
	
	        this.defaultValue = defaultValue;
	    }
	
	    DefaultIfEmptyOperator.prototype.call = function call(subscriber) {
	        return new DefaultIfEmptySubscriber(subscriber, this.defaultValue);
	    };
	
	    return DefaultIfEmptyOperator;
	})();
	
	var DefaultIfEmptySubscriber = (function (_Subscriber) {
	    _inherits(DefaultIfEmptySubscriber, _Subscriber);
	
	    function DefaultIfEmptySubscriber(destination, defaultValue) {
	        _classCallCheck(this, DefaultIfEmptySubscriber);
	
	        _Subscriber.call(this, destination);
	        this.defaultValue = defaultValue;
	        this.isEmpty = true;
	    }
	
	    DefaultIfEmptySubscriber.prototype._next = function _next(x) {
	        this.isEmpty = false;
	        this.destination.next(x);
	    };
	
	    DefaultIfEmptySubscriber.prototype._complete = function _complete() {
	        if (this.isEmpty) {
	            this.destination.next(this.defaultValue);
	        }
	        this.destination.complete();
	    };
	
	    return DefaultIfEmptySubscriber;
	})(_Subscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = delay;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	var _Notification = __webpack_require__(18);
	
	var _Notification2 = _interopRequireDefault(_Notification);
	
	var _schedulersImmediate = __webpack_require__(10);
	
	var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);
	
	function delay(delay) {
	    var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersImmediate2['default'] : arguments[1];
	
	    return this.lift(new DelayOperator(delay, scheduler));
	}
	
	var DelayOperator = (function () {
	    function DelayOperator(delay, scheduler) {
	        _classCallCheck(this, DelayOperator);
	
	        this.delay = delay;
	        this.scheduler = scheduler;
	    }
	
	    DelayOperator.prototype.call = function call(subscriber) {
	        return new DelaySubscriber(subscriber, this.delay, this.scheduler);
	    };
	
	    return DelayOperator;
	})();
	
	var DelaySubscriber = (function (_Subscriber) {
	    _inherits(DelaySubscriber, _Subscriber);
	
	    function DelaySubscriber(destination, delay, scheduler) {
	        _classCallCheck(this, DelaySubscriber);
	
	        _Subscriber.call(this, destination);
	        this.queue = [];
	        this.active = false;
	        this.errored = false;
	        this.delay = delay;
	        this.scheduler = scheduler;
	    }
	
	    DelaySubscriber.dispatch = function dispatch(state) {
	        var source = state.source;
	        var queue = source.queue;
	        var scheduler = state.scheduler;
	        var destination = state.destination;
	        while (queue.length > 0 && queue[0].time - scheduler.now() <= 0) {
	            queue.shift().notification.observe(destination);
	        }
	        if (queue.length > 0) {
	            var _delay = Math.max(0, queue[0].time - scheduler.now());
	            this.schedule(state, _delay);
	        } else {
	            source.active = false;
	        }
	    };
	
	    DelaySubscriber.prototype._next = function _next(x) {
	        if (this.errored) {
	            return;
	        }
	        var scheduler = this.scheduler;
	        this.queue.push(new DelayMessage(scheduler.now() + this.delay, _Notification2['default'].createNext(x)));
	        if (this.active === false) {
	            this._schedule(scheduler);
	        }
	    };
	
	    DelaySubscriber.prototype._error = function _error(e) {
	        var scheduler = this.scheduler;
	        this.errored = true;
	        this.queue = [new DelayMessage(scheduler.now() + this.delay, _Notification2['default'].createError(e))];
	        if (this.active === false) {
	            this._schedule(scheduler);
	        }
	    };
	
	    DelaySubscriber.prototype._complete = function _complete() {
	        if (this.errored) {
	            return;
	        }
	        var scheduler = this.scheduler;
	        this.queue.push(new DelayMessage(scheduler.now() + this.delay, _Notification2['default'].createComplete()));
	        if (this.active === false) {
	            this._schedule(scheduler);
	        }
	    };
	
	    DelaySubscriber.prototype._schedule = function _schedule(scheduler) {
	        this.active = true;
	        this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
	            source: this, destination: this.destination, scheduler: scheduler
	        }));
	    };
	
	    return DelaySubscriber;
	})(_Subscriber3['default']);
	
	var DelayMessage = function DelayMessage(time, notification) {
	    _classCallCheck(this, DelayMessage);
	
	    this.time = time;
	    this.notification = notification;
	};
	
	module.exports = exports['default'];

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = dematerialize;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	function dematerialize() {
	    return this.lift(new DeMaterializeOperator());
	}
	
	var DeMaterializeOperator = (function () {
	    function DeMaterializeOperator() {
	        _classCallCheck(this, DeMaterializeOperator);
	    }
	
	    DeMaterializeOperator.prototype.call = function call(subscriber) {
	        return new DeMaterializeSubscriber(subscriber);
	    };
	
	    return DeMaterializeOperator;
	})();
	
	var DeMaterializeSubscriber = (function (_Subscriber) {
	    _inherits(DeMaterializeSubscriber, _Subscriber);
	
	    function DeMaterializeSubscriber(destination) {
	        _classCallCheck(this, DeMaterializeSubscriber);
	
	        _Subscriber.call(this, destination);
	    }
	
	    DeMaterializeSubscriber.prototype._next = function _next(value) {
	        value.observe(this.destination);
	    };
	
	    return DeMaterializeSubscriber;
	})(_Subscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = _do;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	var _utilNoop = __webpack_require__(65);
	
	var _utilNoop2 = _interopRequireDefault(_utilNoop);
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	function _do(nextOrObserver, error, complete) {
	    var next = undefined;
	    if (nextOrObserver && typeof nextOrObserver === 'object') {
	        next = nextOrObserver.next;
	        error = nextOrObserver.error;
	        complete = nextOrObserver.complete;
	    } else {
	        next = nextOrObserver;
	    }
	    return this.lift(new DoOperator(next || _utilNoop2['default'], error || _utilNoop2['default'], complete || _utilNoop2['default']));
	}
	
	var DoOperator = (function () {
	    function DoOperator(next, error, complete) {
	        _classCallCheck(this, DoOperator);
	
	        this.next = next;
	        this.error = error;
	        this.complete = complete;
	    }
	
	    DoOperator.prototype.call = function call(subscriber) {
	        return new DoSubscriber(subscriber, this.next, this.error, this.complete);
	    };
	
	    return DoOperator;
	})();
	
	var DoSubscriber = (function (_Subscriber) {
	    _inherits(DoSubscriber, _Subscriber);
	
	    function DoSubscriber(destination, next, error, complete) {
	        _classCallCheck(this, DoSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.__next = next;
	        this.__error = error;
	        this.__complete = complete;
	    }
	
	    DoSubscriber.prototype._next = function _next(x) {
	        var result = _utilTryCatch2['default'](this.__next)(x);
	        if (result === _utilErrorObject.errorObject) {
	            this.destination.error(_utilErrorObject.errorObject.e);
	        } else {
	            this.destination.next(x);
	        }
	    };
	
	    DoSubscriber.prototype._error = function _error(e) {
	        var result = _utilTryCatch2['default'](this.__error)(e);
	        if (result === _utilErrorObject.errorObject) {
	            this.destination.error(_utilErrorObject.errorObject.e);
	        } else {
	            this.destination.error(e);
	        }
	    };
	
	    DoSubscriber.prototype._complete = function _complete() {
	        var result = _utilTryCatch2['default'](this.__complete)();
	        if (result === _utilErrorObject.errorObject) {
	            this.destination.error(_utilErrorObject.errorObject.e);
	        } else {
	            this.destination.complete();
	        }
	    };
	
	    return DoSubscriber;
	})(_Subscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = every;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _observablesScalarObservable = __webpack_require__(30);
	
	var _observablesScalarObservable2 = _interopRequireDefault(_observablesScalarObservable);
	
	var _observablesArrayObservable = __webpack_require__(14);
	
	var _observablesArrayObservable2 = _interopRequireDefault(_observablesArrayObservable);
	
	var _observablesErrorObservable = __webpack_require__(28);
	
	var _observablesErrorObservable2 = _interopRequireDefault(_observablesErrorObservable);
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	var _utilBindCallback = __webpack_require__(15);
	
	var _utilBindCallback2 = _interopRequireDefault(_utilBindCallback);
	
	function every(predicate, thisArg) {
	    var source = this;
	    var result = undefined;
	    if (source._isScalar) {
	        result = _utilTryCatch2['default'](predicate)(source.value, 0, source);
	        if (result === _utilErrorObject.errorObject) {
	            return new _observablesErrorObservable2['default'](_utilErrorObject.errorObject.e, source.scheduler);
	        } else {
	            return new _observablesScalarObservable2['default'](result, source.scheduler);
	        }
	    }
	    if (source instanceof _observablesArrayObservable2['default']) {
	        var array = source.array;
	        var _result = _utilTryCatch2['default'](function (array, predicate) {
	            return array.every(predicate);
	        })(array, predicate);
	        if (_result === _utilErrorObject.errorObject) {
	            return new _observablesErrorObservable2['default'](_utilErrorObject.errorObject.e, source.scheduler);
	        } else {
	            return new _observablesScalarObservable2['default'](_result, source.scheduler);
	        }
	    }
	    return source.lift(new EveryOperator(predicate, thisArg, source));
	}
	
	var EveryOperator = (function () {
	    function EveryOperator(predicate, thisArg, source) {
	        _classCallCheck(this, EveryOperator);
	
	        this.predicate = predicate;
	        this.thisArg = thisArg;
	        this.source = source;
	    }
	
	    EveryOperator.prototype.call = function call(observer) {
	        return new EverySubscriber(observer, this.predicate, this.thisArg, this.source);
	    };
	
	    return EveryOperator;
	})();
	
	var EverySubscriber = (function (_Subscriber) {
	    _inherits(EverySubscriber, _Subscriber);
	
	    function EverySubscriber(destination, predicate, thisArg, source) {
	        _classCallCheck(this, EverySubscriber);
	
	        _Subscriber.call(this, destination);
	        this.thisArg = thisArg;
	        this.source = source;
	        this.predicate = undefined;
	        this.index = 0;
	        if (typeof predicate === 'function') {
	            this.predicate = _utilBindCallback2['default'](predicate, thisArg, 3);
	        }
	    }
	
	    EverySubscriber.prototype.notifyComplete = function notifyComplete(everyValueMatch) {
	        this.destination.next(everyValueMatch);
	        this.destination.complete();
	    };
	
	    EverySubscriber.prototype._next = function _next(value) {
	        var predicate = this.predicate;
	        if (predicate === undefined) {
	            this.destination.error(new TypeError('predicate must be a function'));
	        }
	        var result = _utilTryCatch2['default'](predicate)(value, this.index++, this.source);
	        if (result === _utilErrorObject.errorObject) {
	            this.destination.error(result.e);
	        } else if (!result) {
	            this.notifyComplete(false);
	        }
	    };
	
	    EverySubscriber.prototype._complete = function _complete() {
	        this.notifyComplete(true);
	    };
	
	    return EverySubscriber;
	})(_Subscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	var _OuterSubscriber2 = __webpack_require__(9);
	
	var _OuterSubscriber3 = _interopRequireDefault(_OuterSubscriber2);
	
	var _utilSubscribeToResult = __webpack_require__(11);
	
	var _utilSubscribeToResult2 = _interopRequireDefault(_utilSubscribeToResult);
	
	var ExpandOperator = (function () {
	    function ExpandOperator(project) {
	        var concurrent = arguments.length <= 1 || arguments[1] === undefined ? Number.POSITIVE_INFINITY : arguments[1];
	
	        _classCallCheck(this, ExpandOperator);
	
	        this.project = project;
	        this.concurrent = concurrent;
	    }
	
	    ExpandOperator.prototype.call = function call(subscriber) {
	        return new ExpandSubscriber(subscriber, this.project, this.concurrent);
	    };
	
	    return ExpandOperator;
	})();
	
	exports.ExpandOperator = ExpandOperator;
	
	var ExpandSubscriber = (function (_OuterSubscriber) {
	    _inherits(ExpandSubscriber, _OuterSubscriber);
	
	    function ExpandSubscriber(destination, project) {
	        var concurrent = arguments.length <= 2 || arguments[2] === undefined ? Number.POSITIVE_INFINITY : arguments[2];
	
	        _classCallCheck(this, ExpandSubscriber);
	
	        _OuterSubscriber.call(this, destination);
	        this.project = project;
	        this.concurrent = concurrent;
	        this.index = 0;
	        this.active = 0;
	        this.hasCompleted = false;
	        if (concurrent < Number.POSITIVE_INFINITY) {
	            this.buffer = [];
	        }
	    }
	
	    ExpandSubscriber.prototype._next = function _next(value) {
	        var index = this.index++;
	        this.destination.next(value);
	        if (this.active < this.concurrent) {
	            var result = _utilTryCatch2['default'](this.project)(value, index);
	            if (result === _utilErrorObject.errorObject) {
	                this.destination.error(result.e);
	            } else {
	                if (result._isScalar) {
	                    this._next(result.value);
	                } else {
	                    this.active++;
	                    this.add(_utilSubscribeToResult2['default'](this, result, value, index));
	                }
	            }
	        } else {
	            this.buffer.push(value);
	        }
	    };
	
	    ExpandSubscriber.prototype._complete = function _complete() {
	        this.hasCompleted = true;
	        if (this.hasCompleted && this.active === 0) {
	            this.destination.complete();
	        }
	    };
	
	    ExpandSubscriber.prototype.notifyComplete = function notifyComplete(innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer && buffer.length > 0) {
	            this._next(buffer.shift());
	        }
	        if (this.hasCompleted && this.active === 0) {
	            this.destination.complete();
	        }
	    };
	
	    ExpandSubscriber.prototype.notifyNext = function notifyNext(outerValue, innerValue, outerIndex, innerIndex) {
	        this._next(innerValue);
	    };
	
	    return ExpandSubscriber;
	})(_OuterSubscriber3['default']);
	
	exports.ExpandSubscriber = ExpandSubscriber;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = expand;
	
	var _expandSupport = __webpack_require__(118);
	
	function expand(project) {
	    var concurrent = arguments.length <= 1 || arguments[1] === undefined ? Number.POSITIVE_INFINITY : arguments[1];
	
	    return this.lift(new _expandSupport.ExpandOperator(project, concurrent));
	}
	
	module.exports = exports['default'];

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = distinctUntilKeyChanged;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _distinctUntilChanged = __webpack_require__(45);
	
	var _distinctUntilChanged2 = _interopRequireDefault(_distinctUntilChanged);
	
	function distinctUntilKeyChanged(key, compare, thisArg) {
	    return _distinctUntilChanged2['default'].call(this, function (x, y) {
	        if (compare) {
	            return compare.call(thisArg, x[key], y[key]);
	        }
	        return x[key] === y[key];
	    });
	}
	
	module.exports = exports['default'];

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = elementAt;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	var _utilArgumentOutOfRangeError = __webpack_require__(61);
	
	var _utilArgumentOutOfRangeError2 = _interopRequireDefault(_utilArgumentOutOfRangeError);
	
	function elementAt(index, defaultValue) {
	    return this.lift(new ElementAtOperator(index, defaultValue));
	}
	
	var ElementAtOperator = (function () {
	    function ElementAtOperator(index, defaultValue) {
	        _classCallCheck(this, ElementAtOperator);
	
	        this.index = index;
	        this.defaultValue = defaultValue;
	        if (index < 0) {
	            throw new _utilArgumentOutOfRangeError2['default']();
	        }
	    }
	
	    ElementAtOperator.prototype.call = function call(subscriber) {
	        return new ElementAtSubscriber(subscriber, this.index, this.defaultValue);
	    };
	
	    return ElementAtOperator;
	})();
	
	var ElementAtSubscriber = (function (_Subscriber) {
	    _inherits(ElementAtSubscriber, _Subscriber);
	
	    function ElementAtSubscriber(destination, index, defaultValue) {
	        _classCallCheck(this, ElementAtSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.index = index;
	        this.defaultValue = defaultValue;
	    }
	
	    ElementAtSubscriber.prototype._next = function _next(x) {
	        if (this.index-- === 0) {
	            this.destination.next(x);
	            this.destination.complete();
	        }
	    };
	
	    ElementAtSubscriber.prototype._complete = function _complete() {
	        var destination = this.destination;
	        if (this.index >= 0) {
	            if (typeof this.defaultValue !== 'undefined') {
	                destination.next(this.defaultValue);
	            } else {
	                destination.error(new _utilArgumentOutOfRangeError2['default']());
	            }
	        }
	        destination.complete();
	    };
	
	    return ElementAtSubscriber;
	})(_Subscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = find;
	
	var _findSupport = __webpack_require__(46);
	
	function find(predicate, thisArg) {
	    return this.lift(new _findSupport.FindValueOperator(predicate, this, false, thisArg));
	}
	
	module.exports = exports['default'];

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = findIndex;
	
	var _findSupport = __webpack_require__(46);
	
	function findIndex(predicate, thisArg) {
	    return this.lift(new _findSupport.FindValueOperator(predicate, this, true, thisArg));
	}
	
	module.exports = exports['default'];

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = isEmpty;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	function isEmpty() {
	    return this.lift(new IsEmptyOperator());
	}
	
	var IsEmptyOperator = (function () {
	    function IsEmptyOperator() {
	        _classCallCheck(this, IsEmptyOperator);
	    }
	
	    IsEmptyOperator.prototype.call = function call(observer) {
	        return new IsEmptySubscriber(observer);
	    };
	
	    return IsEmptyOperator;
	})();
	
	var IsEmptySubscriber = (function (_Subscriber) {
	    _inherits(IsEmptySubscriber, _Subscriber);
	
	    function IsEmptySubscriber(destination) {
	        _classCallCheck(this, IsEmptySubscriber);
	
	        _Subscriber.call(this, destination);
	    }
	
	    IsEmptySubscriber.prototype.notifyComplete = function notifyComplete(isEmpty) {
	        var destination = this.destination;
	        destination.next(isEmpty);
	        destination.complete();
	    };
	
	    IsEmptySubscriber.prototype._next = function _next(value) {
	        this.notifyComplete(false);
	    };
	
	    IsEmptySubscriber.prototype._complete = function _complete() {
	        this.notifyComplete(true);
	    };
	
	    return IsEmptySubscriber;
	})(_Subscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = timeInterval;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	var _schedulersImmediate = __webpack_require__(10);
	
	var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);
	
	function timeInterval() {
	    var scheduler = arguments.length <= 0 || arguments[0] === undefined ? _schedulersImmediate2['default'] : arguments[0];
	
	    return this.lift(new TimeIntervalOperator(scheduler));
	}
	
	var TimeInterval = function TimeInterval(value, interval) {
	    _classCallCheck(this, TimeInterval);
	
	    this.value = value;
	    this.interval = interval;
	};
	
	exports.TimeInterval = TimeInterval;
	
	;
	
	var TimeIntervalOperator = (function () {
	    function TimeIntervalOperator(scheduler) {
	        _classCallCheck(this, TimeIntervalOperator);
	
	        this.scheduler = scheduler;
	    }
	
	    TimeIntervalOperator.prototype.call = function call(observer) {
	        return new TimeIntervalSubscriber(observer, this.scheduler);
	    };
	
	    return TimeIntervalOperator;
	})();
	
	var TimeIntervalSubscriber = (function (_Subscriber) {
	    _inherits(TimeIntervalSubscriber, _Subscriber);
	
	    function TimeIntervalSubscriber(destination, scheduler) {
	        _classCallCheck(this, TimeIntervalSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.scheduler = scheduler;
	        this.lastTime = 0;
	        this.lastTime = scheduler.now();
	    }
	
	    TimeIntervalSubscriber.prototype._next = function _next(value) {
	        var now = this.scheduler.now();
	        var span = now - this.lastTime;
	        this.lastTime = now;
	        this.destination.next(new TimeInterval(value, span));
	    };
	
	    return TimeIntervalSubscriber;
	})(_Subscriber3['default']);

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = _finally;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	var _Subscription = __webpack_require__(5);
	
	var _Subscription2 = _interopRequireDefault(_Subscription);
	
	var _utilBindCallback = __webpack_require__(15);
	
	var _utilBindCallback2 = _interopRequireDefault(_utilBindCallback);
	
	function _finally(finallySelector, thisArg) {
	    return this.lift(new FinallyOperator(thisArg ? _utilBindCallback2['default'](finallySelector, thisArg, 2) : finallySelector));
	}
	
	var FinallyOperator = (function () {
	    function FinallyOperator(finallySelector) {
	        _classCallCheck(this, FinallyOperator);
	
	        this.finallySelector = finallySelector;
	    }
	
	    FinallyOperator.prototype.call = function call(subscriber) {
	        return new FinallySubscriber(subscriber, this.finallySelector);
	    };
	
	    return FinallyOperator;
	})();
	
	var FinallySubscriber = (function (_Subscriber) {
	    _inherits(FinallySubscriber, _Subscriber);
	
	    function FinallySubscriber(destination, finallySelector) {
	        _classCallCheck(this, FinallySubscriber);
	
	        _Subscriber.call(this, destination);
	        this.add(new _Subscription2['default'](finallySelector));
	    }
	
	    return FinallySubscriber;
	})(_Subscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = first;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	var _utilEmptyError = __webpack_require__(25);
	
	var _utilEmptyError2 = _interopRequireDefault(_utilEmptyError);
	
	function first(predicate, resultSelector, defaultValue) {
	    return this.lift(new FirstOperator(predicate, resultSelector, defaultValue, this));
	}
	
	var FirstOperator = (function () {
	    function FirstOperator(predicate, resultSelector, defaultValue, source) {
	        _classCallCheck(this, FirstOperator);
	
	        this.predicate = predicate;
	        this.resultSelector = resultSelector;
	        this.defaultValue = defaultValue;
	        this.source = source;
	    }
	
	    FirstOperator.prototype.call = function call(observer) {
	        return new FirstSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source);
	    };
	
	    return FirstOperator;
	})();
	
	var FirstSubscriber = (function (_Subscriber) {
	    _inherits(FirstSubscriber, _Subscriber);
	
	    function FirstSubscriber(destination, predicate, resultSelector, defaultValue, source) {
	        _classCallCheck(this, FirstSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.predicate = predicate;
	        this.resultSelector = resultSelector;
	        this.defaultValue = defaultValue;
	        this.source = source;
	        this.index = 0;
	        this.hasCompleted = false;
	    }
	
	    FirstSubscriber.prototype._next = function _next(value) {
	        var destination = this.destination;
	        var predicate = this.predicate;
	        var resultSelector = this.resultSelector;
	
	        var index = this.index++;
	        var passed = true;
	        if (predicate) {
	            passed = _utilTryCatch2['default'](predicate)(value, index, this.source);
	            if (passed === _utilErrorObject.errorObject) {
	                destination.error(_utilErrorObject.errorObject.e);
	                return;
	            }
	        }
	        if (passed) {
	            if (resultSelector) {
	                value = _utilTryCatch2['default'](resultSelector)(value, index);
	                if (value === _utilErrorObject.errorObject) {
	                    destination.error(_utilErrorObject.errorObject.e);
	                    return;
	                }
	            }
	            destination.next(value);
	            destination.complete();
	            this.hasCompleted = true;
	        }
	    };
	
	    FirstSubscriber.prototype._complete = function _complete() {
	        var destination = this.destination;
	        if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {
	            destination.next(this.defaultValue);
	            destination.complete();
	        } else if (!this.hasCompleted) {
	            destination.error(new _utilEmptyError2['default']());
	        }
	    };
	
	    return FirstSubscriber;
	})(_Subscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _Subscription3 = __webpack_require__(5);
	
	var _Subscription4 = _interopRequireDefault(_Subscription3);
	
	var _Observable2 = __webpack_require__(4);
	
	var _Observable3 = _interopRequireDefault(_Observable2);
	
	var RefCountSubscription = (function (_Subscription) {
	    _inherits(RefCountSubscription, _Subscription);
	
	    function RefCountSubscription() {
	        _classCallCheck(this, RefCountSubscription);
	
	        _Subscription.call(this);
	        this.attemptedToUnsubscribePrimary = false;
	        this.count = 0;
	    }
	
	    RefCountSubscription.prototype.setPrimary = function setPrimary(subscription) {
	        this.primary = subscription;
	    };
	
	    RefCountSubscription.prototype.unsubscribe = function unsubscribe() {
	        if (!this.isUnsubscribed && !this.attemptedToUnsubscribePrimary) {
	            this.attemptedToUnsubscribePrimary = true;
	            if (this.count === 0) {
	                _Subscription.prototype.unsubscribe.call(this);
	                this.primary.unsubscribe();
	            }
	        }
	    };
	
	    return RefCountSubscription;
	})(_Subscription4['default']);
	
	exports.RefCountSubscription = RefCountSubscription;
	
	var GroupedObservable = (function (_Observable) {
	    _inherits(GroupedObservable, _Observable);
	
	    function GroupedObservable(key, groupSubject, refCountSubscription) {
	        _classCallCheck(this, GroupedObservable);
	
	        _Observable.call(this);
	        this.key = key;
	        this.groupSubject = groupSubject;
	        this.refCountSubscription = refCountSubscription;
	    }
	
	    GroupedObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var subscription = new _Subscription4['default']();
	        if (this.refCountSubscription && !this.refCountSubscription.isUnsubscribed) {
	            subscription.add(new InnerRefCountSubscription(this.refCountSubscription));
	        }
	        subscription.add(this.groupSubject.subscribe(subscriber));
	        return subscription;
	    };
	
	    return GroupedObservable;
	})(_Observable3['default']);
	
	exports.GroupedObservable = GroupedObservable;
	
	var InnerRefCountSubscription = (function (_Subscription2) {
	    _inherits(InnerRefCountSubscription, _Subscription2);
	
	    function InnerRefCountSubscription(parent) {
	        _classCallCheck(this, InnerRefCountSubscription);
	
	        _Subscription2.call(this);
	        this.parent = parent;
	        parent.count++;
	    }
	
	    InnerRefCountSubscription.prototype.unsubscribe = function unsubscribe() {
	        if (!this.parent.isUnsubscribed && !this.isUnsubscribed) {
	            _Subscription2.prototype.unsubscribe.call(this);
	            this.parent.count--;
	            if (this.parent.count === 0 && this.parent.attemptedToUnsubscribePrimary) {
	                this.parent.unsubscribe();
	                this.parent.primary.unsubscribe();
	            }
	        }
	    };
	
	    return InnerRefCountSubscription;
	})(_Subscription4['default']);
	
	exports.InnerRefCountSubscription = InnerRefCountSubscription;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.groupBy = groupBy;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _Subscriber3 = __webpack_require__(1);
	
	var _Subscriber4 = _interopRequireDefault(_Subscriber3);
	
	var _Observable2 = __webpack_require__(4);
	
	var _Observable3 = _interopRequireDefault(_Observable2);
	
	var _Subject = __webpack_require__(7);
	
	var _Subject2 = _interopRequireDefault(_Subject);
	
	var _utilMap = __webpack_require__(183);
	
	var _utilMap2 = _interopRequireDefault(_utilMap);
	
	var _utilFastMap = __webpack_require__(181);
	
	var _utilFastMap2 = _interopRequireDefault(_utilFastMap);
	
	var _groupBySupport = __webpack_require__(128);
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	function groupBy(keySelector, elementSelector, durationSelector) {
	    return new GroupByObservable(this, keySelector, elementSelector, durationSelector);
	}
	
	var GroupByObservable = (function (_Observable) {
	    _inherits(GroupByObservable, _Observable);
	
	    function GroupByObservable(source, keySelector, elementSelector, durationSelector) {
	        _classCallCheck(this, GroupByObservable);
	
	        _Observable.call(this);
	        this.source = source;
	        this.keySelector = keySelector;
	        this.elementSelector = elementSelector;
	        this.durationSelector = durationSelector;
	    }
	
	    GroupByObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var refCountSubscription = new _groupBySupport.RefCountSubscription();
	        var groupBySubscriber = new GroupBySubscriber(subscriber, refCountSubscription, this.keySelector, this.elementSelector, this.durationSelector);
	        refCountSubscription.setPrimary(this.source.subscribe(groupBySubscriber));
	        return refCountSubscription;
	    };
	
	    return GroupByObservable;
	})(_Observable3['default']);
	
	exports.GroupByObservable = GroupByObservable;
	
	var GroupBySubscriber = (function (_Subscriber) {
	    _inherits(GroupBySubscriber, _Subscriber);
	
	    function GroupBySubscriber(destination, refCountSubscription, keySelector, elementSelector, durationSelector) {
	        _classCallCheck(this, GroupBySubscriber);
	
	        _Subscriber.call(this);
	        this.refCountSubscription = refCountSubscription;
	        this.keySelector = keySelector;
	        this.elementSelector = elementSelector;
	        this.durationSelector = durationSelector;
	        this.groups = null;
	        this.destination = destination;
	        this.add(destination);
	    }
	
	    GroupBySubscriber.prototype._next = function _next(x) {
	        var key = _utilTryCatch2['default'](this.keySelector)(x);
	        if (key === _utilErrorObject.errorObject) {
	            this.error(key.e);
	        } else {
	            var groups = this.groups;
	            var elementSelector = this.elementSelector;
	            var durationSelector = this.durationSelector;
	            if (!groups) {
	                groups = this.groups = typeof key === 'string' ? new _utilFastMap2['default']() : new _utilMap2['default']();
	            }
	            var group = groups.get(key);
	            if (!group) {
	                groups.set(key, group = new _Subject2['default']());
	                var groupedObservable = new _groupBySupport.GroupedObservable(key, group, this.refCountSubscription);
	                if (durationSelector) {
	                    var duration = _utilTryCatch2['default'](durationSelector)(new _groupBySupport.GroupedObservable(key, group));
	                    if (duration === _utilErrorObject.errorObject) {
	                        this.error(duration.e);
	                    } else {
	                        this.add(duration._subscribe(new GroupDurationSubscriber(key, group, this)));
	                    }
	                }
	                this.destination.next(groupedObservable);
	            }
	            if (elementSelector) {
	                var value = _utilTryCatch2['default'](elementSelector)(x);
	                if (value === _utilErrorObject.errorObject) {
	                    this.error(value.e);
	                } else {
	                    group.next(value);
	                }
	            } else {
	                group.next(x);
	            }
	        }
	    };
	
	    GroupBySubscriber.prototype._error = function _error(err) {
	        var _this = this;
	
	        var groups = this.groups;
	        if (groups) {
	            groups.forEach(function (group, key) {
	                group.error(err);
	                _this.removeGroup(key);
	            });
	        }
	        this.destination.error(err);
	    };
	
	    GroupBySubscriber.prototype._complete = function _complete() {
	        var _this2 = this;
	
	        var groups = this.groups;
	        if (groups) {
	            groups.forEach(function (group, key) {
	                group.complete();
	                _this2.removeGroup(group);
	            });
	        }
	        this.destination.complete();
	    };
	
	    GroupBySubscriber.prototype.removeGroup = function removeGroup(key) {
	        this.groups['delete'](key);
	    };
	
	    return GroupBySubscriber;
	})(_Subscriber4['default']);
	
	var GroupDurationSubscriber = (function (_Subscriber2) {
	    _inherits(GroupDurationSubscriber, _Subscriber2);
	
	    function GroupDurationSubscriber(key, group, parent) {
	        _classCallCheck(this, GroupDurationSubscriber);
	
	        _Subscriber2.call(this, null);
	        this.key = key;
	        this.group = group;
	        this.parent = parent;
	    }
	
	    GroupDurationSubscriber.prototype._next = function _next(value) {
	        this.group.complete();
	        this.parent.removeGroup(this.key);
	    };
	
	    GroupDurationSubscriber.prototype._error = function _error(err) {
	        this.group.error(err);
	        this.parent.removeGroup(this.key);
	    };
	
	    GroupDurationSubscriber.prototype._complete = function _complete() {
	        this.group.complete();
	        this.parent.removeGroup(this.key);
	    };
	
	    return GroupDurationSubscriber;
	})(_Subscriber4['default']);

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = ignoreElements;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	function ignoreElements() {
	    return this.lift(new IgnoreElementsOperator());
	}
	
	;
	
	var IgnoreElementsOperator = (function () {
	    function IgnoreElementsOperator() {
	        _classCallCheck(this, IgnoreElementsOperator);
	    }
	
	    IgnoreElementsOperator.prototype.call = function call(subscriber) {
	        return new IgnoreElementsSubscriber(subscriber);
	    };
	
	    return IgnoreElementsOperator;
	})();
	
	var IgnoreElementsSubscriber = (function (_Subscriber) {
	    _inherits(IgnoreElementsSubscriber, _Subscriber);
	
	    function IgnoreElementsSubscriber() {
	        _classCallCheck(this, IgnoreElementsSubscriber);
	
	        _Subscriber.apply(this, arguments);
	    }
	
	    IgnoreElementsSubscriber.prototype._next = function _next() {};
	
	    return IgnoreElementsSubscriber;
	})(_Subscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = last;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	var _utilEmptyError = __webpack_require__(25);
	
	var _utilEmptyError2 = _interopRequireDefault(_utilEmptyError);
	
	function last(predicate, resultSelector, defaultValue) {
	    return this.lift(new LastOperator(predicate, resultSelector, defaultValue, this));
	}
	
	var LastOperator = (function () {
	    function LastOperator(predicate, resultSelector, defaultValue, source) {
	        _classCallCheck(this, LastOperator);
	
	        this.predicate = predicate;
	        this.resultSelector = resultSelector;
	        this.defaultValue = defaultValue;
	        this.source = source;
	    }
	
	    LastOperator.prototype.call = function call(observer) {
	        return new LastSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source);
	    };
	
	    return LastOperator;
	})();
	
	var LastSubscriber = (function (_Subscriber) {
	    _inherits(LastSubscriber, _Subscriber);
	
	    function LastSubscriber(destination, predicate, resultSelector, defaultValue, source) {
	        _classCallCheck(this, LastSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.predicate = predicate;
	        this.resultSelector = resultSelector;
	        this.defaultValue = defaultValue;
	        this.source = source;
	        this.hasValue = false;
	        this.index = 0;
	        if (typeof defaultValue !== 'undefined') {
	            this.lastValue = defaultValue;
	            this.hasValue = true;
	        }
	    }
	
	    LastSubscriber.prototype._next = function _next(value) {
	        var predicate = this.predicate;
	        var resultSelector = this.resultSelector;
	        var destination = this.destination;
	
	        var index = this.index++;
	        if (predicate) {
	            var found = _utilTryCatch2['default'](predicate)(value, index, this.source);
	            if (found === _utilErrorObject.errorObject) {
	                destination.error(_utilErrorObject.errorObject.e);
	                return;
	            }
	            if (found) {
	                if (resultSelector) {
	                    value = _utilTryCatch2['default'](resultSelector)(value, index);
	                    if (value === _utilErrorObject.errorObject) {
	                        destination.error(_utilErrorObject.errorObject.e);
	                        return;
	                    }
	                }
	                this.lastValue = value;
	                this.hasValue = true;
	            }
	        } else {
	            this.lastValue = value;
	            this.hasValue = true;
	        }
	    };
	
	    LastSubscriber.prototype._complete = function _complete() {
	        var destination = this.destination;
	        if (this.hasValue) {
	            destination.next(this.lastValue);
	            destination.complete();
	        } else {
	            destination.error(new _utilEmptyError2['default']());
	        }
	    };
	
	    return LastSubscriber;
	})(_Subscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = map;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	var _utilBindCallback = __webpack_require__(15);
	
	var _utilBindCallback2 = _interopRequireDefault(_utilBindCallback);
	
	/**
	 * Similar to the well known `Array.prototype.map` function, this operator
	 * applies a projection to each value and emits that projection in the returned observable
	 *
	 * @param {Function} project the function to create projection
	 * @param {any} [thisArg] an optional argument to define what `this` is in the project function
	 * @returns {Observable} a observable of projected values
	 */
	
	function map(project, thisArg) {
	    return this.lift(new MapOperator(project, thisArg));
	}
	
	var MapOperator = (function () {
	    function MapOperator(project, thisArg) {
	        _classCallCheck(this, MapOperator);
	
	        this.project = _utilBindCallback2['default'](project, thisArg, 2);
	    }
	
	    MapOperator.prototype.call = function call(subscriber) {
	        return new MapSubscriber(subscriber, this.project);
	    };
	
	    return MapOperator;
	})();
	
	var MapSubscriber = (function (_Subscriber) {
	    _inherits(MapSubscriber, _Subscriber);
	
	    function MapSubscriber(destination, project) {
	        _classCallCheck(this, MapSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.count = 0;
	        this.project = project;
	    }
	
	    MapSubscriber.prototype._next = function _next(x) {
	        var result = _utilTryCatch2['default'](this.project)(x, this.count++);
	        if (result === _utilErrorObject.errorObject) {
	            this.error(_utilErrorObject.errorObject.e);
	        } else {
	            this.destination.next(result);
	        }
	    };
	
	    return MapSubscriber;
	})(_Subscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = mapTo;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	/**
	 * Maps every value to the same value every time.
	 * @param {any} value the value to map each incoming value to
	 * @returns {Observable} an observable of the passed value that emits everytime the source does
	 */
	
	function mapTo(value) {
	    return this.lift(new MapToOperator(value));
	}
	
	var MapToOperator = (function () {
	    function MapToOperator(value) {
	        _classCallCheck(this, MapToOperator);
	
	        this.value = value;
	    }
	
	    MapToOperator.prototype.call = function call(subscriber) {
	        return new MapToSubscriber(subscriber, this.value);
	    };
	
	    return MapToOperator;
	})();
	
	var MapToSubscriber = (function (_Subscriber) {
	    _inherits(MapToSubscriber, _Subscriber);
	
	    function MapToSubscriber(destination, value) {
	        _classCallCheck(this, MapToSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.value = value;
	    }
	
	    MapToSubscriber.prototype._next = function _next(x) {
	        this.destination.next(this.value);
	    };
	
	    return MapToSubscriber;
	})(_Subscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = materialize;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	var _Notification = __webpack_require__(18);
	
	var _Notification2 = _interopRequireDefault(_Notification);
	
	function materialize() {
	    return this.lift(new MaterializeOperator());
	}
	
	var MaterializeOperator = (function () {
	    function MaterializeOperator() {
	        _classCallCheck(this, MaterializeOperator);
	    }
	
	    MaterializeOperator.prototype.call = function call(subscriber) {
	        return new MaterializeSubscriber(subscriber);
	    };
	
	    return MaterializeOperator;
	})();
	
	var MaterializeSubscriber = (function (_Subscriber) {
	    _inherits(MaterializeSubscriber, _Subscriber);
	
	    function MaterializeSubscriber(destination) {
	        _classCallCheck(this, MaterializeSubscriber);
	
	        _Subscriber.call(this, destination);
	    }
	
	    MaterializeSubscriber.prototype._next = function _next(value) {
	        this.destination.next(_Notification2['default'].createNext(value));
	    };
	
	    MaterializeSubscriber.prototype._error = function _error(err) {
	        var destination = this.destination;
	        destination.next(_Notification2['default'].createError(err));
	        destination.complete();
	    };
	
	    MaterializeSubscriber.prototype._complete = function _complete() {
	        var destination = this.destination;
	        destination.next(_Notification2['default'].createComplete());
	        destination.complete();
	    };
	
	    return MaterializeSubscriber;
	})(_Subscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = merge;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _mergeStatic = __webpack_require__(48);
	
	var _mergeStatic2 = _interopRequireDefault(_mergeStatic);
	
	function merge() {
	    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
	        observables[_key] = arguments[_key];
	    }
	
	    observables.unshift(this);
	    return _mergeStatic2['default'].apply(this, observables);
	}
	
	module.exports = exports['default'];

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = mergeAll;
	
	var _mergeAllSupport = __webpack_require__(32);
	
	function mergeAll() {
	    var concurrent = arguments.length <= 0 || arguments[0] === undefined ? Number.POSITIVE_INFINITY : arguments[0];
	
	    return this.lift(new _mergeAllSupport.MergeAllOperator(concurrent));
	}
	
	module.exports = exports['default'];

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = mergeMap;
	
	var _mergeMapSupport = __webpack_require__(49);
	
	function mergeMap(project, resultSelector) {
	    var concurrent = arguments.length <= 2 || arguments[2] === undefined ? Number.POSITIVE_INFINITY : arguments[2];
	
	    return this.lift(new _mergeMapSupport.MergeMapOperator(project, resultSelector, concurrent));
	}
	
	module.exports = exports['default'];

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = mergeMapTo;
	
	var _mergeMapToSupport = __webpack_require__(33);
	
	function mergeMapTo(observable, resultSelector) {
	    var concurrent = arguments.length <= 2 || arguments[2] === undefined ? Number.POSITIVE_INFINITY : arguments[2];
	
	    return this.lift(new _mergeMapToSupport.MergeMapToOperator(observable, resultSelector, concurrent));
	}
	
	module.exports = exports['default'];

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = observeOn;
	
	var _observeOnSupport = __webpack_require__(50);
	
	function observeOn(scheduler) {
	    var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	
	    return this.lift(new _observeOnSupport.ObserveOnOperator(scheduler, delay));
	}
	
	module.exports = exports['default'];

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = partition;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _utilNot = __webpack_require__(184);
	
	var _utilNot2 = _interopRequireDefault(_utilNot);
	
	var _filter = __webpack_require__(47);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	function partition(predicate, thisArg) {
	    return [_filter2['default'].call(this, predicate), _filter2['default'].call(this, _utilNot2['default'](predicate, thisArg))];
	}
	
	module.exports = exports['default'];

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = publishBehavior;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _subjectsBehaviorSubject = __webpack_require__(57);
	
	var _subjectsBehaviorSubject2 = _interopRequireDefault(_subjectsBehaviorSubject);
	
	var _multicast = __webpack_require__(23);
	
	var _multicast2 = _interopRequireDefault(_multicast);
	
	function publishBehavior(value) {
	    return _multicast2['default'].call(this, function () {
	        return new _subjectsBehaviorSubject2['default'](value);
	    });
	}
	
	module.exports = exports['default'];

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = reduce;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	function reduce(project, acc) {
	    return this.lift(new ReduceOperator(project, acc));
	}
	
	var ReduceOperator = (function () {
	    function ReduceOperator(project, acc) {
	        _classCallCheck(this, ReduceOperator);
	
	        this.acc = acc;
	        this.project = project;
	    }
	
	    ReduceOperator.prototype.call = function call(subscriber) {
	        return new ReduceSubscriber(subscriber, this.project, this.acc);
	    };
	
	    return ReduceOperator;
	})();
	
	var ReduceSubscriber = (function (_Subscriber) {
	    _inherits(ReduceSubscriber, _Subscriber);
	
	    function ReduceSubscriber(destination, project, acc) {
	        _classCallCheck(this, ReduceSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.hasValue = false;
	        this.acc = acc;
	        this.project = project;
	        this.hasSeed = typeof acc !== 'undefined';
	    }
	
	    ReduceSubscriber.prototype._next = function _next(x) {
	        if (this.hasValue || (this.hasValue = this.hasSeed)) {
	            var result = _utilTryCatch2['default'](this.project).call(this, this.acc, x);
	            if (result === _utilErrorObject.errorObject) {
	                this.destination.error(_utilErrorObject.errorObject.e);
	            } else {
	                this.acc = result;
	            }
	        } else {
	            this.acc = x;
	            this.hasValue = true;
	        }
	    };
	
	    ReduceSubscriber.prototype._complete = function _complete() {
	        if (this.hasValue || this.hasSeed) {
	            this.destination.next(this.acc);
	        }
	        this.destination.complete();
	    };
	
	    return ReduceSubscriber;
	})(_Subscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = repeat;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	function repeat(count) {
	    return this.lift(new RepeatOperator(count, this));
	}
	
	var RepeatOperator = (function () {
	    function RepeatOperator(count, original) {
	        _classCallCheck(this, RepeatOperator);
	
	        this.count = count;
	        this.original = original;
	    }
	
	    RepeatOperator.prototype.call = function call(subscriber) {
	        return new RepeatSubscriber(subscriber, this.count, this.original);
	    };
	
	    return RepeatOperator;
	})();
	
	var RepeatSubscriber = (function (_Subscriber) {
	    _inherits(RepeatSubscriber, _Subscriber);
	
	    function RepeatSubscriber(destination, count, original) {
	        _classCallCheck(this, RepeatSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.count = count;
	        this.original = original;
	        this.repeated = 0;
	    }
	
	    RepeatSubscriber.prototype._complete = function _complete() {
	        if (this.count === (this.repeated += 1)) {
	            this.destination.complete();
	        } else {
	            this.resubscribe();
	        }
	    };
	
	    RepeatSubscriber.prototype.resubscribe = function resubscribe() {
	        this.original.subscribe(this);
	    };
	
	    return RepeatSubscriber;
	})(_Subscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = retry;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	function retry() {
	    var count = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	
	    return this.lift(new RetryOperator(count, this));
	}
	
	var RetryOperator = (function () {
	    function RetryOperator(count, original) {
	        _classCallCheck(this, RetryOperator);
	
	        this.count = count;
	        this.original = original;
	    }
	
	    RetryOperator.prototype.call = function call(subscriber) {
	        return new RetrySubscriber(subscriber, this.count, this.original);
	    };
	
	    return RetryOperator;
	})();
	
	var RetrySubscriber = (function (_Subscriber) {
	    _inherits(RetrySubscriber, _Subscriber);
	
	    function RetrySubscriber(destination, count, original) {
	        _classCallCheck(this, RetrySubscriber);
	
	        _Subscriber.call(this, destination);
	        this.count = count;
	        this.original = original;
	        this.retries = 0;
	    }
	
	    RetrySubscriber.prototype._error = function _error(err) {
	        var count = this.count;
	        if (count && count === (this.retries += 1)) {
	            this.destination.error(err);
	        } else {
	            this.resubscribe();
	        }
	    };
	
	    RetrySubscriber.prototype.resubscribe = function resubscribe() {
	        this.original.subscribe(this);
	    };
	
	    return RetrySubscriber;
	})(_Subscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = retryWhen;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber3 = __webpack_require__(1);
	
	var _Subscriber4 = _interopRequireDefault(_Subscriber3);
	
	var _Subject = __webpack_require__(7);
	
	var _Subject2 = _interopRequireDefault(_Subject);
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	function retryWhen(notifier) {
	    return this.lift(new RetryWhenOperator(notifier, this));
	}
	
	var RetryWhenOperator = (function () {
	    function RetryWhenOperator(notifier, original) {
	        _classCallCheck(this, RetryWhenOperator);
	
	        this.notifier = notifier;
	        this.original = original;
	    }
	
	    RetryWhenOperator.prototype.call = function call(subscriber) {
	        return new RetryWhenSubscriber(subscriber, this.notifier, this.original);
	    };
	
	    return RetryWhenOperator;
	})();
	
	var RetryWhenSubscriber = (function (_Subscriber) {
	    _inherits(RetryWhenSubscriber, _Subscriber);
	
	    function RetryWhenSubscriber(destination, notifier, original) {
	        _classCallCheck(this, RetryWhenSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.notifier = notifier;
	        this.original = original;
	    }
	
	    RetryWhenSubscriber.prototype._error = function _error(err) {
	        if (!this.retryNotifications) {
	            this.errors = new _Subject2['default']();
	            var notifications = _utilTryCatch2['default'](this.notifier).call(this, this.errors);
	            if (notifications === _utilErrorObject.errorObject) {
	                this.destination.error(_utilErrorObject.errorObject.e);
	            } else {
	                this.retryNotifications = notifications;
	                this.add(notifications._subscribe(new RetryNotificationSubscriber(this)));
	            }
	        }
	        this.errors.next(err);
	    };
	
	    RetryWhenSubscriber.prototype.finalError = function finalError(err) {
	        this.destination.error(err);
	    };
	
	    RetryWhenSubscriber.prototype.resubscribe = function resubscribe() {
	        this.original.subscribe(this);
	    };
	
	    return RetryWhenSubscriber;
	})(_Subscriber4['default']);
	
	var RetryNotificationSubscriber = (function (_Subscriber2) {
	    _inherits(RetryNotificationSubscriber, _Subscriber2);
	
	    function RetryNotificationSubscriber(parent) {
	        _classCallCheck(this, RetryNotificationSubscriber);
	
	        _Subscriber2.call(this, null);
	        this.parent = parent;
	    }
	
	    RetryNotificationSubscriber.prototype._next = function _next(value) {
	        this.parent.resubscribe();
	    };
	
	    RetryNotificationSubscriber.prototype._error = function _error(err) {
	        this.parent.finalError(err);
	    };
	
	    RetryNotificationSubscriber.prototype._complete = function _complete() {
	        this.parent.complete();
	    };
	
	    return RetryNotificationSubscriber;
	})(_Subscriber4['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = sample;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber3 = __webpack_require__(1);
	
	var _Subscriber4 = _interopRequireDefault(_Subscriber3);
	
	function sample(notifier) {
	    return this.lift(new SampleOperator(notifier));
	}
	
	var SampleOperator = (function () {
	    function SampleOperator(notifier) {
	        _classCallCheck(this, SampleOperator);
	
	        this.notifier = notifier;
	    }
	
	    SampleOperator.prototype.call = function call(subscriber) {
	        return new SampleSubscriber(subscriber, this.notifier);
	    };
	
	    return SampleOperator;
	})();
	
	var SampleSubscriber = (function (_Subscriber) {
	    _inherits(SampleSubscriber, _Subscriber);
	
	    function SampleSubscriber(destination, notifier) {
	        _classCallCheck(this, SampleSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.notifier = notifier;
	        this.hasValue = false;
	        this.add(notifier._subscribe(new SampleNoficationSubscriber(this)));
	    }
	
	    SampleSubscriber.prototype._next = function _next(value) {
	        this.lastValue = value;
	        this.hasValue = true;
	    };
	
	    SampleSubscriber.prototype.notifyNext = function notifyNext() {
	        if (this.hasValue) {
	            this.destination.next(this.lastValue);
	        }
	    };
	
	    return SampleSubscriber;
	})(_Subscriber4['default']);
	
	var SampleNoficationSubscriber = (function (_Subscriber2) {
	    _inherits(SampleNoficationSubscriber, _Subscriber2);
	
	    function SampleNoficationSubscriber(parent) {
	        _classCallCheck(this, SampleNoficationSubscriber);
	
	        _Subscriber2.call(this, null);
	        this.parent = parent;
	    }
	
	    SampleNoficationSubscriber.prototype._next = function _next() {
	        this.parent.notifyNext();
	    };
	
	    SampleNoficationSubscriber.prototype._error = function _error(err) {
	        this.parent.error(err);
	    };
	
	    SampleNoficationSubscriber.prototype._complete = function _complete() {
	        //noop
	    };
	
	    return SampleNoficationSubscriber;
	})(_Subscriber4['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = sampleTime;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	var _schedulersNextTick = __webpack_require__(13);
	
	var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);
	
	function sampleTime(delay) {
	    var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersNextTick2['default'] : arguments[1];
	
	    return this.lift(new SampleTimeOperator(delay, scheduler));
	}
	
	var SampleTimeOperator = (function () {
	    function SampleTimeOperator(delay, scheduler) {
	        _classCallCheck(this, SampleTimeOperator);
	
	        this.delay = delay;
	        this.scheduler = scheduler;
	    }
	
	    SampleTimeOperator.prototype.call = function call(subscriber) {
	        return new SampleTimeSubscriber(subscriber, this.delay, this.scheduler);
	    };
	
	    return SampleTimeOperator;
	})();
	
	var SampleTimeSubscriber = (function (_Subscriber) {
	    _inherits(SampleTimeSubscriber, _Subscriber);
	
	    function SampleTimeSubscriber(destination, delay, scheduler) {
	        _classCallCheck(this, SampleTimeSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.delay = delay;
	        this.scheduler = scheduler;
	        this.hasValue = false;
	        this.add(scheduler.schedule(dispatchNotification, delay, { subscriber: this, delay: delay }));
	    }
	
	    SampleTimeSubscriber.prototype._next = function _next(value) {
	        this.lastValue = value;
	        this.hasValue = true;
	    };
	
	    SampleTimeSubscriber.prototype.notifyNext = function notifyNext() {
	        if (this.hasValue) {
	            this.destination.next(this.lastValue);
	        }
	    };
	
	    return SampleTimeSubscriber;
	})(_Subscriber3['default']);
	
	function dispatchNotification(state) {
	    var subscriber = state.subscriber;
	    var delay = state.delay;
	
	    subscriber.notifyNext();
	    this.schedule(state, delay);
	}
	module.exports = exports['default'];

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = scan;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	function scan(project, acc) {
	    return this.lift(new ScanOperator(project));
	}
	
	var ScanOperator = (function () {
	    function ScanOperator(project, acc) {
	        _classCallCheck(this, ScanOperator);
	
	        this.acc = acc;
	        this.project = project;
	    }
	
	    ScanOperator.prototype.call = function call(subscriber) {
	        return new ScanSubscriber(subscriber, this.project, this.acc);
	    };
	
	    return ScanOperator;
	})();
	
	var ScanSubscriber = (function (_Subscriber) {
	    _inherits(ScanSubscriber, _Subscriber);
	
	    function ScanSubscriber(destination, project, acc) {
	        _classCallCheck(this, ScanSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.hasValue = false;
	        this.acc = acc;
	        this.project = project;
	        this.hasSeed = typeof acc !== 'undefined';
	    }
	
	    ScanSubscriber.prototype._next = function _next(x) {
	        if (this.hasValue || (this.hasValue = this.hasSeed)) {
	            var result = _utilTryCatch2['default'](this.project).call(this, this.acc, x);
	            if (result === _utilErrorObject.errorObject) {
	                this.destination.error(_utilErrorObject.errorObject.e);
	            } else {
	                this.destination.next(this.acc = result);
	            }
	        } else {
	            return this.destination.next((this.hasValue = true) && (this.acc = x));
	        }
	    };
	
	    ScanSubscriber.prototype._complete = function _complete() {
	        if (!this.hasValue && this.hasSeed) {
	            this.destination.next(this.acc);
	        }
	        this.destination.complete();
	    };
	
	    return ScanSubscriber;
	})(_Subscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = share;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _publish = __webpack_require__(51);
	
	var _publish2 = _interopRequireDefault(_publish);
	
	function share() {
	    return _publish2['default'].call(this).refCount();
	}
	
	;
	module.exports = exports['default'];

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = shareReplay;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _publishReplay = __webpack_require__(52);
	
	var _publishReplay2 = _interopRequireDefault(_publishReplay);
	
	function shareReplay(bufferSize, windowTime, scheduler) {
	    if (bufferSize === undefined) bufferSize = Number.POSITIVE_INFINITY;
	    if (windowTime === undefined) windowTime = Number.POSITIVE_INFINITY;
	
	    return _publishReplay2['default'].call(this, bufferSize, windowTime, scheduler).refCount();
	}
	
	module.exports = exports['default'];

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = single;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	var _utilBindCallback = __webpack_require__(15);
	
	var _utilBindCallback2 = _interopRequireDefault(_utilBindCallback);
	
	var _utilEmptyError = __webpack_require__(25);
	
	var _utilEmptyError2 = _interopRequireDefault(_utilEmptyError);
	
	function single(predicate, thisArg) {
	    return this.lift(new SingleOperator(predicate, thisArg, this));
	}
	
	var SingleOperator = (function () {
	    function SingleOperator(predicate, thisArg, source) {
	        _classCallCheck(this, SingleOperator);
	
	        this.predicate = predicate;
	        this.thisArg = thisArg;
	        this.source = source;
	    }
	
	    SingleOperator.prototype.call = function call(subscriber) {
	        return new SingleSubscriber(subscriber, this.predicate, this.thisArg, this.source);
	    };
	
	    return SingleOperator;
	})();
	
	var SingleSubscriber = (function (_Subscriber) {
	    _inherits(SingleSubscriber, _Subscriber);
	
	    function SingleSubscriber(destination, predicate, thisArg, source) {
	        _classCallCheck(this, SingleSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.thisArg = thisArg;
	        this.source = source;
	        this.seenValue = false;
	        this.index = 0;
	        if (typeof predicate === 'function') {
	            this.predicate = _utilBindCallback2['default'](predicate, thisArg, 3);
	        }
	    }
	
	    SingleSubscriber.prototype.applySingleValue = function applySingleValue(value) {
	        if (this.seenValue) {
	            this.destination.error('Sequence contains more than one element');
	        } else {
	            this.seenValue = true;
	            this.singleValue = value;
	        }
	    };
	
	    SingleSubscriber.prototype._next = function _next(value) {
	        var predicate = this.predicate;
	        var currentIndex = this.index++;
	        if (predicate) {
	            var result = _utilTryCatch2['default'](predicate)(value, currentIndex, this.source);
	            if (result === _utilErrorObject.errorObject) {
	                this.destination.error(result.e);
	            } else if (result) {
	                this.applySingleValue(value);
	            }
	        } else {
	            this.applySingleValue(value);
	        }
	    };
	
	    SingleSubscriber.prototype._complete = function _complete() {
	        var destination = this.destination;
	        if (this.index > 0) {
	            destination.next(this.seenValue ? this.singleValue : undefined);
	            destination.complete();
	        } else {
	            destination.error(new _utilEmptyError2['default']());
	        }
	    };
	
	    return SingleSubscriber;
	})(_Subscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = skip;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	function skip(total) {
	    return this.lift(new SkipOperator(total));
	}
	
	var SkipOperator = (function () {
	    function SkipOperator(total) {
	        _classCallCheck(this, SkipOperator);
	
	        this.total = total;
	    }
	
	    SkipOperator.prototype.call = function call(subscriber) {
	        return new SkipSubscriber(subscriber, this.total);
	    };
	
	    return SkipOperator;
	})();
	
	var SkipSubscriber = (function (_Subscriber) {
	    _inherits(SkipSubscriber, _Subscriber);
	
	    function SkipSubscriber(destination, total) {
	        _classCallCheck(this, SkipSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.count = 0;
	        this.total = total;
	    }
	
	    SkipSubscriber.prototype._next = function _next(x) {
	        if (++this.count > this.total) {
	            this.destination.next(x);
	        }
	    };
	
	    return SkipSubscriber;
	})(_Subscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = skipUntil;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber3 = __webpack_require__(1);
	
	var _Subscriber4 = _interopRequireDefault(_Subscriber3);
	
	function skipUntil(total) {
	    return this.lift(new SkipUntilOperator(total));
	}
	
	var SkipUntilOperator = (function () {
	    function SkipUntilOperator(notifier) {
	        _classCallCheck(this, SkipUntilOperator);
	
	        this.notifier = notifier;
	    }
	
	    SkipUntilOperator.prototype.call = function call(subscriber) {
	        return new SkipUntilSubscriber(subscriber, this.notifier);
	    };
	
	    return SkipUntilOperator;
	})();
	
	var SkipUntilSubscriber = (function (_Subscriber) {
	    _inherits(SkipUntilSubscriber, _Subscriber);
	
	    function SkipUntilSubscriber(destination, notifier) {
	        _classCallCheck(this, SkipUntilSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.notifier = notifier;
	        this.notificationSubscriber = null;
	        this.notificationSubscriber = new NotificationSubscriber(this);
	        this.add(this.notifier.subscribe(this.notificationSubscriber));
	    }
	
	    SkipUntilSubscriber.prototype._next = function _next(value) {
	        if (this.notificationSubscriber.hasValue) {
	            this.destination.next(value);
	        }
	    };
	
	    SkipUntilSubscriber.prototype._complete = function _complete() {
	        if (this.notificationSubscriber.hasCompleted) {
	            this.destination.complete();
	        }
	        this.notificationSubscriber.unsubscribe();
	    };
	
	    return SkipUntilSubscriber;
	})(_Subscriber4['default']);
	
	var NotificationSubscriber = (function (_Subscriber2) {
	    _inherits(NotificationSubscriber, _Subscriber2);
	
	    function NotificationSubscriber(parent) {
	        _classCallCheck(this, NotificationSubscriber);
	
	        _Subscriber2.call(this, null);
	        this.parent = parent;
	        this.hasValue = false;
	        this.hasCompleted = false;
	    }
	
	    NotificationSubscriber.prototype._next = function _next(unused) {
	        this.hasValue = true;
	    };
	
	    NotificationSubscriber.prototype._error = function _error(err) {
	        this.parent.error(err);
	        this.hasValue = true;
	    };
	
	    NotificationSubscriber.prototype._complete = function _complete() {
	        this.hasCompleted = true;
	    };
	
	    return NotificationSubscriber;
	})(_Subscriber4['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = startWith;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _observablesArrayObservable = __webpack_require__(14);
	
	var _observablesArrayObservable2 = _interopRequireDefault(_observablesArrayObservable);
	
	var _observablesScalarObservable = __webpack_require__(30);
	
	var _observablesScalarObservable2 = _interopRequireDefault(_observablesScalarObservable);
	
	var _observablesEmptyObservable = __webpack_require__(22);
	
	var _observablesEmptyObservable2 = _interopRequireDefault(_observablesEmptyObservable);
	
	var _concatStatic = __webpack_require__(44);
	
	var _concatStatic2 = _interopRequireDefault(_concatStatic);
	
	function startWith() {
	    for (var _len = arguments.length, array = Array(_len), _key = 0; _key < _len; _key++) {
	        array[_key] = arguments[_key];
	    }
	
	    var scheduler = array[array.length - 1];
	    if (scheduler && typeof scheduler.schedule === 'function') {
	        array.pop();
	    } else {
	        scheduler = void 0;
	    }
	    var len = array.length;
	    if (len === 1) {
	        return _concatStatic2['default'](new _observablesScalarObservable2['default'](array[0], scheduler), this);
	    } else if (len > 1) {
	        return _concatStatic2['default'](new _observablesArrayObservable2['default'](array, scheduler), this);
	    } else {
	        return _concatStatic2['default'](new _observablesEmptyObservable2['default'](scheduler), this);
	    }
	}
	
	module.exports = exports['default'];

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = subscribeOn;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _observablesSubscribeOnObservable = __webpack_require__(95);
	
	var _observablesSubscribeOnObservable2 = _interopRequireDefault(_observablesSubscribeOnObservable);
	
	function subscribeOn(scheduler) {
	    var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	
	    return new _observablesSubscribeOnObservable2['default'](this, delay, scheduler);
	}
	
	module.exports = exports['default'];

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = _switch;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _OuterSubscriber2 = __webpack_require__(9);
	
	var _OuterSubscriber3 = _interopRequireDefault(_OuterSubscriber2);
	
	var _utilSubscribeToResult = __webpack_require__(11);
	
	var _utilSubscribeToResult2 = _interopRequireDefault(_utilSubscribeToResult);
	
	function _switch() {
	    return this.lift(new SwitchOperator());
	}
	
	var SwitchOperator = (function () {
	    function SwitchOperator() {
	        _classCallCheck(this, SwitchOperator);
	    }
	
	    SwitchOperator.prototype.call = function call(subscriber) {
	        return new SwitchSubscriber(subscriber);
	    };
	
	    return SwitchOperator;
	})();
	
	var SwitchSubscriber = (function (_OuterSubscriber) {
	    _inherits(SwitchSubscriber, _OuterSubscriber);
	
	    function SwitchSubscriber(destination) {
	        _classCallCheck(this, SwitchSubscriber);
	
	        _OuterSubscriber.call(this, destination);
	        this.active = 0;
	        this.hasCompleted = false;
	    }
	
	    SwitchSubscriber.prototype._next = function _next(value) {
	        this.unsubscribeInner();
	        this.active++;
	        this.add(this.innerSubscription = _utilSubscribeToResult2['default'](this, value));
	    };
	
	    SwitchSubscriber.prototype._complete = function _complete() {
	        this.hasCompleted = true;
	        if (this.active === 0) {
	            this.destination.complete();
	        }
	    };
	
	    SwitchSubscriber.prototype.unsubscribeInner = function unsubscribeInner() {
	        this.active = this.active > 0 ? this.active - 1 : 0;
	        var innerSubscription = this.innerSubscription;
	        if (innerSubscription) {
	            innerSubscription.unsubscribe();
	            this.remove(innerSubscription);
	        }
	    };
	
	    SwitchSubscriber.prototype.notifyNext = function notifyNext(outerValue, innerValue) {
	        this.destination.next(innerValue);
	    };
	
	    SwitchSubscriber.prototype.notifyError = function notifyError(err) {
	        this.destination.error(err);
	    };
	
	    SwitchSubscriber.prototype.notifyComplete = function notifyComplete() {
	        this.unsubscribeInner();
	        if (this.hasCompleted && this.active === 0) {
	            this.destination.complete();
	        }
	    };
	
	    return SwitchSubscriber;
	})(_OuterSubscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = switchMap;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	var _OuterSubscriber2 = __webpack_require__(9);
	
	var _OuterSubscriber3 = _interopRequireDefault(_OuterSubscriber2);
	
	var _utilSubscribeToResult = __webpack_require__(11);
	
	var _utilSubscribeToResult2 = _interopRequireDefault(_utilSubscribeToResult);
	
	function switchMap(project, resultSelector) {
	    return this.lift(new SwitchMapOperator(project, resultSelector));
	}
	
	var SwitchMapOperator = (function () {
	    function SwitchMapOperator(project, resultSelector) {
	        _classCallCheck(this, SwitchMapOperator);
	
	        this.project = project;
	        this.resultSelector = resultSelector;
	    }
	
	    SwitchMapOperator.prototype.call = function call(subscriber) {
	        return new SwitchMapSubscriber(subscriber, this.project, this.resultSelector);
	    };
	
	    return SwitchMapOperator;
	})();
	
	var SwitchMapSubscriber = (function (_OuterSubscriber) {
	    _inherits(SwitchMapSubscriber, _OuterSubscriber);
	
	    function SwitchMapSubscriber(destination, project, resultSelector) {
	        _classCallCheck(this, SwitchMapSubscriber);
	
	        _OuterSubscriber.call(this, destination);
	        this.project = project;
	        this.resultSelector = resultSelector;
	        this.hasCompleted = false;
	        this.index = 0;
	    }
	
	    SwitchMapSubscriber.prototype._next = function _next(value) {
	        var index = this.index++;
	        var destination = this.destination;
	        var result = _utilTryCatch2['default'](this.project)(value, index);
	        if (result === _utilErrorObject.errorObject) {
	            destination.error(result.e);
	        } else {
	            var innerSubscription = this.innerSubscription;
	            if (innerSubscription) {
	                innerSubscription.unsubscribe();
	            }
	            this.add(this.innerSubscription = _utilSubscribeToResult2['default'](this, result, value, index));
	        }
	    };
	
	    SwitchMapSubscriber.prototype._complete = function _complete() {
	        var innerSubscription = this.innerSubscription;
	        this.hasCompleted = true;
	        if (!innerSubscription || innerSubscription.isUnsubscribed) {
	            this.destination.complete();
	        }
	    };
	
	    SwitchMapSubscriber.prototype.notifyComplete = function notifyComplete(innerSub) {
	        this.remove(innerSub);
	        var prevSubscription = this.innerSubscription;
	        if (prevSubscription) {
	            prevSubscription.unsubscribe();
	        }
	        this.innerSubscription = null;
	        if (this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	
	    SwitchMapSubscriber.prototype.notifyError = function notifyError(err) {
	        this.destination.error(err);
	    };
	
	    SwitchMapSubscriber.prototype.notifyNext = function notifyNext(outerValue, innerValue, outerIndex, innerIndex) {
	        var resultSelector = this.resultSelector;
	        var destination = this.destination;
	
	        if (resultSelector) {
	            var result = _utilTryCatch2['default'](resultSelector)(outerValue, innerValue, outerIndex, innerIndex);
	            if (result === _utilErrorObject.errorObject) {
	                destination.error(_utilErrorObject.errorObject.e);
	            } else {
	                destination.next(result);
	            }
	        } else {
	            destination.next(innerValue);
	        }
	    };
	
	    return SwitchMapSubscriber;
	})(_OuterSubscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = switchMapTo;
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _mergeMapToSupport = __webpack_require__(33);
	
	function switchMapTo(observable, projectResult) {
	    return this.lift(new SwitchMapToOperator(observable, projectResult));
	}
	
	var SwitchMapToOperator = (function () {
	    function SwitchMapToOperator(observable, resultSelector) {
	        _classCallCheck(this, SwitchMapToOperator);
	
	        this.observable = observable;
	        this.resultSelector = resultSelector;
	    }
	
	    SwitchMapToOperator.prototype.call = function call(subscriber) {
	        return new SwitchMapToSubscriber(subscriber, this.observable, this.resultSelector);
	    };
	
	    return SwitchMapToOperator;
	})();
	
	var SwitchMapToSubscriber = (function (_MergeMapToSubscriber) {
	    _inherits(SwitchMapToSubscriber, _MergeMapToSubscriber);
	
	    function SwitchMapToSubscriber(destination, observable, resultSelector) {
	        _classCallCheck(this, SwitchMapToSubscriber);
	
	        _MergeMapToSubscriber.call(this, destination, observable, resultSelector, 1);
	    }
	
	    return SwitchMapToSubscriber;
	})(_mergeMapToSupport.MergeMapToSubscriber);
	
	module.exports = exports['default'];

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = take;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	function take(total) {
	    return this.lift(new TakeOperator(total));
	}
	
	var TakeOperator = (function () {
	    function TakeOperator(total) {
	        _classCallCheck(this, TakeOperator);
	
	        this.total = total;
	    }
	
	    TakeOperator.prototype.call = function call(subscriber) {
	        return new TakeSubscriber(subscriber, this.total);
	    };
	
	    return TakeOperator;
	})();
	
	var TakeSubscriber = (function (_Subscriber) {
	    _inherits(TakeSubscriber, _Subscriber);
	
	    function TakeSubscriber(destination, total) {
	        _classCallCheck(this, TakeSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.count = 0;
	        this.total = total;
	    }
	
	    TakeSubscriber.prototype._next = function _next(x) {
	        var total = this.total;
	        if (++this.count <= total) {
	            this.destination.next(x);
	            if (this.count === total) {
	                this.destination.complete();
	            }
	        }
	    };
	
	    return TakeSubscriber;
	})(_Subscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = takeUntil;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber3 = __webpack_require__(1);
	
	var _Subscriber4 = _interopRequireDefault(_Subscriber3);
	
	function takeUntil(observable) {
	    return this.lift(new TakeUntilOperator(observable));
	}
	
	var TakeUntilOperator = (function () {
	    function TakeUntilOperator(observable) {
	        _classCallCheck(this, TakeUntilOperator);
	
	        this.observable = observable;
	    }
	
	    TakeUntilOperator.prototype.call = function call(subscriber) {
	        return new TakeUntilSubscriber(subscriber, this.observable);
	    };
	
	    return TakeUntilOperator;
	})();
	
	var TakeUntilSubscriber = (function (_Subscriber) {
	    _inherits(TakeUntilSubscriber, _Subscriber);
	
	    function TakeUntilSubscriber(destination, observable) {
	        _classCallCheck(this, TakeUntilSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.add(observable._subscribe(new TakeUntilInnerSubscriber(destination)));
	    }
	
	    return TakeUntilSubscriber;
	})(_Subscriber4['default']);
	
	var TakeUntilInnerSubscriber = (function (_Subscriber2) {
	    _inherits(TakeUntilInnerSubscriber, _Subscriber2);
	
	    function TakeUntilInnerSubscriber(destination) {
	        _classCallCheck(this, TakeUntilInnerSubscriber);
	
	        _Subscriber2.call(this, destination);
	    }
	
	    TakeUntilInnerSubscriber.prototype._next = function _next() {
	        this.destination.complete();
	    };
	
	    TakeUntilInnerSubscriber.prototype._error = function _error(e) {
	        this.destination.error(e);
	    };
	
	    TakeUntilInnerSubscriber.prototype._complete = function _complete() {};
	
	    return TakeUntilInnerSubscriber;
	})(_Subscriber4['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = throttle;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	var _schedulersNextTick = __webpack_require__(13);
	
	var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);
	
	function throttle(delay) {
	    var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersNextTick2['default'] : arguments[1];
	
	    return this.lift(new ThrottleOperator(delay, scheduler));
	}
	
	var ThrottleOperator = (function () {
	    function ThrottleOperator(delay, scheduler) {
	        _classCallCheck(this, ThrottleOperator);
	
	        this.delay = delay;
	        this.scheduler = scheduler;
	    }
	
	    ThrottleOperator.prototype.call = function call(subscriber) {
	        return new ThrottleSubscriber(subscriber, this.delay, this.scheduler);
	    };
	
	    return ThrottleOperator;
	})();
	
	var ThrottleSubscriber = (function (_Subscriber) {
	    _inherits(ThrottleSubscriber, _Subscriber);
	
	    function ThrottleSubscriber(destination, delay, scheduler) {
	        _classCallCheck(this, ThrottleSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.delay = delay;
	        this.scheduler = scheduler;
	    }
	
	    ThrottleSubscriber.prototype._next = function _next(value) {
	        if (!this.throttled) {
	            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.delay, { value: value, subscriber: this }));
	        }
	    };
	
	    ThrottleSubscriber.prototype.throttledNext = function throttledNext(value) {
	        this.clearThrottle();
	        this.destination.next(value);
	    };
	
	    ThrottleSubscriber.prototype.clearThrottle = function clearThrottle() {
	        var throttled = this.throttled;
	        if (throttled) {
	            throttled.unsubscribe();
	            this.remove(throttled);
	        }
	    };
	
	    return ThrottleSubscriber;
	})(_Subscriber3['default']);
	
	function dispatchNext(_ref) {
	    var value = _ref.value;
	    var subscriber = _ref.subscriber;
	
	    subscriber.throttledNext(value);
	}
	module.exports = exports['default'];

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	exports['default'] = timeout;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	var _schedulersImmediate = __webpack_require__(10);
	
	var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);
	
	var _utilIsDate = __webpack_require__(63);
	
	var _utilIsDate2 = _interopRequireDefault(_utilIsDate);
	
	function timeout(due) {
	    var errorToSend = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    var scheduler = arguments.length <= 2 || arguments[2] === undefined ? _schedulersImmediate2['default'] : arguments[2];
	
	    var absoluteTimeout = _utilIsDate2['default'](due);
	    var waitFor = absoluteTimeout ? +due - scheduler.now() : due;
	    return this.lift(new TimeoutOperator(waitFor, absoluteTimeout, errorToSend, scheduler));
	}
	
	var TimeoutOperator = (function () {
	    function TimeoutOperator(waitFor, absoluteTimeout, errorToSend, scheduler) {
	        _classCallCheck(this, TimeoutOperator);
	
	        this.waitFor = waitFor;
	        this.absoluteTimeout = absoluteTimeout;
	        this.errorToSend = errorToSend;
	        this.scheduler = scheduler;
	    }
	
	    TimeoutOperator.prototype.call = function call(subscriber) {
	        return new TimeoutSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.errorToSend, this.scheduler);
	    };
	
	    return TimeoutOperator;
	})();
	
	var TimeoutSubscriber = (function (_Subscriber) {
	    _inherits(TimeoutSubscriber, _Subscriber);
	
	    function TimeoutSubscriber(destination, absoluteTimeout, waitFor, errorToSend, scheduler) {
	        _classCallCheck(this, TimeoutSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.absoluteTimeout = absoluteTimeout;
	        this.waitFor = waitFor;
	        this.errorToSend = errorToSend;
	        this.scheduler = scheduler;
	        this.index = 0;
	        this._previousIndex = 0;
	        this._hasCompleted = false;
	        this.scheduleTimeout();
	    }
	
	    TimeoutSubscriber.dispatchTimeout = function dispatchTimeout(state) {
	        var source = state.subscriber;
	        var currentIndex = state.index;
	        if (!source.hasCompleted && source.previousIndex === currentIndex) {
	            source.notifyTimeout();
	        }
	    };
	
	    TimeoutSubscriber.prototype.scheduleTimeout = function scheduleTimeout() {
	        var currentIndex = this.index;
	        this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, { subscriber: this, index: currentIndex });
	        this.index++;
	        this._previousIndex = currentIndex;
	    };
	
	    TimeoutSubscriber.prototype._next = function _next(value) {
	        this.destination.next(value);
	        if (!this.absoluteTimeout) {
	            this.scheduleTimeout();
	        }
	    };
	
	    TimeoutSubscriber.prototype._error = function _error(err) {
	        this.destination.error(err);
	        this._hasCompleted = true;
	    };
	
	    TimeoutSubscriber.prototype._complete = function _complete() {
	        this.destination.complete();
	        this._hasCompleted = true;
	    };
	
	    TimeoutSubscriber.prototype.notifyTimeout = function notifyTimeout() {
	        this.error(this.errorToSend || new Error('timeout'));
	    };
	
	    _createClass(TimeoutSubscriber, [{
	        key: 'previousIndex',
	        get: function get() {
	            return this._previousIndex;
	        }
	    }, {
	        key: 'hasCompleted',
	        get: function get() {
	            return this._hasCompleted;
	        }
	    }]);
	
	    return TimeoutSubscriber;
	})(_Subscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	exports['default'] = timeoutWith;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _schedulersImmediate = __webpack_require__(10);
	
	var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);
	
	var _utilIsDate = __webpack_require__(63);
	
	var _utilIsDate2 = _interopRequireDefault(_utilIsDate);
	
	var _OuterSubscriber2 = __webpack_require__(9);
	
	var _OuterSubscriber3 = _interopRequireDefault(_OuterSubscriber2);
	
	var _utilSubscribeToResult = __webpack_require__(11);
	
	var _utilSubscribeToResult2 = _interopRequireDefault(_utilSubscribeToResult);
	
	function timeoutWith(due, withObservable) {
	    var scheduler = arguments.length <= 2 || arguments[2] === undefined ? _schedulersImmediate2['default'] : arguments[2];
	
	    var absoluteTimeout = _utilIsDate2['default'](due);
	    var waitFor = absoluteTimeout ? +due - scheduler.now() : due;
	    return this.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
	}
	
	var TimeoutWithOperator = (function () {
	    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
	        _classCallCheck(this, TimeoutWithOperator);
	
	        this.waitFor = waitFor;
	        this.absoluteTimeout = absoluteTimeout;
	        this.withObservable = withObservable;
	        this.scheduler = scheduler;
	    }
	
	    TimeoutWithOperator.prototype.call = function call(subscriber) {
	        return new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler);
	    };
	
	    return TimeoutWithOperator;
	})();
	
	var TimeoutWithSubscriber = (function (_OuterSubscriber) {
	    _inherits(TimeoutWithSubscriber, _OuterSubscriber);
	
	    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
	        _classCallCheck(this, TimeoutWithSubscriber);
	
	        _OuterSubscriber.call(this, destination);
	        this.absoluteTimeout = absoluteTimeout;
	        this.waitFor = waitFor;
	        this.withObservable = withObservable;
	        this.scheduler = scheduler;
	        this.timeoutSubscription = undefined;
	        this.timedOut = false;
	        this.index = 0;
	        this._previousIndex = 0;
	        this._hasCompleted = false;
	        this.scheduleTimeout();
	    }
	
	    TimeoutWithSubscriber.dispatchTimeout = function dispatchTimeout(state) {
	        var source = state.subscriber;
	        var currentIndex = state.index;
	        if (!source.hasCompleted && source.previousIndex === currentIndex) {
	            source.handleTimeout();
	        }
	    };
	
	    TimeoutWithSubscriber.prototype.scheduleTimeout = function scheduleTimeout() {
	        var currentIndex = this.index;
	        var timeoutState = { subscriber: this, index: currentIndex };
	        this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, timeoutState);
	        this.index++;
	        this._previousIndex = currentIndex;
	    };
	
	    TimeoutWithSubscriber.prototype._next = function _next(value) {
	        if (!this.timedOut) {
	            this.destination.next(value);
	            if (!this.absoluteTimeout) {
	                this.scheduleTimeout();
	            }
	        }
	    };
	
	    TimeoutWithSubscriber.prototype._error = function _error(err) {
	        if (!this.timedOut) {
	            this.destination.error(err);
	            this._hasCompleted = true;
	        }
	    };
	
	    TimeoutWithSubscriber.prototype._complete = function _complete() {
	        if (!this.timedOut) {
	            this.destination.complete();
	            this._hasCompleted = true;
	        }
	    };
	
	    TimeoutWithSubscriber.prototype.handleTimeout = function handleTimeout() {
	        var withObservable = this.withObservable;
	        this.timedOut = true;
	        this.add(this.timeoutSubscription = _utilSubscribeToResult2['default'](this, withObservable));
	    };
	
	    _createClass(TimeoutWithSubscriber, [{
	        key: 'previousIndex',
	        get: function get() {
	            return this._previousIndex;
	        }
	    }, {
	        key: 'hasCompleted',
	        get: function get() {
	            return this._hasCompleted;
	        }
	    }]);
	
	    return TimeoutWithSubscriber;
	})(_OuterSubscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = toArray;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	function toArray() {
	    return this.lift(new ToArrayOperator());
	}
	
	var ToArrayOperator = (function () {
	    function ToArrayOperator() {
	        _classCallCheck(this, ToArrayOperator);
	    }
	
	    ToArrayOperator.prototype.call = function call(subscriber) {
	        return new ToArraySubscriber(subscriber);
	    };
	
	    return ToArrayOperator;
	})();
	
	var ToArraySubscriber = (function (_Subscriber) {
	    _inherits(ToArraySubscriber, _Subscriber);
	
	    function ToArraySubscriber(destination) {
	        _classCallCheck(this, ToArraySubscriber);
	
	        _Subscriber.call(this, destination);
	        this.array = [];
	    }
	
	    ToArraySubscriber.prototype._next = function _next(x) {
	        this.array.push(x);
	    };
	
	    ToArraySubscriber.prototype._complete = function _complete() {
	        this.destination.next(this.array);
	        this.destination.complete();
	    };
	
	    return ToArraySubscriber;
	})(_Subscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = toPromise;
	
	var _utilRoot = __webpack_require__(16);
	
	function toPromise(PromiseCtor) {
	    var _this = this;
	
	    if (!PromiseCtor) {
	        if (_utilRoot.root.Rx && _utilRoot.root.Rx.config && _utilRoot.root.Rx.config.Promise) {
	            PromiseCtor = _utilRoot.root.Rx.config.Promise;
	        } else if (_utilRoot.root.Promise) {
	            PromiseCtor = _utilRoot.root.Promise;
	        }
	    }
	    if (!PromiseCtor) {
	        throw new Error('no Promise impl found');
	    }
	    return new PromiseCtor(function (resolve, reject) {
	        var value = undefined;
	        _this.subscribe(function (x) {
	            return value = x;
	        }, function (err) {
	            return reject(err);
	        }, function () {
	            return resolve(value);
	        });
	    });
	}
	
	module.exports = exports['default'];

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = window;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber3 = __webpack_require__(1);
	
	var _Subscriber4 = _interopRequireDefault(_Subscriber3);
	
	var _Subject = __webpack_require__(7);
	
	var _Subject2 = _interopRequireDefault(_Subject);
	
	function window(closingNotifier) {
	    return this.lift(new WindowOperator(closingNotifier));
	}
	
	var WindowOperator = (function () {
	    function WindowOperator(closingNotifier) {
	        _classCallCheck(this, WindowOperator);
	
	        this.closingNotifier = closingNotifier;
	    }
	
	    WindowOperator.prototype.call = function call(subscriber) {
	        return new WindowSubscriber(subscriber, this.closingNotifier);
	    };
	
	    return WindowOperator;
	})();
	
	var WindowSubscriber = (function (_Subscriber) {
	    _inherits(WindowSubscriber, _Subscriber);
	
	    function WindowSubscriber(destination, closingNotifier) {
	        _classCallCheck(this, WindowSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.closingNotifier = closingNotifier;
	        this.window = new _Subject2['default']();
	        this.add(closingNotifier._subscribe(new WindowClosingNotifierSubscriber(this)));
	        this.openWindow();
	    }
	
	    WindowSubscriber.prototype._next = function _next(value) {
	        this.window.next(value);
	    };
	
	    WindowSubscriber.prototype._error = function _error(err) {
	        this.window.error(err);
	        this.destination.error(err);
	    };
	
	    WindowSubscriber.prototype._complete = function _complete() {
	        this.window.complete();
	        this.destination.complete();
	    };
	
	    WindowSubscriber.prototype.openWindow = function openWindow() {
	        var prevWindow = this.window;
	        if (prevWindow) {
	            prevWindow.complete();
	        }
	        this.destination.next(this.window = new _Subject2['default']());
	    };
	
	    return WindowSubscriber;
	})(_Subscriber4['default']);
	
	var WindowClosingNotifierSubscriber = (function (_Subscriber2) {
	    _inherits(WindowClosingNotifierSubscriber, _Subscriber2);
	
	    function WindowClosingNotifierSubscriber(parent) {
	        _classCallCheck(this, WindowClosingNotifierSubscriber);
	
	        _Subscriber2.call(this, null);
	        this.parent = parent;
	    }
	
	    WindowClosingNotifierSubscriber.prototype._next = function _next() {
	        this.parent.openWindow();
	    };
	
	    WindowClosingNotifierSubscriber.prototype._error = function _error(err) {
	        this.parent._error(err);
	    };
	
	    WindowClosingNotifierSubscriber.prototype._complete = function _complete() {
	        this.parent._complete();
	    };
	
	    return WindowClosingNotifierSubscriber;
	})(_Subscriber4['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = windowCount;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	var _Subject = __webpack_require__(7);
	
	var _Subject2 = _interopRequireDefault(_Subject);
	
	function windowCount(windowSize) {
	    var startWindowEvery = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	
	    return this.lift(new WindowCountOperator(windowSize, startWindowEvery));
	}
	
	var WindowCountOperator = (function () {
	    function WindowCountOperator(windowSize, startWindowEvery) {
	        _classCallCheck(this, WindowCountOperator);
	
	        this.windowSize = windowSize;
	        this.startWindowEvery = startWindowEvery;
	    }
	
	    WindowCountOperator.prototype.call = function call(subscriber) {
	        return new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery);
	    };
	
	    return WindowCountOperator;
	})();
	
	var WindowCountSubscriber = (function (_Subscriber) {
	    _inherits(WindowCountSubscriber, _Subscriber);
	
	    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
	        _classCallCheck(this, WindowCountSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.windowSize = windowSize;
	        this.startWindowEvery = startWindowEvery;
	        this.windows = [new _Subject2['default']()];
	        this.count = 0;
	        destination.next(this.windows[0]);
	    }
	
	    WindowCountSubscriber.prototype._next = function _next(value) {
	        var startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;
	        var windowSize = this.windowSize;
	        var windows = this.windows;
	        var len = windows.length;
	        for (var i = 0; i < len; i++) {
	            windows[i].next(value);
	        }
	        var c = this.count - windowSize + 1;
	        if (c >= 0 && c % startWindowEvery === 0) {
	            windows.shift().complete();
	        }
	        if (++this.count % startWindowEvery === 0) {
	            var _window = new _Subject2['default']();
	            windows.push(_window);
	            this.destination.next(_window);
	        }
	    };
	
	    WindowCountSubscriber.prototype._error = function _error(err) {
	        var windows = this.windows;
	        while (windows.length > 0) {
	            windows.shift().error(err);
	        }
	        this.destination.error(err);
	    };
	
	    WindowCountSubscriber.prototype._complete = function _complete() {
	        var windows = this.windows;
	        while (windows.length > 0) {
	            windows.shift().complete();
	        }
	        this.destination.complete();
	    };
	
	    return WindowCountSubscriber;
	})(_Subscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = windowTime;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber2 = __webpack_require__(1);
	
	var _Subscriber3 = _interopRequireDefault(_Subscriber2);
	
	var _Subject = __webpack_require__(7);
	
	var _Subject2 = _interopRequireDefault(_Subject);
	
	var _schedulersNextTick = __webpack_require__(13);
	
	var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);
	
	function windowTime(windowTimeSpan) {
	    var windowCreationInterval = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    var scheduler = arguments.length <= 2 || arguments[2] === undefined ? _schedulersNextTick2['default'] : arguments[2];
	
	    return this.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, scheduler));
	}
	
	var WindowTimeOperator = (function () {
	    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, scheduler) {
	        _classCallCheck(this, WindowTimeOperator);
	
	        this.windowTimeSpan = windowTimeSpan;
	        this.windowCreationInterval = windowCreationInterval;
	        this.scheduler = scheduler;
	    }
	
	    WindowTimeOperator.prototype.call = function call(subscriber) {
	        return new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.scheduler);
	    };
	
	    return WindowTimeOperator;
	})();
	
	var WindowTimeSubscriber = (function (_Subscriber) {
	    _inherits(WindowTimeSubscriber, _Subscriber);
	
	    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, scheduler) {
	        _classCallCheck(this, WindowTimeSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.windowTimeSpan = windowTimeSpan;
	        this.windowCreationInterval = windowCreationInterval;
	        this.scheduler = scheduler;
	        this.windows = [];
	        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
	            var _window = this.openWindow();
	            var closeState = { subscriber: this, window: _window, context: null };
	            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: this, scheduler: scheduler };
	            this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
	            this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
	        } else {
	            var _window2 = this.openWindow();
	            var timeSpanOnlyState = { subscriber: this, window: _window2, windowTimeSpan: windowTimeSpan };
	            this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
	        }
	    }
	
	    WindowTimeSubscriber.prototype._next = function _next(value) {
	        var windows = this.windows;
	        var len = windows.length;
	        for (var i = 0; i < len; i++) {
	            windows[i].next(value);
	        }
	    };
	
	    WindowTimeSubscriber.prototype._error = function _error(err) {
	        var windows = this.windows;
	        while (windows.length > 0) {
	            windows.shift().error(err);
	        }
	        this.destination.error(err);
	    };
	
	    WindowTimeSubscriber.prototype._complete = function _complete() {
	        var windows = this.windows;
	        while (windows.length > 0) {
	            windows.shift().complete();
	        }
	        this.destination.complete();
	    };
	
	    WindowTimeSubscriber.prototype.openWindow = function openWindow() {
	        var window = new _Subject2['default']();
	        this.windows.push(window);
	        this.destination.next(window);
	        return window;
	    };
	
	    WindowTimeSubscriber.prototype.closeWindow = function closeWindow(window) {
	        window.complete();
	        var windows = this.windows;
	        windows.splice(windows.indexOf(window), 1);
	    };
	
	    return WindowTimeSubscriber;
	})(_Subscriber3['default']);
	
	function dispatchWindowTimeSpanOnly(state) {
	    var subscriber = state.subscriber;
	    var windowTimeSpan = state.windowTimeSpan;
	    var window = state.window;
	
	    if (window) {
	        window.complete();
	    }
	    state.window = subscriber.openWindow();
	    this.schedule(state, windowTimeSpan);
	}
	function dispatchWindowCreation(state) {
	    var windowTimeSpan = state.windowTimeSpan;
	    var subscriber = state.subscriber;
	    var scheduler = state.scheduler;
	    var windowCreationInterval = state.windowCreationInterval;
	
	    var window = subscriber.openWindow();
	    var action = this;
	    var context = { action: action, subscription: null };
	    var timeSpanState = { subscriber: subscriber, window: window, context: context };
	    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
	    action.add(context.subscription);
	    action.schedule(state, windowCreationInterval);
	}
	function dispatchWindowClose(_ref) {
	    var subscriber = _ref.subscriber;
	    var window = _ref.window;
	    var context = _ref.context;
	
	    if (context && context.action && context.subscription) {
	        context.action.remove(context.subscription);
	    }
	    subscriber.closeWindow(window);
	}
	module.exports = exports['default'];

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = windowToggle;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber4 = __webpack_require__(1);
	
	var _Subscriber5 = _interopRequireDefault(_Subscriber4);
	
	var _Subject = __webpack_require__(7);
	
	var _Subject2 = _interopRequireDefault(_Subject);
	
	var _Subscription = __webpack_require__(5);
	
	var _Subscription2 = _interopRequireDefault(_Subscription);
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	function windowToggle(openings, closingSelector) {
	    return this.lift(new WindowToggleOperator(openings, closingSelector));
	}
	
	var WindowToggleOperator = (function () {
	    function WindowToggleOperator(openings, closingSelector) {
	        _classCallCheck(this, WindowToggleOperator);
	
	        this.openings = openings;
	        this.closingSelector = closingSelector;
	    }
	
	    WindowToggleOperator.prototype.call = function call(subscriber) {
	        return new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector);
	    };
	
	    return WindowToggleOperator;
	})();
	
	var WindowToggleSubscriber = (function (_Subscriber) {
	    _inherits(WindowToggleSubscriber, _Subscriber);
	
	    function WindowToggleSubscriber(destination, openings, closingSelector) {
	        _classCallCheck(this, WindowToggleSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.openings = openings;
	        this.closingSelector = closingSelector;
	        this.windows = [];
	        this.add(this.openings._subscribe(new WindowToggleOpeningsSubscriber(this)));
	    }
	
	    WindowToggleSubscriber.prototype._next = function _next(value) {
	        var windows = this.windows;
	        var len = windows.length;
	        for (var i = 0; i < len; i++) {
	            windows[i].next(value);
	        }
	    };
	
	    WindowToggleSubscriber.prototype._error = function _error(err) {
	        var windows = this.windows;
	        while (windows.length > 0) {
	            windows.shift().error(err);
	        }
	        this.destination.error(err);
	    };
	
	    WindowToggleSubscriber.prototype._complete = function _complete() {
	        var windows = this.windows;
	        while (windows.length > 0) {
	            windows.shift().complete();
	        }
	        this.destination.complete();
	    };
	
	    WindowToggleSubscriber.prototype.openWindow = function openWindow(value) {
	        var window = new _Subject2['default']();
	        this.windows.push(window);
	        this.destination.next(window);
	        var windowContext = {
	            window: window,
	            subscription: new _Subscription2['default']()
	        };
	        var closingSelector = this.closingSelector;
	        var closingNotifier = _utilTryCatch2['default'](closingSelector)(value);
	        if (closingNotifier === _utilErrorObject.errorObject) {
	            this.error(closingNotifier.e);
	        } else {
	            var subscriber = new WindowClosingNotifierSubscriber(this, windowContext);
	            var subscription = closingNotifier._subscribe(subscriber);
	            this.add(windowContext.subscription.add(subscription));
	        }
	    };
	
	    WindowToggleSubscriber.prototype.closeWindow = function closeWindow(windowContext) {
	        var window = windowContext.window;
	        var subscription = windowContext.subscription;
	
	        var windows = this.windows;
	        windows.splice(windows.indexOf(window), 1);
	        window.complete();
	        this.remove(subscription);
	    };
	
	    return WindowToggleSubscriber;
	})(_Subscriber5['default']);
	
	var WindowClosingNotifierSubscriber = (function (_Subscriber2) {
	    _inherits(WindowClosingNotifierSubscriber, _Subscriber2);
	
	    function WindowClosingNotifierSubscriber(parent, windowContext) {
	        _classCallCheck(this, WindowClosingNotifierSubscriber);
	
	        _Subscriber2.call(this, null);
	        this.parent = parent;
	        this.windowContext = windowContext;
	    }
	
	    WindowClosingNotifierSubscriber.prototype._next = function _next() {
	        this.parent.closeWindow(this.windowContext);
	    };
	
	    WindowClosingNotifierSubscriber.prototype._error = function _error(err) {
	        this.parent.error(err);
	    };
	
	    WindowClosingNotifierSubscriber.prototype._complete = function _complete() {
	        // noop
	    };
	
	    return WindowClosingNotifierSubscriber;
	})(_Subscriber5['default']);
	
	var WindowToggleOpeningsSubscriber = (function (_Subscriber3) {
	    _inherits(WindowToggleOpeningsSubscriber, _Subscriber3);
	
	    function WindowToggleOpeningsSubscriber(parent) {
	        _classCallCheck(this, WindowToggleOpeningsSubscriber);
	
	        _Subscriber3.call(this);
	        this.parent = parent;
	    }
	
	    WindowToggleOpeningsSubscriber.prototype._next = function _next(value) {
	        this.parent.openWindow(value);
	    };
	
	    WindowToggleOpeningsSubscriber.prototype._error = function _error(err) {
	        this.parent.error(err);
	    };
	
	    WindowToggleOpeningsSubscriber.prototype._complete = function _complete() {
	        // noop
	    };
	
	    return WindowToggleOpeningsSubscriber;
	})(_Subscriber5['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = window;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _Subscriber3 = __webpack_require__(1);
	
	var _Subscriber4 = _interopRequireDefault(_Subscriber3);
	
	var _Subject = __webpack_require__(7);
	
	var _Subject2 = _interopRequireDefault(_Subject);
	
	var _Subscription = __webpack_require__(5);
	
	var _Subscription2 = _interopRequireDefault(_Subscription);
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	function window(closingSelector) {
	    return this.lift(new WindowOperator(closingSelector));
	}
	
	var WindowOperator = (function () {
	    function WindowOperator(closingSelector) {
	        _classCallCheck(this, WindowOperator);
	
	        this.closingSelector = closingSelector;
	    }
	
	    WindowOperator.prototype.call = function call(subscriber) {
	        return new WindowSubscriber(subscriber, this.closingSelector);
	    };
	
	    return WindowOperator;
	})();
	
	var WindowSubscriber = (function (_Subscriber) {
	    _inherits(WindowSubscriber, _Subscriber);
	
	    function WindowSubscriber(destination, closingSelector) {
	        _classCallCheck(this, WindowSubscriber);
	
	        _Subscriber.call(this, destination);
	        this.closingSelector = closingSelector;
	        this.window = new _Subject2['default']();
	        this.openWindow();
	    }
	
	    WindowSubscriber.prototype._next = function _next(value) {
	        this.window.next(value);
	    };
	
	    WindowSubscriber.prototype._error = function _error(err) {
	        this.window.error(err);
	        this.destination.error(err);
	    };
	
	    WindowSubscriber.prototype._complete = function _complete() {
	        this.window.complete();
	        this.destination.complete();
	    };
	
	    WindowSubscriber.prototype.openWindow = function openWindow() {
	        var prevClosingNotification = this.closingNotification;
	        if (prevClosingNotification) {
	            this.remove(prevClosingNotification);
	            prevClosingNotification.unsubscribe();
	        }
	        var prevWindow = this.window;
	        if (prevWindow) {
	            prevWindow.complete();
	        }
	        this.destination.next(this.window = new _Subject2['default']());
	        var closingNotifier = _utilTryCatch2['default'](this.closingSelector)();
	        if (closingNotifier === _utilErrorObject.errorObject) {
	            var err = closingNotifier.e;
	            this.destination.error(err);
	            this.window.error(err);
	        } else {
	            var closingNotification = this.closingNotification = new _Subscription2['default']();
	            this.add(closingNotification.add(closingNotifier._subscribe(new WindowClosingNotifierSubscriber(this))));
	        }
	    };
	
	    return WindowSubscriber;
	})(_Subscriber4['default']);
	
	var WindowClosingNotifierSubscriber = (function (_Subscriber2) {
	    _inherits(WindowClosingNotifierSubscriber, _Subscriber2);
	
	    function WindowClosingNotifierSubscriber(parent) {
	        _classCallCheck(this, WindowClosingNotifierSubscriber);
	
	        _Subscriber2.call(this, null);
	        this.parent = parent;
	    }
	
	    WindowClosingNotifierSubscriber.prototype._next = function _next() {
	        this.parent.openWindow();
	    };
	
	    WindowClosingNotifierSubscriber.prototype._error = function _error(err) {
	        this.parent.error(err);
	    };
	
	    WindowClosingNotifierSubscriber.prototype._complete = function _complete() {
	        // noop
	    };
	
	    return WindowClosingNotifierSubscriber;
	})(_Subscriber4['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = withLatestFrom;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _utilTryCatch = __webpack_require__(3);
	
	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);
	
	var _utilErrorObject = __webpack_require__(2);
	
	var _OuterSubscriber2 = __webpack_require__(9);
	
	var _OuterSubscriber3 = _interopRequireDefault(_OuterSubscriber2);
	
	var _utilSubscribeToResult = __webpack_require__(11);
	
	var _utilSubscribeToResult2 = _interopRequireDefault(_utilSubscribeToResult);
	
	/**
	 * @param {Observable} observables the observables to get the latest values from.
	 * @param {Function} [project] optional projection function for merging values together. Receives all values in order
	 *  of observables passed. (e.g. `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not passed, arrays
	 *  will be returned.
	 * @description merges each value from an observable with the latest values from the other passed observables.
	 * All observables must emit at least one value before the resulting observable will emit
	 *
	 * #### example
	 * ```
	 * A.withLatestFrom(B, C)
	 *
	 *  A:     ----a-----------------b---------------c-----------|
	 *  B:     ---d----------------e--------------f---------|
	 *  C:     --x----------------y-------------z-------------|
	 * result: ---([a,d,x])---------([b,e,y])--------([c,f,z])---|
	 * ```
	 */
	
	function withLatestFrom() {
	    var project = undefined;
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	    }
	
	    if (typeof args[args.length - 1] === 'function') {
	        project = args.pop();
	    }
	    var observables = args;
	    return this.lift(new WithLatestFromOperator(observables, project));
	}
	
	var WithLatestFromOperator = (function () {
	    function WithLatestFromOperator(observables, project) {
	        _classCallCheck(this, WithLatestFromOperator);
	
	        this.observables = observables;
	        this.project = project;
	    }
	
	    WithLatestFromOperator.prototype.call = function call(subscriber) {
	        return new WithLatestFromSubscriber(subscriber, this.observables, this.project);
	    };
	
	    return WithLatestFromOperator;
	})();
	
	var WithLatestFromSubscriber = (function (_OuterSubscriber) {
	    _inherits(WithLatestFromSubscriber, _OuterSubscriber);
	
	    function WithLatestFromSubscriber(destination, observables, project) {
	        _classCallCheck(this, WithLatestFromSubscriber);
	
	        _OuterSubscriber.call(this, destination);
	        this.observables = observables;
	        this.project = project;
	        this.toRespond = [];
	        var len = observables.length;
	        this.values = new Array(len);
	        for (var i = 0; i < len; i++) {
	            this.toRespond.push(i);
	        }
	        for (var i = 0; i < len; i++) {
	            var observable = observables[i];
	            this.add(_utilSubscribeToResult2['default'](this, observable, observable, i));
	        }
	    }
	
	    WithLatestFromSubscriber.prototype.notifyNext = function notifyNext(observable, value, observableIndex, index) {
	        this.values[observableIndex] = value;
	        var toRespond = this.toRespond;
	        if (toRespond.length > 0) {
	            var found = toRespond.indexOf(observableIndex);
	            if (found !== -1) {
	                toRespond.splice(found, 1);
	            }
	        }
	    };
	
	    WithLatestFromSubscriber.prototype.notifyComplete = function notifyComplete() {
	        // noop
	    };
	
	    WithLatestFromSubscriber.prototype._next = function _next(value) {
	        if (this.toRespond.length === 0) {
	            var values = this.values;
	            var destination = this.destination;
	            var project = this.project;
	            var args = [value].concat(values);
	            if (project) {
	                var result = _utilTryCatch2['default'](this.project).apply(this, args);
	                if (result === _utilErrorObject.errorObject) {
	                    destination.error(result.e);
	                } else {
	                    destination.next(result);
	                }
	            } else {
	                destination.next(args);
	            }
	        }
	    };
	
	    return WithLatestFromSubscriber;
	})(_OuterSubscriber3['default']);
	
	module.exports = exports['default'];

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = zipProto;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _zipStatic = __webpack_require__(53);
	
	var _zipStatic2 = _interopRequireDefault(_zipStatic);
	
	function zipProto() {
	    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
	        observables[_key] = arguments[_key];
	    }
	
	    observables.unshift(this);
	    return _zipStatic2['default'].apply(this, observables);
	}
	
	module.exports = exports['default'];

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = zipAll;
	
	var _zipSupport = __webpack_require__(54);
	
	function zipAll(project) {
	    return this.lift(new _zipSupport.ZipOperator(project));
	}
	
	module.exports = exports['default'];

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _ImmediateAction2 = __webpack_require__(24);
	
	var _ImmediateAction3 = _interopRequireDefault(_ImmediateAction2);
	
	var FutureAction = (function (_ImmediateAction) {
	    _inherits(FutureAction, _ImmediateAction);
	
	    function FutureAction(scheduler, work) {
	        _classCallCheck(this, FutureAction);
	
	        _ImmediateAction.call(this, scheduler, work);
	        this.scheduler = scheduler;
	        this.work = work;
	    }
	
	    FutureAction.prototype.schedule = function schedule(state) {
	        var _this = this;
	
	        var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	
	        if (this.isUnsubscribed) {
	            return this;
	        }
	        this.delay = delay;
	        this.state = state;
	        var id = this.id;
	        if (id != null) {
	            this.id = undefined;
	            clearTimeout(id);
	        }
	        var scheduler = this.scheduler;
	        this.id = setTimeout(function () {
	            _this.id = void 0;
	            scheduler.actions.push(_this);
	            scheduler.flush();
	        }, this.delay);
	        return this;
	    };
	
	    FutureAction.prototype.unsubscribe = function unsubscribe() {
	        var id = this.id;
	        if (id != null) {
	            this.id = void 0;
	            clearTimeout(id);
	        }
	        _ImmediateAction.prototype.unsubscribe.call(this);
	    };
	
	    return FutureAction;
	})(_ImmediateAction3['default']);
	
	exports['default'] = FutureAction;
	module.exports = exports['default'];

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _utilImmediate = __webpack_require__(182);
	
	var _ImmediateAction2 = __webpack_require__(24);
	
	var _ImmediateAction3 = _interopRequireDefault(_ImmediateAction2);
	
	var NextTickAction = (function (_ImmediateAction) {
	    _inherits(NextTickAction, _ImmediateAction);
	
	    function NextTickAction() {
	        _classCallCheck(this, NextTickAction);
	
	        _ImmediateAction.apply(this, arguments);
	    }
	
	    NextTickAction.prototype.schedule = function schedule(state) {
	        var _this = this;
	
	        if (this.isUnsubscribed) {
	            return this;
	        }
	        this.state = state;
	        var scheduler = this.scheduler;
	        scheduler.actions.push(this);
	        if (!scheduler.scheduled) {
	            scheduler.scheduled = true;
	            this.id = _utilImmediate.Immediate.setImmediate(function () {
	                _this.id = void 0;
	                _this.scheduler.scheduled = false;
	                _this.scheduler.flush();
	            });
	        }
	        return this;
	    };
	
	    NextTickAction.prototype.unsubscribe = function unsubscribe() {
	        var id = this.id;
	        var scheduler = this.scheduler;
	        _ImmediateAction.prototype.unsubscribe.call(this);
	        if (scheduler.actions.length === 0) {
	            scheduler.active = false;
	            scheduler.scheduled = false;
	            if (id) {
	                this.id = void 0;
	                _utilImmediate.Immediate.clearImmediate(id);
	            }
	        }
	    };
	
	    return NextTickAction;
	})(_ImmediateAction3['default']);
	
	exports['default'] = NextTickAction;
	module.exports = exports['default'];

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _ImmediateScheduler2 = __webpack_require__(55);
	
	var _ImmediateScheduler3 = _interopRequireDefault(_ImmediateScheduler2);
	
	var _NextTickAction = __webpack_require__(175);
	
	var _NextTickAction2 = _interopRequireDefault(_NextTickAction);
	
	var _ImmediateAction = __webpack_require__(24);
	
	var _ImmediateAction2 = _interopRequireDefault(_ImmediateAction);
	
	var NextTickScheduler = (function (_ImmediateScheduler) {
	    _inherits(NextTickScheduler, _ImmediateScheduler);
	
	    function NextTickScheduler() {
	        _classCallCheck(this, NextTickScheduler);
	
	        _ImmediateScheduler.apply(this, arguments);
	    }
	
	    NextTickScheduler.prototype.scheduleNow = function scheduleNow(work, state) {
	        return (this.scheduled ? new _ImmediateAction2['default'](this, work) : new _NextTickAction2['default'](this, work)).schedule(state);
	    };
	
	    return NextTickScheduler;
	})(_ImmediateScheduler3['default']);
	
	exports['default'] = NextTickScheduler;
	module.exports = exports['default'];

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _Subscription2 = __webpack_require__(5);
	
	var _Subscription3 = _interopRequireDefault(_Subscription2);
	
	var _Subscriber = __webpack_require__(1);
	
	var _Subscriber2 = _interopRequireDefault(_Subscriber);
	
	var SubjectSubscription = (function (_Subscription) {
	    _inherits(SubjectSubscription, _Subscription);
	
	    function SubjectSubscription(subject, observer) {
	        _classCallCheck(this, SubjectSubscription);
	
	        _Subscription.call(this);
	        this.subject = subject;
	        this.observer = observer;
	        this.isUnsubscribed = false;
	    }
	
	    SubjectSubscription.prototype.unsubscribe = function unsubscribe() {
	        if (this.isUnsubscribed) {
	            return;
	        }
	        this.isUnsubscribed = true;
	        var subject = this.subject;
	        var observers = subject.observers;
	        this.subject = void 0;
	        if (!observers || observers.length === 0 || subject.isUnsubscribed) {
	            return;
	        }
	        if (this.observer instanceof _Subscriber2['default']) {
	            this.observer.unsubscribe();
	        }
	        var subscriberIndex = observers.indexOf(this.observer);
	        if (subscriberIndex !== -1) {
	            observers.splice(subscriberIndex, 1);
	        }
	    };
	
	    return SubjectSubscription;
	})(_Subscription3['default']);
	
	exports['default'] = SubjectSubscription;
	module.exports = exports['default'];

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _Observable2 = __webpack_require__(4);
	
	var _Observable3 = _interopRequireDefault(_Observable2);
	
	var _Subscription = __webpack_require__(5);
	
	var _Subscription2 = _interopRequireDefault(_Subscription);
	
	var _SubscriptionLoggable = __webpack_require__(60);
	
	var _SubscriptionLoggable2 = _interopRequireDefault(_SubscriptionLoggable);
	
	var _utilApplyMixins = __webpack_require__(62);
	
	var _utilApplyMixins2 = _interopRequireDefault(_utilApplyMixins);
	
	var ColdObservable = (function (_Observable) {
	    _inherits(ColdObservable, _Observable);
	
	    function ColdObservable(messages, scheduler) {
	        _classCallCheck(this, ColdObservable);
	
	        _Observable.call(this, function (subscriber) {
	            var observable = this;
	            var index = observable.logSubscribedFrame();
	            subscriber.add(new _Subscription2['default'](function () {
	                observable.logUnsubscribedFrame(index);
	            }));
	            observable.scheduleMessages(subscriber);
	            return subscriber;
	        });
	        this.messages = messages;
	        this.subscriptions = [];
	        this.scheduler = scheduler;
	    }
	
	    ColdObservable.prototype.scheduleMessages = function scheduleMessages(subscriber) {
	        var messagesLength = this.messages.length;
	        for (var i = 0; i < messagesLength; i++) {
	            var message = this.messages[i];
	            subscriber.add(this.scheduler.schedule(function (_ref) {
	                var message = _ref.message;
	                var subscriber = _ref.subscriber;
	                message.notification.observe(subscriber);
	            }, message.frame, { message: message, subscriber: subscriber }));
	        }
	    };
	
	    return ColdObservable;
	})(_Observable3['default']);
	
	exports['default'] = ColdObservable;
	
	_utilApplyMixins2['default'](ColdObservable, [_SubscriptionLoggable2['default']]);
	module.exports = exports['default'];

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _Subject2 = __webpack_require__(7);
	
	var _Subject3 = _interopRequireDefault(_Subject2);
	
	var _Subscription = __webpack_require__(5);
	
	var _Subscription2 = _interopRequireDefault(_Subscription);
	
	var _SubscriptionLoggable = __webpack_require__(60);
	
	var _SubscriptionLoggable2 = _interopRequireDefault(_SubscriptionLoggable);
	
	var _utilApplyMixins = __webpack_require__(62);
	
	var _utilApplyMixins2 = _interopRequireDefault(_utilApplyMixins);
	
	var HotObservable = (function (_Subject) {
	    _inherits(HotObservable, _Subject);
	
	    function HotObservable(messages, scheduler) {
	        _classCallCheck(this, HotObservable);
	
	        _Subject.call(this);
	        this.messages = messages;
	        this.subscriptions = [];
	        this.scheduler = scheduler;
	    }
	
	    HotObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var subject = this;
	        var index = subject.logSubscribedFrame();
	        subscriber.add(new _Subscription2['default'](function () {
	            subject.logUnsubscribedFrame(index);
	        }));
	        return _Subject.prototype._subscribe.call(this, subscriber);
	    };
	
	    HotObservable.prototype.setup = function setup() {
	        var _this = this;
	
	        var subject = this;
	        var messagesLength = subject.messages.length;
	
	        var _loop = function (i) {
	            var message = subject.messages[i];
	            _this.scheduler.schedule(function () {
	                message.notification.observe(subject);
	            }, message.frame);
	        };
	
	        for (var i = 0; i < messagesLength; i++) {
	            _loop(i);
	        }
	    };
	
	    return HotObservable;
	})(_Subject3['default']);
	
	exports['default'] = HotObservable;
	
	_utilApplyMixins2['default'](HotObservable, [_SubscriptionLoggable2['default']]);
	module.exports = exports['default'];

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _Observable = __webpack_require__(4);
	
	var _Observable2 = _interopRequireDefault(_Observable);
	
	var _schedulersVirtualTimeScheduler = __webpack_require__(56);
	
	var _schedulersVirtualTimeScheduler2 = _interopRequireDefault(_schedulersVirtualTimeScheduler);
	
	var _Notification = __webpack_require__(18);
	
	var _Notification2 = _interopRequireDefault(_Notification);
	
	var _ColdObservable = __webpack_require__(178);
	
	var _ColdObservable2 = _interopRequireDefault(_ColdObservable);
	
	var _HotObservable = __webpack_require__(179);
	
	var _HotObservable2 = _interopRequireDefault(_HotObservable);
	
	var _SubscriptionLog = __webpack_require__(59);
	
	var _SubscriptionLog2 = _interopRequireDefault(_SubscriptionLog);
	
	var TestScheduler = (function (_VirtualTimeScheduler) {
	    _inherits(TestScheduler, _VirtualTimeScheduler);
	
	    function TestScheduler(assertDeepEqual) {
	        _classCallCheck(this, TestScheduler);
	
	        _VirtualTimeScheduler.call(this);
	        this.assertDeepEqual = assertDeepEqual;
	        this.hotObservables = [];
	        this.flushTests = [];
	    }
	
	    TestScheduler.prototype.createColdObservable = function createColdObservable(marbles, values, error) {
	        if (marbles.indexOf('^') !== -1) {
	            throw new Error('Cold observable cannot have subscription offset "^"');
	        }
	        if (marbles.indexOf('!') !== -1) {
	            throw new Error('Cold observable cannot have unsubscription marker "!"');
	        }
	        var messages = TestScheduler.parseMarbles(marbles, values, error);
	        return new _ColdObservable2['default'](messages, this);
	    };
	
	    TestScheduler.prototype.createHotObservable = function createHotObservable(marbles, values, error) {
	        if (marbles.indexOf('!') !== -1) {
	            throw new Error('Hot observable cannot have unsubscription marker "!"');
	        }
	        var messages = TestScheduler.parseMarbles(marbles, values, error);
	        var subject = new _HotObservable2['default'](messages, this);
	        this.hotObservables.push(subject);
	        return subject;
	    };
	
	    TestScheduler.prototype.materializeInnerObservable = function materializeInnerObservable(observable, outerFrame) {
	        var _this = this;
	
	        var messages = [];
	        observable.subscribe(function (value) {
	            messages.push({ frame: _this.frame - outerFrame, notification: _Notification2['default'].createNext(value) });
	        }, function (err) {
	            messages.push({ frame: _this.frame - outerFrame, notification: _Notification2['default'].createError(err) });
	        }, function () {
	            messages.push({ frame: _this.frame - outerFrame, notification: _Notification2['default'].createComplete() });
	        });
	        return messages;
	    };
	
	    TestScheduler.prototype.expectObservable = function expectObservable(observable) {
	        var _this2 = this;
	
	        var unsubscriptionMarbles = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	
	        var actual = [];
	        var flushTest = { actual: actual, ready: false };
	        var unsubscriptionFrame = TestScheduler.parseMarblesAsSubscriptions(unsubscriptionMarbles).unsubscribedFrame;
	        var subscription = undefined;
	        this.schedule(function () {
	            subscription = observable.subscribe(function (x) {
	                var value = x;
	                // Support Observable-of-Observables
	                if (x instanceof _Observable2['default']) {
	                    value = _this2.materializeInnerObservable(value, _this2.frame);
	                }
	                actual.push({ frame: _this2.frame, notification: _Notification2['default'].createNext(value) });
	            }, function (err) {
	                actual.push({ frame: _this2.frame, notification: _Notification2['default'].createError(err) });
	            }, function () {
	                actual.push({ frame: _this2.frame, notification: _Notification2['default'].createComplete() });
	            });
	        }, 0);
	        if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {
	            this.schedule(function () {
	                return subscription.unsubscribe();
	            }, unsubscriptionFrame);
	        }
	        this.flushTests.push(flushTest);
	        return {
	            toBe: function toBe(marbles, values, errorValue) {
	                flushTest.ready = true;
	                flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true);
	            }
	        };
	    };
	
	    TestScheduler.prototype.expectSubscriptions = function expectSubscriptions(actualSubscriptionLogs) {
	        var flushTest = { actual: actualSubscriptionLogs, ready: false };
	        this.flushTests.push(flushTest);
	        return {
	            toBe: function toBe(marbles) {
	                var marblesArray = typeof marbles === 'string' ? [marbles] : marbles;
	                flushTest.ready = true;
	                flushTest.expected = marblesArray.map(function (marbles) {
	                    return TestScheduler.parseMarblesAsSubscriptions(marbles);
	                });
	            }
	        };
	    };
	
	    TestScheduler.prototype.flush = function flush() {
	        var hotObservables = this.hotObservables;
	        while (hotObservables.length > 0) {
	            hotObservables.shift().setup();
	        }
	        _VirtualTimeScheduler.prototype.flush.call(this);
	        var readyFlushTests = this.flushTests.filter(function (test) {
	            return test.ready;
	        });
	        while (readyFlushTests.length > 0) {
	            var test = readyFlushTests.shift();
	            this.assertDeepEqual(test.actual, test.expected);
	        }
	    };
	
	    TestScheduler.parseMarblesAsSubscriptions = function parseMarblesAsSubscriptions(marbles) {
	        if (typeof marbles !== 'string') {
	            return new _SubscriptionLog2['default'](Number.POSITIVE_INFINITY);
	        }
	        var len = marbles.length;
	        var groupStart = -1;
	        var subscriptionFrame = Number.POSITIVE_INFINITY;
	        var unsubscriptionFrame = Number.POSITIVE_INFINITY;
	        for (var i = 0; i < len; i++) {
	            var frame = i * this.frameTimeFactor;
	            var c = marbles[i];
	            switch (c) {
	                case '-':
	                case ' ':
	                    break;
	                case '(':
	                    groupStart = frame;
	                    break;
	                case ')':
	                    groupStart = -1;
	                    break;
	                case '^':
	                    if (subscriptionFrame !== Number.POSITIVE_INFINITY) {
	                        throw new Error('Found a second subscription point \'^\' in a ' + 'subscription marble diagram. There can only be one.');
	                    }
	                    subscriptionFrame = groupStart > -1 ? groupStart : frame;
	                    break;
	                case '!':
	                    if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {
	                        throw new Error('Found a second subscription point \'^\' in a ' + 'subscription marble diagram. There can only be one.');
	                    }
	                    unsubscriptionFrame = groupStart > -1 ? groupStart : frame;
	                    break;
	                default:
	                    throw new Error('There can only be \'^\' and \'!\' markers in a ' + 'subscription marble diagram. Found instead \'' + c + '\'.');
	            }
	        }
	        if (unsubscriptionFrame < 0) {
	            return new _SubscriptionLog2['default'](subscriptionFrame);
	        } else {
	            return new _SubscriptionLog2['default'](subscriptionFrame, unsubscriptionFrame);
	        }
	    };
	
	    TestScheduler.parseMarbles = function parseMarbles(marbles, values, errorValue) {
	        var materializeInnerObservables = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
	
	        if (marbles.indexOf('!') !== -1) {
	            throw new Error('Conventional marble diagrams cannot have the ' + 'unsubscription marker "!"');
	        }
	        var len = marbles.length;
	        var testMessages = [];
	        var subIndex = marbles.indexOf('^');
	        var frameOffset = subIndex === -1 ? 0 : subIndex * -this.frameTimeFactor;
	        var getValue = typeof values !== 'object' ? function (x) {
	            return x;
	        } : function (x) {
	            // Support Observable-of-Observables
	            if (materializeInnerObservables && values[x] instanceof _ColdObservable2['default']) {
	                return values[x].messages;
	            }
	            return values[x];
	        };
	        var groupStart = -1;
	        for (var i = 0; i < len; i++) {
	            var frame = i * this.frameTimeFactor;
	            var notification = undefined;
	            var c = marbles[i];
	            switch (c) {
	                case '-':
	                case ' ':
	                    break;
	                case '(':
	                    groupStart = frame;
	                    break;
	                case ')':
	                    groupStart = -1;
	                    break;
	                case '|':
	                    notification = _Notification2['default'].createComplete();
	                    break;
	                case '^':
	                    break;
	                case '#':
	                    notification = _Notification2['default'].createError(errorValue || 'error');
	                    break;
	                default:
	                    notification = _Notification2['default'].createNext(getValue(c));
	                    break;
	            }
	            frame += frameOffset;
	            if (notification) {
	                testMessages.push({ frame: groupStart > -1 ? groupStart : frame, notification: notification });
	            }
	        }
	        return testMessages;
	    };
	
	    return TestScheduler;
	})(_schedulersVirtualTimeScheduler2['default']);
	
	exports.TestScheduler = TestScheduler;

/***/ }),
/* 181 */
/***/ (function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var FastMap = (function () {
	    function FastMap() {
	        _classCallCheck(this, FastMap);
	
	        this.size = 0;
	        this._values = {};
	    }
	
	    FastMap.prototype["delete"] = function _delete(key) {
	        this._values[key] = null;
	        return true;
	    };
	
	    FastMap.prototype.set = function set(key, value) {
	        this._values[key] = value;
	        return this;
	    };
	
	    FastMap.prototype.get = function get(key) {
	        return this._values[key];
	    };
	
	    FastMap.prototype.forEach = function forEach(cb, thisArg) {
	        var values = this._values;
	        for (var key in values) {
	            if (values.hasOwnProperty(key) && values[key] !== null) {
	                cb.call(thisArg, values[key], key);
	            }
	        }
	    };
	
	    FastMap.prototype.clear = function clear() {
	        this._values = {};
	    };
	
	    return FastMap;
	})();
	
	exports["default"] = FastMap;
	module.exports = exports["default"];

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(clearImmediate) {/**
	All credit for this helper goes to http://github.com/YuzuJS/setImmediate
	*/
	'use strict';
	
	exports.__esModule = true;
	
	var _root = __webpack_require__(16);
	
	var Immediate = {
	    setImmediate: function setImmediate(x) {
	        return 0;
	    },
	    clearImmediate: function clearImmediate(id) {}
	};
	exports.Immediate = Immediate;
	if (_root.root && _root.root.setImmediate) {
	    Immediate.setImmediate = _root.root.setImmediate;
	    Immediate.clearImmediate = _root.root.clearImmediate;
	} else {
	    exports.Immediate = Immediate = (function (global, Immediate) {
	        var nextHandle = 1,
	            // Spec says greater than zero
	        tasksByHandle = {},
	            currentlyRunningATask = false,
	            doc = global.document,
	            setImmediate = undefined;
	        // Don't get fooled by e.g. browserify environments.
	        if (({}).toString.call(global.process) === '[object process]') {
	            // For Node.js before 0.9
	            setImmediate = installNextTickImplementation();
	        } else if (canUsePostMessage()) {
	            // For non-IE10 modern browsers
	            setImmediate = installPostMessageImplementation();
	        } else if (global.MessageChannel) {
	            // For web workers, where supported
	            setImmediate = installMessageChannelImplementation();
	        } else if (doc && 'onreadystatechange' in doc.createElement('script')) {
	            // For IE 6–8
	            setImmediate = installReadyStateChangeImplementation();
	        } else {
	            // For older browsers
	            setImmediate = installSetTimeoutImplementation();
	        }
	        Immediate.setImmediate = setImmediate;
	        Immediate.clearImmediate = clearImmediate;
	        return Immediate;
	        function clearImmediate(handle) {
	            delete tasksByHandle[handle];
	        }
	        function addFromSetImmediateArguments(args) {
	            tasksByHandle[nextHandle] = partiallyApplied.apply(undefined, args);
	            return nextHandle++;
	        }
	        // This function accepts the same arguments as setImmediate, but
	        // returns a function that requires no arguments.
	        function partiallyApplied(handler) {
	            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	                args[_key - 1] = arguments[_key];
	            }
	
	            return function () {
	                if (typeof handler === 'function') {
	                    handler.apply(undefined, args);
	                } else {
	                    new Function('' + handler)();
	                }
	            };
	        }
	        function runIfPresent(handle) {
	            // From the spec: 'Wait until any invocations of this algorithm started before this one have completed.'
	            // So if we're currently running a task, we'll need to delay this invocation.
	            if (currentlyRunningATask) {
	                // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
	                // 'too much recursion' error.
	                setTimeout(partiallyApplied(runIfPresent, handle), 0);
	            } else {
	                var task = tasksByHandle[handle];
	                if (task) {
	                    currentlyRunningATask = true;
	                    try {
	                        task();
	                    } finally {
	                        clearImmediate(handle);
	                        currentlyRunningATask = false;
	                    }
	                }
	            }
	        }
	        function installNextTickImplementation() {
	            return function setImmediate() {
	                var handle = addFromSetImmediateArguments(arguments);
	                global.process.nextTick(partiallyApplied(runIfPresent, handle));
	                return handle;
	            };
	        }
	        function canUsePostMessage() {
	            // The test against `importScripts` prevents this implementation from being installed inside a web worker,
	            // where `global.postMessage` means something completely different and can't be used for this purpose.
	            if (global.postMessage && !global.importScripts) {
	                var postMessageIsAsynchronous = true;
	                var oldOnMessage = global.onmessage;
	                global.onmessage = function () {
	                    postMessageIsAsynchronous = false;
	                };
	                global.postMessage('', '*');
	                global.onmessage = oldOnMessage;
	                return postMessageIsAsynchronous;
	            }
	        }
	        function installPostMessageImplementation() {
	            // Installs an event handler on `global` for the `message` event: see
	            // * https://developer.mozilla.org/en/DOM/window.postMessage
	            // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
	            var messagePrefix = 'setImmediate$' + Math.random() + '$';
	            var onGlobalMessage = function onGlobalMessage(event) {
	                if (event.source === global && typeof event.data === 'string' && event.data.indexOf(messagePrefix) === 0) {
	                    runIfPresent(+event.data.slice(messagePrefix.length));
	                }
	            };
	            if (global.addEventListener) {
	                global.addEventListener('message', onGlobalMessage, false);
	            } else {
	                global.attachEvent('onmessage', onGlobalMessage);
	            }
	            return function setImmediate() {
	                var handle = addFromSetImmediateArguments(arguments);
	                global.postMessage(messagePrefix + handle, '*');
	                return handle;
	            };
	        }
	        function installMessageChannelImplementation() {
	            var channel = new MessageChannel();
	            channel.port1.onmessage = function (event) {
	                var handle = event.data;
	                runIfPresent(handle);
	            };
	            return function setImmediate() {
	                var handle = addFromSetImmediateArguments(arguments);
	                channel.port2.postMessage(handle);
	                return handle;
	            };
	        }
	        function installReadyStateChangeImplementation() {
	            var html = doc.documentElement;
	            return function setImmediate() {
	                var handle = addFromSetImmediateArguments(arguments);
	                // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
	                // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
	                var script = doc.createElement('script');
	                script.onreadystatechange = function () {
	                    runIfPresent(handle);
	                    script.onreadystatechange = null;
	                    html.removeChild(script);
	                    script = null;
	                };
	                html.appendChild(script);
	                return handle;
	            };
	        }
	        function installSetTimeoutImplementation() {
	            return function setImmediate() {
	                var handle = addFromSetImmediateArguments(arguments);
	                setTimeout(partiallyApplied(runIfPresent, handle), 0);
	                return handle;
	            };
	        }
	    })(_root.root, Immediate);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(221).clearImmediate))

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _root = __webpack_require__(16);
	
	exports['default'] = _root.root.Map || (function () {
	    function Map() {
	        this.size = 0;
	        this._values = [];
	        this._keys = [];
	    }
	    Map.prototype['delete'] = function (key) {
	        var i = this._keys.indexOf(key);
	        if (i === -1) {
	            return false;
	        }
	        this._values.splice(i, 1);
	        this._keys.splice(i, 1);
	        this.size--;
	        return true;
	    };
	    Map.prototype.get = function (key) {
	        var i = this._keys.indexOf(key);
	        return i === -1 ? undefined : this._values[i];
	    };
	    Map.prototype.set = function (key, value) {
	        var i = this._keys.indexOf(key);
	        if (i === -1) {
	            this._keys.push(key);
	            this._values.push(value);
	            this.size++;
	        } else {
	            this._values[i] = value;
	        }
	        return this;
	    };
	    Map.prototype.forEach = function (cb, thisArg) {
	        for (var i = 0; i < this.size; i++) {
	            cb.call(thisArg, this._values[i], this._keys[i]);
	        }
	    };
	    return Map;
	})();
	
	module.exports = exports['default'];

/***/ }),
/* 184 */
/***/ (function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = not;
	
	function not(pred, thisArg) {
	    function notPred() {
	        return !notPred.pred.apply(notPred.thisArg, arguments);
	    }
	    notPred.pred = pred;
	    notPred.thisArg = thisArg;
	    return notPred;
	}
	
	module.exports = exports["default"];

/***/ }),
/* 185 */
/***/ (function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = throwError;
	
	function throwError(e) {
	  throw e;
	}
	
	module.exports = exports["default"];

/***/ }),
/* 186 */
/***/ (function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = tryOrOnError;
	
	function tryOrOnError(target) {
	    function tryCatcher() {
	        try {
	            tryCatcher.target.apply(this, arguments);
	        } catch (e) {
	            this.error(e);
	        }
	    }
	    tryCatcher.target = target;
	    return tryCatcher;
	}
	
	module.exports = exports["default"];

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(85);


/***/ }),
/* 188 */,
/* 189 */,
/* 190 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {var win;
	
	if (typeof window !== "undefined") {
	    win = window;
	} else if (typeof global !== "undefined") {
	    win = global;
	} else if (typeof self !== "undefined"){
	    win = self;
	} else {
	    win = {};
	}
	
	module.exports = win;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {/*! *****************************************************************************
	Copyright (C) Microsoft. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0
	
	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.
	
	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
	var Reflect;
	(function (Reflect) {
	    "use strict";
	    var hasOwn = Object.prototype.hasOwnProperty;
	    // feature test for Symbol support
	    var supportsSymbol = typeof Symbol === "function";
	    var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
	    var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
	    var HashMap;
	    (function (HashMap) {
	        var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
	        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
	        var downLevel = !supportsCreate && !supportsProto;
	        // create an object in dictionary mode (a.k.a. "slow" mode in v8)
	        HashMap.create = supportsCreate
	            ? function () { return MakeDictionary(Object.create(null)); }
	            : supportsProto
	                ? function () { return MakeDictionary({ __proto__: null }); }
	                : function () { return MakeDictionary({}); };
	        HashMap.has = downLevel
	            ? function (map, key) { return hasOwn.call(map, key); }
	            : function (map, key) { return key in map; };
	        HashMap.get = downLevel
	            ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
	            : function (map, key) { return map[key]; };
	    })(HashMap || (HashMap = {}));
	    // Load global or shim versions of Map, Set, and WeakMap
	    var functionPrototype = Object.getPrototypeOf(Function);
	    var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
	    var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
	    var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
	    var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
	    // [[Metadata]] internal slot
	    // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
	    var Metadata = new _WeakMap();
	    /**
	      * Applies a set of decorators to a property of a target object.
	      * @param decorators An array of decorators.
	      * @param target The target object.
	      * @param propertyKey (Optional) The property key to decorate.
	      * @param attributes (Optional) The property descriptor for the target key.
	      * @remarks Decorators are applied in reverse order.
	      * @example
	      *
	      *     class Example {
	      *         // property declarations are not part of ES6, though they are valid in TypeScript:
	      *         // static staticProperty;
	      *         // property;
	      *
	      *         constructor(p) { }
	      *         static staticMethod(p) { }
	      *         method(p) { }
	      *     }
	      *
	      *     // constructor
	      *     Example = Reflect.decorate(decoratorsArray, Example);
	      *
	      *     // property (on constructor)
	      *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
	      *
	      *     // property (on prototype)
	      *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
	      *
	      *     // method (on constructor)
	      *     Object.defineProperty(Example, "staticMethod",
	      *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
	      *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
	      *
	      *     // method (on prototype)
	      *     Object.defineProperty(Example.prototype, "method",
	      *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
	      *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
	      *
	      */
	    function decorate(decorators, target, propertyKey, attributes) {
	        if (!IsUndefined(propertyKey)) {
	            if (!IsArray(decorators))
	                throw new TypeError();
	            if (!IsObject(target))
	                throw new TypeError();
	            if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
	                throw new TypeError();
	            if (IsNull(attributes))
	                attributes = undefined;
	            propertyKey = ToPropertyKey(propertyKey);
	            return DecorateProperty(decorators, target, propertyKey, attributes);
	        }
	        else {
	            if (!IsArray(decorators))
	                throw new TypeError();
	            if (!IsConstructor(target))
	                throw new TypeError();
	            return DecorateConstructor(decorators, target);
	        }
	    }
	    Reflect.decorate = decorate;
	    // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
	    // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
	    /**
	      * A default metadata decorator factory that can be used on a class, class member, or parameter.
	      * @param metadataKey The key for the metadata entry.
	      * @param metadataValue The value for the metadata entry.
	      * @returns A decorator function.
	      * @remarks
	      * If `metadataKey` is already defined for the target and target key, the
	      * metadataValue for that key will be overwritten.
	      * @example
	      *
	      *     // constructor
	      *     @Reflect.metadata(key, value)
	      *     class Example {
	      *     }
	      *
	      *     // property (on constructor, TypeScript only)
	      *     class Example {
	      *         @Reflect.metadata(key, value)
	      *         static staticProperty;
	      *     }
	      *
	      *     // property (on prototype, TypeScript only)
	      *     class Example {
	      *         @Reflect.metadata(key, value)
	      *         property;
	      *     }
	      *
	      *     // method (on constructor)
	      *     class Example {
	      *         @Reflect.metadata(key, value)
	      *         static staticMethod() { }
	      *     }
	      *
	      *     // method (on prototype)
	      *     class Example {
	      *         @Reflect.metadata(key, value)
	      *         method() { }
	      *     }
	      *
	      */
	    function metadata(metadataKey, metadataValue) {
	        function decorator(target, propertyKey) {
	            if (!IsObject(target))
	                throw new TypeError();
	            if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
	                throw new TypeError();
	            OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
	        }
	        return decorator;
	    }
	    Reflect.metadata = metadata;
	    /**
	      * Define a unique metadata entry on the target.
	      * @param metadataKey A key used to store and retrieve metadata.
	      * @param metadataValue A value that contains attached metadata.
	      * @param target The target object on which to define metadata.
	      * @param propertyKey (Optional) The property key for the target.
	      * @example
	      *
	      *     class Example {
	      *         // property declarations are not part of ES6, though they are valid in TypeScript:
	      *         // static staticProperty;
	      *         // property;
	      *
	      *         constructor(p) { }
	      *         static staticMethod(p) { }
	      *         method(p) { }
	      *     }
	      *
	      *     // constructor
	      *     Reflect.defineMetadata("custom:annotation", options, Example);
	      *
	      *     // property (on constructor)
	      *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
	      *
	      *     // property (on prototype)
	      *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
	      *
	      *     // method (on constructor)
	      *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
	      *
	      *     // method (on prototype)
	      *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
	      *
	      *     // decorator factory as metadata-producing annotation.
	      *     function MyAnnotation(options): Decorator {
	      *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
	      *     }
	      *
	      */
	    function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
	        if (!IsObject(target))
	            throw new TypeError();
	        if (!IsUndefined(propertyKey))
	            propertyKey = ToPropertyKey(propertyKey);
	        return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
	    }
	    Reflect.defineMetadata = defineMetadata;
	    /**
	      * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
	      * @param metadataKey A key used to store and retrieve metadata.
	      * @param target The target object on which the metadata is defined.
	      * @param propertyKey (Optional) The property key for the target.
	      * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
	      * @example
	      *
	      *     class Example {
	      *         // property declarations are not part of ES6, though they are valid in TypeScript:
	      *         // static staticProperty;
	      *         // property;
	      *
	      *         constructor(p) { }
	      *         static staticMethod(p) { }
	      *         method(p) { }
	      *     }
	      *
	      *     // constructor
	      *     result = Reflect.hasMetadata("custom:annotation", Example);
	      *
	      *     // property (on constructor)
	      *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
	      *
	      *     // property (on prototype)
	      *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
	      *
	      *     // method (on constructor)
	      *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
	      *
	      *     // method (on prototype)
	      *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
	      *
	      */
	    function hasMetadata(metadataKey, target, propertyKey) {
	        if (!IsObject(target))
	            throw new TypeError();
	        if (!IsUndefined(propertyKey))
	            propertyKey = ToPropertyKey(propertyKey);
	        return OrdinaryHasMetadata(metadataKey, target, propertyKey);
	    }
	    Reflect.hasMetadata = hasMetadata;
	    /**
	      * Gets a value indicating whether the target object has the provided metadata key defined.
	      * @param metadataKey A key used to store and retrieve metadata.
	      * @param target The target object on which the metadata is defined.
	      * @param propertyKey (Optional) The property key for the target.
	      * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
	      * @example
	      *
	      *     class Example {
	      *         // property declarations are not part of ES6, though they are valid in TypeScript:
	      *         // static staticProperty;
	      *         // property;
	      *
	      *         constructor(p) { }
	      *         static staticMethod(p) { }
	      *         method(p) { }
	      *     }
	      *
	      *     // constructor
	      *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
	      *
	      *     // property (on constructor)
	      *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
	      *
	      *     // property (on prototype)
	      *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
	      *
	      *     // method (on constructor)
	      *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
	      *
	      *     // method (on prototype)
	      *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
	      *
	      */
	    function hasOwnMetadata(metadataKey, target, propertyKey) {
	        if (!IsObject(target))
	            throw new TypeError();
	        if (!IsUndefined(propertyKey))
	            propertyKey = ToPropertyKey(propertyKey);
	        return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
	    }
	    Reflect.hasOwnMetadata = hasOwnMetadata;
	    /**
	      * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
	      * @param metadataKey A key used to store and retrieve metadata.
	      * @param target The target object on which the metadata is defined.
	      * @param propertyKey (Optional) The property key for the target.
	      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
	      * @example
	      *
	      *     class Example {
	      *         // property declarations are not part of ES6, though they are valid in TypeScript:
	      *         // static staticProperty;
	      *         // property;
	      *
	      *         constructor(p) { }
	      *         static staticMethod(p) { }
	      *         method(p) { }
	      *     }
	      *
	      *     // constructor
	      *     result = Reflect.getMetadata("custom:annotation", Example);
	      *
	      *     // property (on constructor)
	      *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
	      *
	      *     // property (on prototype)
	      *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
	      *
	      *     // method (on constructor)
	      *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
	      *
	      *     // method (on prototype)
	      *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
	      *
	      */
	    function getMetadata(metadataKey, target, propertyKey) {
	        if (!IsObject(target))
	            throw new TypeError();
	        if (!IsUndefined(propertyKey))
	            propertyKey = ToPropertyKey(propertyKey);
	        return OrdinaryGetMetadata(metadataKey, target, propertyKey);
	    }
	    Reflect.getMetadata = getMetadata;
	    /**
	      * Gets the metadata value for the provided metadata key on the target object.
	      * @param metadataKey A key used to store and retrieve metadata.
	      * @param target The target object on which the metadata is defined.
	      * @param propertyKey (Optional) The property key for the target.
	      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
	      * @example
	      *
	      *     class Example {
	      *         // property declarations are not part of ES6, though they are valid in TypeScript:
	      *         // static staticProperty;
	      *         // property;
	      *
	      *         constructor(p) { }
	      *         static staticMethod(p) { }
	      *         method(p) { }
	      *     }
	      *
	      *     // constructor
	      *     result = Reflect.getOwnMetadata("custom:annotation", Example);
	      *
	      *     // property (on constructor)
	      *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
	      *
	      *     // property (on prototype)
	      *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
	      *
	      *     // method (on constructor)
	      *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
	      *
	      *     // method (on prototype)
	      *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
	      *
	      */
	    function getOwnMetadata(metadataKey, target, propertyKey) {
	        if (!IsObject(target))
	            throw new TypeError();
	        if (!IsUndefined(propertyKey))
	            propertyKey = ToPropertyKey(propertyKey);
	        return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
	    }
	    Reflect.getOwnMetadata = getOwnMetadata;
	    /**
	      * Gets the metadata keys defined on the target object or its prototype chain.
	      * @param target The target object on which the metadata is defined.
	      * @param propertyKey (Optional) The property key for the target.
	      * @returns An array of unique metadata keys.
	      * @example
	      *
	      *     class Example {
	      *         // property declarations are not part of ES6, though they are valid in TypeScript:
	      *         // static staticProperty;
	      *         // property;
	      *
	      *         constructor(p) { }
	      *         static staticMethod(p) { }
	      *         method(p) { }
	      *     }
	      *
	      *     // constructor
	      *     result = Reflect.getMetadataKeys(Example);
	      *
	      *     // property (on constructor)
	      *     result = Reflect.getMetadataKeys(Example, "staticProperty");
	      *
	      *     // property (on prototype)
	      *     result = Reflect.getMetadataKeys(Example.prototype, "property");
	      *
	      *     // method (on constructor)
	      *     result = Reflect.getMetadataKeys(Example, "staticMethod");
	      *
	      *     // method (on prototype)
	      *     result = Reflect.getMetadataKeys(Example.prototype, "method");
	      *
	      */
	    function getMetadataKeys(target, propertyKey) {
	        if (!IsObject(target))
	            throw new TypeError();
	        if (!IsUndefined(propertyKey))
	            propertyKey = ToPropertyKey(propertyKey);
	        return OrdinaryMetadataKeys(target, propertyKey);
	    }
	    Reflect.getMetadataKeys = getMetadataKeys;
	    /**
	      * Gets the unique metadata keys defined on the target object.
	      * @param target The target object on which the metadata is defined.
	      * @param propertyKey (Optional) The property key for the target.
	      * @returns An array of unique metadata keys.
	      * @example
	      *
	      *     class Example {
	      *         // property declarations are not part of ES6, though they are valid in TypeScript:
	      *         // static staticProperty;
	      *         // property;
	      *
	      *         constructor(p) { }
	      *         static staticMethod(p) { }
	      *         method(p) { }
	      *     }
	      *
	      *     // constructor
	      *     result = Reflect.getOwnMetadataKeys(Example);
	      *
	      *     // property (on constructor)
	      *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
	      *
	      *     // property (on prototype)
	      *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
	      *
	      *     // method (on constructor)
	      *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
	      *
	      *     // method (on prototype)
	      *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
	      *
	      */
	    function getOwnMetadataKeys(target, propertyKey) {
	        if (!IsObject(target))
	            throw new TypeError();
	        if (!IsUndefined(propertyKey))
	            propertyKey = ToPropertyKey(propertyKey);
	        return OrdinaryOwnMetadataKeys(target, propertyKey);
	    }
	    Reflect.getOwnMetadataKeys = getOwnMetadataKeys;
	    /**
	      * Deletes the metadata entry from the target object with the provided key.
	      * @param metadataKey A key used to store and retrieve metadata.
	      * @param target The target object on which the metadata is defined.
	      * @param propertyKey (Optional) The property key for the target.
	      * @returns `true` if the metadata entry was found and deleted; otherwise, false.
	      * @example
	      *
	      *     class Example {
	      *         // property declarations are not part of ES6, though they are valid in TypeScript:
	      *         // static staticProperty;
	      *         // property;
	      *
	      *         constructor(p) { }
	      *         static staticMethod(p) { }
	      *         method(p) { }
	      *     }
	      *
	      *     // constructor
	      *     result = Reflect.deleteMetadata("custom:annotation", Example);
	      *
	      *     // property (on constructor)
	      *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
	      *
	      *     // property (on prototype)
	      *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
	      *
	      *     // method (on constructor)
	      *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
	      *
	      *     // method (on prototype)
	      *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
	      *
	      */
	    function deleteMetadata(metadataKey, target, propertyKey) {
	        if (!IsObject(target))
	            throw new TypeError();
	        if (!IsUndefined(propertyKey))
	            propertyKey = ToPropertyKey(propertyKey);
	        var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);
	        if (IsUndefined(metadataMap))
	            return false;
	        if (!metadataMap.delete(metadataKey))
	            return false;
	        if (metadataMap.size > 0)
	            return true;
	        var targetMetadata = Metadata.get(target);
	        targetMetadata.delete(propertyKey);
	        if (targetMetadata.size > 0)
	            return true;
	        Metadata.delete(target);
	        return true;
	    }
	    Reflect.deleteMetadata = deleteMetadata;
	    function DecorateConstructor(decorators, target) {
	        for (var i = decorators.length - 1; i >= 0; --i) {
	            var decorator = decorators[i];
	            var decorated = decorator(target);
	            if (!IsUndefined(decorated) && !IsNull(decorated)) {
	                if (!IsConstructor(decorated))
	                    throw new TypeError();
	                target = decorated;
	            }
	        }
	        return target;
	    }
	    function DecorateProperty(decorators, target, propertyKey, descriptor) {
	        for (var i = decorators.length - 1; i >= 0; --i) {
	            var decorator = decorators[i];
	            var decorated = decorator(target, propertyKey, descriptor);
	            if (!IsUndefined(decorated) && !IsNull(decorated)) {
	                if (!IsObject(decorated))
	                    throw new TypeError();
	                descriptor = decorated;
	            }
	        }
	        return descriptor;
	    }
	    function GetOrCreateMetadataMap(O, P, Create) {
	        var targetMetadata = Metadata.get(O);
	        if (IsUndefined(targetMetadata)) {
	            if (!Create)
	                return undefined;
	            targetMetadata = new _Map();
	            Metadata.set(O, targetMetadata);
	        }
	        var metadataMap = targetMetadata.get(P);
	        if (IsUndefined(metadataMap)) {
	            if (!Create)
	                return undefined;
	            metadataMap = new _Map();
	            targetMetadata.set(P, metadataMap);
	        }
	        return metadataMap;
	    }
	    // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
	    // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
	    function OrdinaryHasMetadata(MetadataKey, O, P) {
	        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
	        if (hasOwn)
	            return true;
	        var parent = OrdinaryGetPrototypeOf(O);
	        if (!IsNull(parent))
	            return OrdinaryHasMetadata(MetadataKey, parent, P);
	        return false;
	    }
	    // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
	    // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
	    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
	        var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
	        if (IsUndefined(metadataMap))
	            return false;
	        return ToBoolean(metadataMap.has(MetadataKey));
	    }
	    // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
	    // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
	    function OrdinaryGetMetadata(MetadataKey, O, P) {
	        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
	        if (hasOwn)
	            return OrdinaryGetOwnMetadata(MetadataKey, O, P);
	        var parent = OrdinaryGetPrototypeOf(O);
	        if (!IsNull(parent))
	            return OrdinaryGetMetadata(MetadataKey, parent, P);
	        return undefined;
	    }
	    // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
	    // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
	    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
	        var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
	        if (IsUndefined(metadataMap))
	            return undefined;
	        return metadataMap.get(MetadataKey);
	    }
	    // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
	    // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
	    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
	        var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
	        metadataMap.set(MetadataKey, MetadataValue);
	    }
	    // 3.1.6.1 OrdinaryMetadataKeys(O, P)
	    // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
	    function OrdinaryMetadataKeys(O, P) {
	        var ownKeys = OrdinaryOwnMetadataKeys(O, P);
	        var parent = OrdinaryGetPrototypeOf(O);
	        if (parent === null)
	            return ownKeys;
	        var parentKeys = OrdinaryMetadataKeys(parent, P);
	        if (parentKeys.length <= 0)
	            return ownKeys;
	        if (ownKeys.length <= 0)
	            return parentKeys;
	        var set = new _Set();
	        var keys = [];
	        for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
	            var key = ownKeys_1[_i];
	            var hasKey = set.has(key);
	            if (!hasKey) {
	                set.add(key);
	                keys.push(key);
	            }
	        }
	        for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
	            var key = parentKeys_1[_a];
	            var hasKey = set.has(key);
	            if (!hasKey) {
	                set.add(key);
	                keys.push(key);
	            }
	        }
	        return keys;
	    }
	    // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
	    // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
	    function OrdinaryOwnMetadataKeys(O, P) {
	        var keys = [];
	        var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
	        if (IsUndefined(metadataMap))
	            return keys;
	        var keysObj = metadataMap.keys();
	        var iterator = GetIterator(keysObj);
	        var k = 0;
	        while (true) {
	            var next = IteratorStep(iterator);
	            if (!next) {
	                keys.length = k;
	                return keys;
	            }
	            var nextValue = IteratorValue(next);
	            try {
	                keys[k] = nextValue;
	            }
	            catch (e) {
	                try {
	                    IteratorClose(iterator);
	                }
	                finally {
	                    throw e;
	                }
	            }
	            k++;
	        }
	    }
	    // 6 ECMAScript Data Typ0es and Values
	    // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
	    function Type(x) {
	        if (x === null)
	            return 1 /* Null */;
	        switch (typeof x) {
	            case "undefined": return 0 /* Undefined */;
	            case "boolean": return 2 /* Boolean */;
	            case "string": return 3 /* String */;
	            case "symbol": return 4 /* Symbol */;
	            case "number": return 5 /* Number */;
	            case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
	            default: return 6 /* Object */;
	        }
	    }
	    // 6.1.1 The Undefined Type
	    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
	    function IsUndefined(x) {
	        return x === undefined;
	    }
	    // 6.1.2 The Null Type
	    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
	    function IsNull(x) {
	        return x === null;
	    }
	    // 6.1.5 The Symbol Type
	    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
	    function IsSymbol(x) {
	        return typeof x === "symbol";
	    }
	    // 6.1.7 The Object Type
	    // https://tc39.github.io/ecma262/#sec-object-type
	    function IsObject(x) {
	        return typeof x === "object" ? x !== null : typeof x === "function";
	    }
	    // 7.1 Type Conversion
	    // https://tc39.github.io/ecma262/#sec-type-conversion
	    // 7.1.1 ToPrimitive(input [, PreferredType])
	    // https://tc39.github.io/ecma262/#sec-toprimitive
	    function ToPrimitive(input, PreferredType) {
	        switch (Type(input)) {
	            case 0 /* Undefined */: return input;
	            case 1 /* Null */: return input;
	            case 2 /* Boolean */: return input;
	            case 3 /* String */: return input;
	            case 4 /* Symbol */: return input;
	            case 5 /* Number */: return input;
	        }
	        var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
	        var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
	        if (exoticToPrim !== undefined) {
	            var result = exoticToPrim.call(input, hint);
	            if (IsObject(result))
	                throw new TypeError();
	            return result;
	        }
	        return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
	    }
	    // 7.1.1.1 OrdinaryToPrimitive(O, hint)
	    // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
	    function OrdinaryToPrimitive(O, hint) {
	        if (hint === "string") {
	            var toString_1 = O.toString;
	            if (IsCallable(toString_1)) {
	                var result = toString_1.call(O);
	                if (!IsObject(result))
	                    return result;
	            }
	            var valueOf = O.valueOf;
	            if (IsCallable(valueOf)) {
	                var result = valueOf.call(O);
	                if (!IsObject(result))
	                    return result;
	            }
	        }
	        else {
	            var valueOf = O.valueOf;
	            if (IsCallable(valueOf)) {
	                var result = valueOf.call(O);
	                if (!IsObject(result))
	                    return result;
	            }
	            var toString_2 = O.toString;
	            if (IsCallable(toString_2)) {
	                var result = toString_2.call(O);
	                if (!IsObject(result))
	                    return result;
	            }
	        }
	        throw new TypeError();
	    }
	    // 7.1.2 ToBoolean(argument)
	    // https://tc39.github.io/ecma262/2016/#sec-toboolean
	    function ToBoolean(argument) {
	        return !!argument;
	    }
	    // 7.1.12 ToString(argument)
	    // https://tc39.github.io/ecma262/#sec-tostring
	    function ToString(argument) {
	        return "" + argument;
	    }
	    // 7.1.14 ToPropertyKey(argument)
	    // https://tc39.github.io/ecma262/#sec-topropertykey
	    function ToPropertyKey(argument) {
	        var key = ToPrimitive(argument, 3 /* String */);
	        if (IsSymbol(key))
	            return key;
	        return ToString(key);
	    }
	    // 7.2 Testing and Comparison Operations
	    // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
	    // 7.2.2 IsArray(argument)
	    // https://tc39.github.io/ecma262/#sec-isarray
	    function IsArray(argument) {
	        return Array.isArray
	            ? Array.isArray(argument)
	            : argument instanceof Object
	                ? argument instanceof Array
	                : Object.prototype.toString.call(argument) === "[object Array]";
	    }
	    // 7.2.3 IsCallable(argument)
	    // https://tc39.github.io/ecma262/#sec-iscallable
	    function IsCallable(argument) {
	        // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
	        return typeof argument === "function";
	    }
	    // 7.2.4 IsConstructor(argument)
	    // https://tc39.github.io/ecma262/#sec-isconstructor
	    function IsConstructor(argument) {
	        // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
	        return typeof argument === "function";
	    }
	    // 7.2.7 IsPropertyKey(argument)
	    // https://tc39.github.io/ecma262/#sec-ispropertykey
	    function IsPropertyKey(argument) {
	        switch (Type(argument)) {
	            case 3 /* String */: return true;
	            case 4 /* Symbol */: return true;
	            default: return false;
	        }
	    }
	    // 7.3 Operations on Objects
	    // https://tc39.github.io/ecma262/#sec-operations-on-objects
	    // 7.3.9 GetMethod(V, P)
	    // https://tc39.github.io/ecma262/#sec-getmethod
	    function GetMethod(V, P) {
	        var func = V[P];
	        if (func === undefined || func === null)
	            return undefined;
	        if (!IsCallable(func))
	            throw new TypeError();
	        return func;
	    }
	    // 7.4 Operations on Iterator Objects
	    // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
	    function GetIterator(obj) {
	        var method = GetMethod(obj, iteratorSymbol);
	        if (!IsCallable(method))
	            throw new TypeError(); // from Call
	        var iterator = method.call(obj);
	        if (!IsObject(iterator))
	            throw new TypeError();
	        return iterator;
	    }
	    // 7.4.4 IteratorValue(iterResult)
	    // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
	    function IteratorValue(iterResult) {
	        return iterResult.value;
	    }
	    // 7.4.5 IteratorStep(iterator)
	    // https://tc39.github.io/ecma262/#sec-iteratorstep
	    function IteratorStep(iterator) {
	        var result = iterator.next();
	        return result.done ? false : result;
	    }
	    // 7.4.6 IteratorClose(iterator, completion)
	    // https://tc39.github.io/ecma262/#sec-iteratorclose
	    function IteratorClose(iterator) {
	        var f = iterator["return"];
	        if (f)
	            f.call(iterator);
	    }
	    // 9.1 Ordinary Object Internal Methods and Internal Slots
	    // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
	    // 9.1.1.1 OrdinaryGetPrototypeOf(O)
	    // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
	    function OrdinaryGetPrototypeOf(O) {
	        var proto = Object.getPrototypeOf(O);
	        if (typeof O !== "function" || O === functionPrototype)
	            return proto;
	        // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
	        // Try to determine the superclass constructor. Compatible implementations
	        // must either set __proto__ on a subclass constructor to the superclass constructor,
	        // or ensure each class has a valid `constructor` property on its prototype that
	        // points back to the constructor.
	        // If this is not the same as Function.[[Prototype]], then this is definately inherited.
	        // This is the case when in ES6 or when using __proto__ in a compatible browser.
	        if (proto !== functionPrototype)
	            return proto;
	        // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
	        var prototype = O.prototype;
	        var prototypeProto = prototype && Object.getPrototypeOf(prototype);
	        if (prototypeProto == null || prototypeProto === Object.prototype)
	            return proto;
	        // If the constructor was not a function, then we cannot determine the heritage.
	        var constructor = prototypeProto.constructor;
	        if (typeof constructor !== "function")
	            return proto;
	        // If we have some kind of self-reference, then we cannot determine the heritage.
	        if (constructor === O)
	            return proto;
	        // we have a pretty good guess at the heritage.
	        return constructor;
	    }
	    // naive Map shim
	    function CreateMapPolyfill() {
	        var cacheSentinel = {};
	        var arraySentinel = [];
	        var MapIterator = (function () {
	            function MapIterator(keys, values, selector) {
	                this._index = 0;
	                this._keys = keys;
	                this._values = values;
	                this._selector = selector;
	            }
	            MapIterator.prototype["@@iterator"] = function () { return this; };
	            MapIterator.prototype[iteratorSymbol] = function () { return this; };
	            MapIterator.prototype.next = function () {
	                var index = this._index;
	                if (index >= 0 && index < this._keys.length) {
	                    var result = this._selector(this._keys[index], this._values[index]);
	                    if (index + 1 >= this._keys.length) {
	                        this._index = -1;
	                        this._keys = arraySentinel;
	                        this._values = arraySentinel;
	                    }
	                    else {
	                        this._index++;
	                    }
	                    return { value: result, done: false };
	                }
	                return { value: undefined, done: true };
	            };
	            MapIterator.prototype.throw = function (error) {
	                if (this._index >= 0) {
	                    this._index = -1;
	                    this._keys = arraySentinel;
	                    this._values = arraySentinel;
	                }
	                throw error;
	            };
	            MapIterator.prototype.return = function (value) {
	                if (this._index >= 0) {
	                    this._index = -1;
	                    this._keys = arraySentinel;
	                    this._values = arraySentinel;
	                }
	                return { value: value, done: true };
	            };
	            return MapIterator;
	        }());
	        return (function () {
	            function Map() {
	                this._keys = [];
	                this._values = [];
	                this._cacheKey = cacheSentinel;
	                this._cacheIndex = -2;
	            }
	            Object.defineProperty(Map.prototype, "size", {
	                get: function () { return this._keys.length; },
	                enumerable: true,
	                configurable: true
	            });
	            Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
	            Map.prototype.get = function (key) {
	                var index = this._find(key, /*insert*/ false);
	                return index >= 0 ? this._values[index] : undefined;
	            };
	            Map.prototype.set = function (key, value) {
	                var index = this._find(key, /*insert*/ true);
	                this._values[index] = value;
	                return this;
	            };
	            Map.prototype.delete = function (key) {
	                var index = this._find(key, /*insert*/ false);
	                if (index >= 0) {
	                    var size = this._keys.length;
	                    for (var i = index + 1; i < size; i++) {
	                        this._keys[i - 1] = this._keys[i];
	                        this._values[i - 1] = this._values[i];
	                    }
	                    this._keys.length--;
	                    this._values.length--;
	                    if (key === this._cacheKey) {
	                        this._cacheKey = cacheSentinel;
	                        this._cacheIndex = -2;
	                    }
	                    return true;
	                }
	                return false;
	            };
	            Map.prototype.clear = function () {
	                this._keys.length = 0;
	                this._values.length = 0;
	                this._cacheKey = cacheSentinel;
	                this._cacheIndex = -2;
	            };
	            Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
	            Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
	            Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
	            Map.prototype["@@iterator"] = function () { return this.entries(); };
	            Map.prototype[iteratorSymbol] = function () { return this.entries(); };
	            Map.prototype._find = function (key, insert) {
	                if (this._cacheKey !== key) {
	                    this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
	                }
	                if (this._cacheIndex < 0 && insert) {
	                    this._cacheIndex = this._keys.length;
	                    this._keys.push(key);
	                    this._values.push(undefined);
	                }
	                return this._cacheIndex;
	            };
	            return Map;
	        }());
	        function getKey(key, _) {
	            return key;
	        }
	        function getValue(_, value) {
	            return value;
	        }
	        function getEntry(key, value) {
	            return [key, value];
	        }
	    }
	    // naive Set shim
	    function CreateSetPolyfill() {
	        return (function () {
	            function Set() {
	                this._map = new _Map();
	            }
	            Object.defineProperty(Set.prototype, "size", {
	                get: function () { return this._map.size; },
	                enumerable: true,
	                configurable: true
	            });
	            Set.prototype.has = function (value) { return this._map.has(value); };
	            Set.prototype.add = function (value) { return this._map.set(value, value), this; };
	            Set.prototype.delete = function (value) { return this._map.delete(value); };
	            Set.prototype.clear = function () { this._map.clear(); };
	            Set.prototype.keys = function () { return this._map.keys(); };
	            Set.prototype.values = function () { return this._map.values(); };
	            Set.prototype.entries = function () { return this._map.entries(); };
	            Set.prototype["@@iterator"] = function () { return this.keys(); };
	            Set.prototype[iteratorSymbol] = function () { return this.keys(); };
	            return Set;
	        }());
	    }
	    // naive WeakMap shim
	    function CreateWeakMapPolyfill() {
	        var UUID_SIZE = 16;
	        var keys = HashMap.create();
	        var rootKey = CreateUniqueKey();
	        return (function () {
	            function WeakMap() {
	                this._key = CreateUniqueKey();
	            }
	            WeakMap.prototype.has = function (target) {
	                var table = GetOrCreateWeakMapTable(target, /*create*/ false);
	                return table !== undefined ? HashMap.has(table, this._key) : false;
	            };
	            WeakMap.prototype.get = function (target) {
	                var table = GetOrCreateWeakMapTable(target, /*create*/ false);
	                return table !== undefined ? HashMap.get(table, this._key) : undefined;
	            };
	            WeakMap.prototype.set = function (target, value) {
	                var table = GetOrCreateWeakMapTable(target, /*create*/ true);
	                table[this._key] = value;
	                return this;
	            };
	            WeakMap.prototype.delete = function (target) {
	                var table = GetOrCreateWeakMapTable(target, /*create*/ false);
	                return table !== undefined ? delete table[this._key] : false;
	            };
	            WeakMap.prototype.clear = function () {
	                // NOTE: not a real clear, just makes the previous data unreachable
	                this._key = CreateUniqueKey();
	            };
	            return WeakMap;
	        }());
	        function CreateUniqueKey() {
	            var key;
	            do
	                key = "@@WeakMap@@" + CreateUUID();
	            while (HashMap.has(keys, key));
	            keys[key] = true;
	            return key;
	        }
	        function GetOrCreateWeakMapTable(target, create) {
	            if (!hasOwn.call(target, rootKey)) {
	                if (!create)
	                    return undefined;
	                Object.defineProperty(target, rootKey, { value: HashMap.create() });
	            }
	            return target[rootKey];
	        }
	        function FillRandomBytes(buffer, size) {
	            for (var i = 0; i < size; ++i)
	                buffer[i] = Math.random() * 0xff | 0;
	            return buffer;
	        }
	        function GenRandomBytes(size) {
	            if (typeof Uint8Array === "function") {
	                if (typeof crypto !== "undefined")
	                    return crypto.getRandomValues(new Uint8Array(size));
	                if (typeof msCrypto !== "undefined")
	                    return msCrypto.getRandomValues(new Uint8Array(size));
	                return FillRandomBytes(new Uint8Array(size), size);
	            }
	            return FillRandomBytes(new Array(size), size);
	        }
	        function CreateUUID() {
	            var data = GenRandomBytes(UUID_SIZE);
	            // mark as random - RFC 4122 § 4.4
	            data[6] = data[6] & 0x4f | 0x40;
	            data[8] = data[8] & 0xbf | 0x80;
	            var result = "";
	            for (var offset = 0; offset < UUID_SIZE; ++offset) {
	                var byte = data[offset];
	                if (offset === 4 || offset === 6 || offset === 8)
	                    result += "-";
	                if (byte < 16)
	                    result += "0";
	                result += byte.toString(16).toLowerCase();
	            }
	            return result;
	        }
	    }
	    // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
	    function MakeDictionary(obj) {
	        obj.__ = undefined;
	        delete obj.__;
	        return obj;
	    }
	    // patch global Reflect
	    (function (__global) {
	        if (typeof __global.Reflect !== "undefined") {
	            if (__global.Reflect !== Reflect) {
	                for (var p in Reflect) {
	                    if (hasOwn.call(Reflect, p)) {
	                        __global.Reflect[p] = Reflect[p];
	                    }
	                }
	            }
	        }
	        else {
	            __global.Reflect = Reflect;
	        }
	    })(typeof global !== "undefined" ? global :
	        typeof self !== "undefined" ? self :
	            Function("return this;")());
	})(Reflect || (Reflect = {}));
	//# sourceMappingURL=Reflect.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(66), (function() { return this; }())))

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(19);
	var ObjectUnsubscribedError_1 = __webpack_require__(72);
	/**
	 * @class BehaviorSubject<T>
	 */
	var BehaviorSubject = (function (_super) {
	    __extends(BehaviorSubject, _super);
	    function BehaviorSubject(_value) {
	        _super.call(this);
	        this._value = _value;
	    }
	    Object.defineProperty(BehaviorSubject.prototype, "value", {
	        get: function () {
	            return this.getValue();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    BehaviorSubject.prototype._subscribe = function (subscriber) {
	        var subscription = _super.prototype._subscribe.call(this, subscriber);
	        if (subscription && !subscription.closed) {
	            subscriber.next(this._value);
	        }
	        return subscription;
	    };
	    BehaviorSubject.prototype.getValue = function () {
	        if (this.hasError) {
	            throw this.thrownError;
	        }
	        else if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        else {
	            return this._value;
	        }
	    };
	    BehaviorSubject.prototype.next = function (value) {
	        _super.prototype.next.call(this, this._value = value);
	    };
	    return BehaviorSubject;
	}(Subject_1.Subject));
	exports.BehaviorSubject = BehaviorSubject;
	//# sourceMappingURL=BehaviorSubject.js.map

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(8);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var InnerSubscriber = (function (_super) {
	    __extends(InnerSubscriber, _super);
	    function InnerSubscriber(parent, outerValue, outerIndex) {
	        _super.call(this);
	        this.parent = parent;
	        this.outerValue = outerValue;
	        this.outerIndex = outerIndex;
	        this.index = 0;
	    }
	    InnerSubscriber.prototype._next = function (value) {
	        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
	    };
	    InnerSubscriber.prototype._error = function (error) {
	        this.parent.notifyError(error, this);
	        this.unsubscribe();
	    };
	    InnerSubscriber.prototype._complete = function () {
	        this.parent.notifyComplete(this);
	        this.unsubscribe();
	    };
	    return InnerSubscriber;
	}(Subscriber_1.Subscriber));
	exports.InnerSubscriber = InnerSubscriber;
	//# sourceMappingURL=InnerSubscriber.js.map

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(6);
	/**
	 * Represents a push-based event or value that an {@link Observable} can emit.
	 * This class is particularly useful for operators that manage notifications,
	 * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
	 * others. Besides wrapping the actual delivered value, it also annotates it
	 * with metadata of, for instance, what type of push message it is (`next`,
	 * `error`, or `complete`).
	 *
	 * @see {@link materialize}
	 * @see {@link dematerialize}
	 * @see {@link observeOn}
	 *
	 * @class Notification<T>
	 */
	var Notification = (function () {
	    function Notification(kind, value, error) {
	        this.kind = kind;
	        this.value = value;
	        this.error = error;
	        this.hasValue = kind === 'N';
	    }
	    /**
	     * Delivers to the given `observer` the value wrapped by this Notification.
	     * @param {Observer} observer
	     * @return
	     */
	    Notification.prototype.observe = function (observer) {
	        switch (this.kind) {
	            case 'N':
	                return observer.next && observer.next(this.value);
	            case 'E':
	                return observer.error && observer.error(this.error);
	            case 'C':
	                return observer.complete && observer.complete();
	        }
	    };
	    /**
	     * Given some {@link Observer} callbacks, deliver the value represented by the
	     * current Notification to the correctly corresponding callback.
	     * @param {function(value: T): void} next An Observer `next` callback.
	     * @param {function(err: any): void} [error] An Observer `error` callback.
	     * @param {function(): void} [complete] An Observer `complete` callback.
	     * @return {any}
	     */
	    Notification.prototype.do = function (next, error, complete) {
	        var kind = this.kind;
	        switch (kind) {
	            case 'N':
	                return next && next(this.value);
	            case 'E':
	                return error && error(this.error);
	            case 'C':
	                return complete && complete();
	        }
	    };
	    /**
	     * Takes an Observer or its individual callback functions, and calls `observe`
	     * or `do` methods accordingly.
	     * @param {Observer|function(value: T): void} nextOrObserver An Observer or
	     * the `next` callback.
	     * @param {function(err: any): void} [error] An Observer `error` callback.
	     * @param {function(): void} [complete] An Observer `complete` callback.
	     * @return {any}
	     */
	    Notification.prototype.accept = function (nextOrObserver, error, complete) {
	        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
	            return this.observe(nextOrObserver);
	        }
	        else {
	            return this.do(nextOrObserver, error, complete);
	        }
	    };
	    /**
	     * Returns a simple Observable that just delivers the notification represented
	     * by this Notification instance.
	     * @return {any}
	     */
	    Notification.prototype.toObservable = function () {
	        var kind = this.kind;
	        switch (kind) {
	            case 'N':
	                return Observable_1.Observable.of(this.value);
	            case 'E':
	                return Observable_1.Observable.throw(this.error);
	            case 'C':
	                return Observable_1.Observable.empty();
	        }
	        throw new Error('unexpected notification kind value');
	    };
	    /**
	     * A shortcut to create a Notification instance of the type `next` from a
	     * given value.
	     * @param {T} value The `next` value.
	     * @return {Notification<T>} The "next" Notification representing the
	     * argument.
	     */
	    Notification.createNext = function (value) {
	        if (typeof value !== 'undefined') {
	            return new Notification('N', value);
	        }
	        return Notification.undefinedValueNotification;
	    };
	    /**
	     * A shortcut to create a Notification instance of the type `error` from a
	     * given error.
	     * @param {any} [err] The `error` error.
	     * @return {Notification<T>} The "error" Notification representing the
	     * argument.
	     */
	    Notification.createError = function (err) {
	        return new Notification('E', undefined, err);
	    };
	    /**
	     * A shortcut to create a Notification instance of the type `complete`.
	     * @return {Notification<any>} The valueless "complete" Notification.
	     */
	    Notification.createComplete = function () {
	        return Notification.completeNotification;
	    };
	    Notification.completeNotification = new Notification('C');
	    Notification.undefinedValueNotification = new Notification('N', undefined);
	    return Notification;
	}());
	exports.Notification = Notification;
	//# sourceMappingURL=Notification.js.map

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscription_1 = __webpack_require__(27);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SubjectSubscription = (function (_super) {
	    __extends(SubjectSubscription, _super);
	    function SubjectSubscription(subject, subscriber) {
	        _super.call(this);
	        this.subject = subject;
	        this.subscriber = subscriber;
	        this.closed = false;
	    }
	    SubjectSubscription.prototype.unsubscribe = function () {
	        if (this.closed) {
	            return;
	        }
	        this.closed = true;
	        var subject = this.subject;
	        var observers = subject.observers;
	        this.subject = null;
	        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
	            return;
	        }
	        var subscriberIndex = observers.indexOf(this.subscriber);
	        if (subscriberIndex !== -1) {
	            observers.splice(subscriberIndex, 1);
	        }
	    };
	    return SubjectSubscription;
	}(Subscription_1.Subscription));
	exports.SubjectSubscription = SubjectSubscription;
	//# sourceMappingURL=SubjectSubscription.js.map

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(6);
	var ScalarObservable_1 = __webpack_require__(70);
	var EmptyObservable_1 = __webpack_require__(68);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var ArrayLikeObservable = (function (_super) {
	    __extends(ArrayLikeObservable, _super);
	    function ArrayLikeObservable(arrayLike, scheduler) {
	        _super.call(this);
	        this.arrayLike = arrayLike;
	        this.scheduler = scheduler;
	        if (!scheduler && arrayLike.length === 1) {
	            this._isScalar = true;
	            this.value = arrayLike[0];
	        }
	    }
	    ArrayLikeObservable.create = function (arrayLike, scheduler) {
	        var length = arrayLike.length;
	        if (length === 0) {
	            return new EmptyObservable_1.EmptyObservable();
	        }
	        else if (length === 1) {
	            return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);
	        }
	        else {
	            return new ArrayLikeObservable(arrayLike, scheduler);
	        }
	    };
	    ArrayLikeObservable.dispatch = function (state) {
	        var arrayLike = state.arrayLike, index = state.index, length = state.length, subscriber = state.subscriber;
	        if (subscriber.closed) {
	            return;
	        }
	        if (index >= length) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(arrayLike[index]);
	        state.index = index + 1;
	        this.schedule(state);
	    };
	    ArrayLikeObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var _a = this, arrayLike = _a.arrayLike, scheduler = _a.scheduler;
	        var length = arrayLike.length;
	        if (scheduler) {
	            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {
	                arrayLike: arrayLike, index: index, length: length, subscriber: subscriber
	            });
	        }
	        else {
	            for (var i = 0; i < length && !subscriber.closed; i++) {
	                subscriber.next(arrayLike[i]);
	            }
	            subscriber.complete();
	        }
	    };
	    return ArrayLikeObservable;
	}(Observable_1.Observable));
	exports.ArrayLikeObservable = ArrayLikeObservable;
	//# sourceMappingURL=ArrayLikeObservable.js.map

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(19);
	var Observable_1 = __webpack_require__(6);
	var Subscriber_1 = __webpack_require__(8);
	var Subscription_1 = __webpack_require__(27);
	/**
	 * @class ConnectableObservable<T>
	 */
	var ConnectableObservable = (function (_super) {
	    __extends(ConnectableObservable, _super);
	    function ConnectableObservable(source, subjectFactory) {
	        _super.call(this);
	        this.source = source;
	        this.subjectFactory = subjectFactory;
	        this._refCount = 0;
	        this._isComplete = false;
	    }
	    ConnectableObservable.prototype._subscribe = function (subscriber) {
	        return this.getSubject().subscribe(subscriber);
	    };
	    ConnectableObservable.prototype.getSubject = function () {
	        var subject = this._subject;
	        if (!subject || subject.isStopped) {
	            this._subject = this.subjectFactory();
	        }
	        return this._subject;
	    };
	    ConnectableObservable.prototype.connect = function () {
	        var connection = this._connection;
	        if (!connection) {
	            this._isComplete = false;
	            connection = this._connection = new Subscription_1.Subscription();
	            connection.add(this.source
	                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
	            if (connection.closed) {
	                this._connection = null;
	                connection = Subscription_1.Subscription.EMPTY;
	            }
	            else {
	                this._connection = connection;
	            }
	        }
	        return connection;
	    };
	    ConnectableObservable.prototype.refCount = function () {
	        return this.lift(new RefCountOperator(this));
	    };
	    return ConnectableObservable;
	}(Observable_1.Observable));
	exports.ConnectableObservable = ConnectableObservable;
	var connectableProto = ConnectableObservable.prototype;
	exports.connectableObservableDescriptor = {
	    operator: { value: null },
	    _refCount: { value: 0, writable: true },
	    _subject: { value: null, writable: true },
	    _connection: { value: null, writable: true },
	    _subscribe: { value: connectableProto._subscribe },
	    _isComplete: { value: connectableProto._isComplete, writable: true },
	    getSubject: { value: connectableProto.getSubject },
	    connect: { value: connectableProto.connect },
	    refCount: { value: connectableProto.refCount }
	};
	var ConnectableSubscriber = (function (_super) {
	    __extends(ConnectableSubscriber, _super);
	    function ConnectableSubscriber(destination, connectable) {
	        _super.call(this, destination);
	        this.connectable = connectable;
	    }
	    ConnectableSubscriber.prototype._error = function (err) {
	        this._unsubscribe();
	        _super.prototype._error.call(this, err);
	    };
	    ConnectableSubscriber.prototype._complete = function () {
	        this.connectable._isComplete = true;
	        this._unsubscribe();
	        _super.prototype._complete.call(this);
	    };
	    ConnectableSubscriber.prototype._unsubscribe = function () {
	        var connectable = this.connectable;
	        if (connectable) {
	            this.connectable = null;
	            var connection = connectable._connection;
	            connectable._refCount = 0;
	            connectable._subject = null;
	            connectable._connection = null;
	            if (connection) {
	                connection.unsubscribe();
	            }
	        }
	    };
	    return ConnectableSubscriber;
	}(Subject_1.SubjectSubscriber));
	var RefCountOperator = (function () {
	    function RefCountOperator(connectable) {
	        this.connectable = connectable;
	    }
	    RefCountOperator.prototype.call = function (subscriber, source) {
	        var connectable = this.connectable;
	        connectable._refCount++;
	        var refCounter = new RefCountSubscriber(subscriber, connectable);
	        var subscription = source.subscribe(refCounter);
	        if (!refCounter.closed) {
	            refCounter.connection = connectable.connect();
	        }
	        return subscription;
	    };
	    return RefCountOperator;
	}());
	var RefCountSubscriber = (function (_super) {
	    __extends(RefCountSubscriber, _super);
	    function RefCountSubscriber(destination, connectable) {
	        _super.call(this, destination);
	        this.connectable = connectable;
	    }
	    RefCountSubscriber.prototype._unsubscribe = function () {
	        var connectable = this.connectable;
	        if (!connectable) {
	            this.connection = null;
	            return;
	        }
	        this.connectable = null;
	        var refCount = connectable._refCount;
	        if (refCount <= 0) {
	            this.connection = null;
	            return;
	        }
	        connectable._refCount = refCount - 1;
	        if (refCount > 1) {
	            this.connection = null;
	            return;
	        }
	        ///
	        // Compare the local RefCountSubscriber's connection Subscription to the
	        // connection Subscription on the shared ConnectableObservable. In cases
	        // where the ConnectableObservable source synchronously emits values, and
	        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
	        // execution continues to here before the RefCountOperator has a chance to
	        // supply the RefCountSubscriber with the shared connection Subscription.
	        // For example:
	        // ```
	        // Observable.range(0, 10)
	        //   .publish()
	        //   .refCount()
	        //   .take(5)
	        //   .subscribe();
	        // ```
	        // In order to account for this case, RefCountSubscriber should only dispose
	        // the ConnectableObservable's shared connection Subscription if the
	        // connection Subscription exists, *and* either:
	        //   a. RefCountSubscriber doesn't have a reference to the shared connection
	        //      Subscription yet, or,
	        //   b. RefCountSubscriber's connection Subscription reference is identical
	        //      to the shared connection Subscription
	        ///
	        var connection = this.connection;
	        var sharedConnection = connectable._connection;
	        this.connection = null;
	        if (sharedConnection && (!connection || sharedConnection === connection)) {
	            sharedConnection.unsubscribe();
	        }
	    };
	    return RefCountSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=ConnectableObservable.js.map

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isArray_1 = __webpack_require__(74);
	var isArrayLike_1 = __webpack_require__(75);
	var isPromise_1 = __webpack_require__(78);
	var PromiseObservable_1 = __webpack_require__(69);
	var IteratorObservable_1 = __webpack_require__(199);
	var ArrayObservable_1 = __webpack_require__(36);
	var ArrayLikeObservable_1 = __webpack_require__(196);
	var iterator_1 = __webpack_require__(38);
	var Observable_1 = __webpack_require__(6);
	var observeOn_1 = __webpack_require__(214);
	var observable_1 = __webpack_require__(39);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var FromObservable = (function (_super) {
	    __extends(FromObservable, _super);
	    function FromObservable(ish, scheduler) {
	        _super.call(this, null);
	        this.ish = ish;
	        this.scheduler = scheduler;
	    }
	    /**
	     * Creates an Observable from an Array, an array-like object, a Promise, an
	     * iterable object, or an Observable-like object.
	     *
	     * <span class="informal">Converts almost anything to an Observable.</span>
	     *
	     * <img src="./img/from.png" width="100%">
	     *
	     * Convert various other objects and data types into Observables. `from`
	     * converts a Promise or an array-like or an
	     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)
	     * object into an Observable that emits the items in that promise or array or
	     * iterable. A String, in this context, is treated as an array of characters.
	     * Observable-like objects (contains a function named with the ES2015 Symbol
	     * for Observable) can also be converted through this operator.
	     *
	     * @example <caption>Converts an array to an Observable</caption>
	     * var array = [10, 20, 30];
	     * var result = Rx.Observable.from(array);
	     * result.subscribe(x => console.log(x));
	     *
	     * // Results in the following:
	     * // 10 20 30
	     *
	     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>
	     * function* generateDoubles(seed) {
	     *   var i = seed;
	     *   while (true) {
	     *     yield i;
	     *     i = 2 * i; // double it
	     *   }
	     * }
	     *
	     * var iterator = generateDoubles(3);
	     * var result = Rx.Observable.from(iterator).take(10);
	     * result.subscribe(x => console.log(x));
	     *
	     * // Results in the following:
	     * // 3 6 12 24 48 96 192 384 768 1536
	     *
	     * @see {@link create}
	     * @see {@link fromEvent}
	     * @see {@link fromEventPattern}
	     * @see {@link fromPromise}
	     *
	     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an
	     * Observable-like, an Array, an iterable or an array-like object to be
	     * converted.
	     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
	     * emissions of values.
	     * @return {Observable<T>} The Observable whose values are originally from the
	     * input object that was converted.
	     * @static true
	     * @name from
	     * @owner Observable
	     */
	    FromObservable.create = function (ish, scheduler) {
	        if (ish != null) {
	            if (typeof ish[observable_1.observable] === 'function') {
	                if (ish instanceof Observable_1.Observable && !scheduler) {
	                    return ish;
	                }
	                return new FromObservable(ish, scheduler);
	            }
	            else if (isArray_1.isArray(ish)) {
	                return new ArrayObservable_1.ArrayObservable(ish, scheduler);
	            }
	            else if (isPromise_1.isPromise(ish)) {
	                return new PromiseObservable_1.PromiseObservable(ish, scheduler);
	            }
	            else if (typeof ish[iterator_1.iterator] === 'function' || typeof ish === 'string') {
	                return new IteratorObservable_1.IteratorObservable(ish, scheduler);
	            }
	            else if (isArrayLike_1.isArrayLike(ish)) {
	                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);
	            }
	        }
	        throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');
	    };
	    FromObservable.prototype._subscribe = function (subscriber) {
	        var ish = this.ish;
	        var scheduler = this.scheduler;
	        if (scheduler == null) {
	            return ish[observable_1.observable]().subscribe(subscriber);
	        }
	        else {
	            return ish[observable_1.observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));
	        }
	    };
	    return FromObservable;
	}(Observable_1.Observable));
	exports.FromObservable = FromObservable;
	//# sourceMappingURL=FromObservable.js.map

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var root_1 = __webpack_require__(17);
	var Observable_1 = __webpack_require__(6);
	var iterator_1 = __webpack_require__(38);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var IteratorObservable = (function (_super) {
	    __extends(IteratorObservable, _super);
	    function IteratorObservable(iterator, scheduler) {
	        _super.call(this);
	        this.scheduler = scheduler;
	        if (iterator == null) {
	            throw new Error('iterator cannot be null.');
	        }
	        this.iterator = getIterator(iterator);
	    }
	    IteratorObservable.create = function (iterator, scheduler) {
	        return new IteratorObservable(iterator, scheduler);
	    };
	    IteratorObservable.dispatch = function (state) {
	        var index = state.index, hasError = state.hasError, iterator = state.iterator, subscriber = state.subscriber;
	        if (hasError) {
	            subscriber.error(state.error);
	            return;
	        }
	        var result = iterator.next();
	        if (result.done) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(result.value);
	        state.index = index + 1;
	        if (subscriber.closed) {
	            if (typeof iterator.return === 'function') {
	                iterator.return();
	            }
	            return;
	        }
	        this.schedule(state);
	    };
	    IteratorObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var _a = this, iterator = _a.iterator, scheduler = _a.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(IteratorObservable.dispatch, 0, {
	                index: index, iterator: iterator, subscriber: subscriber
	            });
	        }
	        else {
	            do {
	                var result = iterator.next();
	                if (result.done) {
	                    subscriber.complete();
	                    break;
	                }
	                else {
	                    subscriber.next(result.value);
	                }
	                if (subscriber.closed) {
	                    if (typeof iterator.return === 'function') {
	                        iterator.return();
	                    }
	                    break;
	                }
	            } while (true);
	        }
	    };
	    return IteratorObservable;
	}(Observable_1.Observable));
	exports.IteratorObservable = IteratorObservable;
	var StringIterator = (function () {
	    function StringIterator(str, idx, len) {
	        if (idx === void 0) { idx = 0; }
	        if (len === void 0) { len = str.length; }
	        this.str = str;
	        this.idx = idx;
	        this.len = len;
	    }
	    StringIterator.prototype[iterator_1.iterator] = function () { return (this); };
	    StringIterator.prototype.next = function () {
	        return this.idx < this.len ? {
	            done: false,
	            value: this.str.charAt(this.idx++)
	        } : {
	            done: true,
	            value: undefined
	        };
	    };
	    return StringIterator;
	}());
	var ArrayIterator = (function () {
	    function ArrayIterator(arr, idx, len) {
	        if (idx === void 0) { idx = 0; }
	        if (len === void 0) { len = toLength(arr); }
	        this.arr = arr;
	        this.idx = idx;
	        this.len = len;
	    }
	    ArrayIterator.prototype[iterator_1.iterator] = function () { return this; };
	    ArrayIterator.prototype.next = function () {
	        return this.idx < this.len ? {
	            done: false,
	            value: this.arr[this.idx++]
	        } : {
	            done: true,
	            value: undefined
	        };
	    };
	    return ArrayIterator;
	}());
	function getIterator(obj) {
	    var i = obj[iterator_1.iterator];
	    if (!i && typeof obj === 'string') {
	        return new StringIterator(obj);
	    }
	    if (!i && obj.length !== undefined) {
	        return new ArrayIterator(obj);
	    }
	    if (!i) {
	        throw new TypeError('object is not iterable');
	    }
	    return obj[iterator_1.iterator]();
	}
	var maxSafeInteger = Math.pow(2, 53) - 1;
	function toLength(o) {
	    var len = +o.length;
	    if (isNaN(len)) {
	        return 0;
	    }
	    if (len === 0 || !numberIsFinite(len)) {
	        return len;
	    }
	    len = sign(len) * Math.floor(Math.abs(len));
	    if (len <= 0) {
	        return 0;
	    }
	    if (len > maxSafeInteger) {
	        return maxSafeInteger;
	    }
	    return len;
	}
	function numberIsFinite(value) {
	    return typeof value === 'number' && root_1.root.isFinite(value);
	}
	function sign(value) {
	    var valueAsNumber = +value;
	    if (valueAsNumber === 0) {
	        return valueAsNumber;
	    }
	    if (isNaN(valueAsNumber)) {
	        return valueAsNumber;
	    }
	    return valueAsNumber < 0 ? -1 : 1;
	}
	//# sourceMappingURL=IteratorObservable.js.map

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var FromObservable_1 = __webpack_require__(198);
	exports.from = FromObservable_1.FromObservable.create;
	//# sourceMappingURL=from.js.map

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var PromiseObservable_1 = __webpack_require__(69);
	exports.fromPromise = PromiseObservable_1.PromiseObservable.create;
	//# sourceMappingURL=fromPromise.js.map

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var merge_1 = __webpack_require__(212);
	exports.merge = merge_1.mergeStatic;
	//# sourceMappingURL=merge.js.map

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var ArrayObservable_1 = __webpack_require__(36);
	exports.of = ArrayObservable_1.ArrayObservable.of;
	//# sourceMappingURL=of.js.map

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(35);
	var subscribeToResult_1 = __webpack_require__(42);
	/**
	 * Catches errors on the observable to be handled by returning a new observable or throwing an error.
	 *
	 * <img src="./img/catch.png" width="100%">
	 *
	 * @example <caption>Continues with a different Observable when there's an error</caption>
	 *
	 * Observable.of(1, 2, 3, 4, 5)
	 *   .map(n => {
	 * 	   if (n == 4) {
	 * 	     throw 'four!';
	 *     }
	 *	   return n;
	 *   })
	 *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))
	 *   .subscribe(x => console.log(x));
	 *   // 1, 2, 3, I, II, III, IV, V
	 *
	 * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>
	 *
	 * Observable.of(1, 2, 3, 4, 5)
	 *   .map(n => {
	 * 	   if (n === 4) {
	 * 	     throw 'four!';
	 *     }
	 * 	   return n;
	 *   })
	 *   .catch((err, caught) => caught)
	 *   .take(30)
	 *   .subscribe(x => console.log(x));
	 *   // 1, 2, 3, 1, 2, 3, ...
	 *
	 * @example <caption>Throws a new error when the source Observable throws an error</caption>
	 *
	 * Observable.of(1, 2, 3, 4, 5)
	 *   .map(n => {
	 *     if (n == 4) {
	 *       throw 'four!';
	 *     }
	 *     return n;
	 *   })
	 *   .catch(err => {
	 *     throw 'error in source. Details: ' + err;
	 *   })
	 *   .subscribe(
	 *     x => console.log(x),
	 *     err => console.log(err)
	 *   );
	 *   // 1, 2, 3, error in source. Details: four!
	 *
	 * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
	 *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
	 *  is returned by the `selector` will be used to continue the observable chain.
	 * @return {Observable} An observable that originates from either the source or the observable returned by the
	 *  catch `selector` function.
	 * @method catch
	 * @name catch
	 * @owner Observable
	 */
	function _catch(selector) {
	    var operator = new CatchOperator(selector);
	    var caught = this.lift(operator);
	    return (operator.caught = caught);
	}
	exports._catch = _catch;
	var CatchOperator = (function () {
	    function CatchOperator(selector) {
	        this.selector = selector;
	    }
	    CatchOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
	    };
	    return CatchOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var CatchSubscriber = (function (_super) {
	    __extends(CatchSubscriber, _super);
	    function CatchSubscriber(destination, selector, caught) {
	        _super.call(this, destination);
	        this.selector = selector;
	        this.caught = caught;
	    }
	    // NOTE: overriding `error` instead of `_error` because we don't want
	    // to have this flag this subscriber as `isStopped`. We can mimic the
	    // behavior of the RetrySubscriber (from the `retry` operator), where
	    // we unsubscribe from our source chain, reset our Subscriber flags,
	    // then subscribe to the selector result.
	    CatchSubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var result = void 0;
	            try {
	                result = this.selector(err, this.caught);
	            }
	            catch (err2) {
	                _super.prototype.error.call(this, err2);
	                return;
	            }
	            this._unsubscribeAndRecycle();
	            this.add(subscribeToResult_1.subscribeToResult(this, result));
	        }
	    };
	    return CatchSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=catch.js.map

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var mergeAll_1 = __webpack_require__(37);
	/* tslint:enable:max-line-length */
	/**
	 * Converts a higher-order Observable into a first-order Observable by
	 * concatenating the inner Observables in order.
	 *
	 * <span class="informal">Flattens an Observable-of-Observables by putting one
	 * inner Observable after the other.</span>
	 *
	 * <img src="./img/concatAll.png" width="100%">
	 *
	 * Joins every Observable emitted by the source (a higher-order Observable), in
	 * a serial fashion. It subscribes to each inner Observable only after the
	 * previous inner Observable has completed, and merges all of their values into
	 * the returned observable.
	 *
	 * __Warning:__ If the source Observable emits Observables quickly and
	 * endlessly, and the inner Observables it emits generally complete slower than
	 * the source emits, you can run into memory issues as the incoming Observables
	 * collect in an unbounded buffer.
	 *
	 * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set
	 * to `1`.
	 *
	 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));
	 * var firstOrder = higherOrder.concatAll();
	 * firstOrder.subscribe(x => console.log(x));
	 *
	 * // Results in the following:
	 * // (results are not concurrent)
	 * // For every click on the "document" it will emit values 0 to 3 spaced
	 * // on a 1000ms interval
	 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
	 *
	 * @see {@link combineAll}
	 * @see {@link concat}
	 * @see {@link concatMap}
	 * @see {@link concatMapTo}
	 * @see {@link exhaust}
	 * @see {@link mergeAll}
	 * @see {@link switch}
	 * @see {@link zipAll}
	 *
	 * @return {Observable} An Observable emitting values from all the inner
	 * Observables concatenated.
	 * @method concatAll
	 * @owner Observable
	 */
	function concatAll() {
	    return this.lift(new mergeAll_1.MergeAllOperator(1));
	}
	exports.concatAll = concatAll;
	//# sourceMappingURL=concatAll.js.map

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var mergeMap_1 = __webpack_require__(71);
	/* tslint:enable:max-line-length */
	/**
	 * Projects each source value to an Observable which is merged in the output
	 * Observable, in a serialized fashion waiting for each one to complete before
	 * merging the next.
	 *
	 * <span class="informal">Maps each value to an Observable, then flattens all of
	 * these inner Observables using {@link concatAll}.</span>
	 *
	 * <img src="./img/concatMap.png" width="100%">
	 *
	 * Returns an Observable that emits items based on applying a function that you
	 * supply to each item emitted by the source Observable, where that function
	 * returns an (so-called "inner") Observable. Each new inner Observable is
	 * concatenated with the previous inner Observable.
	 *
	 * __Warning:__ if source values arrive endlessly and faster than their
	 * corresponding inner Observables can complete, it will result in memory issues
	 * as inner Observables amass in an unbounded buffer waiting for their turn to
	 * be subscribed to.
	 *
	 * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set
	 * to `1`.
	 *
	 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));
	 * result.subscribe(x => console.log(x));
	 *
	 * // Results in the following:
	 * // (results are not concurrent)
	 * // For every click on the "document" it will emit values 0 to 3 spaced
	 * // on a 1000ms interval
	 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
	 *
	 * @see {@link concat}
	 * @see {@link concatAll}
	 * @see {@link concatMapTo}
	 * @see {@link exhaustMap}
	 * @see {@link mergeMap}
	 * @see {@link switchMap}
	 *
	 * @param {function(value: T, ?index: number): ObservableInput} project A function
	 * that, when applied to an item emitted by the source Observable, returns an
	 * Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @return {Observable} An Observable that emits the result of applying the
	 * projection function (and the optional `resultSelector`) to each item emitted
	 * by the source Observable and taking values from each projected inner
	 * Observable sequentially.
	 * @method concatMap
	 * @owner Observable
	 */
	function concatMap(project, resultSelector) {
	    return this.lift(new mergeMap_1.MergeMapOperator(project, resultSelector, 1));
	}
	exports.concatMap = concatMap;
	//# sourceMappingURL=concatMap.js.map

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(8);
	/**
	 * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.
	 *
	 * @example <caption>A simple example emitting true if all elements are less than 5, false otherwise</caption>
	 *  Observable.of(1, 2, 3, 4, 5, 6)
	 *     .every(x => x < 5)
	 *     .subscribe(x => console.log(x)); // -> false
	 *
	 * @param {function} predicate A function for determining if an item meets a specified condition.
	 * @param {any} [thisArg] Optional object to use for `this` in the callback.
	 * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.
	 * @method every
	 * @owner Observable
	 */
	function every(predicate, thisArg) {
	    return this.lift(new EveryOperator(predicate, thisArg, this));
	}
	exports.every = every;
	var EveryOperator = (function () {
	    function EveryOperator(predicate, thisArg, source) {
	        this.predicate = predicate;
	        this.thisArg = thisArg;
	        this.source = source;
	    }
	    EveryOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
	    };
	    return EveryOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var EverySubscriber = (function (_super) {
	    __extends(EverySubscriber, _super);
	    function EverySubscriber(destination, predicate, thisArg, source) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.thisArg = thisArg;
	        this.source = source;
	        this.index = 0;
	        this.thisArg = thisArg || this;
	    }
	    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {
	        this.destination.next(everyValueMatch);
	        this.destination.complete();
	    };
	    EverySubscriber.prototype._next = function (value) {
	        var result = false;
	        try {
	            result = this.predicate.call(this.thisArg, value, this.index++, this.source);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        if (!result) {
	            this.notifyComplete(false);
	        }
	    };
	    EverySubscriber.prototype._complete = function () {
	        this.notifyComplete(true);
	    };
	    return EverySubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=every.js.map

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(8);
	/* tslint:enable:max-line-length */
	/**
	 * Filter items emitted by the source Observable by only emitting those that
	 * satisfy a specified predicate.
	 *
	 * <span class="informal">Like
	 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
	 * it only emits a value from the source if it passes a criterion function.</span>
	 *
	 * <img src="./img/filter.png" width="100%">
	 *
	 * Similar to the well-known `Array.prototype.filter` method, this operator
	 * takes values from the source Observable, passes them through a `predicate`
	 * function and only emits those values that yielded `true`.
	 *
	 * @example <caption>Emit only click events whose target was a DIV element</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
	 * clicksOnDivs.subscribe(x => console.log(x));
	 *
	 * @see {@link distinct}
	 * @see {@link distinctUntilChanged}
	 * @see {@link distinctUntilKeyChanged}
	 * @see {@link ignoreElements}
	 * @see {@link partition}
	 * @see {@link skip}
	 *
	 * @param {function(value: T, index: number): boolean} predicate A function that
	 * evaluates each value emitted by the source Observable. If it returns `true`,
	 * the value is emitted, if `false` the value is not passed to the output
	 * Observable. The `index` parameter is the number `i` for the i-th source
	 * emission that has happened since the subscription, starting from the number
	 * `0`.
	 * @param {any} [thisArg] An optional argument to determine the value of `this`
	 * in the `predicate` function.
	 * @return {Observable} An Observable of values from the source that were
	 * allowed by the `predicate` function.
	 * @method filter
	 * @owner Observable
	 */
	function filter(predicate, thisArg) {
	    return this.lift(new FilterOperator(predicate, thisArg));
	}
	exports.filter = filter;
	var FilterOperator = (function () {
	    function FilterOperator(predicate, thisArg) {
	        this.predicate = predicate;
	        this.thisArg = thisArg;
	    }
	    FilterOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
	    };
	    return FilterOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var FilterSubscriber = (function (_super) {
	    __extends(FilterSubscriber, _super);
	    function FilterSubscriber(destination, predicate, thisArg) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.thisArg = thisArg;
	        this.count = 0;
	        this.predicate = predicate;
	    }
	    // the try catch block below is left specifically for
	    // optimization and perf reasons. a tryCatcher is not necessary here.
	    FilterSubscriber.prototype._next = function (value) {
	        var result;
	        try {
	            result = this.predicate.call(this.thisArg, value, this.count++);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        if (result) {
	            this.destination.next(value);
	        }
	    };
	    return FilterSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=filter.js.map

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(8);
	var EmptyError_1 = __webpack_require__(41);
	/**
	 * Emits only the first value (or the first value that meets some condition)
	 * emitted by the source Observable.
	 *
	 * <span class="informal">Emits only the first value. Or emits only the first
	 * value that passes some test.</span>
	 *
	 * <img src="./img/first.png" width="100%">
	 *
	 * If called with no arguments, `first` emits the first value of the source
	 * Observable, then completes. If called with a `predicate` function, `first`
	 * emits the first value of the source that matches the specified condition. It
	 * may also take a `resultSelector` function to produce the output value from
	 * the input value, and a `defaultValue` to emit in case the source completes
	 * before it is able to emit a valid value. Throws an error if `defaultValue`
	 * was not provided and a matching element is not found.
	 *
	 * @example <caption>Emit only the first click that happens on the DOM</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.first();
	 * result.subscribe(x => console.log(x));
	 *
	 * @example <caption>Emits the first click that happens on a DIV</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.first(ev => ev.target.tagName === 'DIV');
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link filter}
	 * @see {@link find}
	 * @see {@link take}
	 *
	 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
	 * callback if the Observable completes before any `next` notification was sent.
	 *
	 * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]
	 * An optional function called with each item to test for condition matching.
	 * @param {function(value: T, index: number): R} [resultSelector] A function to
	 * produce the value on the output Observable based on the values
	 * and the indices of the source Observable. The arguments passed to this
	 * function are:
	 * - `value`: the value that was emitted on the source.
	 * - `index`: the "index" of the value from the source.
	 * @param {R} [defaultValue] The default value emitted in case no valid value
	 * was found on the source.
	 * @return {Observable<T|R>} An Observable of the first item that matches the
	 * condition.
	 * @method first
	 * @owner Observable
	 */
	function first(predicate, resultSelector, defaultValue) {
	    return this.lift(new FirstOperator(predicate, resultSelector, defaultValue, this));
	}
	exports.first = first;
	var FirstOperator = (function () {
	    function FirstOperator(predicate, resultSelector, defaultValue, source) {
	        this.predicate = predicate;
	        this.resultSelector = resultSelector;
	        this.defaultValue = defaultValue;
	        this.source = source;
	    }
	    FirstOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new FirstSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));
	    };
	    return FirstOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var FirstSubscriber = (function (_super) {
	    __extends(FirstSubscriber, _super);
	    function FirstSubscriber(destination, predicate, resultSelector, defaultValue, source) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.resultSelector = resultSelector;
	        this.defaultValue = defaultValue;
	        this.source = source;
	        this.index = 0;
	        this.hasCompleted = false;
	        this._emitted = false;
	    }
	    FirstSubscriber.prototype._next = function (value) {
	        var index = this.index++;
	        if (this.predicate) {
	            this._tryPredicate(value, index);
	        }
	        else {
	            this._emit(value, index);
	        }
	    };
	    FirstSubscriber.prototype._tryPredicate = function (value, index) {
	        var result;
	        try {
	            result = this.predicate(value, index, this.source);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        if (result) {
	            this._emit(value, index);
	        }
	    };
	    FirstSubscriber.prototype._emit = function (value, index) {
	        if (this.resultSelector) {
	            this._tryResultSelector(value, index);
	            return;
	        }
	        this._emitFinal(value);
	    };
	    FirstSubscriber.prototype._tryResultSelector = function (value, index) {
	        var result;
	        try {
	            result = this.resultSelector(value, index);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this._emitFinal(result);
	    };
	    FirstSubscriber.prototype._emitFinal = function (value) {
	        var destination = this.destination;
	        if (!this._emitted) {
	            this._emitted = true;
	            destination.next(value);
	            destination.complete();
	            this.hasCompleted = true;
	        }
	    };
	    FirstSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {
	            destination.next(this.defaultValue);
	            destination.complete();
	        }
	        else if (!this.hasCompleted) {
	            destination.error(new EmptyError_1.EmptyError);
	        }
	    };
	    return FirstSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=first.js.map

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(8);
	var EmptyError_1 = __webpack_require__(41);
	/* tslint:enable:max-line-length */
	/**
	 * Returns an Observable that emits only the last item emitted by the source Observable.
	 * It optionally takes a predicate function as a parameter, in which case, rather than emitting
	 * the last item from the source Observable, the resulting Observable will emit the last item
	 * from the source Observable that satisfies the predicate.
	 *
	 * <img src="./img/last.png" width="100%">
	 *
	 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
	 * callback if the Observable completes before any `next` notification was sent.
	 * @param {function} predicate - The condition any source emitted item has to satisfy.
	 * @return {Observable} An Observable that emits only the last item satisfying the given condition
	 * from the source, or an NoSuchElementException if no such items are emitted.
	 * @throws - Throws if no items that match the predicate are emitted by the source Observable.
	 * @method last
	 * @owner Observable
	 */
	function last(predicate, resultSelector, defaultValue) {
	    return this.lift(new LastOperator(predicate, resultSelector, defaultValue, this));
	}
	exports.last = last;
	var LastOperator = (function () {
	    function LastOperator(predicate, resultSelector, defaultValue, source) {
	        this.predicate = predicate;
	        this.resultSelector = resultSelector;
	        this.defaultValue = defaultValue;
	        this.source = source;
	    }
	    LastOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new LastSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));
	    };
	    return LastOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var LastSubscriber = (function (_super) {
	    __extends(LastSubscriber, _super);
	    function LastSubscriber(destination, predicate, resultSelector, defaultValue, source) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.resultSelector = resultSelector;
	        this.defaultValue = defaultValue;
	        this.source = source;
	        this.hasValue = false;
	        this.index = 0;
	        if (typeof defaultValue !== 'undefined') {
	            this.lastValue = defaultValue;
	            this.hasValue = true;
	        }
	    }
	    LastSubscriber.prototype._next = function (value) {
	        var index = this.index++;
	        if (this.predicate) {
	            this._tryPredicate(value, index);
	        }
	        else {
	            if (this.resultSelector) {
	                this._tryResultSelector(value, index);
	                return;
	            }
	            this.lastValue = value;
	            this.hasValue = true;
	        }
	    };
	    LastSubscriber.prototype._tryPredicate = function (value, index) {
	        var result;
	        try {
	            result = this.predicate(value, index, this.source);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        if (result) {
	            if (this.resultSelector) {
	                this._tryResultSelector(value, index);
	                return;
	            }
	            this.lastValue = value;
	            this.hasValue = true;
	        }
	    };
	    LastSubscriber.prototype._tryResultSelector = function (value, index) {
	        var result;
	        try {
	            result = this.resultSelector(value, index);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.lastValue = result;
	        this.hasValue = true;
	    };
	    LastSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        if (this.hasValue) {
	            destination.next(this.lastValue);
	            destination.complete();
	        }
	        else {
	            destination.error(new EmptyError_1.EmptyError);
	        }
	    };
	    return LastSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=last.js.map

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(8);
	/**
	 * Applies a given `project` function to each value emitted by the source
	 * Observable, and emits the resulting values as an Observable.
	 *
	 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
	 * it passes each source value through a transformation function to get
	 * corresponding output values.</span>
	 *
	 * <img src="./img/map.png" width="100%">
	 *
	 * Similar to the well known `Array.prototype.map` function, this operator
	 * applies a projection to each value and emits that projection in the output
	 * Observable.
	 *
	 * @example <caption>Map every click to the clientX position of that click</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var positions = clicks.map(ev => ev.clientX);
	 * positions.subscribe(x => console.log(x));
	 *
	 * @see {@link mapTo}
	 * @see {@link pluck}
	 *
	 * @param {function(value: T, index: number): R} project The function to apply
	 * to each `value` emitted by the source Observable. The `index` parameter is
	 * the number `i` for the i-th emission that has happened since the
	 * subscription, starting from the number `0`.
	 * @param {any} [thisArg] An optional argument to define what `this` is in the
	 * `project` function.
	 * @return {Observable<R>} An Observable that emits the values from the source
	 * Observable transformed by the given `project` function.
	 * @method map
	 * @owner Observable
	 */
	function map(project, thisArg) {
	    if (typeof project !== 'function') {
	        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
	    }
	    return this.lift(new MapOperator(project, thisArg));
	}
	exports.map = map;
	var MapOperator = (function () {
	    function MapOperator(project, thisArg) {
	        this.project = project;
	        this.thisArg = thisArg;
	    }
	    MapOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
	    };
	    return MapOperator;
	}());
	exports.MapOperator = MapOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MapSubscriber = (function (_super) {
	    __extends(MapSubscriber, _super);
	    function MapSubscriber(destination, project, thisArg) {
	        _super.call(this, destination);
	        this.project = project;
	        this.count = 0;
	        this.thisArg = thisArg || this;
	    }
	    // NOTE: This looks unoptimized, but it's actually purposefully NOT
	    // using try/catch optimizations.
	    MapSubscriber.prototype._next = function (value) {
	        var result;
	        try {
	            result = this.project.call(this.thisArg, value, this.count++);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return MapSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=map.js.map

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(6);
	var ArrayObservable_1 = __webpack_require__(36);
	var mergeAll_1 = __webpack_require__(37);
	var isScheduler_1 = __webpack_require__(79);
	/* tslint:enable:max-line-length */
	/**
	 * Creates an output Observable which concurrently emits all values from every
	 * given input Observable.
	 *
	 * <span class="informal">Flattens multiple Observables together by blending
	 * their values into one Observable.</span>
	 *
	 * <img src="./img/merge.png" width="100%">
	 *
	 * `merge` subscribes to each given input Observable (either the source or an
	 * Observable given as argument), and simply forwards (without doing any
	 * transformation) all the values from all the input Observables to the output
	 * Observable. The output Observable only completes once all input Observables
	 * have completed. Any error delivered by an input Observable will be immediately
	 * emitted on the output Observable.
	 *
	 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var timer = Rx.Observable.interval(1000);
	 * var clicksOrTimer = clicks.merge(timer);
	 * clicksOrTimer.subscribe(x => console.log(x));
	 *
	 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
	 * var timer1 = Rx.Observable.interval(1000).take(10);
	 * var timer2 = Rx.Observable.interval(2000).take(6);
	 * var timer3 = Rx.Observable.interval(500).take(10);
	 * var concurrent = 2; // the argument
	 * var merged = timer1.merge(timer2, timer3, concurrent);
	 * merged.subscribe(x => console.log(x));
	 *
	 * @see {@link mergeAll}
	 * @see {@link mergeMap}
	 * @see {@link mergeMapTo}
	 * @see {@link mergeScan}
	 *
	 * @param {ObservableInput} other An input Observable to merge with the source
	 * Observable. More than one input Observables may be given as argument.
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
	 * Observables being subscribed to concurrently.
	 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
	 * concurrency of input Observables.
	 * @return {Observable} An Observable that emits items that are the result of
	 * every input Observable.
	 * @method merge
	 * @owner Observable
	 */
	function merge() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    return this.lift.call(mergeStatic.apply(void 0, [this].concat(observables)));
	}
	exports.merge = merge;
	/* tslint:enable:max-line-length */
	/**
	 * Creates an output Observable which concurrently emits all values from every
	 * given input Observable.
	 *
	 * <span class="informal">Flattens multiple Observables together by blending
	 * their values into one Observable.</span>
	 *
	 * <img src="./img/merge.png" width="100%">
	 *
	 * `merge` subscribes to each given input Observable (as arguments), and simply
	 * forwards (without doing any transformation) all the values from all the input
	 * Observables to the output Observable. The output Observable only completes
	 * once all input Observables have completed. Any error delivered by an input
	 * Observable will be immediately emitted on the output Observable.
	 *
	 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var timer = Rx.Observable.interval(1000);
	 * var clicksOrTimer = Rx.Observable.merge(clicks, timer);
	 * clicksOrTimer.subscribe(x => console.log(x));
	 *
	 * // Results in the following:
	 * // timer will emit ascending values, one every second(1000ms) to console
	 * // clicks logs MouseEvents to console everytime the "document" is clicked
	 * // Since the two streams are merged you see these happening
	 * // as they occur.
	 *
	 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
	 * var timer1 = Rx.Observable.interval(1000).take(10);
	 * var timer2 = Rx.Observable.interval(2000).take(6);
	 * var timer3 = Rx.Observable.interval(500).take(10);
	 * var concurrent = 2; // the argument
	 * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);
	 * merged.subscribe(x => console.log(x));
	 *
	 * // Results in the following:
	 * // - First timer1 and timer2 will run concurrently
	 * // - timer1 will emit a value every 1000ms for 10 iterations
	 * // - timer2 will emit a value every 2000ms for 6 iterations
	 * // - after timer1 hits it's max iteration, timer2 will
	 * //   continue, and timer3 will start to run concurrently with timer2
	 * // - when timer2 hits it's max iteration it terminates, and
	 * //   timer3 will continue to emit a value every 500ms until it is complete
	 *
	 * @see {@link mergeAll}
	 * @see {@link mergeMap}
	 * @see {@link mergeMapTo}
	 * @see {@link mergeScan}
	 *
	 * @param {...ObservableInput} observables Input Observables to merge together.
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
	 * Observables being subscribed to concurrently.
	 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
	 * concurrency of input Observables.
	 * @return {Observable} an Observable that emits items that are the result of
	 * every input Observable.
	 * @static true
	 * @name merge
	 * @owner Observable
	 */
	function mergeStatic() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    var concurrent = Number.POSITIVE_INFINITY;
	    var scheduler = null;
	    var last = observables[observables.length - 1];
	    if (isScheduler_1.isScheduler(last)) {
	        scheduler = observables.pop();
	        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
	            concurrent = observables.pop();
	        }
	    }
	    else if (typeof last === 'number') {
	        concurrent = observables.pop();
	    }
	    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
	        return observables[0];
	    }
	    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(concurrent));
	}
	exports.mergeStatic = mergeStatic;
	//# sourceMappingURL=merge.js.map

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var ConnectableObservable_1 = __webpack_require__(197);
	/* tslint:enable:max-line-length */
	/**
	 * Returns an Observable that emits the results of invoking a specified selector on items
	 * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.
	 *
	 * <img src="./img/multicast.png" width="100%">
	 *
	 * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through
	 * which the source sequence's elements will be multicast to the selector function
	 * or Subject to push source elements into.
	 * @param {Function} [selector] - Optional selector function that can use the multicasted source stream
	 * as many times as needed, without causing multiple subscriptions to the source stream.
	 * Subscribers to the given source will receive all notifications of the source from the
	 * time of the subscription forward.
	 * @return {Observable} An Observable that emits the results of invoking the selector
	 * on the items emitted by a `ConnectableObservable` that shares a single subscription to
	 * the underlying stream.
	 * @method multicast
	 * @owner Observable
	 */
	function multicast(subjectOrSubjectFactory, selector) {
	    var subjectFactory;
	    if (typeof subjectOrSubjectFactory === 'function') {
	        subjectFactory = subjectOrSubjectFactory;
	    }
	    else {
	        subjectFactory = function subjectFactory() {
	            return subjectOrSubjectFactory;
	        };
	    }
	    if (typeof selector === 'function') {
	        return this.lift(new MulticastOperator(subjectFactory, selector));
	    }
	    var connectable = Object.create(this, ConnectableObservable_1.connectableObservableDescriptor);
	    connectable.source = this;
	    connectable.subjectFactory = subjectFactory;
	    return connectable;
	}
	exports.multicast = multicast;
	var MulticastOperator = (function () {
	    function MulticastOperator(subjectFactory, selector) {
	        this.subjectFactory = subjectFactory;
	        this.selector = selector;
	    }
	    MulticastOperator.prototype.call = function (subscriber, source) {
	        var selector = this.selector;
	        var subject = this.subjectFactory();
	        var subscription = selector(subject).subscribe(subscriber);
	        subscription.add(source.subscribe(subject));
	        return subscription;
	    };
	    return MulticastOperator;
	}());
	exports.MulticastOperator = MulticastOperator;
	//# sourceMappingURL=multicast.js.map

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(8);
	var Notification_1 = __webpack_require__(194);
	/**
	 *
	 * Re-emits all notifications from source Observable with specified scheduler.
	 *
	 * <span class="informal">Ensure a specific scheduler is used, from outside of an Observable.</span>
	 *
	 * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule
	 * notifications emitted by the source Observable. It might be useful, if you do not have control over
	 * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.
	 *
	 * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,
	 * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal
	 * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits
	 * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.
	 * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split
	 * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source
	 * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a
	 * little bit more, to ensure that they are emitted at expected moments.
	 *
	 * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications
	 * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`
	 * will delay all notifications - including error notifications - while `delay` will pass through error
	 * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator
	 * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used
	 * for notification emissions in general.
	 *
	 * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>
	 * const intervals = Rx.Observable.interval(10); // Intervals are scheduled
	 *                                               // with async scheduler by default...
	 *
	 * intervals
	 * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame
	 * .subscribe(val => {                           // scheduler to ensure smooth animation.
	 *   someDiv.style.height = val + 'px';
	 * });
	 *
	 * @see {@link delay}
	 *
	 * @param {IScheduler} scheduler Scheduler that will be used to reschedule notifications from source Observable.
	 * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.
	 * @return {Observable<T>} Observable that emits the same notifications as the source Observable,
	 * but with provided scheduler.
	 *
	 * @method observeOn
	 * @owner Observable
	 */
	function observeOn(scheduler, delay) {
	    if (delay === void 0) { delay = 0; }
	    return this.lift(new ObserveOnOperator(scheduler, delay));
	}
	exports.observeOn = observeOn;
	var ObserveOnOperator = (function () {
	    function ObserveOnOperator(scheduler, delay) {
	        if (delay === void 0) { delay = 0; }
	        this.scheduler = scheduler;
	        this.delay = delay;
	    }
	    ObserveOnOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
	    };
	    return ObserveOnOperator;
	}());
	exports.ObserveOnOperator = ObserveOnOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ObserveOnSubscriber = (function (_super) {
	    __extends(ObserveOnSubscriber, _super);
	    function ObserveOnSubscriber(destination, scheduler, delay) {
	        if (delay === void 0) { delay = 0; }
	        _super.call(this, destination);
	        this.scheduler = scheduler;
	        this.delay = delay;
	    }
	    ObserveOnSubscriber.dispatch = function (arg) {
	        var notification = arg.notification, destination = arg.destination;
	        notification.observe(destination);
	        this.unsubscribe();
	    };
	    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
	        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
	    };
	    ObserveOnSubscriber.prototype._next = function (value) {
	        this.scheduleMessage(Notification_1.Notification.createNext(value));
	    };
	    ObserveOnSubscriber.prototype._error = function (err) {
	        this.scheduleMessage(Notification_1.Notification.createError(err));
	    };
	    ObserveOnSubscriber.prototype._complete = function () {
	        this.scheduleMessage(Notification_1.Notification.createComplete());
	    };
	    return ObserveOnSubscriber;
	}(Subscriber_1.Subscriber));
	exports.ObserveOnSubscriber = ObserveOnSubscriber;
	var ObserveOnMessage = (function () {
	    function ObserveOnMessage(notification, destination) {
	        this.notification = notification;
	        this.destination = destination;
	    }
	    return ObserveOnMessage;
	}());
	exports.ObserveOnMessage = ObserveOnMessage;
	//# sourceMappingURL=observeOn.js.map

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(8);
	/* tslint:enable:max-line-length */
	/**
	 * Applies an accumulator function over the source Observable, and returns the
	 * accumulated result when the source completes, given an optional seed value.
	 *
	 * <span class="informal">Combines together all values emitted on the source,
	 * using an accumulator function that knows how to join a new source value into
	 * the accumulation from the past.</span>
	 *
	 * <img src="./img/reduce.png" width="100%">
	 *
	 * Like
	 * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),
	 * `reduce` applies an `accumulator` function against an accumulation and each
	 * value of the source Observable (from the past) to reduce it to a single
	 * value, emitted on the output Observable. Note that `reduce` will only emit
	 * one value, only when the source Observable completes. It is equivalent to
	 * applying operator {@link scan} followed by operator {@link last}.
	 *
	 * Returns an Observable that applies a specified `accumulator` function to each
	 * item emitted by the source Observable. If a `seed` value is specified, then
	 * that value will be used as the initial value for the accumulator. If no seed
	 * value is specified, the first item of the source is used as the seed.
	 *
	 * @example <caption>Count the number of click events that happened in 5 seconds</caption>
	 * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')
	 *   .takeUntil(Rx.Observable.interval(5000));
	 * var ones = clicksInFiveSeconds.mapTo(1);
	 * var seed = 0;
	 * var count = ones.reduce((acc, one) => acc + one, seed);
	 * count.subscribe(x => console.log(x));
	 *
	 * @see {@link count}
	 * @see {@link expand}
	 * @see {@link mergeScan}
	 * @see {@link scan}
	 *
	 * @param {function(acc: R, value: T, index: number): R} accumulator The accumulator function
	 * called on each source value.
	 * @param {R} [seed] The initial accumulation value.
	 * @return {Observable<R>} An Observable that emits a single value that is the
	 * result of accumulating the values emitted by the source Observable.
	 * @method reduce
	 * @owner Observable
	 */
	function reduce(accumulator, seed) {
	    var hasSeed = false;
	    // providing a seed of `undefined` *should* be valid and trigger
	    // hasSeed! so don't use `seed !== undefined` checks!
	    // For this reason, we have to check it here at the original call site
	    // otherwise inside Operator/Subscriber we won't know if `undefined`
	    // means they didn't provide anything or if they literally provided `undefined`
	    if (arguments.length >= 2) {
	        hasSeed = true;
	    }
	    return this.lift(new ReduceOperator(accumulator, seed, hasSeed));
	}
	exports.reduce = reduce;
	var ReduceOperator = (function () {
	    function ReduceOperator(accumulator, seed, hasSeed) {
	        if (hasSeed === void 0) { hasSeed = false; }
	        this.accumulator = accumulator;
	        this.seed = seed;
	        this.hasSeed = hasSeed;
	    }
	    ReduceOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ReduceSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
	    };
	    return ReduceOperator;
	}());
	exports.ReduceOperator = ReduceOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ReduceSubscriber = (function (_super) {
	    __extends(ReduceSubscriber, _super);
	    function ReduceSubscriber(destination, accumulator, seed, hasSeed) {
	        _super.call(this, destination);
	        this.accumulator = accumulator;
	        this.hasSeed = hasSeed;
	        this.index = 0;
	        this.hasValue = false;
	        this.acc = seed;
	        if (!this.hasSeed) {
	            this.index++;
	        }
	    }
	    ReduceSubscriber.prototype._next = function (value) {
	        if (this.hasValue || (this.hasValue = this.hasSeed)) {
	            this._tryReduce(value);
	        }
	        else {
	            this.acc = value;
	            this.hasValue = true;
	        }
	    };
	    ReduceSubscriber.prototype._tryReduce = function (value) {
	        var result;
	        try {
	            result = this.accumulator(this.acc, value, this.index++);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.acc = result;
	    };
	    ReduceSubscriber.prototype._complete = function () {
	        if (this.hasValue || this.hasSeed) {
	            this.destination.next(this.acc);
	        }
	        this.destination.complete();
	    };
	    return ReduceSubscriber;
	}(Subscriber_1.Subscriber));
	exports.ReduceSubscriber = ReduceSubscriber;
	//# sourceMappingURL=reduce.js.map

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var multicast_1 = __webpack_require__(213);
	var Subject_1 = __webpack_require__(19);
	function shareSubjectFactory() {
	    return new Subject_1.Subject();
	}
	/**
	 * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one
	 * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will
	 * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.
	 * This is an alias for .publish().refCount().
	 *
	 * <img src="./img/share.png" width="100%">
	 *
	 * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.
	 * @method share
	 * @owner Observable
	 */
	function share() {
	    return multicast_1.multicast.call(this, shareSubjectFactory).refCount();
	}
	exports.share = share;
	;
	//# sourceMappingURL=share.js.map

/***/ }),
/* 217 */
/***/ (function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when one or more errors have occurred during the
	 * `unsubscribe` of a {@link Subscription}.
	 */
	var UnsubscriptionError = (function (_super) {
	    __extends(UnsubscriptionError, _super);
	    function UnsubscriptionError(errors) {
	        _super.call(this);
	        this.errors = errors;
	        var err = Error.call(this, errors ?
	            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n  ') : '');
	        this.name = err.name = 'UnsubscriptionError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return UnsubscriptionError;
	}(Error));
	exports.UnsubscriptionError = UnsubscriptionError;
	//# sourceMappingURL=UnsubscriptionError.js.map

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Subscriber_1 = __webpack_require__(8);
	var rxSubscriber_1 = __webpack_require__(40);
	var Observer_1 = __webpack_require__(67);
	function toSubscriber(nextOrObserver, error, complete) {
	    if (nextOrObserver) {
	        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
	            return nextOrObserver;
	        }
	        if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {
	            return nextOrObserver[rxSubscriber_1.rxSubscriber]();
	        }
	    }
	    if (!nextOrObserver && !error && !complete) {
	        return new Subscriber_1.Subscriber(Observer_1.empty);
	    }
	    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
	}
	exports.toSubscriber = toSubscriber;
	//# sourceMappingURL=toSubscriber.js.map

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var errorObject_1 = __webpack_require__(73);
	var tryCatchTarget;
	function tryCatcher() {
	    try {
	        return tryCatchTarget.apply(this, arguments);
	    }
	    catch (e) {
	        errorObject_1.errorObject.e = e;
	        return errorObject_1.errorObject;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}
	exports.tryCatch = tryCatch;
	;
	//# sourceMappingURL=tryCatch.js.map

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
	    "use strict";
	
	    if (global.setImmediate) {
	        return;
	    }
	
	    var nextHandle = 1; // Spec says greater than zero
	    var tasksByHandle = {};
	    var currentlyRunningATask = false;
	    var doc = global.document;
	    var registerImmediate;
	
	    function setImmediate(callback) {
	      // Callback can either be a function or a string
	      if (typeof callback !== "function") {
	        callback = new Function("" + callback);
	      }
	      // Copy function arguments
	      var args = new Array(arguments.length - 1);
	      for (var i = 0; i < args.length; i++) {
	          args[i] = arguments[i + 1];
	      }
	      // Store and register the task
	      var task = { callback: callback, args: args };
	      tasksByHandle[nextHandle] = task;
	      registerImmediate(nextHandle);
	      return nextHandle++;
	    }
	
	    function clearImmediate(handle) {
	        delete tasksByHandle[handle];
	    }
	
	    function run(task) {
	        var callback = task.callback;
	        var args = task.args;
	        switch (args.length) {
	        case 0:
	            callback();
	            break;
	        case 1:
	            callback(args[0]);
	            break;
	        case 2:
	            callback(args[0], args[1]);
	            break;
	        case 3:
	            callback(args[0], args[1], args[2]);
	            break;
	        default:
	            callback.apply(undefined, args);
	            break;
	        }
	    }
	
	    function runIfPresent(handle) {
	        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
	        // So if we're currently running a task, we'll need to delay this invocation.
	        if (currentlyRunningATask) {
	            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
	            // "too much recursion" error.
	            setTimeout(runIfPresent, 0, handle);
	        } else {
	            var task = tasksByHandle[handle];
	            if (task) {
	                currentlyRunningATask = true;
	                try {
	                    run(task);
	                } finally {
	                    clearImmediate(handle);
	                    currentlyRunningATask = false;
	                }
	            }
	        }
	    }
	
	    function installNextTickImplementation() {
	        registerImmediate = function(handle) {
	            process.nextTick(function () { runIfPresent(handle); });
	        };
	    }
	
	    function canUsePostMessage() {
	        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
	        // where `global.postMessage` means something completely different and can't be used for this purpose.
	        if (global.postMessage && !global.importScripts) {
	            var postMessageIsAsynchronous = true;
	            var oldOnMessage = global.onmessage;
	            global.onmessage = function() {
	                postMessageIsAsynchronous = false;
	            };
	            global.postMessage("", "*");
	            global.onmessage = oldOnMessage;
	            return postMessageIsAsynchronous;
	        }
	    }
	
	    function installPostMessageImplementation() {
	        // Installs an event handler on `global` for the `message` event: see
	        // * https://developer.mozilla.org/en/DOM/window.postMessage
	        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
	
	        var messagePrefix = "setImmediate$" + Math.random() + "$";
	        var onGlobalMessage = function(event) {
	            if (event.source === global &&
	                typeof event.data === "string" &&
	                event.data.indexOf(messagePrefix) === 0) {
	                runIfPresent(+event.data.slice(messagePrefix.length));
	            }
	        };
	
	        if (global.addEventListener) {
	            global.addEventListener("message", onGlobalMessage, false);
	        } else {
	            global.attachEvent("onmessage", onGlobalMessage);
	        }
	
	        registerImmediate = function(handle) {
	            global.postMessage(messagePrefix + handle, "*");
	        };
	    }
	
	    function installMessageChannelImplementation() {
	        var channel = new MessageChannel();
	        channel.port1.onmessage = function(event) {
	            var handle = event.data;
	            runIfPresent(handle);
	        };
	
	        registerImmediate = function(handle) {
	            channel.port2.postMessage(handle);
	        };
	    }
	
	    function installReadyStateChangeImplementation() {
	        var html = doc.documentElement;
	        registerImmediate = function(handle) {
	            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
	            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
	            var script = doc.createElement("script");
	            script.onreadystatechange = function () {
	                runIfPresent(handle);
	                script.onreadystatechange = null;
	                html.removeChild(script);
	                script = null;
	            };
	            html.appendChild(script);
	        };
	    }
	
	    function installSetTimeoutImplementation() {
	        registerImmediate = function(handle) {
	            setTimeout(runIfPresent, 0, handle);
	        };
	    }
	
	    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
	    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
	    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;
	
	    // Don't get fooled by e.g. browserify environments.
	    if ({}.toString.call(global.process) === "[object process]") {
	        // For Node.js before 0.9
	        installNextTickImplementation();
	
	    } else if (canUsePostMessage()) {
	        // For non-IE10 modern browsers
	        installPostMessageImplementation();
	
	    } else if (global.MessageChannel) {
	        // For web workers, where supported
	        installMessageChannelImplementation();
	
	    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
	        // For IE 6–8
	        installReadyStateChangeImplementation();
	
	    } else {
	        // For older browsers
	        installSetTimeoutImplementation();
	    }
	
	    attachTo.setImmediate = setImmediate;
	    attachTo.clearImmediate = clearImmediate;
	}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(66)))

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

	var apply = Function.prototype.apply;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) {
	  if (timeout) {
	    timeout.close();
	  }
	};
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// setimmediate attaches itself to the global object
	__webpack_require__(220);
	var global = __webpack_require__(190);
	exports.setImmediate = global.setImmediate;
	exports.clearImmediate = global.clearImmediate;


/***/ }),
/* 222 */
/***/ (function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	* @license
	* Copyright Google Inc. All Rights Reserved.
	*
	* Use of this source code is governed by an MIT-style license that can be
	* found in the LICENSE file at https://angular.io/license
	*/
	(function (global, factory) {
		 true ? factory() :
		typeof define === 'function' && define.amd ? define(factory) :
		(factory());
	}(this, (function () { 'use strict';
	
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var Zone$1 = (function (global) {
	    var performance = global['performance'];
	    function mark(name) {
	        performance && performance['mark'] && performance['mark'](name);
	    }
	    function performanceMeasure(name, label) {
	        performance && performance['measure'] && performance['measure'](name, label);
	    }
	    mark('Zone');
	    if (global['Zone']) {
	        throw new Error('Zone already loaded.');
	    }
	    var Zone = (function () {
	        function Zone(parent, zoneSpec) {
	            this._properties = null;
	            this._parent = parent;
	            this._name = zoneSpec ? zoneSpec.name || 'unnamed' : '<root>';
	            this._properties = zoneSpec && zoneSpec.properties || {};
	            this._zoneDelegate =
	                new ZoneDelegate(this, this._parent && this._parent._zoneDelegate, zoneSpec);
	        }
	        Zone.assertZonePatched = function () {
	            if (global['Promise'] !== patches['ZoneAwarePromise']) {
	                throw new Error('Zone.js has detected that ZoneAwarePromise `(window|global).Promise` ' +
	                    'has been overwritten.\n' +
	                    'Most likely cause is that a Promise polyfill has been loaded ' +
	                    'after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. ' +
	                    'If you must load one, do so before loading zone.js.)');
	            }
	        };
	        Object.defineProperty(Zone, "root", {
	            get: function () {
	                var zone = Zone.current;
	                while (zone.parent) {
	                    zone = zone.parent;
	                }
	                return zone;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(Zone, "current", {
	            get: function () {
	                return _currentZoneFrame.zone;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        
	        Object.defineProperty(Zone, "currentTask", {
	            get: function () {
	                return _currentTask;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        
	        Zone.__load_patch = function (name, fn) {
	            if (patches.hasOwnProperty(name)) {
	                throw Error('Already loaded patch: ' + name);
	            }
	            else if (!global['__Zone_disable_' + name]) {
	                var perfName = 'Zone:' + name;
	                mark(perfName);
	                patches[name] = fn(global, Zone, _api);
	                performanceMeasure(perfName, perfName);
	            }
	        };
	        Object.defineProperty(Zone.prototype, "parent", {
	            get: function () {
	                return this._parent;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        
	        Object.defineProperty(Zone.prototype, "name", {
	            get: function () {
	                return this._name;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        
	        Zone.prototype.get = function (key) {
	            var zone = this.getZoneWith(key);
	            if (zone)
	                return zone._properties[key];
	        };
	        Zone.prototype.getZoneWith = function (key) {
	            var current = this;
	            while (current) {
	                if (current._properties.hasOwnProperty(key)) {
	                    return current;
	                }
	                current = current._parent;
	            }
	            return null;
	        };
	        Zone.prototype.fork = function (zoneSpec) {
	            if (!zoneSpec)
	                throw new Error('ZoneSpec required!');
	            return this._zoneDelegate.fork(this, zoneSpec);
	        };
	        Zone.prototype.wrap = function (callback, source) {
	            if (typeof callback !== 'function') {
	                throw new Error('Expecting function got: ' + callback);
	            }
	            var _callback = this._zoneDelegate.intercept(this, callback, source);
	            var zone = this;
	            return function () {
	                return zone.runGuarded(_callback, this, arguments, source);
	            };
	        };
	        Zone.prototype.run = function (callback, applyThis, applyArgs, source) {
	            if (applyThis === void 0) { applyThis = undefined; }
	            if (applyArgs === void 0) { applyArgs = null; }
	            if (source === void 0) { source = null; }
	            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };
	            try {
	                return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
	            }
	            finally {
	                _currentZoneFrame = _currentZoneFrame.parent;
	            }
	        };
	        Zone.prototype.runGuarded = function (callback, applyThis, applyArgs, source) {
	            if (applyThis === void 0) { applyThis = null; }
	            if (applyArgs === void 0) { applyArgs = null; }
	            if (source === void 0) { source = null; }
	            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };
	            try {
	                try {
	                    return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
	                }
	                catch (error) {
	                    if (this._zoneDelegate.handleError(this, error)) {
	                        throw error;
	                    }
	                }
	            }
	            finally {
	                _currentZoneFrame = _currentZoneFrame.parent;
	            }
	        };
	        Zone.prototype.runTask = function (task, applyThis, applyArgs) {
	            if (task.zone != this) {
	                throw new Error('A task can only be run in the zone of creation! (Creation: ' +
	                    (task.zone || NO_ZONE).name + '; Execution: ' + this.name + ')');
	            }
	            // https://github.com/angular/zone.js/issues/778, sometimes eventTask
	            // will run in notScheduled(canceled) state, we should not try to
	            // run such kind of task but just return
	            // we have to define an variable here, if not
	            // typescript compiler will complain below
	            var isNotScheduled = task.state === notScheduled;
	            if (isNotScheduled && task.type === eventTask) {
	                return;
	            }
	            var reEntryGuard = task.state != running;
	            reEntryGuard && task._transitionTo(running, scheduled);
	            task.runCount++;
	            var previousTask = _currentTask;
	            _currentTask = task;
	            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };
	            try {
	                if (task.type == macroTask && task.data && !task.data.isPeriodic) {
	                    task.cancelFn = null;
	                }
	                try {
	                    return this._zoneDelegate.invokeTask(this, task, applyThis, applyArgs);
	                }
	                catch (error) {
	                    if (this._zoneDelegate.handleError(this, error)) {
	                        throw error;
	                    }
	                }
	            }
	            finally {
	                // if the task's state is notScheduled or unknown, then it has already been cancelled
	                // we should not reset the state to scheduled
	                if (task.state !== notScheduled && task.state !== unknown) {
	                    if (task.type == eventTask || (task.data && task.data.isPeriodic)) {
	                        reEntryGuard && task._transitionTo(scheduled, running);
	                    }
	                    else {
	                        task.runCount = 0;
	                        this._updateTaskCount(task, -1);
	                        reEntryGuard &&
	                            task._transitionTo(notScheduled, running, notScheduled);
	                    }
	                }
	                _currentZoneFrame = _currentZoneFrame.parent;
	                _currentTask = previousTask;
	            }
	        };
	        Zone.prototype.scheduleTask = function (task) {
	            if (task.zone && task.zone !== this) {
	                // check if the task was rescheduled, the newZone
	                // should not be the children of the original zone
	                var newZone = this;
	                while (newZone) {
	                    if (newZone === task.zone) {
	                        throw Error("can not reschedule task to " + this
	                            .name + " which is descendants of the original zone " + task.zone.name);
	                    }
	                    newZone = newZone.parent;
	                }
	            }
	            task._transitionTo(scheduling, notScheduled);
	            var zoneDelegates = [];
	            task._zoneDelegates = zoneDelegates;
	            task._zone = this;
	            try {
	                task = this._zoneDelegate.scheduleTask(this, task);
	            }
	            catch (err) {
	                // should set task's state to unknown when scheduleTask throw error
	                // because the err may from reschedule, so the fromState maybe notScheduled
	                task._transitionTo(unknown, scheduling, notScheduled);
	                // TODO: @JiaLiPassion, should we check the result from handleError?
	                this._zoneDelegate.handleError(this, err);
	                throw err;
	            }
	            if (task._zoneDelegates === zoneDelegates) {
	                // we have to check because internally the delegate can reschedule the task.
	                this._updateTaskCount(task, 1);
	            }
	            if (task.state == scheduling) {
	                task._transitionTo(scheduled, scheduling);
	            }
	            return task;
	        };
	        Zone.prototype.scheduleMicroTask = function (source, callback, data, customSchedule) {
	            return this.scheduleTask(new ZoneTask(microTask, source, callback, data, customSchedule, null));
	        };
	        Zone.prototype.scheduleMacroTask = function (source, callback, data, customSchedule, customCancel) {
	            return this.scheduleTask(new ZoneTask(macroTask, source, callback, data, customSchedule, customCancel));
	        };
	        Zone.prototype.scheduleEventTask = function (source, callback, data, customSchedule, customCancel) {
	            return this.scheduleTask(new ZoneTask(eventTask, source, callback, data, customSchedule, customCancel));
	        };
	        Zone.prototype.cancelTask = function (task) {
	            if (task.zone != this)
	                throw new Error('A task can only be cancelled in the zone of creation! (Creation: ' +
	                    (task.zone || NO_ZONE).name + '; Execution: ' + this.name + ')');
	            task._transitionTo(canceling, scheduled, running);
	            try {
	                this._zoneDelegate.cancelTask(this, task);
	            }
	            catch (err) {
	                // if error occurs when cancelTask, transit the state to unknown
	                task._transitionTo(unknown, canceling);
	                this._zoneDelegate.handleError(this, err);
	                throw err;
	            }
	            this._updateTaskCount(task, -1);
	            task._transitionTo(notScheduled, canceling);
	            task.runCount = 0;
	            return task;
	        };
	        Zone.prototype._updateTaskCount = function (task, count) {
	            var zoneDelegates = task._zoneDelegates;
	            if (count == -1) {
	                task._zoneDelegates = null;
	            }
	            for (var i = 0; i < zoneDelegates.length; i++) {
	                zoneDelegates[i]._updateTaskCount(task.type, count);
	            }
	        };
	        return Zone;
	    }());
	    Zone.__symbol__ = __symbol__;
	    var DELEGATE_ZS = {
	        name: '',
	        onHasTask: function (delegate, _, target, hasTaskState) {
	            return delegate.hasTask(target, hasTaskState);
	        },
	        onScheduleTask: function (delegate, _, target, task) {
	            return delegate.scheduleTask(target, task);
	        },
	        onInvokeTask: function (delegate, _, target, task, applyThis, applyArgs) { return delegate.invokeTask(target, task, applyThis, applyArgs); },
	        onCancelTask: function (delegate, _, target, task) {
	            return delegate.cancelTask(target, task);
	        }
	    };
	    var ZoneDelegate = (function () {
	        function ZoneDelegate(zone, parentDelegate, zoneSpec) {
	            this._taskCounts = { 'microTask': 0, 'macroTask': 0, 'eventTask': 0 };
	            this.zone = zone;
	            this._parentDelegate = parentDelegate;
	            this._forkZS = zoneSpec && (zoneSpec && zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);
	            this._forkDlgt = zoneSpec && (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);
	            this._forkCurrZone = zoneSpec && (zoneSpec.onFork ? this.zone : parentDelegate.zone);
	            this._interceptZS =
	                zoneSpec && (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);
	            this._interceptDlgt =
	                zoneSpec && (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);
	            this._interceptCurrZone =
	                zoneSpec && (zoneSpec.onIntercept ? this.zone : parentDelegate.zone);
	            this._invokeZS = zoneSpec && (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);
	            this._invokeDlgt =
	                zoneSpec && (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);
	            this._invokeCurrZone = zoneSpec && (zoneSpec.onInvoke ? this.zone : parentDelegate.zone);
	            this._handleErrorZS =
	                zoneSpec && (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);
	            this._handleErrorDlgt =
	                zoneSpec && (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);
	            this._handleErrorCurrZone =
	                zoneSpec && (zoneSpec.onHandleError ? this.zone : parentDelegate.zone);
	            this._scheduleTaskZS =
	                zoneSpec && (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);
	            this._scheduleTaskDlgt =
	                zoneSpec && (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);
	            this._scheduleTaskCurrZone =
	                zoneSpec && (zoneSpec.onScheduleTask ? this.zone : parentDelegate.zone);
	            this._invokeTaskZS =
	                zoneSpec && (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);
	            this._invokeTaskDlgt =
	                zoneSpec && (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);
	            this._invokeTaskCurrZone =
	                zoneSpec && (zoneSpec.onInvokeTask ? this.zone : parentDelegate.zone);
	            this._cancelTaskZS =
	                zoneSpec && (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);
	            this._cancelTaskDlgt =
	                zoneSpec && (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);
	            this._cancelTaskCurrZone =
	                zoneSpec && (zoneSpec.onCancelTask ? this.zone : parentDelegate.zone);
	            this._hasTaskZS = null;
	            this._hasTaskDlgt = null;
	            this._hasTaskDlgtOwner = null;
	            this._hasTaskCurrZone = null;
	            var zoneSpecHasTask = zoneSpec && zoneSpec.onHasTask;
	            var parentHasTask = parentDelegate && parentDelegate._hasTaskZS;
	            if (zoneSpecHasTask || parentHasTask) {
	                // If we need to report hasTask, than this ZS needs to do ref counting on tasks. In such
	                // a case all task related interceptors must go through this ZD. We can't short circuit it.
	                this._hasTaskZS = zoneSpecHasTask ? zoneSpec : DELEGATE_ZS;
	                this._hasTaskDlgt = parentDelegate;
	                this._hasTaskDlgtOwner = this;
	                this._hasTaskCurrZone = zone;
	                if (!zoneSpec.onScheduleTask) {
	                    this._scheduleTaskZS = DELEGATE_ZS;
	                    this._scheduleTaskDlgt = parentDelegate;
	                    this._scheduleTaskCurrZone = this.zone;
	                }
	                if (!zoneSpec.onInvokeTask) {
	                    this._invokeTaskZS = DELEGATE_ZS;
	                    this._invokeTaskDlgt = parentDelegate;
	                    this._invokeTaskCurrZone = this.zone;
	                }
	                if (!zoneSpec.onCancelTask) {
	                    this._cancelTaskZS = DELEGATE_ZS;
	                    this._cancelTaskDlgt = parentDelegate;
	                    this._cancelTaskCurrZone = this.zone;
	                }
	            }
	        }
	        ZoneDelegate.prototype.fork = function (targetZone, zoneSpec) {
	            return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec) :
	                new Zone(targetZone, zoneSpec);
	        };
	        ZoneDelegate.prototype.intercept = function (targetZone, callback, source) {
	            return this._interceptZS ?
	                this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, targetZone, callback, source) :
	                callback;
	        };
	        ZoneDelegate.prototype.invoke = function (targetZone, callback, applyThis, applyArgs, source) {
	            return this._invokeZS ?
	                this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, targetZone, callback, applyThis, applyArgs, source) :
	                callback.apply(applyThis, applyArgs);
	        };
	        ZoneDelegate.prototype.handleError = function (targetZone, error) {
	            return this._handleErrorZS ?
	                this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, targetZone, error) :
	                true;
	        };
	        ZoneDelegate.prototype.scheduleTask = function (targetZone, task) {
	            var returnTask = task;
	            if (this._scheduleTaskZS) {
	                if (this._hasTaskZS) {
	                    returnTask._zoneDelegates.push(this._hasTaskDlgtOwner);
	                }
	                returnTask = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, targetZone, task);
	                if (!returnTask)
	                    returnTask = task;
	            }
	            else {
	                if (task.scheduleFn) {
	                    task.scheduleFn(task);
	                }
	                else if (task.type == microTask) {
	                    scheduleMicroTask(task);
	                }
	                else {
	                    throw new Error('Task is missing scheduleFn.');
	                }
	            }
	            return returnTask;
	        };
	        ZoneDelegate.prototype.invokeTask = function (targetZone, task, applyThis, applyArgs) {
	            return this._invokeTaskZS ?
	                this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, targetZone, task, applyThis, applyArgs) :
	                task.callback.apply(applyThis, applyArgs);
	        };
	        ZoneDelegate.prototype.cancelTask = function (targetZone, task) {
	            var value;
	            if (this._cancelTaskZS) {
	                value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, targetZone, task);
	            }
	            else {
	                if (!task.cancelFn) {
	                    throw Error('Task is not cancelable');
	                }
	                value = task.cancelFn(task);
	            }
	            return value;
	        };
	        ZoneDelegate.prototype.hasTask = function (targetZone, isEmpty) {
	            // hasTask should not throw error so other ZoneDelegate
	            // can still trigger hasTask callback
	            try {
	                return this._hasTaskZS &&
	                    this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, targetZone, isEmpty);
	            }
	            catch (err) {
	                this.handleError(targetZone, err);
	            }
	        };
	        ZoneDelegate.prototype._updateTaskCount = function (type, count) {
	            var counts = this._taskCounts;
	            var prev = counts[type];
	            var next = counts[type] = prev + count;
	            if (next < 0) {
	                throw new Error('More tasks executed then were scheduled.');
	            }
	            if (prev == 0 || next == 0) {
	                var isEmpty = {
	                    microTask: counts.microTask > 0,
	                    macroTask: counts.macroTask > 0,
	                    eventTask: counts.eventTask > 0,
	                    change: type
	                };
	                this.hasTask(this.zone, isEmpty);
	            }
	        };
	        return ZoneDelegate;
	    }());
	    var ZoneTask = (function () {
	        function ZoneTask(type, source, callback, options, scheduleFn, cancelFn) {
	            this._zone = null;
	            this.runCount = 0;
	            this._zoneDelegates = null;
	            this._state = 'notScheduled';
	            this.type = type;
	            this.source = source;
	            this.data = options;
	            this.scheduleFn = scheduleFn;
	            this.cancelFn = cancelFn;
	            this.callback = callback;
	            var self = this;
	            if (type === eventTask && options && options.isUsingGlobalCallback) {
	                this.invoke = ZoneTask.invokeTask;
	            }
	            else {
	                this.invoke = function () {
	                    return ZoneTask.invokeTask.apply(global, [self, this, arguments]);
	                };
	            }
	        }
	        ZoneTask.invokeTask = function (task, target, args) {
	            if (!task) {
	                task = this;
	            }
	            _numberOfNestedTaskFrames++;
	            try {
	                task.runCount++;
	                return task.zone.runTask(task, target, args);
	            }
	            finally {
	                if (_numberOfNestedTaskFrames == 1) {
	                    drainMicroTaskQueue();
	                }
	                _numberOfNestedTaskFrames--;
	            }
	        };
	        Object.defineProperty(ZoneTask.prototype, "zone", {
	            get: function () {
	                return this._zone;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ZoneTask.prototype, "state", {
	            get: function () {
	                return this._state;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        ZoneTask.prototype.cancelScheduleRequest = function () {
	            this._transitionTo(notScheduled, scheduling);
	        };
	        ZoneTask.prototype._transitionTo = function (toState, fromState1, fromState2) {
	            if (this._state === fromState1 || this._state === fromState2) {
	                this._state = toState;
	                if (toState == notScheduled) {
	                    this._zoneDelegates = null;
	                }
	            }
	            else {
	                throw new Error(this.type + " '" + this.source + "': can not transition to '" + toState + "', expecting state '" + fromState1 + "'" + (fromState2 ?
	                    ' or \'' + fromState2 + '\'' :
	                    '') + ", was '" + this._state + "'.");
	            }
	        };
	        ZoneTask.prototype.toString = function () {
	            if (this.data && typeof this.data.handleId !== 'undefined') {
	                return this.data.handleId;
	            }
	            else {
	                return Object.prototype.toString.call(this);
	            }
	        };
	        // add toJSON method to prevent cyclic error when
	        // call JSON.stringify(zoneTask)
	        ZoneTask.prototype.toJSON = function () {
	            return {
	                type: this.type,
	                state: this.state,
	                source: this.source,
	                zone: this.zone.name,
	                invoke: this.invoke,
	                scheduleFn: this.scheduleFn,
	                cancelFn: this.cancelFn,
	                runCount: this.runCount,
	                callback: this.callback
	            };
	        };
	        return ZoneTask;
	    }());
	    //////////////////////////////////////////////////////
	    //////////////////////////////////////////////////////
	    ///  MICROTASK QUEUE
	    //////////////////////////////////////////////////////
	    //////////////////////////////////////////////////////
	    var symbolSetTimeout = __symbol__('setTimeout');
	    var symbolPromise = __symbol__('Promise');
	    var symbolThen = __symbol__('then');
	    var _microTaskQueue = [];
	    var _isDrainingMicrotaskQueue = false;
	    function scheduleMicroTask(task) {
	        // if we are not running in any task, and there has not been anything scheduled
	        // we must bootstrap the initial task creation by manually scheduling the drain
	        if (_numberOfNestedTaskFrames === 0 && _microTaskQueue.length === 0) {
	            // We are not running in Task, so we need to kickstart the microtask queue.
	            if (global[symbolPromise]) {
	                global[symbolPromise].resolve(0)[symbolThen](drainMicroTaskQueue);
	            }
	            else {
	                global[symbolSetTimeout](drainMicroTaskQueue, 0);
	            }
	        }
	        task && _microTaskQueue.push(task);
	    }
	    function drainMicroTaskQueue() {
	        if (!_isDrainingMicrotaskQueue) {
	            _isDrainingMicrotaskQueue = true;
	            while (_microTaskQueue.length) {
	                var queue = _microTaskQueue;
	                _microTaskQueue = [];
	                for (var i = 0; i < queue.length; i++) {
	                    var task = queue[i];
	                    try {
	                        task.zone.runTask(task, null, null);
	                    }
	                    catch (error) {
	                        _api.onUnhandledError(error);
	                    }
	                }
	            }
	            var showError = !Zone[__symbol__('ignoreConsoleErrorUncaughtError')];
	            _api.microtaskDrainDone();
	            _isDrainingMicrotaskQueue = false;
	        }
	    }
	    //////////////////////////////////////////////////////
	    //////////////////////////////////////////////////////
	    ///  BOOTSTRAP
	    //////////////////////////////////////////////////////
	    //////////////////////////////////////////////////////
	    var NO_ZONE = { name: 'NO ZONE' };
	    var notScheduled = 'notScheduled', scheduling = 'scheduling', scheduled = 'scheduled', running = 'running', canceling = 'canceling', unknown = 'unknown';
	    var microTask = 'microTask', macroTask = 'macroTask', eventTask = 'eventTask';
	    var patches = {};
	    var _api = {
	        symbol: __symbol__,
	        currentZoneFrame: function () { return _currentZoneFrame; },
	        onUnhandledError: noop,
	        microtaskDrainDone: noop,
	        scheduleMicroTask: scheduleMicroTask,
	        showUncaughtError: function () { return !Zone[__symbol__('ignoreConsoleErrorUncaughtError')]; },
	        patchEventTarget: function () { return []; },
	        patchOnProperties: noop,
	        patchMethod: function () { return noop; },
	    };
	    var _currentZoneFrame = { parent: null, zone: new Zone(null, null) };
	    var _currentTask = null;
	    var _numberOfNestedTaskFrames = 0;
	    function noop() { }
	    function __symbol__(name) {
	        return '__zone_symbol__' + name;
	    }
	    performanceMeasure('Zone', 'Zone');
	    return global['Zone'] = Zone;
	})(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);
	
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	Zone.__load_patch('ZoneAwarePromise', function (global, Zone, api) {
	    var __symbol__ = api.symbol;
	    var _uncaughtPromiseErrors = [];
	    var symbolPromise = __symbol__('Promise');
	    var symbolThen = __symbol__('then');
	    api.onUnhandledError = function (e) {
	        if (api.showUncaughtError()) {
	            var rejection = e && e.rejection;
	            if (rejection) {
	                console.error('Unhandled Promise rejection:', rejection instanceof Error ? rejection.message : rejection, '; Zone:', e.zone.name, '; Task:', e.task && e.task.source, '; Value:', rejection, rejection instanceof Error ? rejection.stack : undefined);
	            }
	            else {
	                console.error(e);
	            }
	        }
	    };
	    api.microtaskDrainDone = function () {
	        while (_uncaughtPromiseErrors.length) {
	            var _loop_1 = function () {
	                var uncaughtPromiseError = _uncaughtPromiseErrors.shift();
	                try {
	                    uncaughtPromiseError.zone.runGuarded(function () {
	                        throw uncaughtPromiseError;
	                    });
	                }
	                catch (error) {
	                    handleUnhandledRejection(error);
	                }
	            };
	            while (_uncaughtPromiseErrors.length) {
	                _loop_1();
	            }
	        }
	    };
	    function handleUnhandledRejection(e) {
	        api.onUnhandledError(e);
	        try {
	            var handler = Zone[__symbol__('unhandledPromiseRejectionHandler')];
	            if (handler && typeof handler === 'function') {
	                handler.apply(this, [e]);
	            }
	        }
	        catch (err) {
	        }
	    }
	    function isThenable(value) {
	        return value && value.then;
	    }
	    function forwardResolution(value) {
	        return value;
	    }
	    function forwardRejection(rejection) {
	        return ZoneAwarePromise.reject(rejection);
	    }
	    var symbolState = __symbol__('state');
	    var symbolValue = __symbol__('value');
	    var source = 'Promise.then';
	    var UNRESOLVED = null;
	    var RESOLVED = true;
	    var REJECTED = false;
	    var REJECTED_NO_CATCH = 0;
	    function makeResolver(promise, state) {
	        return function (v) {
	            try {
	                resolvePromise(promise, state, v);
	            }
	            catch (err) {
	                resolvePromise(promise, false, err);
	            }
	            // Do not return value or you will break the Promise spec.
	        };
	    }
	    var once = function () {
	        var wasCalled = false;
	        return function wrapper(wrappedFunction) {
	            return function () {
	                if (wasCalled) {
	                    return;
	                }
	                wasCalled = true;
	                wrappedFunction.apply(null, arguments);
	            };
	        };
	    };
	    // Promise Resolution
	    function resolvePromise(promise, state, value) {
	        var onceWrapper = once();
	        if (promise === value) {
	            throw new TypeError('Promise resolved with itself');
	        }
	        if (promise[symbolState] === UNRESOLVED) {
	            // should only get value.then once based on promise spec.
	            var then = null;
	            try {
	                if (typeof value === 'object' || typeof value === 'function') {
	                    then = value && value.then;
	                }
	            }
	            catch (err) {
	                onceWrapper(function () {
	                    resolvePromise(promise, false, err);
	                })();
	                return promise;
	            }
	            // if (value instanceof ZoneAwarePromise) {
	            if (state !== REJECTED && value instanceof ZoneAwarePromise &&
	                value.hasOwnProperty(symbolState) && value.hasOwnProperty(symbolValue) &&
	                value[symbolState] !== UNRESOLVED) {
	                clearRejectedNoCatch(value);
	                resolvePromise(promise, value[symbolState], value[symbolValue]);
	            }
	            else if (state !== REJECTED && typeof then === 'function') {
	                try {
	                    then.apply(value, [
	                        onceWrapper(makeResolver(promise, state)), onceWrapper(makeResolver(promise, false))
	                    ]);
	                }
	                catch (err) {
	                    onceWrapper(function () {
	                        resolvePromise(promise, false, err);
	                    })();
	                }
	            }
	            else {
	                promise[symbolState] = state;
	                var queue = promise[symbolValue];
	                promise[symbolValue] = value;
	                // record task information in value when error occurs, so we can
	                // do some additional work such as render longStackTrace
	                if (state === REJECTED && value instanceof Error) {
	                    value[__symbol__('currentTask')] = Zone.currentTask;
	                }
	                for (var i = 0; i < queue.length;) {
	                    scheduleResolveOrReject(promise, queue[i++], queue[i++], queue[i++], queue[i++]);
	                }
	                if (queue.length == 0 && state == REJECTED) {
	                    promise[symbolState] = REJECTED_NO_CATCH;
	                    try {
	                        throw new Error('Uncaught (in promise): ' + value +
	                            (value && value.stack ? '\n' + value.stack : ''));
	                    }
	                    catch (err) {
	                        var error_1 = err;
	                        error_1.rejection = value;
	                        error_1.promise = promise;
	                        error_1.zone = Zone.current;
	                        error_1.task = Zone.currentTask;
	                        _uncaughtPromiseErrors.push(error_1);
	                        api.scheduleMicroTask(); // to make sure that it is running
	                    }
	                }
	            }
	        }
	        // Resolving an already resolved promise is a noop.
	        return promise;
	    }
	    function clearRejectedNoCatch(promise) {
	        if (promise[symbolState] === REJECTED_NO_CATCH) {
	            // if the promise is rejected no catch status
	            // and queue.length > 0, means there is a error handler
	            // here to handle the rejected promise, we should trigger
	            // windows.rejectionhandled eventHandler or nodejs rejectionHandled
	            // eventHandler
	            try {
	                var handler = Zone[__symbol__('rejectionHandledHandler')];
	                if (handler && typeof handler === 'function') {
	                    handler.apply(this, [{ rejection: promise[symbolValue], promise: promise }]);
	                }
	            }
	            catch (err) {
	            }
	            promise[symbolState] = REJECTED;
	            for (var i = 0; i < _uncaughtPromiseErrors.length; i++) {
	                if (promise === _uncaughtPromiseErrors[i].promise) {
	                    _uncaughtPromiseErrors.splice(i, 1);
	                }
	            }
	        }
	    }
	    function scheduleResolveOrReject(promise, zone, chainPromise, onFulfilled, onRejected) {
	        clearRejectedNoCatch(promise);
	        var delegate = promise[symbolState] ?
	            (typeof onFulfilled === 'function') ? onFulfilled : forwardResolution :
	            (typeof onRejected === 'function') ? onRejected : forwardRejection;
	        zone.scheduleMicroTask(source, function () {
	            try {
	                resolvePromise(chainPromise, true, zone.run(delegate, undefined, [promise[symbolValue]]));
	            }
	            catch (error) {
	                resolvePromise(chainPromise, false, error);
	            }
	        });
	    }
	    var ZoneAwarePromise = (function () {
	        function ZoneAwarePromise(executor) {
	            var promise = this;
	            if (!(promise instanceof ZoneAwarePromise)) {
	                throw new Error('Must be an instanceof Promise.');
	            }
	            promise[symbolState] = UNRESOLVED;
	            promise[symbolValue] = []; // queue;
	            try {
	                executor && executor(makeResolver(promise, RESOLVED), makeResolver(promise, REJECTED));
	            }
	            catch (error) {
	                resolvePromise(promise, false, error);
	            }
	        }
	        ZoneAwarePromise.toString = function () {
	            return 'function ZoneAwarePromise() { [native code] }';
	        };
	        ZoneAwarePromise.resolve = function (value) {
	            return resolvePromise(new this(null), RESOLVED, value);
	        };
	        ZoneAwarePromise.reject = function (error) {
	            return resolvePromise(new this(null), REJECTED, error);
	        };
	        ZoneAwarePromise.race = function (values) {
	            var resolve;
	            var reject;
	            var promise = new this(function (res, rej) {
	                _a = [res, rej], resolve = _a[0], reject = _a[1];
	                var _a;
	            });
	            function onResolve(value) {
	                promise && (promise = null || resolve(value));
	            }
	            function onReject(error) {
	                promise && (promise = null || reject(error));
	            }
	            for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
	                var value = values_1[_i];
	                if (!isThenable(value)) {
	                    value = this.resolve(value);
	                }
	                value.then(onResolve, onReject);
	            }
	            return promise;
	        };
	        ZoneAwarePromise.all = function (values) {
	            var resolve;
	            var reject;
	            var promise = new this(function (res, rej) {
	                resolve = res;
	                reject = rej;
	            });
	            var count = 0;
	            var resolvedValues = [];
	            for (var _i = 0, values_2 = values; _i < values_2.length; _i++) {
	                var value = values_2[_i];
	                if (!isThenable(value)) {
	                    value = this.resolve(value);
	                }
	                value.then((function (index) { return function (value) {
	                    resolvedValues[index] = value;
	                    count--;
	                    if (!count) {
	                        resolve(resolvedValues);
	                    }
	                }; })(count), reject);
	                count++;
	            }
	            if (!count)
	                resolve(resolvedValues);
	            return promise;
	        };
	        ZoneAwarePromise.prototype.then = function (onFulfilled, onRejected) {
	            var chainPromise = new this.constructor(null);
	            var zone = Zone.current;
	            if (this[symbolState] == UNRESOLVED) {
	                this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);
	            }
	            else {
	                scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);
	            }
	            return chainPromise;
	        };
	        ZoneAwarePromise.prototype.catch = function (onRejected) {
	            return this.then(null, onRejected);
	        };
	        return ZoneAwarePromise;
	    }());
	    // Protect against aggressive optimizers dropping seemingly unused properties.
	    // E.g. Closure Compiler in advanced mode.
	    ZoneAwarePromise['resolve'] = ZoneAwarePromise.resolve;
	    ZoneAwarePromise['reject'] = ZoneAwarePromise.reject;
	    ZoneAwarePromise['race'] = ZoneAwarePromise.race;
	    ZoneAwarePromise['all'] = ZoneAwarePromise.all;
	    var NativePromise = global[symbolPromise] = global['Promise'];
	    global['Promise'] = ZoneAwarePromise;
	    var symbolThenPatched = __symbol__('thenPatched');
	    function patchThen(Ctor) {
	        var proto = Ctor.prototype;
	        var originalThen = proto.then;
	        // Keep a reference to the original method.
	        proto[symbolThen] = originalThen;
	        // check Ctor.prototype.then propertyDescritor is writable or not
	        // in meteor env, writable is false, we have to make it to be true.
	        var prop = Object.getOwnPropertyDescriptor(Ctor.prototype, 'then');
	        if (prop && prop.writable === false && prop.configurable) {
	            Object.defineProperty(Ctor.prototype, 'then', { writable: true });
	        }
	        Ctor.prototype.then = function (onResolve, onReject) {
	            var _this = this;
	            var wrapped = new ZoneAwarePromise(function (resolve, reject) {
	                originalThen.call(_this, resolve, reject);
	            });
	            return wrapped.then(onResolve, onReject);
	        };
	        Ctor[symbolThenPatched] = true;
	    }
	    function zoneify(fn) {
	        return function () {
	            var resultPromise = fn.apply(this, arguments);
	            if (resultPromise instanceof ZoneAwarePromise) {
	                return resultPromise;
	            }
	            var ctor = resultPromise.constructor;
	            if (!ctor[symbolThenPatched]) {
	                patchThen(ctor);
	            }
	            return resultPromise;
	        };
	    }
	    if (NativePromise) {
	        patchThen(NativePromise);
	        var fetch_1 = global['fetch'];
	        if (typeof fetch_1 == 'function') {
	            global['fetch'] = zoneify(fetch_1);
	        }
	    }
	    // This is not part of public API, but it is useful for tests, so we expose it.
	    Promise[Zone.__symbol__('uncaughtPromiseErrors')] = _uncaughtPromiseErrors;
	    return ZoneAwarePromise;
	});
	
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Suppress closure compiler errors about unknown 'Zone' variable
	 * @fileoverview
	 * @suppress {undefinedVars,globalThis}
	 */
	var zoneSymbol = Zone.__symbol__;
	var _global = typeof window === 'object' && window || typeof self === 'object' && self || global;
	function bindArguments(args, source) {
	    for (var i = args.length - 1; i >= 0; i--) {
	        if (typeof args[i] === 'function') {
	            args[i] = Zone.current.wrap(args[i], source + '_' + i);
	        }
	    }
	    return args;
	}
	function patchPrototype(prototype, fnNames) {
	    var source = prototype.constructor['name'];
	    var _loop_1 = function (i) {
	        var name_1 = fnNames[i];
	        var delegate = prototype[name_1];
	        if (delegate) {
	            prototype[name_1] = (function (delegate) {
	                var patched = function () {
	                    return delegate.apply(this, bindArguments(arguments, source + '.' + name_1));
	                };
	                attachOriginToPatched(patched, delegate);
	                return patched;
	            })(delegate);
	        }
	    };
	    for (var i = 0; i < fnNames.length; i++) {
	        _loop_1(i);
	    }
	}
	var isWebWorker = (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope);
	// Make sure to access `process` through `_global` so that WebPack does not accidently browserify
	// this code.
	var isNode = (!('nw' in _global) && typeof _global.process !== 'undefined' &&
	    {}.toString.call(_global.process) === '[object process]');
	var isBrowser = !isNode && !isWebWorker && !!(typeof window !== 'undefined' && window['HTMLElement']);
	// we are in electron of nw, so we are both browser and nodejs
	// Make sure to access `process` through `_global` so that WebPack does not accidently browserify
	// this code.
	var isMix = typeof _global.process !== 'undefined' &&
	    {}.toString.call(_global.process) === '[object process]' && !isWebWorker &&
	    !!(typeof window !== 'undefined' && window['HTMLElement']);
	function patchProperty(obj, prop, prototype) {
	    var desc = Object.getOwnPropertyDescriptor(obj, prop);
	    if (!desc && prototype) {
	        // when patch window object, use prototype to check prop exist or not
	        var prototypeDesc = Object.getOwnPropertyDescriptor(prototype, prop);
	        if (prototypeDesc) {
	            desc = { enumerable: true, configurable: true };
	        }
	    }
	    // if the descriptor not exists or is not configurable
	    // just return
	    if (!desc || !desc.configurable) {
	        return;
	    }
	    // A property descriptor cannot have getter/setter and be writable
	    // deleting the writable and value properties avoids this error:
	    //
	    // TypeError: property descriptors must not specify a value or be writable when a
	    // getter or setter has been specified
	    delete desc.writable;
	    delete desc.value;
	    var originalDescGet = desc.get;
	    // substr(2) cuz 'onclick' -> 'click', etc
	    var eventName = prop.substr(2);
	    var _prop = zoneSymbol('_' + prop);
	    desc.set = function (newValue) {
	        // in some of windows's onproperty callback, this is undefined
	        // so we need to check it
	        var target = this;
	        if (!target && obj === _global) {
	            target = _global;
	        }
	        if (!target) {
	            return;
	        }
	        var previousValue = target[_prop];
	        if (previousValue) {
	            target.removeEventListener(eventName, previousValue);
	        }
	        if (typeof newValue === 'function') {
	            var wrapFn = function (event) {
	                var result = newValue.apply(this, arguments);
	                if (result != undefined && !result) {
	                    event.preventDefault();
	                }
	                return result;
	            };
	            target[_prop] = wrapFn;
	            target.addEventListener(eventName, wrapFn, false);
	        }
	        else {
	            target[_prop] = null;
	        }
	    };
	    // The getter would return undefined for unassigned properties but the default value of an
	    // unassigned property is null
	    desc.get = function () {
	        // in some of windows's onproperty callback, this is undefined
	        // so we need to check it
	        var target = this;
	        if (!target && obj === _global) {
	            target = _global;
	        }
	        if (!target) {
	            return null;
	        }
	        if (target.hasOwnProperty(_prop)) {
	            return target[_prop];
	        }
	        else if (originalDescGet) {
	            // result will be null when use inline event attribute,
	            // such as <button onclick="func();">OK</button>
	            // because the onclick function is internal raw uncompiled handler
	            // the onclick will be evaluated when first time event was triggered or
	            // the property is accessed, https://github.com/angular/zone.js/issues/525
	            // so we should use original native get to retrieve the handler
	            var value = originalDescGet && originalDescGet.apply(this);
	            if (value) {
	                desc.set.apply(this, [value]);
	                if (typeof target['removeAttribute'] === 'function') {
	                    target.removeAttribute(prop);
	                }
	                return value;
	            }
	        }
	        return null;
	    };
	    Object.defineProperty(obj, prop, desc);
	}
	function patchOnProperties(obj, properties, prototype) {
	    if (properties) {
	        for (var i = 0; i < properties.length; i++) {
	            patchProperty(obj, 'on' + properties[i], prototype);
	        }
	    }
	    else {
	        var onProperties = [];
	        for (var prop in obj) {
	            if (prop.substr(0, 2) == 'on') {
	                onProperties.push(prop);
	            }
	        }
	        for (var j = 0; j < onProperties.length; j++) {
	            patchProperty(obj, onProperties[j], prototype);
	        }
	    }
	}
	var originalInstanceKey = zoneSymbol('originalInstance');
	// wrap some native API on `window`
	function patchClass(className) {
	    var OriginalClass = _global[className];
	    if (!OriginalClass)
	        return;
	    // keep original class in global
	    _global[zoneSymbol(className)] = OriginalClass;
	    _global[className] = function () {
	        var a = bindArguments(arguments, className);
	        switch (a.length) {
	            case 0:
	                this[originalInstanceKey] = new OriginalClass();
	                break;
	            case 1:
	                this[originalInstanceKey] = new OriginalClass(a[0]);
	                break;
	            case 2:
	                this[originalInstanceKey] = new OriginalClass(a[0], a[1]);
	                break;
	            case 3:
	                this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2]);
	                break;
	            case 4:
	                this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2], a[3]);
	                break;
	            default:
	                throw new Error('Arg list too long.');
	        }
	    };
	    // attach original delegate to patched function
	    attachOriginToPatched(_global[className], OriginalClass);
	    var instance = new OriginalClass(function () { });
	    var prop;
	    for (prop in instance) {
	        // https://bugs.webkit.org/show_bug.cgi?id=44721
	        if (className === 'XMLHttpRequest' && prop === 'responseBlob')
	            continue;
	        (function (prop) {
	            if (typeof instance[prop] === 'function') {
	                _global[className].prototype[prop] = function () {
	                    return this[originalInstanceKey][prop].apply(this[originalInstanceKey], arguments);
	                };
	            }
	            else {
	                Object.defineProperty(_global[className].prototype, prop, {
	                    set: function (fn) {
	                        if (typeof fn === 'function') {
	                            this[originalInstanceKey][prop] = Zone.current.wrap(fn, className + '.' + prop);
	                            // keep callback in wrapped function so we can
	                            // use it in Function.prototype.toString to return
	                            // the native one.
	                            attachOriginToPatched(this[originalInstanceKey][prop], fn);
	                        }
	                        else {
	                            this[originalInstanceKey][prop] = fn;
	                        }
	                    },
	                    get: function () {
	                        return this[originalInstanceKey][prop];
	                    }
	                });
	            }
	        }(prop));
	    }
	    for (prop in OriginalClass) {
	        if (prop !== 'prototype' && OriginalClass.hasOwnProperty(prop)) {
	            _global[className][prop] = OriginalClass[prop];
	        }
	    }
	}
	function patchMethod(target, name, patchFn) {
	    var proto = target;
	    while (proto && !proto.hasOwnProperty(name)) {
	        proto = Object.getPrototypeOf(proto);
	    }
	    if (!proto && target[name]) {
	        // somehow we did not find it, but we can see it. This happens on IE for Window properties.
	        proto = target;
	    }
	    var delegateName = zoneSymbol(name);
	    var delegate;
	    if (proto && !(delegate = proto[delegateName])) {
	        delegate = proto[delegateName] = proto[name];
	        var patchDelegate_1 = patchFn(delegate, delegateName, name);
	        proto[name] = function () {
	            return patchDelegate_1(this, arguments);
	        };
	        attachOriginToPatched(proto[name], delegate);
	    }
	    return delegate;
	}
	// TODO: @JiaLiPassion, support cancel task later if necessary
	function patchMacroTask(obj, funcName, metaCreator) {
	    var setNative = null;
	    function scheduleTask(task) {
	        var data = task.data;
	        data.args[data.callbackIndex] = function () {
	            task.invoke.apply(this, arguments);
	        };
	        setNative.apply(data.target, data.args);
	        return task;
	    }
	    setNative = patchMethod(obj, funcName, function (delegate) { return function (self, args) {
	        var meta = metaCreator(self, args);
	        if (meta.callbackIndex >= 0 && typeof args[meta.callbackIndex] === 'function') {
	            var task = Zone.current.scheduleMacroTask(meta.name, args[meta.callbackIndex], meta, scheduleTask, null);
	            return task;
	        }
	        else {
	            // cause an error by calling it directly.
	            return delegate.apply(self, args);
	        }
	    }; });
	}
	
	function attachOriginToPatched(patched, original) {
	    patched[zoneSymbol('OriginalDelegate')] = original;
	}
	var isDetectedIEOrEdge = false;
	var ieOrEdge = false;
	function isIEOrEdge() {
	    if (isDetectedIEOrEdge) {
	        return ieOrEdge;
	    }
	    isDetectedIEOrEdge = true;
	    try {
	        var ua = window.navigator.userAgent;
	        var msie = ua.indexOf('MSIE ');
	        if (ua.indexOf('MSIE ') !== -1 || ua.indexOf('Trident/') !== -1 || ua.indexOf('Edge/') !== -1) {
	            ieOrEdge = true;
	        }
	        return ieOrEdge;
	    }
	    catch (error) {
	    }
	}
	
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	// override Function.prototype.toString to make zone.js patched function
	// look like native function
	Zone.__load_patch('toString', function (global, Zone, api) {
	    // patch Func.prototype.toString to let them look like native
	    var originalFunctionToString = Zone['__zone_symbol__originalToString'] =
	        Function.prototype.toString;
	    Function.prototype.toString = function () {
	        if (typeof this === 'function') {
	            var originalDelegate = this[zoneSymbol('OriginalDelegate')];
	            if (originalDelegate) {
	                if (typeof originalDelegate === 'function') {
	                    return originalFunctionToString.apply(this[zoneSymbol('OriginalDelegate')], arguments);
	                }
	                else {
	                    return Object.prototype.toString.call(originalDelegate);
	                }
	            }
	            if (this === Promise) {
	                var nativePromise = global[zoneSymbol('Promise')];
	                if (nativePromise) {
	                    return originalFunctionToString.apply(nativePromise, arguments);
	                }
	            }
	            if (this === Error) {
	                var nativeError = global[zoneSymbol('Error')];
	                if (nativeError) {
	                    return originalFunctionToString.apply(nativeError, arguments);
	                }
	            }
	        }
	        return originalFunctionToString.apply(this, arguments);
	    };
	    // patch Object.prototype.toString to let them look like native
	    var originalObjectToString = Object.prototype.toString;
	    Object.prototype.toString = function () {
	        if (this instanceof Promise) {
	            return '[object Promise]';
	        }
	        return originalObjectToString.apply(this, arguments);
	    };
	});
	
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var TRUE_STR = 'true';
	var FALSE_STR = 'false';
	// an identifier to tell ZoneTask do not create a new invoke closure
	var OPTIMIZED_ZONE_EVENT_TASK_DATA = {
	    isUsingGlobalCallback: true
	};
	var zoneSymbolEventNames = {};
	var globalSources = {};
	var CONSTRUCTOR_NAME = 'name';
	var FUNCTION_TYPE = 'function';
	var OBJECT_TYPE = 'object';
	var ZONE_SYMBOL_PREFIX = '__zone_symbol__';
	var EVENT_NAME_SYMBOL_REGX = /^__zone_symbol__(\w+)(true|false)$/;
	function patchEventTarget(_global, apis, patchOptions) {
	    var ADD_EVENT_LISTENER = (patchOptions && patchOptions.addEventListenerFnName) || 'addEventListener';
	    var REMOVE_EVENT_LISTENER = (patchOptions && patchOptions.removeEventListenerFnName) || 'removeEventListener';
	    var LISTENERS_EVENT_LISTENER = (patchOptions && patchOptions.listenersFnName) || 'eventListeners';
	    var REMOVE_ALL_LISTENERS_EVENT_LISTENER = (patchOptions && patchOptions.removeAllFnName) || 'removeAllListeners';
	    var zoneSymbolAddEventListener = zoneSymbol(ADD_EVENT_LISTENER);
	    var ADD_EVENT_LISTENER_SOURCE = '.' + ADD_EVENT_LISTENER + ':';
	    var PREPEND_EVENT_LISTENER = 'prependListener';
	    var PREPEND_EVENT_LISTENER_SOURCE = '.' + PREPEND_EVENT_LISTENER + ':';
	    var invokeTask = function (task, target, event) {
	        // for better performance, check isRemoved which is set
	        // by removeEventListener
	        if (task.isRemoved) {
	            return;
	        }
	        var delegate = task.callback;
	        if (typeof delegate === OBJECT_TYPE && delegate.handleEvent) {
	            // create the bind version of handleEvent when invoke
	            task.callback = function (event) { return delegate.handleEvent(event); };
	            task.originalDelegate = delegate;
	        }
	        // invoke static task.invoke
	        task.invoke(task, target, [event]);
	        var options = task.options;
	        if (options && typeof options === 'object' && options.once) {
	            // if options.once is true, after invoke once remove listener here
	            // only browser need to do this, nodejs eventEmitter will cal removeListener
	            // inside EventEmitter.once
	            var delegate_1 = task.originalDelegate ? task.originalDelegate : task.callback;
	            target[REMOVE_EVENT_LISTENER].apply(target, [event.type, delegate_1, options]);
	        }
	    };
	    // global shared zoneAwareCallback to handle all event callback with capture = false
	    var globalZoneAwareCallback = function (event) {
	        var target = this || _global;
	        var tasks = target[zoneSymbolEventNames[event.type][FALSE_STR]];
	        if (tasks) {
	            // invoke all tasks which attached to current target with given event.type and capture = false
	            // for performance concern, if task.length === 1, just invoke
	            if (tasks.length === 1) {
	                invokeTask(tasks[0], target, event);
	            }
	            else {
	                // https://github.com/angular/zone.js/issues/836
	                // copy the tasks array before invoke, to avoid
	                // the callback will remove itself or other listener
	                var copyTasks = tasks.slice();
	                for (var i = 0; i < copyTasks.length; i++) {
	                    invokeTask(copyTasks[i], target, event);
	                }
	            }
	        }
	    };
	    // global shared zoneAwareCallback to handle all event callback with capture = true
	    var globalZoneAwareCaptureCallback = function (event) {
	        var target = this || _global;
	        var tasks = target[zoneSymbolEventNames[event.type][TRUE_STR]];
	        if (tasks) {
	            // invoke all tasks which attached to current target with given event.type and capture = false
	            // for performance concern, if task.length === 1, just invoke
	            if (tasks.length === 1) {
	                invokeTask(tasks[0], target, event);
	            }
	            else {
	                // https://github.com/angular/zone.js/issues/836
	                // copy the tasks array before invoke, to avoid
	                // the callback will remove itself or other listener
	                var copyTasks = tasks.slice();
	                for (var i = 0; i < copyTasks.length; i++) {
	                    invokeTask(copyTasks[i], target, event);
	                }
	            }
	        }
	    };
	    function patchEventTargetMethods(obj, patchOptions) {
	        if (!obj) {
	            return false;
	        }
	        var useGlobalCallback = true;
	        if (patchOptions && patchOptions.useGlobalCallback !== undefined) {
	            useGlobalCallback = patchOptions.useGlobalCallback;
	        }
	        var validateHandler = patchOptions && patchOptions.validateHandler;
	        var checkDuplicate = true;
	        if (patchOptions && patchOptions.checkDuplicate !== undefined) {
	            checkDuplicate = patchOptions.checkDuplicate;
	        }
	        var returnTarget = false;
	        if (patchOptions && patchOptions.returnTarget !== undefined) {
	            returnTarget = patchOptions.returnTarget;
	        }
	        var proto = obj;
	        while (proto && !proto.hasOwnProperty(ADD_EVENT_LISTENER)) {
	            proto = Object.getPrototypeOf(proto);
	        }
	        if (!proto && obj[ADD_EVENT_LISTENER]) {
	            // somehow we did not find it, but we can see it. This happens on IE for Window properties.
	            proto = obj;
	        }
	        if (!proto) {
	            return false;
	        }
	        if (proto[zoneSymbolAddEventListener]) {
	            return false;
	        }
	        // a shared global taskData to pass data for scheduleEventTask
	        // so we do not need to create a new object just for pass some data
	        var taskData = {};
	        var nativeAddEventListener = proto[zoneSymbolAddEventListener] = proto[ADD_EVENT_LISTENER];
	        var nativeRemoveEventListener = proto[zoneSymbol(REMOVE_EVENT_LISTENER)] =
	            proto[REMOVE_EVENT_LISTENER];
	        var nativeListeners = proto[zoneSymbol(LISTENERS_EVENT_LISTENER)] =
	            proto[LISTENERS_EVENT_LISTENER];
	        var nativeRemoveAllListeners = proto[zoneSymbol(REMOVE_ALL_LISTENERS_EVENT_LISTENER)] =
	            proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER];
	        var nativePrependEventListener;
	        if (patchOptions && patchOptions.prependEventListenerFnName) {
	            nativePrependEventListener = proto[zoneSymbol(patchOptions.prependEventListenerFnName)] =
	                proto[patchOptions.prependEventListenerFnName];
	        }
	        var customScheduleGlobal = function (task) {
	            // if there is already a task for the eventName + capture,
	            // just return, because we use the shared globalZoneAwareCallback here.
	            if (taskData.isExisting) {
	                return;
	            }
	            return nativeAddEventListener.apply(taskData.target, [
	                taskData.eventName,
	                taskData.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback,
	                taskData.options
	            ]);
	        };
	        var customCancelGlobal = function (task) {
	            // if task is not marked as isRemoved, this call is directly
	            // from Zone.prototype.cancelTask, we should remove the task
	            // from tasksList of target first
	            if (!task.isRemoved) {
	                var symbolEventNames = zoneSymbolEventNames[task.eventName];
	                var symbolEventName = void 0;
	                if (symbolEventNames) {
	                    symbolEventName = symbolEventNames[task.capture ? TRUE_STR : FALSE_STR];
	                }
	                var existingTasks = symbolEventName && task.target[symbolEventName];
	                if (existingTasks) {
	                    for (var i = 0; i < existingTasks.length; i++) {
	                        var existingTask = existingTasks[i];
	                        if (existingTask === task) {
	                            existingTasks.splice(i, 1);
	                            // set isRemoved to data for faster invokeTask check
	                            task.isRemoved = true;
	                            if (existingTasks.length === 0) {
	                                // all tasks for the eventName + capture have gone,
	                                // remove globalZoneAwareCallback and remove the task cache from target
	                                task.allRemoved = true;
	                                task.target[symbolEventName] = null;
	                            }
	                            break;
	                        }
	                    }
	                }
	            }
	            // if all tasks for the eventName + capture have gone,
	            // we will really remove the global event callback,
	            // if not, return
	            if (!task.allRemoved) {
	                return;
	            }
	            return nativeRemoveEventListener.apply(task.target, [
	                task.eventName, task.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback,
	                task.options
	            ]);
	        };
	        var customScheduleNonGlobal = function (task) {
	            return nativeAddEventListener.apply(taskData.target, [taskData.eventName, task.invoke, taskData.options]);
	        };
	        var customSchedulePrepend = function (task) {
	            return nativePrependEventListener.apply(taskData.target, [taskData.eventName, task.invoke, taskData.options]);
	        };
	        var customCancelNonGlobal = function (task) {
	            return nativeRemoveEventListener.apply(task.target, [task.eventName, task.invoke, task.options]);
	        };
	        var customSchedule = useGlobalCallback ? customScheduleGlobal : customScheduleNonGlobal;
	        var customCancel = useGlobalCallback ? customCancelGlobal : customCancelNonGlobal;
	        var compareTaskCallbackVsDelegate = function (task, delegate) {
	            var typeOfDelegate = typeof delegate;
	            if ((typeOfDelegate === FUNCTION_TYPE && task.callback === delegate) ||
	                (typeOfDelegate === OBJECT_TYPE && task.originalDelegate === delegate)) {
	                // same callback, same capture, same event name, just return
	                return true;
	            }
	            return false;
	        };
	        var compare = (patchOptions && patchOptions.compareTaskCallbackVsDelegate) ?
	            patchOptions.compareTaskCallbackVsDelegate :
	            compareTaskCallbackVsDelegate;
	        var makeAddListener = function (nativeListener, addSource, customScheduleFn, customCancelFn, returnTarget, prepend) {
	            if (returnTarget === void 0) { returnTarget = false; }
	            if (prepend === void 0) { prepend = false; }
	            return function () {
	                var target = this || _global;
	                var targetZone = Zone.current;
	                var delegate = arguments[1];
	                if (!delegate) {
	                    return nativeListener.apply(this, arguments);
	                }
	                // don't create the bind delegate function for handleEvent
	                // case here to improve addEventListener performance
	                // we will create the bind delegate when invoke
	                var isHandleEvent = false;
	                if (typeof delegate !== FUNCTION_TYPE) {
	                    if (!delegate.handleEvent) {
	                        return nativeListener.apply(this, arguments);
	                    }
	                    isHandleEvent = true;
	                }
	                if (validateHandler && !validateHandler(nativeListener, delegate, target, arguments)) {
	                    return;
	                }
	                var eventName = arguments[0];
	                var options = arguments[2];
	                var capture;
	                var once = false;
	                if (options === undefined) {
	                    capture = false;
	                }
	                else if (options === true) {
	                    capture = true;
	                }
	                else if (options === false) {
	                    capture = false;
	                }
	                else {
	                    capture = options ? !!options.capture : false;
	                    once = options ? !!options.once : false;
	                }
	                var zone = Zone.current;
	                var symbolEventNames = zoneSymbolEventNames[eventName];
	                var symbolEventName;
	                if (!symbolEventNames) {
	                    // the code is duplicate, but I just want to get some better performance
	                    var falseEventName = eventName + FALSE_STR;
	                    var trueEventName = eventName + TRUE_STR;
	                    var symbol = ZONE_SYMBOL_PREFIX + falseEventName;
	                    var symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;
	                    zoneSymbolEventNames[eventName] = {};
	                    zoneSymbolEventNames[eventName][FALSE_STR] = symbol;
	                    zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;
	                    symbolEventName = capture ? symbolCapture : symbol;
	                }
	                else {
	                    symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];
	                }
	                var existingTasks = target[symbolEventName];
	                var isExisting = false;
	                if (existingTasks) {
	                    // already have task registered
	                    isExisting = true;
	                    if (checkDuplicate) {
	                        for (var i = 0; i < existingTasks.length; i++) {
	                            if (compare(existingTasks[i], delegate)) {
	                                // same callback, same capture, same event name, just return
	                                return;
	                            }
	                        }
	                    }
	                }
	                else {
	                    existingTasks = target[symbolEventName] = [];
	                }
	                var source;
	                var constructorName = target.constructor[CONSTRUCTOR_NAME];
	                var targetSource = globalSources[constructorName];
	                if (targetSource) {
	                    source = targetSource[eventName];
	                }
	                if (!source) {
	                    source = constructorName + addSource + eventName;
	                }
	                // do not create a new object as task.data to pass those things
	                // just use the global shared one
	                taskData.options = options;
	                if (once) {
	                    // if addEventListener with once options, we don't pass it to
	                    // native addEventListener, instead we keep the once setting
	                    // and handle ourselves.
	                    taskData.options.once = false;
	                }
	                taskData.target = target;
	                taskData.capture = capture;
	                taskData.eventName = eventName;
	                taskData.isExisting = isExisting;
	                var data = useGlobalCallback ? OPTIMIZED_ZONE_EVENT_TASK_DATA : null;
	                var task = zone.scheduleEventTask(source, delegate, data, customScheduleFn, customCancelFn);
	                // have to save those information to task in case
	                // application may call task.zone.cancelTask() directly
	                if (once) {
	                    options.once = true;
	                }
	                task.options = options;
	                task.target = target;
	                task.capture = capture;
	                task.eventName = eventName;
	                if (isHandleEvent) {
	                    // save original delegate for compare to check duplicate
	                    task.originalDelegate = delegate;
	                }
	                if (!prepend) {
	                    existingTasks.push(task);
	                }
	                else {
	                    existingTasks.unshift(task);
	                }
	                if (returnTarget) {
	                    return target;
	                }
	            };
	        };
	        proto[ADD_EVENT_LISTENER] = makeAddListener(nativeAddEventListener, ADD_EVENT_LISTENER_SOURCE, customSchedule, customCancel, returnTarget);
	        if (nativePrependEventListener) {
	            proto[PREPEND_EVENT_LISTENER] = makeAddListener(nativePrependEventListener, PREPEND_EVENT_LISTENER_SOURCE, customSchedulePrepend, customCancel, returnTarget, true);
	        }
	        proto[REMOVE_EVENT_LISTENER] = function () {
	            var target = this || _global;
	            var eventName = arguments[0];
	            var options = arguments[2];
	            var capture;
	            if (options === undefined) {
	                capture = false;
	            }
	            else if (options === true) {
	                capture = true;
	            }
	            else if (options === false) {
	                capture = false;
	            }
	            else {
	                capture = options ? !!options.capture : false;
	            }
	            var delegate = arguments[1];
	            if (!delegate) {
	                return nativeRemoveEventListener.apply(this, arguments);
	            }
	            if (validateHandler &&
	                !validateHandler(nativeRemoveEventListener, delegate, target, arguments)) {
	                return;
	            }
	            var symbolEventNames = zoneSymbolEventNames[eventName];
	            var symbolEventName;
	            if (symbolEventNames) {
	                symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];
	            }
	            var existingTasks = symbolEventName && target[symbolEventName];
	            if (existingTasks) {
	                for (var i = 0; i < existingTasks.length; i++) {
	                    var existingTask = existingTasks[i];
	                    var typeOfDelegate = typeof delegate;
	                    if (compare(existingTask, delegate)) {
	                        existingTasks.splice(i, 1);
	                        // set isRemoved to data for faster invokeTask check
	                        existingTask.isRemoved = true;
	                        if (existingTasks.length === 0) {
	                            // all tasks for the eventName + capture have gone,
	                            // remove globalZoneAwareCallback and remove the task cache from target
	                            existingTask.allRemoved = true;
	                            target[symbolEventName] = null;
	                        }
	                        existingTask.zone.cancelTask(existingTask);
	                        return;
	                    }
	                }
	            }
	        };
	        proto[LISTENERS_EVENT_LISTENER] = function () {
	            var target = this || _global;
	            var eventName = arguments[0];
	            var listeners = [];
	            var tasks = findEventTasks(target, eventName);
	            for (var i = 0; i < tasks.length; i++) {
	                var task = tasks[i];
	                var delegate = task.originalDelegate ? task.originalDelegate : task.callback;
	                listeners.push(delegate);
	            }
	            return listeners;
	        };
	        proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER] = function () {
	            var target = this || _global;
	            var eventName = arguments[0];
	            if (!eventName) {
	                var keys = Object.keys(target);
	                for (var i = 0; i < keys.length; i++) {
	                    var prop = keys[i];
	                    var match = EVENT_NAME_SYMBOL_REGX.exec(prop);
	                    var evtName = match && match[1];
	                    // in nodejs EventEmitter, removeListener event is
	                    // used for monitoring the removeListener call,
	                    // so just keep removeListener eventListener until
	                    // all other eventListeners are removed
	                    if (evtName && evtName !== 'removeListener') {
	                        this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].apply(this, [evtName]);
	                    }
	                }
	                // remove removeListener listener finally
	                this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].apply(this, ['removeListener']);
	            }
	            else {
	                var symbolEventNames = zoneSymbolEventNames[eventName];
	                if (symbolEventNames) {
	                    var symbolEventName = symbolEventNames[FALSE_STR];
	                    var symbolCaptureEventName = symbolEventNames[TRUE_STR];
	                    var tasks = target[symbolEventName];
	                    var captureTasks = target[symbolCaptureEventName];
	                    if (tasks) {
	                        var removeTasks = tasks.slice();
	                        for (var i = 0; i < removeTasks.length; i++) {
	                            var task = removeTasks[i];
	                            var delegate = task.originalDelegate ? task.originalDelegate : task.callback;
	                            this[REMOVE_EVENT_LISTENER].apply(this, [eventName, delegate, task.options]);
	                        }
	                    }
	                    if (captureTasks) {
	                        var removeTasks = captureTasks.slice();
	                        for (var i = 0; i < removeTasks.length; i++) {
	                            var task = removeTasks[i];
	                            var delegate = task.originalDelegate ? task.originalDelegate : task.callback;
	                            this[REMOVE_EVENT_LISTENER].apply(this, [eventName, delegate, task.options]);
	                        }
	                    }
	                }
	            }
	        };
	        // for native toString patch
	        attachOriginToPatched(proto[ADD_EVENT_LISTENER], nativeAddEventListener);
	        attachOriginToPatched(proto[REMOVE_EVENT_LISTENER], nativeRemoveEventListener);
	        if (nativeRemoveAllListeners) {
	            attachOriginToPatched(proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER], nativeRemoveAllListeners);
	        }
	        if (nativeListeners) {
	            attachOriginToPatched(proto[LISTENERS_EVENT_LISTENER], nativeListeners);
	        }
	        return true;
	    }
	    var results = [];
	    for (var i = 0; i < apis.length; i++) {
	        results[i] = patchEventTargetMethods(apis[i], patchOptions);
	    }
	    return results;
	}
	function findEventTasks(target, eventName) {
	    var foundTasks = [];
	    for (var prop in target) {
	        var match = EVENT_NAME_SYMBOL_REGX.exec(prop);
	        var evtName = match && match[1];
	        if (evtName && (!eventName || evtName === eventName)) {
	            var tasks = target[prop];
	            if (tasks) {
	                for (var i = 0; i < tasks.length; i++) {
	                    foundTasks.push(tasks[i]);
	                }
	            }
	        }
	    }
	    return foundTasks;
	}
	
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	function patchTimer(window, setName, cancelName, nameSuffix) {
	    var setNative = null;
	    var clearNative = null;
	    setName += nameSuffix;
	    cancelName += nameSuffix;
	    var tasksByHandleId = {};
	    function scheduleTask(task) {
	        var data = task.data;
	        function timer() {
	            try {
	                task.invoke.apply(this, arguments);
	            }
	            finally {
	                if (typeof data.handleId === 'number') {
	                    // Node returns complex objects as handleIds
	                    delete tasksByHandleId[data.handleId];
	                }
	            }
	        }
	        data.args[0] = timer;
	        data.handleId = setNative.apply(window, data.args);
	        if (typeof data.handleId === 'number') {
	            // Node returns complex objects as handleIds -> no need to keep them around. Additionally,
	            // this throws an
	            // exception in older node versions and has no effect there, because of the stringified key.
	            tasksByHandleId[data.handleId] = task;
	        }
	        return task;
	    }
	    function clearTask(task) {
	        if (typeof task.data.handleId === 'number') {
	            // Node returns complex objects as handleIds
	            delete tasksByHandleId[task.data.handleId];
	        }
	        return clearNative(task.data.handleId);
	    }
	    setNative =
	        patchMethod(window, setName, function (delegate) { return function (self, args) {
	            if (typeof args[0] === 'function') {
	                var zone = Zone.current;
	                var options = {
	                    handleId: null,
	                    isPeriodic: nameSuffix === 'Interval',
	                    delay: (nameSuffix === 'Timeout' || nameSuffix === 'Interval') ? args[1] || 0 : null,
	                    args: args
	                };
	                var task = zone.scheduleMacroTask(setName, args[0], options, scheduleTask, clearTask);
	                if (!task) {
	                    return task;
	                }
	                // Node.js must additionally support the ref and unref functions.
	                var handle = task.data.handleId;
	                // check whether handle is null, because some polyfill or browser
	                // may return undefined from setTimeout/setInterval/setImmediate/requestAnimationFrame
	                if (handle && handle.ref && handle.unref && typeof handle.ref === 'function' &&
	                    typeof handle.unref === 'function') {
	                    task.ref = handle.ref.bind(handle);
	                    task.unref = handle.unref.bind(handle);
	                }
	                return task;
	            }
	            else {
	                // cause an error by calling it directly.
	                return delegate.apply(window, args);
	            }
	        }; });
	    clearNative =
	        patchMethod(window, cancelName, function (delegate) { return function (self, args) {
	            var task = typeof args[0] === 'number' ? tasksByHandleId[args[0]] : args[0];
	            if (task && typeof task.type === 'string') {
	                if (task.state !== 'notScheduled' &&
	                    (task.cancelFn && task.data.isPeriodic || task.runCount === 0)) {
	                    // Do not cancel already canceled functions
	                    task.zone.cancelTask(task);
	                }
	            }
	            else {
	                // cause an error by calling it directly.
	                delegate.apply(window, args);
	            }
	        }; });
	}
	
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/*
	 * This is necessary for Chrome and Chrome mobile, to enable
	 * things like redefining `createdCallback` on an element.
	 */
	var _defineProperty = Object[zoneSymbol('defineProperty')] = Object.defineProperty;
	var _getOwnPropertyDescriptor = Object[zoneSymbol('getOwnPropertyDescriptor')] =
	    Object.getOwnPropertyDescriptor;
	var _create = Object.create;
	var unconfigurablesKey = zoneSymbol('unconfigurables');
	function propertyPatch() {
	    Object.defineProperty = function (obj, prop, desc) {
	        if (isUnconfigurable(obj, prop)) {
	            throw new TypeError('Cannot assign to read only property \'' + prop + '\' of ' + obj);
	        }
	        var originalConfigurableFlag = desc.configurable;
	        if (prop !== 'prototype') {
	            desc = rewriteDescriptor(obj, prop, desc);
	        }
	        return _tryDefineProperty(obj, prop, desc, originalConfigurableFlag);
	    };
	    Object.defineProperties = function (obj, props) {
	        Object.keys(props).forEach(function (prop) {
	            Object.defineProperty(obj, prop, props[prop]);
	        });
	        return obj;
	    };
	    Object.create = function (obj, proto) {
	        if (typeof proto === 'object' && !Object.isFrozen(proto)) {
	            Object.keys(proto).forEach(function (prop) {
	                proto[prop] = rewriteDescriptor(obj, prop, proto[prop]);
	            });
	        }
	        return _create(obj, proto);
	    };
	    Object.getOwnPropertyDescriptor = function (obj, prop) {
	        var desc = _getOwnPropertyDescriptor(obj, prop);
	        if (isUnconfigurable(obj, prop)) {
	            desc.configurable = false;
	        }
	        return desc;
	    };
	}
	function _redefineProperty(obj, prop, desc) {
	    var originalConfigurableFlag = desc.configurable;
	    desc = rewriteDescriptor(obj, prop, desc);
	    return _tryDefineProperty(obj, prop, desc, originalConfigurableFlag);
	}
	function isUnconfigurable(obj, prop) {
	    return obj && obj[unconfigurablesKey] && obj[unconfigurablesKey][prop];
	}
	function rewriteDescriptor(obj, prop, desc) {
	    desc.configurable = true;
	    if (!desc.configurable) {
	        if (!obj[unconfigurablesKey]) {
	            _defineProperty(obj, unconfigurablesKey, { writable: true, value: {} });
	        }
	        obj[unconfigurablesKey][prop] = true;
	    }
	    return desc;
	}
	function _tryDefineProperty(obj, prop, desc, originalConfigurableFlag) {
	    try {
	        return _defineProperty(obj, prop, desc);
	    }
	    catch (error) {
	        if (desc.configurable) {
	            // In case of errors, when the configurable flag was likely set by rewriteDescriptor(), let's
	            // retry with the original flag value
	            if (typeof originalConfigurableFlag == 'undefined') {
	                delete desc.configurable;
	            }
	            else {
	                desc.configurable = originalConfigurableFlag;
	            }
	            try {
	                return _defineProperty(obj, prop, desc);
	            }
	            catch (error) {
	                var descJson = null;
	                try {
	                    descJson = JSON.stringify(desc);
	                }
	                catch (error) {
	                    descJson = descJson.toString();
	                }
	                console.log("Attempting to configure '" + prop + "' with descriptor '" + descJson + "' on object '" + obj + "' and got error, giving up: " + error);
	            }
	        }
	        else {
	            throw error;
	        }
	    }
	}
	
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	// we have to patch the instance since the proto is non-configurable
	function apply(api, _global) {
	    var WS = _global.WebSocket;
	    // On Safari window.EventTarget doesn't exist so need to patch WS add/removeEventListener
	    // On older Chrome, no need since EventTarget was already patched
	    if (!_global.EventTarget) {
	        patchEventTarget(api, _global, [WS.prototype]);
	    }
	    _global.WebSocket = function (a, b) {
	        var socket = arguments.length > 1 ? new WS(a, b) : new WS(a);
	        var proxySocket;
	        var proxySocketProto;
	        // Safari 7.0 has non-configurable own 'onmessage' and friends properties on the socket instance
	        var onmessageDesc = Object.getOwnPropertyDescriptor(socket, 'onmessage');
	        if (onmessageDesc && onmessageDesc.configurable === false) {
	            proxySocket = Object.create(socket);
	            // socket have own property descriptor 'onopen', 'onmessage', 'onclose', 'onerror'
	            // but proxySocket not, so we will keep socket as prototype and pass it to
	            // patchOnProperties method
	            proxySocketProto = socket;
	            ['addEventListener', 'removeEventListener', 'send', 'close'].forEach(function (propName) {
	                proxySocket[propName] = function () {
	                    return socket[propName].apply(socket, arguments);
	                };
	            });
	        }
	        else {
	            // we can patch the real socket
	            proxySocket = socket;
	        }
	        patchOnProperties(proxySocket, ['close', 'error', 'message', 'open'], proxySocketProto);
	        return proxySocket;
	    };
	    for (var prop in WS) {
	        _global['WebSocket'][prop] = WS[prop];
	    }
	}
	
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var globalEventHandlersEventNames = [
	    'abort',
	    'animationcancel',
	    'animationend',
	    'animationiteration',
	    'auxclick',
	    'beforeinput',
	    'blur',
	    'cancel',
	    'canplay',
	    'canplaythrough',
	    'change',
	    'compositionstart',
	    'compositionupdate',
	    'compositionend',
	    'cuechange',
	    'click',
	    'close',
	    'contextmenu',
	    'curechange',
	    'dblclick',
	    'drag',
	    'dragend',
	    'dragenter',
	    'dragexit',
	    'dragleave',
	    'dragover',
	    'drop',
	    'durationchange',
	    'emptied',
	    'ended',
	    'error',
	    'focus',
	    'focusin',
	    'focusout',
	    'gotpointercapture',
	    'input',
	    'invalid',
	    'keydown',
	    'keypress',
	    'keyup',
	    'load',
	    'loadstart',
	    'loadeddata',
	    'loadedmetadata',
	    'lostpointercapture',
	    'mousedown',
	    'mouseenter',
	    'mouseleave',
	    'mousemove',
	    'mouseout',
	    'mouseover',
	    'mouseup',
	    'mousewheel',
	    'pause',
	    'play',
	    'playing',
	    'pointercancel',
	    'pointerdown',
	    'pointerenter',
	    'pointerleave',
	    'pointerlockchange',
	    'mozpointerlockchange',
	    'webkitpointerlockerchange',
	    'pointerlockerror',
	    'mozpointerlockerror',
	    'webkitpointerlockerror',
	    'pointermove',
	    'pointout',
	    'pointerover',
	    'pointerup',
	    'progress',
	    'ratechange',
	    'reset',
	    'resize',
	    'scroll',
	    'seeked',
	    'seeking',
	    'select',
	    'selectionchange',
	    'selectstart',
	    'show',
	    'sort',
	    'stalled',
	    'submit',
	    'suspend',
	    'timeupdate',
	    'volumechange',
	    'touchcancel',
	    'touchmove',
	    'touchstart',
	    'transitioncancel',
	    'transitionend',
	    'waiting',
	    'wheel'
	];
	var documentEventNames = [
	    'afterscriptexecute', 'beforescriptexecute', 'DOMContentLoaded', 'fullscreenchange',
	    'mozfullscreenchange', 'webkitfullscreenchange', 'msfullscreenchange', 'fullscreenerror',
	    'mozfullscreenerror', 'webkitfullscreenerror', 'msfullscreenerror', 'readystatechange'
	];
	var windowEventNames = [
	    'absolutedeviceorientation',
	    'afterinput',
	    'afterprint',
	    'appinstalled',
	    'beforeinstallprompt',
	    'beforeprint',
	    'beforeunload',
	    'devicelight',
	    'devicemotion',
	    'deviceorientation',
	    'deviceorientationabsolute',
	    'deviceproximity',
	    'hashchange',
	    'languagechange',
	    'message',
	    'mozbeforepaint',
	    'offline',
	    'online',
	    'paint',
	    'pageshow',
	    'pagehide',
	    'popstate',
	    'rejectionhandled',
	    'storage',
	    'unhandledrejection',
	    'unload',
	    'userproximity',
	    'vrdisplyconnected',
	    'vrdisplaydisconnected',
	    'vrdisplaypresentchange'
	];
	var htmlElementEventNames = [
	    'beforecopy', 'beforecut', 'beforepaste', 'copy', 'cut', 'paste', 'dragstart', 'loadend',
	    'animationstart', 'search', 'transitionrun', 'transitionstart', 'webkitanimationend',
	    'webkitanimationiteration', 'webkitanimationstart', 'webkittransitionend'
	];
	var mediaElementEventNames = ['encrypted', 'waitingforkey', 'msneedkey', 'mozinterruptbegin', 'mozinterruptend'];
	var ieElementEventNames = [
	    'activate',
	    'afterupdate',
	    'ariarequest',
	    'beforeactivate',
	    'beforedeactivate',
	    'beforeeditfocus',
	    'beforeupdate',
	    'cellchange',
	    'controlselect',
	    'dataavailable',
	    'datasetchanged',
	    'datasetcomplete',
	    'errorupdate',
	    'filterchange',
	    'layoutcomplete',
	    'losecapture',
	    'move',
	    'moveend',
	    'movestart',
	    'propertychange',
	    'resizeend',
	    'resizestart',
	    'rowenter',
	    'rowexit',
	    'rowsdelete',
	    'rowsinserted',
	    'command',
	    'compassneedscalibration',
	    'deactivate',
	    'help',
	    'mscontentzoom',
	    'msmanipulationstatechanged',
	    'msgesturechange',
	    'msgesturedoubletap',
	    'msgestureend',
	    'msgesturehold',
	    'msgesturestart',
	    'msgesturetap',
	    'msgotpointercapture',
	    'msinertiastart',
	    'mslostpointercapture',
	    'mspointercancel',
	    'mspointerdown',
	    'mspointerenter',
	    'mspointerhover',
	    'mspointerleave',
	    'mspointermove',
	    'mspointerout',
	    'mspointerover',
	    'mspointerup',
	    'pointerout',
	    'mssitemodejumplistitemremoved',
	    'msthumbnailclick',
	    'stop',
	    'storagecommit'
	];
	var webglEventNames = ['webglcontextrestored', 'webglcontextlost', 'webglcontextcreationerror'];
	var formEventNames = ['autocomplete', 'autocompleteerror'];
	var detailEventNames = ['toggle'];
	var frameEventNames = ['load'];
	var frameSetEventNames = ['blur', 'error', 'focus', 'load', 'resize', 'scroll'];
	var marqueeEventNames = ['bounce', 'finish', 'start'];
	var XMLHttpRequestEventNames = [
	    'loadstart', 'progress', 'abort', 'error', 'load', 'progress', 'timeout', 'loadend',
	    'readystatechange'
	];
	var IDBIndexEventNames = ['upgradeneeded', 'complete', 'abort', 'success', 'error', 'blocked', 'versionchange', 'close'];
	var websocketEventNames = ['close', 'error', 'open', 'message'];
	var eventNames = globalEventHandlersEventNames.concat(webglEventNames, formEventNames, detailEventNames, documentEventNames, windowEventNames, htmlElementEventNames, ieElementEventNames);
	function propertyDescriptorPatch(api, _global) {
	    if (isNode && !isMix) {
	        return;
	    }
	    var supportsWebSocket = typeof WebSocket !== 'undefined';
	    if (canPatchViaPropertyDescriptor()) {
	        // for browsers that we can patch the descriptor:  Chrome & Firefox
	        if (isBrowser) {
	            // in IE/Edge, onProp not exist in window object, but in WindowPrototype
	            // so we need to pass WindowPrototype to check onProp exist or not
	            patchOnProperties(window, eventNames, Object.getPrototypeOf(window));
	            patchOnProperties(Document.prototype, eventNames);
	            if (typeof window['SVGElement'] !== 'undefined') {
	                patchOnProperties(window['SVGElement'].prototype, eventNames);
	            }
	            patchOnProperties(Element.prototype, eventNames);
	            patchOnProperties(HTMLElement.prototype, eventNames);
	            patchOnProperties(HTMLMediaElement.prototype, mediaElementEventNames);
	            patchOnProperties(HTMLFrameSetElement.prototype, windowEventNames.concat(frameSetEventNames));
	            patchOnProperties(HTMLBodyElement.prototype, windowEventNames.concat(frameSetEventNames));
	            patchOnProperties(HTMLFrameElement.prototype, frameEventNames);
	            patchOnProperties(HTMLIFrameElement.prototype, frameEventNames);
	            var HTMLMarqueeElement_1 = window['HTMLMarqueeElement'];
	            if (HTMLMarqueeElement_1) {
	                patchOnProperties(HTMLMarqueeElement_1.prototype, marqueeEventNames);
	            }
	        }
	        patchOnProperties(XMLHttpRequest.prototype, XMLHttpRequestEventNames);
	        var XMLHttpRequestEventTarget = _global['XMLHttpRequestEventTarget'];
	        if (XMLHttpRequestEventTarget) {
	            patchOnProperties(XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype, XMLHttpRequestEventNames);
	        }
	        if (typeof IDBIndex !== 'undefined') {
	            patchOnProperties(IDBIndex.prototype, IDBIndexEventNames);
	            patchOnProperties(IDBRequest.prototype, IDBIndexEventNames);
	            patchOnProperties(IDBOpenDBRequest.prototype, IDBIndexEventNames);
	            patchOnProperties(IDBDatabase.prototype, IDBIndexEventNames);
	            patchOnProperties(IDBTransaction.prototype, IDBIndexEventNames);
	            patchOnProperties(IDBCursor.prototype, IDBIndexEventNames);
	        }
	        if (supportsWebSocket) {
	            patchOnProperties(WebSocket.prototype, websocketEventNames);
	        }
	    }
	    else {
	        // Safari, Android browsers (Jelly Bean)
	        patchViaCapturingAllTheEvents();
	        patchClass('XMLHttpRequest');
	        if (supportsWebSocket) {
	            apply(api, _global);
	        }
	    }
	}
	function canPatchViaPropertyDescriptor() {
	    if ((isBrowser || isMix) && !Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'onclick') &&
	        typeof Element !== 'undefined') {
	        // WebKit https://bugs.webkit.org/show_bug.cgi?id=134364
	        // IDL interface attributes are not configurable
	        var desc = Object.getOwnPropertyDescriptor(Element.prototype, 'onclick');
	        if (desc && !desc.configurable)
	            return false;
	    }
	    var xhrDesc = Object.getOwnPropertyDescriptor(XMLHttpRequest.prototype, 'onreadystatechange');
	    // add enumerable and configurable here because in opera
	    // by default XMLHttpRequest.prototype.onreadystatechange is undefined
	    // without adding enumerable and configurable will cause onreadystatechange
	    // non-configurable
	    // and if XMLHttpRequest.prototype.onreadystatechange is undefined,
	    // we should set a real desc instead a fake one
	    if (xhrDesc) {
	        Object.defineProperty(XMLHttpRequest.prototype, 'onreadystatechange', {
	            enumerable: true,
	            configurable: true,
	            get: function () {
	                return true;
	            }
	        });
	        var req = new XMLHttpRequest();
	        var result = !!req.onreadystatechange;
	        // restore original desc
	        Object.defineProperty(XMLHttpRequest.prototype, 'onreadystatechange', xhrDesc || {});
	        return result;
	    }
	    else {
	        Object.defineProperty(XMLHttpRequest.prototype, 'onreadystatechange', {
	            enumerable: true,
	            configurable: true,
	            get: function () {
	                return this[zoneSymbol('fakeonreadystatechange')];
	            },
	            set: function (value) {
	                this[zoneSymbol('fakeonreadystatechange')] = value;
	            }
	        });
	        var req = new XMLHttpRequest();
	        var detectFunc = function () { };
	        req.onreadystatechange = detectFunc;
	        var result = req[zoneSymbol('fakeonreadystatechange')] === detectFunc;
	        req.onreadystatechange = null;
	        return result;
	    }
	}
	
	var unboundKey = zoneSymbol('unbound');
	// Whenever any eventListener fires, we check the eventListener target and all parents
	// for `onwhatever` properties and replace them with zone-bound functions
	// - Chrome (for now)
	function patchViaCapturingAllTheEvents() {
	    var _loop_1 = function (i) {
	        var property = eventNames[i];
	        var onproperty = 'on' + property;
	        self.addEventListener(property, function (event) {
	            var elt = event.target, bound, source;
	            if (elt) {
	                source = elt.constructor['name'] + '.' + onproperty;
	            }
	            else {
	                source = 'unknown.' + onproperty;
	            }
	            while (elt) {
	                if (elt[onproperty] && !elt[onproperty][unboundKey]) {
	                    bound = Zone.current.wrap(elt[onproperty], source);
	                    bound[unboundKey] = elt[onproperty];
	                    elt[onproperty] = bound;
	                }
	                elt = elt.parentElement;
	            }
	        }, true);
	    };
	    for (var i = 0; i < eventNames.length; i++) {
	        _loop_1(i);
	    }
	}
	
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	function eventTargetPatch(_global, api) {
	    var WTF_ISSUE_555 = 'Anchor,Area,Audio,BR,Base,BaseFont,Body,Button,Canvas,Content,DList,Directory,Div,Embed,FieldSet,Font,Form,Frame,FrameSet,HR,Head,Heading,Html,IFrame,Image,Input,Keygen,LI,Label,Legend,Link,Map,Marquee,Media,Menu,Meta,Meter,Mod,OList,Object,OptGroup,Option,Output,Paragraph,Pre,Progress,Quote,Script,Select,Source,Span,Style,TableCaption,TableCell,TableCol,Table,TableRow,TableSection,TextArea,Title,Track,UList,Unknown,Video';
	    var NO_EVENT_TARGET = 'ApplicationCache,EventSource,FileReader,InputMethodContext,MediaController,MessagePort,Node,Performance,SVGElementInstance,SharedWorker,TextTrack,TextTrackCue,TextTrackList,WebKitNamedFlow,Window,Worker,WorkerGlobalScope,XMLHttpRequest,XMLHttpRequestEventTarget,XMLHttpRequestUpload,IDBRequest,IDBOpenDBRequest,IDBDatabase,IDBTransaction,IDBCursor,DBIndex,WebSocket'
	        .split(',');
	    var EVENT_TARGET = 'EventTarget';
	    var apis = [];
	    var isWtf = _global['wtf'];
	    var WTF_ISSUE_555_ARRAY = WTF_ISSUE_555.split(',');
	    if (isWtf) {
	        // Workaround for: https://github.com/google/tracing-framework/issues/555
	        apis = WTF_ISSUE_555_ARRAY.map(function (v) { return 'HTML' + v + 'Element'; }).concat(NO_EVENT_TARGET);
	    }
	    else if (_global[EVENT_TARGET]) {
	        apis.push(EVENT_TARGET);
	    }
	    else {
	        // Note: EventTarget is not available in all browsers,
	        // if it's not available, we instead patch the APIs in the IDL that inherit from EventTarget
	        apis = NO_EVENT_TARGET;
	    }
	    var isDisableIECheck = _global['__Zone_disable_IE_check'] || false;
	    var isEnableCrossContextCheck = _global['__Zone_enable_cross_context_check'] || false;
	    var ieOrEdge = isIEOrEdge();
	    var ADD_EVENT_LISTENER_SOURCE = '.addEventListener:';
	    var FUNCTION_WRAPPER = '[object FunctionWrapper]';
	    var BROWSER_TOOLS = 'function __BROWSERTOOLS_CONSOLE_SAFEFUNC() { [native code] }';
	    //  predefine all __zone_symbol__ + eventName + true/false string
	    for (var i = 0; i < eventNames.length; i++) {
	        var eventName = eventNames[i];
	        var falseEventName = eventName + FALSE_STR;
	        var trueEventName = eventName + TRUE_STR;
	        var symbol = ZONE_SYMBOL_PREFIX + falseEventName;
	        var symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;
	        zoneSymbolEventNames[eventName] = {};
	        zoneSymbolEventNames[eventName][FALSE_STR] = symbol;
	        zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;
	    }
	    //  predefine all task.source string
	    for (var i = 0; i < WTF_ISSUE_555.length; i++) {
	        var target = WTF_ISSUE_555_ARRAY[i];
	        var targets = globalSources[target] = {};
	        for (var j = 0; j < eventNames.length; j++) {
	            var eventName = eventNames[j];
	            targets[eventName] = target + ADD_EVENT_LISTENER_SOURCE + eventName;
	        }
	    }
	    var checkIEAndCrossContext = function (nativeDelegate, delegate, target, args) {
	        if (!isDisableIECheck && ieOrEdge) {
	            if (isEnableCrossContextCheck) {
	                try {
	                    var testString = delegate.toString();
	                    if ((testString === FUNCTION_WRAPPER || testString == BROWSER_TOOLS)) {
	                        nativeDelegate.apply(target, args);
	                        return false;
	                    }
	                }
	                catch (error) {
	                    nativeDelegate.apply(target, args);
	                    return false;
	                }
	            }
	            else {
	                var testString = delegate.toString();
	                if ((testString === FUNCTION_WRAPPER || testString == BROWSER_TOOLS)) {
	                    nativeDelegate.apply(target, args);
	                    return false;
	                }
	            }
	        }
	        else if (isEnableCrossContextCheck) {
	            try {
	                delegate.toString();
	            }
	            catch (error) {
	                nativeDelegate.apply(target, args);
	                return false;
	            }
	        }
	        return true;
	    };
	    var apiTypes = [];
	    for (var i = 0; i < apis.length; i++) {
	        var type = _global[apis[i]];
	        apiTypes.push(type && type.prototype);
	    }
	    patchEventTarget(_global, apiTypes, { validateHandler: checkIEAndCrossContext });
	    api.patchEventTarget = patchEventTarget;
	    return true;
	}
	
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	function registerElementPatch(_global) {
	    if ((!isBrowser && !isMix) || !('registerElement' in _global.document)) {
	        return;
	    }
	    var _registerElement = document.registerElement;
	    var callbacks = ['createdCallback', 'attachedCallback', 'detachedCallback', 'attributeChangedCallback'];
	    document.registerElement = function (name, opts) {
	        if (opts && opts.prototype) {
	            callbacks.forEach(function (callback) {
	                var source = 'Document.registerElement::' + callback;
	                if (opts.prototype.hasOwnProperty(callback)) {
	                    var descriptor = Object.getOwnPropertyDescriptor(opts.prototype, callback);
	                    if (descriptor && descriptor.value) {
	                        descriptor.value = Zone.current.wrap(descriptor.value, source);
	                        _redefineProperty(opts.prototype, callback, descriptor);
	                    }
	                    else {
	                        opts.prototype[callback] = Zone.current.wrap(opts.prototype[callback], source);
	                    }
	                }
	                else if (opts.prototype[callback]) {
	                    opts.prototype[callback] = Zone.current.wrap(opts.prototype[callback], source);
	                }
	            });
	        }
	        return _registerElement.apply(document, [name, opts]);
	    };
	    attachOriginToPatched(document.registerElement, _registerElement);
	}
	
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	Zone.__load_patch('timers', function (global, Zone, api) {
	    var set = 'set';
	    var clear = 'clear';
	    patchTimer(global, set, clear, 'Timeout');
	    patchTimer(global, set, clear, 'Interval');
	    patchTimer(global, set, clear, 'Immediate');
	    patchTimer(global, 'request', 'cancel', 'AnimationFrame');
	    patchTimer(global, 'mozRequest', 'mozCancel', 'AnimationFrame');
	    patchTimer(global, 'webkitRequest', 'webkitCancel', 'AnimationFrame');
	});
	Zone.__load_patch('blocking', function (global, Zone, api) {
	    var blockingMethods = ['alert', 'prompt', 'confirm'];
	    for (var i = 0; i < blockingMethods.length; i++) {
	        var name_1 = blockingMethods[i];
	        patchMethod(global, name_1, function (delegate, symbol, name) {
	            return function (s, args) {
	                return Zone.current.run(delegate, global, args, name);
	            };
	        });
	    }
	});
	Zone.__load_patch('EventTarget', function (global, Zone, api) {
	    eventTargetPatch(global, api);
	    // patch XMLHttpRequestEventTarget's addEventListener/removeEventListener
	    var XMLHttpRequestEventTarget = global['XMLHttpRequestEventTarget'];
	    if (XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype) {
	        api.patchEventTarget(global, [XMLHttpRequestEventTarget.prototype]);
	    }
	    patchClass('MutationObserver');
	    patchClass('WebKitMutationObserver');
	    patchClass('FileReader');
	});
	Zone.__load_patch('on_property', function (global, Zone, api) {
	    propertyDescriptorPatch(api, global);
	    propertyPatch();
	    registerElementPatch(global);
	});
	Zone.__load_patch('canvas', function (global, Zone, api) {
	    var HTMLCanvasElement = global['HTMLCanvasElement'];
	    if (typeof HTMLCanvasElement !== 'undefined' && HTMLCanvasElement.prototype &&
	        HTMLCanvasElement.prototype.toBlob) {
	        patchMacroTask(HTMLCanvasElement.prototype, 'toBlob', function (self, args) {
	            return { name: 'HTMLCanvasElement.toBlob', target: self, callbackIndex: 0, args: args };
	        });
	    }
	});
	Zone.__load_patch('XHR', function (global, Zone, api) {
	    // Treat XMLHTTPRequest as a macrotask.
	    patchXHR(global);
	    var XHR_TASK = zoneSymbol('xhrTask');
	    var XHR_SYNC = zoneSymbol('xhrSync');
	    var XHR_LISTENER = zoneSymbol('xhrListener');
	    var XHR_SCHEDULED = zoneSymbol('xhrScheduled');
	    function patchXHR(window) {
	        function findPendingTask(target) {
	            var pendingTask = target[XHR_TASK];
	            return pendingTask;
	        }
	        function scheduleTask(task) {
	            XMLHttpRequest[XHR_SCHEDULED] = false;
	            var data = task.data;
	            // remove existing event listener
	            var listener = data.target[XHR_LISTENER];
	            var oriAddListener = data.target[zoneSymbol('addEventListener')];
	            var oriRemoveListener = data.target[zoneSymbol('removeEventListener')];
	            if (listener) {
	                oriRemoveListener.apply(data.target, ['readystatechange', listener]);
	            }
	            var newListener = data.target[XHR_LISTENER] = function () {
	                if (data.target.readyState === data.target.DONE) {
	                    // sometimes on some browsers XMLHttpRequest will fire onreadystatechange with
	                    // readyState=4 multiple times, so we need to check task state here
	                    if (!data.aborted && XMLHttpRequest[XHR_SCHEDULED] &&
	                        task.state === 'scheduled') {
	                        task.invoke();
	                    }
	                }
	            };
	            oriAddListener.apply(data.target, ['readystatechange', newListener]);
	            var storedTask = data.target[XHR_TASK];
	            if (!storedTask) {
	                data.target[XHR_TASK] = task;
	            }
	            sendNative.apply(data.target, data.args);
	            XMLHttpRequest[XHR_SCHEDULED] = true;
	            return task;
	        }
	        function placeholderCallback() { }
	        function clearTask(task) {
	            var data = task.data;
	            // Note - ideally, we would call data.target.removeEventListener here, but it's too late
	            // to prevent it from firing. So instead, we store info for the event listener.
	            data.aborted = true;
	            return abortNative.apply(data.target, data.args);
	        }
	        var openNative = patchMethod(window.XMLHttpRequest.prototype, 'open', function () { return function (self, args) {
	            self[XHR_SYNC] = args[2] == false;
	            return openNative.apply(self, args);
	        }; });
	        var sendNative = patchMethod(window.XMLHttpRequest.prototype, 'send', function () { return function (self, args) {
	            var zone = Zone.current;
	            if (self[XHR_SYNC]) {
	                // if the XHR is sync there is no task to schedule, just execute the code.
	                return sendNative.apply(self, args);
	            }
	            else {
	                var options = { target: self, isPeriodic: false, delay: null, args: args, aborted: false };
	                return zone.scheduleMacroTask('XMLHttpRequest.send', placeholderCallback, options, scheduleTask, clearTask);
	            }
	        }; });
	        var abortNative = patchMethod(window.XMLHttpRequest.prototype, 'abort', function (delegate) { return function (self, args) {
	            var task = findPendingTask(self);
	            if (task && typeof task.type == 'string') {
	                // If the XHR has already completed, do nothing.
	                // If the XHR has already been aborted, do nothing.
	                // Fix #569, call abort multiple times before done will cause
	                // macroTask task count be negative number
	                if (task.cancelFn == null || (task.data && task.data.aborted)) {
	                    return;
	                }
	                task.zone.cancelTask(task);
	            }
	            // Otherwise, we are trying to abort an XHR which has not yet been sent, so there is no
	            // task
	            // to cancel. Do nothing.
	        }; });
	    }
	});
	Zone.__load_patch('geolocation', function (global, Zone, api) {
	    /// GEO_LOCATION
	    if (global['navigator'] && global['navigator'].geolocation) {
	        patchPrototype(global['navigator'].geolocation, ['getCurrentPosition', 'watchPosition']);
	    }
	});
	Zone.__load_patch('PromiseRejectionEvent', function (global, Zone, api) {
	    // handle unhandled promise rejection
	    function findPromiseRejectionHandler(evtName) {
	        return function (e) {
	            var eventTasks = findEventTasks(global, evtName);
	            eventTasks.forEach(function (eventTask) {
	                // windows has added unhandledrejection event listener
	                // trigger the event listener
	                var PromiseRejectionEvent = global['PromiseRejectionEvent'];
	                if (PromiseRejectionEvent) {
	                    var evt = new PromiseRejectionEvent(evtName, { promise: e.promise, reason: e.rejection });
	                    eventTask.invoke(evt);
	                }
	            });
	        };
	    }
	    if (global['PromiseRejectionEvent']) {
	        Zone[zoneSymbol('unhandledPromiseRejectionHandler')] =
	            findPromiseRejectionHandler('unhandledrejection');
	        Zone[zoneSymbol('rejectionHandledHandler')] =
	            findPromiseRejectionHandler('rejectionhandled');
	    }
	});
	Zone.__load_patch('util', function (global, Zone, api) {
	    api.patchOnProperties = patchOnProperties;
	    api.patchMethod = patchMethod;
	});
	
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	
	})));
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ })
/******/ ]);
//# sourceMappingURL=angular.js.map